(function () {
    (function (global, factory) {
        if (typeof module === 'object' && typeof module.exports === 'object') {
            module.exports = global.document ? factory(global, true) : function (w) {
                if (!w.document) {
                    throw new Error('jQuery requires a window with a document');
                }
                return factory(w);
            };
        } else {
            factory(global);
        }
    }(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
        var arr = [];
        var document = window.document;
        var slice = arr.slice;
        var concat = arr.concat;
        var push = arr.push;
        var indexOf = arr.indexOf;
        var class2type = {};
        var toString = class2type.toString;
        var hasOwn = class2type.hasOwnProperty;
        var support = {};
        var version = '2.2.3', jQuery = function (selector, context) {
                return new jQuery.fn.init(selector, context);
            }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function (all, letter) {
                return letter.toUpperCase();
            };
        jQuery.fn = jQuery.prototype = {
            jquery: version,
            constructor: jQuery,
            selector: '',
            length: 0,
            toArray: function () {
                return slice.call(this);
            },
            get: function (num) {
                return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
            },
            pushStack: function (elems) {
                var ret = jQuery.merge(this.constructor(), elems);
                ret.prevObject = this;
                ret.context = this.context;
                return ret;
            },
            each: function (callback) {
                return jQuery.each(this, callback);
            },
            map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem);
                }));
            },
            slice: function () {
                return this.pushStack(slice.apply(this, arguments));
            },
            first: function () {
                return this.eq(0);
            },
            last: function () {
                return this.eq(-1);
            },
            eq: function (i) {
                var len = this.length, j = +i + (i < 0 ? len : 0);
                return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
            },
            end: function () {
                return this.prevObject || this.constructor();
            },
            push: push,
            sort: arr.sort,
            splice: arr.splice
        };
        jQuery.extend = jQuery.fn.extend = function () {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
            if (typeof target === 'boolean') {
                deep = target;
                target = arguments[i] || {};
                i++;
            }
            if (typeof target !== 'object' && !jQuery.isFunction(target)) {
                target = {};
            }
            if (i === length) {
                target = this;
                i--;
            }
            for (; i < length; i++) {
                if ((options = arguments[i]) != null) {
                    for (name in options) {
                        src = target[name];
                        copy = options[name];
                        if (target === copy) {
                            continue;
                        }
                        if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
                            if (copyIsArray) {
                                copyIsArray = false;
                                clone = src && jQuery.isArray(src) ? src : [];
                            } else {
                                clone = src && jQuery.isPlainObject(src) ? src : {};
                            }
                            target[name] = jQuery.extend(deep, clone, copy);
                        } else if (copy !== undefined) {
                            target[name] = copy;
                        }
                    }
                }
            }
            return target;
        };
        jQuery.extend({
            expando: 'jQuery' + (version + Math.random()).replace(/\D/g, ''),
            isReady: true,
            error: function (msg) {
                throw new Error(msg);
            },
            noop: function () {
            },
            isFunction: function (obj) {
                return jQuery.type(obj) === 'function';
            },
            isArray: Array.isArray,
            isWindow: function (obj) {
                return obj != null && obj === obj.window;
            },
            isNumeric: function (obj) {
                var realStringObj = obj && obj.toString();
                return !jQuery.isArray(obj) && realStringObj - parseFloat(realStringObj) + 1 >= 0;
            },
            isPlainObject: function (obj) {
                var key;
                if (jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
                    return false;
                }
                if (obj.constructor && !hasOwn.call(obj, 'constructor') && !hasOwn.call(obj.constructor.prototype || {}, 'isPrototypeOf')) {
                    return false;
                }
                for (key in obj) {
                }
                return key === undefined || hasOwn.call(obj, key);
            },
            isEmptyObject: function (obj) {
                var name;
                for (name in obj) {
                    return false;
                }
                return true;
            },
            type: function (obj) {
                if (obj == null) {
                    return obj + '';
                }
                return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
            },
            globalEval: function (code) {
                var script, indirect = eval;
                code = jQuery.trim(code);
                if (code) {
                    if (code.indexOf('use strict') === 1) {
                        script = document.createElement('script');
                        script.text = code;
                        document.head.appendChild(script).parentNode.removeChild(script);
                    } else {
                        indirect(code);
                    }
                }
            },
            camelCase: function (string) {
                return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
            },
            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
            },
            each: function (obj, callback) {
                var length, i = 0;
                if (isArrayLike(obj)) {
                    length = obj.length;
                    for (; i < length; i++) {
                        if (callback.call(obj[i], i, obj[i]) === false) {
                            break;
                        }
                    }
                } else {
                    for (i in obj) {
                        if (callback.call(obj[i], i, obj[i]) === false) {
                            break;
                        }
                    }
                }
                return obj;
            },
            trim: function (text) {
                return text == null ? '' : (text + '').replace(rtrim, '');
            },
            makeArray: function (arr, results) {
                var ret = results || [];
                if (arr != null) {
                    if (isArrayLike(Object(arr))) {
                        jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
                    } else {
                        push.call(ret, arr);
                    }
                }
                return ret;
            },
            inArray: function (elem, arr, i) {
                return arr == null ? -1 : indexOf.call(arr, elem, i);
            },
            merge: function (first, second) {
                var len = +second.length, j = 0, i = first.length;
                for (; j < len; j++) {
                    first[i++] = second[j];
                }
                first.length = i;
                return first;
            },
            grep: function (elems, callback, invert) {
                var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
                for (; i < length; i++) {
                    callbackInverse = !callback(elems[i], i);
                    if (callbackInverse !== callbackExpect) {
                        matches.push(elems[i]);
                    }
                }
                return matches;
            },
            map: function (elems, callback, arg) {
                var length, value, i = 0, ret = [];
                if (isArrayLike(elems)) {
                    length = elems.length;
                    for (; i < length; i++) {
                        value = callback(elems[i], i, arg);
                        if (value != null) {
                            ret.push(value);
                        }
                    }
                } else {
                    for (i in elems) {
                        value = callback(elems[i], i, arg);
                        if (value != null) {
                            ret.push(value);
                        }
                    }
                }
                return concat.apply([], ret);
            },
            guid: 1,
            proxy: function (fn, context) {
                var tmp, args, proxy;
                if (typeof context === 'string') {
                    tmp = fn[context];
                    context = fn;
                    fn = tmp;
                }
                if (!jQuery.isFunction(fn)) {
                    return undefined;
                }
                args = slice.call(arguments, 2);
                proxy = function () {
                    return fn.apply(context || this, args.concat(slice.call(arguments)));
                };
                proxy.guid = fn.guid = fn.guid || jQuery.guid++;
                return proxy;
            },
            now: Date.now,
            support: support
        });
        if (typeof Symbol === 'function') {
            jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
        }
        jQuery.each('Boolean Number String Function Array Date RegExp Object Error Symbol'.split(' '), function (i, name) {
            class2type['[object ' + name + ']'] = name.toLowerCase();
        });
        function isArrayLike(obj) {
            var length = !!obj && 'length' in obj && obj.length, type = jQuery.type(obj);
            if (type === 'function' || jQuery.isWindow(obj)) {
                return false;
            }
            return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
        }
        var Sizzle = function (window) {
            var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                    }
                    return 0;
                }, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function (list, elem) {
                    var i = 0, len = list.length;
                    for (; i < len; i++) {
                        if (list[i] === elem) {
                            return i;
                        }
                    }
                    return -1;
                }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', identifier = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', attributes = '\\[' + whitespace + '*(' + identifier + ')(?:' + whitespace + '*([*^$|!~]?=)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', pseudos = ':(' + identifier + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)', rwhitespace = new RegExp(whitespace + '+', 'g'), rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*?)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
                    'ID': new RegExp('^#(' + identifier + ')'),
                    'CLASS': new RegExp('^\\.(' + identifier + ')'),
                    'TAG': new RegExp('^(' + identifier + '|[*])'),
                    'ATTR': new RegExp('^' + attributes),
                    'PSEUDO': new RegExp('^' + pseudos),
                    'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
                    'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
                    'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
                }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
                    var high = '0x' + escaped - 65536;
                    return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
                }, unloadHandler = function () {
                    setDocument();
                };
            try {
                push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
                arr[preferredDoc.childNodes.length].nodeType;
            } catch (e) {
                push = {
                    apply: arr.length ? function (target, els) {
                        push_native.apply(target, slice.call(els));
                    } : function (target, els) {
                        var j = target.length, i = 0;
                        while (target[j++] = els[i++]) {
                        }
                        target.length = j - 1;
                    }
                };
            }
            function Sizzle(selector, context, results, seed) {
                var m, i, elem, nid, nidselect, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
                results = results || [];
                if (typeof selector !== 'string' || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
                    return results;
                }
                if (!seed) {
                    if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                        setDocument(context);
                    }
                    context = context || document;
                    if (documentIsHTML) {
                        if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
                            if (m = match[1]) {
                                if (nodeType === 9) {
                                    if (elem = context.getElementById(m)) {
                                        if (elem.id === m) {
                                            results.push(elem);
                                            return results;
                                        }
                                    } else {
                                        return results;
                                    }
                                } else {
                                    if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                }
                            } else if (match[2]) {
                                push.apply(results, context.getElementsByTagName(selector));
                                return results;
                            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                                push.apply(results, context.getElementsByClassName(m));
                                return results;
                            }
                        }
                        if (support.qsa && !compilerCache[selector + ' '] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                            if (nodeType !== 1) {
                                newContext = context;
                                newSelector = selector;
                            } else if (context.nodeName.toLowerCase() !== 'object') {
                                if (nid = context.getAttribute('id')) {
                                    nid = nid.replace(rescape, '\\$&');
                                } else {
                                    context.setAttribute('id', nid = expando);
                                }
                                groups = tokenize(selector);
                                i = groups.length;
                                nidselect = ridentifier.test(nid) ? '#' + nid : '[id=\'' + nid + '\']';
                                while (i--) {
                                    groups[i] = nidselect + ' ' + toSelector(groups[i]);
                                }
                                newSelector = groups.join(',');
                                newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                            }
                            if (newSelector) {
                                try {
                                    push.apply(results, newContext.querySelectorAll(newSelector));
                                    return results;
                                } catch (qsaError) {
                                } finally {
                                    if (nid === expando) {
                                        context.removeAttribute('id');
                                    }
                                }
                            }
                        }
                    }
                }
                return select(selector.replace(rtrim, '$1'), context, results, seed);
            }
            function createCache() {
                var keys = [];
                function cache(key, value) {
                    if (keys.push(key + ' ') > Expr.cacheLength) {
                        delete cache[keys.shift()];
                    }
                    return cache[key + ' '] = value;
                }
                return cache;
            }
            function markFunction(fn) {
                fn[expando] = true;
                return fn;
            }
            function assert(fn) {
                var div = document.createElement('div');
                try {
                    return !!fn(div);
                } catch (e) {
                    return false;
                } finally {
                    if (div.parentNode) {
                        div.parentNode.removeChild(div);
                    }
                    div = null;
                }
            }
            function addHandle(attrs, handler) {
                var arr = attrs.split('|'), i = arr.length;
                while (i--) {
                    Expr.attrHandle[arr[i]] = handler;
                }
            }
            function siblingCheck(a, b) {
                var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
                if (diff) {
                    return diff;
                }
                if (cur) {
                    while (cur = cur.nextSibling) {
                        if (cur === b) {
                            return -1;
                        }
                    }
                }
                return a ? 1 : -1;
            }
            function createInputPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === 'input' && elem.type === type;
                };
            }
            function createButtonPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return (name === 'input' || name === 'button') && elem.type === type;
                };
            }
            function createPositionalPseudo(fn) {
                return markFunction(function (argument) {
                    argument = +argument;
                    return markFunction(function (seed, matches) {
                        var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
                        while (i--) {
                            if (seed[j = matchIndexes[i]]) {
                                seed[j] = !(matches[j] = seed[j]);
                            }
                        }
                    });
                });
            }
            function testContext(context) {
                return context && typeof context.getElementsByTagName !== 'undefined' && context;
            }
            support = Sizzle.support = {};
            isXML = Sizzle.isXML = function (elem) {
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? documentElement.nodeName !== 'HTML' : false;
            };
            setDocument = Sizzle.setDocument = function (node) {
                var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;
                if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                    return document;
                }
                document = doc;
                docElem = document.documentElement;
                documentIsHTML = !isXML(document);
                if ((parent = document.defaultView) && parent.top !== parent) {
                    if (parent.addEventListener) {
                        parent.addEventListener('unload', unloadHandler, false);
                    } else if (parent.attachEvent) {
                        parent.attachEvent('onunload', unloadHandler);
                    }
                }
                support.attributes = assert(function (div) {
                    div.className = 'i';
                    return !div.getAttribute('className');
                });
                support.getElementsByTagName = assert(function (div) {
                    div.appendChild(document.createComment(''));
                    return !div.getElementsByTagName('*').length;
                });
                support.getElementsByClassName = rnative.test(document.getElementsByClassName);
                support.getById = assert(function (div) {
                    docElem.appendChild(div).id = expando;
                    return !document.getElementsByName || !document.getElementsByName(expando).length;
                });
                if (support.getById) {
                    Expr.find['ID'] = function (id, context) {
                        if (typeof context.getElementById !== 'undefined' && documentIsHTML) {
                            var m = context.getElementById(id);
                            return m ? [m] : [];
                        }
                    };
                    Expr.filter['ID'] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            return elem.getAttribute('id') === attrId;
                        };
                    };
                } else {
                    delete Expr.find['ID'];
                    Expr.filter['ID'] = function (id) {
                        var attrId = id.replace(runescape, funescape);
                        return function (elem) {
                            var node = typeof elem.getAttributeNode !== 'undefined' && elem.getAttributeNode('id');
                            return node && node.value === attrId;
                        };
                    };
                }
                Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
                    if (typeof context.getElementsByTagName !== 'undefined') {
                        return context.getElementsByTagName(tag);
                    } else if (support.qsa) {
                        return context.querySelectorAll(tag);
                    }
                } : function (tag, context) {
                    var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                    if (tag === '*') {
                        while (elem = results[i++]) {
                            if (elem.nodeType === 1) {
                                tmp.push(elem);
                            }
                        }
                        return tmp;
                    }
                    return results;
                };
                Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
                    if (typeof context.getElementsByClassName !== 'undefined' && documentIsHTML) {
                        return context.getElementsByClassName(className);
                    }
                };
                rbuggyMatches = [];
                rbuggyQSA = [];
                if (support.qsa = rnative.test(document.querySelectorAll)) {
                    assert(function (div) {
                        docElem.appendChild(div).innerHTML = '<a id=\'' + expando + '\'></a>' + '<select id=\'' + expando + '-\r\\\' msallowcapture=\'\'>' + '<option selected=\'\'></option></select>';
                        if (div.querySelectorAll('[msallowcapture^=\'\']').length) {
                            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
                        }
                        if (!div.querySelectorAll('[selected]').length) {
                            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
                        }
                        if (!div.querySelectorAll('[id~=' + expando + '-]').length) {
                            rbuggyQSA.push('~=');
                        }
                        if (!div.querySelectorAll(':checked').length) {
                            rbuggyQSA.push(':checked');
                        }
                        if (!div.querySelectorAll('a#' + expando + '+*').length) {
                            rbuggyQSA.push('.#.+[+~]');
                        }
                    });
                    assert(function (div) {
                        var input = document.createElement('input');
                        input.setAttribute('type', 'hidden');
                        div.appendChild(input).setAttribute('name', 'D');
                        if (div.querySelectorAll('[name=d]').length) {
                            rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?=');
                        }
                        if (!div.querySelectorAll(':enabled').length) {
                            rbuggyQSA.push(':enabled', ':disabled');
                        }
                        div.querySelectorAll('*,:x');
                        rbuggyQSA.push(',.*:');
                    });
                }
                if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
                    assert(function (div) {
                        support.disconnectedMatch = matches.call(div, 'div');
                        matches.call(div, '[s!=\'\']:x');
                        rbuggyMatches.push('!=', pseudos);
                    });
                }
                rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
                rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
                hasCompare = rnative.test(docElem.compareDocumentPosition);
                contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                    var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
                    return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
                } : function (a, b) {
                    if (b) {
                        while (b = b.parentNode) {
                            if (b === a) {
                                return true;
                            }
                        }
                    }
                    return false;
                };
                sortOrder = hasCompare ? function (a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                        return 0;
                    }
                    var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                    if (compare) {
                        return compare;
                    }
                    compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
                    if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
                        if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                            return -1;
                        }
                        if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                            return 1;
                        }
                        return sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                    }
                    return compare & 4 ? -1 : 1;
                } : function (a, b) {
                    if (a === b) {
                        hasDuplicate = true;
                        return 0;
                    }
                    var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                    if (!aup || !bup) {
                        return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                    } else if (aup === bup) {
                        return siblingCheck(a, b);
                    }
                    cur = a;
                    while (cur = cur.parentNode) {
                        ap.unshift(cur);
                    }
                    cur = b;
                    while (cur = cur.parentNode) {
                        bp.unshift(cur);
                    }
                    while (ap[i] === bp[i]) {
                        i++;
                    }
                    return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
                };
                return document;
            };
            Sizzle.matches = function (expr, elements) {
                return Sizzle(expr, null, null, elements);
            };
            Sizzle.matchesSelector = function (elem, expr) {
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }
                expr = expr.replace(rattributeQuotes, '=\'$1\']');
                if (support.matchesSelector && documentIsHTML && !compilerCache[expr + ' '] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
                    try {
                        var ret = matches.call(elem, expr);
                        if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
                            return ret;
                        }
                    } catch (e) {
                    }
                }
                return Sizzle(expr, document, null, [elem]).length > 0;
            };
            Sizzle.contains = function (context, elem) {
                if ((context.ownerDocument || context) !== document) {
                    setDocument(context);
                }
                return contains(context, elem);
            };
            Sizzle.attr = function (elem, name) {
                if ((elem.ownerDocument || elem) !== document) {
                    setDocument(elem);
                }
                var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
                return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
            };
            Sizzle.error = function (msg) {
                throw new Error('Syntax error, unrecognized expression: ' + msg);
            };
            Sizzle.uniqueSort = function (results) {
                var elem, duplicates = [], j = 0, i = 0;
                hasDuplicate = !support.detectDuplicates;
                sortInput = !support.sortStable && results.slice(0);
                results.sort(sortOrder);
                if (hasDuplicate) {
                    while (elem = results[i++]) {
                        if (elem === results[i]) {
                            j = duplicates.push(i);
                        }
                    }
                    while (j--) {
                        results.splice(duplicates[j], 1);
                    }
                }
                sortInput = null;
                return results;
            };
            getText = Sizzle.getText = function (elem) {
                var node, ret = '', i = 0, nodeType = elem.nodeType;
                if (!nodeType) {
                    while (node = elem[i++]) {
                        ret += getText(node);
                    }
                } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                    if (typeof elem.textContent === 'string') {
                        return elem.textContent;
                    } else {
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            ret += getText(elem);
                        }
                    }
                } else if (nodeType === 3 || nodeType === 4) {
                    return elem.nodeValue;
                }
                return ret;
            };
            Expr = Sizzle.selectors = {
                cacheLength: 50,
                createPseudo: markFunction,
                match: matchExpr,
                attrHandle: {},
                find: {},
                relative: {
                    '>': {
                        dir: 'parentNode',
                        first: true
                    },
                    ' ': { dir: 'parentNode' },
                    '+': {
                        dir: 'previousSibling',
                        first: true
                    },
                    '~': { dir: 'previousSibling' }
                },
                preFilter: {
                    'ATTR': function (match) {
                        match[1] = match[1].replace(runescape, funescape);
                        match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
                        if (match[2] === '~=') {
                            match[3] = ' ' + match[3] + ' ';
                        }
                        return match.slice(0, 4);
                    },
                    'CHILD': function (match) {
                        match[1] = match[1].toLowerCase();
                        if (match[1].slice(0, 3) === 'nth') {
                            if (!match[3]) {
                                Sizzle.error(match[0]);
                            }
                            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
                            match[5] = +(match[7] + match[8] || match[3] === 'odd');
                        } else if (match[3]) {
                            Sizzle.error(match[0]);
                        }
                        return match;
                    },
                    'PSEUDO': function (match) {
                        var excess, unquoted = !match[6] && match[2];
                        if (matchExpr['CHILD'].test(match[0])) {
                            return null;
                        }
                        if (match[3]) {
                            match[2] = match[4] || match[5] || '';
                        } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
                            match[0] = match[0].slice(0, excess);
                            match[2] = unquoted.slice(0, excess);
                        }
                        return match.slice(0, 3);
                    }
                },
                filter: {
                    'TAG': function (nodeNameSelector) {
                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                        return nodeNameSelector === '*' ? function () {
                            return true;
                        } : function (elem) {
                            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                        };
                    },
                    'CLASS': function (className) {
                        var pattern = classCache[className + ' '];
                        return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
                            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== 'undefined' && elem.getAttribute('class') || '');
                        });
                    },
                    'ATTR': function (name, operator, check) {
                        return function (elem) {
                            var result = Sizzle.attr(elem, name);
                            if (result == null) {
                                return operator === '!=';
                            }
                            if (!operator) {
                                return true;
                            }
                            result += '';
                            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result.replace(rwhitespace, ' ') + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
                        };
                    },
                    'CHILD': function (type, what, argument, first, last) {
                        var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
                        return first === 1 && last === 0 ? function (elem) {
                            return !!elem.parentNode;
                        } : function (elem, context, xml) {
                            var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;
                            if (parent) {
                                if (simple) {
                                    while (dir) {
                                        node = elem;
                                        while (node = node[dir]) {
                                            if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                                                return false;
                                            }
                                        }
                                        start = dir = type === 'only' && !start && 'nextSibling';
                                    }
                                    return true;
                                }
                                start = [forward ? parent.firstChild : parent.lastChild];
                                if (forward && useCache) {
                                    node = parent;
                                    outerCache = node[expando] || (node[expando] = {});
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex && cache[2];
                                    node = nodeIndex && parent.childNodes[nodeIndex];
                                    while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                        if (node.nodeType === 1 && ++diff && node === elem) {
                                            uniqueCache[type] = [
                                                dirruns,
                                                nodeIndex,
                                                diff
                                            ];
                                            break;
                                        }
                                    }
                                } else {
                                    if (useCache) {
                                        node = elem;
                                        outerCache = node[expando] || (node[expando] = {});
                                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                        cache = uniqueCache[type] || [];
                                        nodeIndex = cache[0] === dirruns && cache[1];
                                        diff = nodeIndex;
                                    }
                                    if (diff === false) {
                                        while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                                            if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                                                if (useCache) {
                                                    outerCache = node[expando] || (node[expando] = {});
                                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                                                    uniqueCache[type] = [
                                                        dirruns,
                                                        diff
                                                    ];
                                                }
                                                if (node === elem) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                                diff -= last;
                                return diff === first || diff % first === 0 && diff / first >= 0;
                            }
                        };
                    },
                    'PSEUDO': function (pseudo, argument) {
                        var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
                        if (fn[expando]) {
                            return fn(argument);
                        }
                        if (fn.length > 1) {
                            args = [
                                pseudo,
                                pseudo,
                                '',
                                argument
                            ];
                            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                                var idx, matched = fn(seed, argument), i = matched.length;
                                while (i--) {
                                    idx = indexOf(seed, matched[i]);
                                    seed[idx] = !(matches[idx] = matched[i]);
                                }
                            }) : function (elem) {
                                return fn(elem, 0, args);
                            };
                        }
                        return fn;
                    }
                },
                pseudos: {
                    'not': markFunction(function (selector) {
                        var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
                        return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
                            while (i--) {
                                if (elem = unmatched[i]) {
                                    seed[i] = !(matches[i] = elem);
                                }
                            }
                        }) : function (elem, context, xml) {
                            input[0] = elem;
                            matcher(input, null, xml, results);
                            input[0] = null;
                            return !results.pop();
                        };
                    }),
                    'has': markFunction(function (selector) {
                        return function (elem) {
                            return Sizzle(selector, elem).length > 0;
                        };
                    }),
                    'contains': markFunction(function (text) {
                        text = text.replace(runescape, funescape);
                        return function (elem) {
                            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                        };
                    }),
                    'lang': markFunction(function (lang) {
                        if (!ridentifier.test(lang || '')) {
                            Sizzle.error('unsupported lang: ' + lang);
                        }
                        lang = lang.replace(runescape, funescape).toLowerCase();
                        return function (elem) {
                            var elemLang;
                            do {
                                if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                                    elemLang = elemLang.toLowerCase();
                                    return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
                                }
                            } while ((elem = elem.parentNode) && elem.nodeType === 1);
                            return false;
                        };
                    }),
                    'target': function (elem) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice(1) === elem.id;
                    },
                    'root': function (elem) {
                        return elem === docElem;
                    },
                    'focus': function (elem) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                    },
                    'enabled': function (elem) {
                        return elem.disabled === false;
                    },
                    'disabled': function (elem) {
                        return elem.disabled === true;
                    },
                    'checked': function (elem) {
                        var nodeName = elem.nodeName.toLowerCase();
                        return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
                    },
                    'selected': function (elem) {
                        if (elem.parentNode) {
                            elem.parentNode.selectedIndex;
                        }
                        return elem.selected === true;
                    },
                    'empty': function (elem) {
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                            if (elem.nodeType < 6) {
                                return false;
                            }
                        }
                        return true;
                    },
                    'parent': function (elem) {
                        return !Expr.pseudos['empty'](elem);
                    },
                    'header': function (elem) {
                        return rheader.test(elem.nodeName);
                    },
                    'input': function (elem) {
                        return rinputs.test(elem.nodeName);
                    },
                    'button': function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return name === 'input' && elem.type === 'button' || name === 'button';
                    },
                    'text': function (elem) {
                        var attr;
                        return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
                    },
                    'first': createPositionalPseudo(function () {
                        return [0];
                    }),
                    'last': createPositionalPseudo(function (matchIndexes, length) {
                        return [length - 1];
                    }),
                    'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
                        return [argument < 0 ? argument + length : argument];
                    }),
                    'even': createPositionalPseudo(function (matchIndexes, length) {
                        var i = 0;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    'odd': createPositionalPseudo(function (matchIndexes, length) {
                        var i = 1;
                        for (; i < length; i += 2) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; --i >= 0;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    }),
                    'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
                        var i = argument < 0 ? argument + length : argument;
                        for (; ++i < length;) {
                            matchIndexes.push(i);
                        }
                        return matchIndexes;
                    })
                }
            };
            Expr.pseudos['nth'] = Expr.pseudos['eq'];
            for (i in {
                    radio: true,
                    checkbox: true,
                    file: true,
                    password: true,
                    image: true
                }) {
                Expr.pseudos[i] = createInputPseudo(i);
            }
            for (i in {
                    submit: true,
                    reset: true
                }) {
                Expr.pseudos[i] = createButtonPseudo(i);
            }
            function setFilters() {
            }
            setFilters.prototype = Expr.filters = Expr.pseudos;
            Expr.setFilters = new setFilters();
            tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
                if (cached) {
                    return parseOnly ? 0 : cached.slice(0);
                }
                soFar = selector;
                groups = [];
                preFilters = Expr.preFilter;
                while (soFar) {
                    if (!matched || (match = rcomma.exec(soFar))) {
                        if (match) {
                            soFar = soFar.slice(match[0].length) || soFar;
                        }
                        groups.push(tokens = []);
                    }
                    matched = false;
                    if (match = rcombinators.exec(soFar)) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: match[0].replace(rtrim, ' ')
                        });
                        soFar = soFar.slice(matched.length);
                    }
                    for (type in Expr.filter) {
                        if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                            matched = match.shift();
                            tokens.push({
                                value: matched,
                                type: type,
                                matches: match
                            });
                            soFar = soFar.slice(matched.length);
                        }
                    }
                    if (!matched) {
                        break;
                    }
                }
                return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
            };
            function toSelector(tokens) {
                var i = 0, len = tokens.length, selector = '';
                for (; i < len; i++) {
                    selector += tokens[i].value;
                }
                return selector;
            }
            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
                return combinator.first ? function (elem, context, xml) {
                    while (elem = elem[dir]) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            return matcher(elem, context, xml);
                        }
                    }
                } : function (elem, context, xml) {
                    var oldCache, uniqueCache, outerCache, newCache = [
                            dirruns,
                            doneName
                        ];
                    if (xml) {
                        while (elem = elem[dir]) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                if (matcher(elem, context, xml)) {
                                    return true;
                                }
                            }
                        }
                    } else {
                        while (elem = elem[dir]) {
                            if (elem.nodeType === 1 || checkNonElements) {
                                outerCache = elem[expando] || (elem[expando] = {});
                                uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
                                if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                                    return newCache[2] = oldCache[2];
                                } else {
                                    uniqueCache[dir] = newCache;
                                    if (newCache[2] = matcher(elem, context, xml)) {
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                };
            }
            function elementMatcher(matchers) {
                return matchers.length > 1 ? function (elem, context, xml) {
                    var i = matchers.length;
                    while (i--) {
                        if (!matchers[i](elem, context, xml)) {
                            return false;
                        }
                    }
                    return true;
                } : matchers[0];
            }
            function multipleContexts(selector, contexts, results) {
                var i = 0, len = contexts.length;
                for (; i < len; i++) {
                    Sizzle(selector, contexts[i], results);
                }
                return results;
            }
            function condense(unmatched, map, filter, context, xml) {
                var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
                for (; i < len; i++) {
                    if (elem = unmatched[i]) {
                        if (!filter || filter(elem, context, xml)) {
                            newUnmatched.push(elem);
                            if (mapped) {
                                map.push(i);
                            }
                        }
                    }
                }
                return newUnmatched;
            }
            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                if (postFilter && !postFilter[expando]) {
                    postFilter = setMatcher(postFilter);
                }
                if (postFinder && !postFinder[expando]) {
                    postFinder = setMatcher(postFinder, postSelector);
                }
                return markFunction(function (seed, results, context, xml) {
                    var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                    if (matcher) {
                        matcher(matcherIn, matcherOut, context, xml);
                    }
                    if (postFilter) {
                        temp = condense(matcherOut, postMap);
                        postFilter(temp, [], context, xml);
                        i = temp.length;
                        while (i--) {
                            if (elem = temp[i]) {
                                matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                            }
                        }
                    }
                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                temp = [];
                                i = matcherOut.length;
                                while (i--) {
                                    if (elem = matcherOut[i]) {
                                        temp.push(matcherIn[i] = elem);
                                    }
                                }
                                postFinder(null, matcherOut = [], temp, xml);
                            }
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                                    seed[temp] = !(results[temp] = elem);
                                }
                            }
                        }
                    } else {
                        matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                        if (postFinder) {
                            postFinder(null, results, matcherOut, xml);
                        } else {
                            push.apply(results, matcherOut);
                        }
                    }
                });
            }
            function matcherFromTokens(tokens) {
                var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                        return elem === checkContext;
                    }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
                        return indexOf(checkContext, elem) > -1;
                    }, implicitRelative, true), matchers = [function (elem, context, xml) {
                            var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                            checkContext = null;
                            return ret;
                        }];
                for (; i < len; i++) {
                    if (matcher = Expr.relative[tokens[i].type]) {
                        matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    } else {
                        matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
                        if (matcher[expando]) {
                            j = ++i;
                            for (; j < len; j++) {
                                if (Expr.relative[tokens[j].type]) {
                                    break;
                                }
                            }
                            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
                        }
                        matchers.push(matcher);
                    }
                }
                return elementMatcher(matchers);
            }
            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                        var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
                        if (outermost) {
                            outermostContext = context === document || context || outermost;
                        }
                        for (; i !== len && (elem = elems[i]) != null; i++) {
                            if (byElement && elem) {
                                j = 0;
                                if (!context && elem.ownerDocument !== document) {
                                    setDocument(elem);
                                    xml = !documentIsHTML;
                                }
                                while (matcher = elementMatchers[j++]) {
                                    if (matcher(elem, context || document, xml)) {
                                        results.push(elem);
                                        break;
                                    }
                                }
                                if (outermost) {
                                    dirruns = dirrunsUnique;
                                }
                            }
                            if (bySet) {
                                if (elem = !matcher && elem) {
                                    matchedCount--;
                                }
                                if (seed) {
                                    unmatched.push(elem);
                                }
                            }
                        }
                        matchedCount += i;
                        if (bySet && i !== matchedCount) {
                            j = 0;
                            while (matcher = setMatchers[j++]) {
                                matcher(unmatched, setMatched, context, xml);
                            }
                            if (seed) {
                                if (matchedCount > 0) {
                                    while (i--) {
                                        if (!(unmatched[i] || setMatched[i])) {
                                            setMatched[i] = pop.call(results);
                                        }
                                    }
                                }
                                setMatched = condense(setMatched);
                            }
                            push.apply(results, setMatched);
                            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
                                Sizzle.uniqueSort(results);
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                            outermostContext = contextBackup;
                        }
                        return unmatched;
                    };
                return bySet ? markFunction(superMatcher) : superMatcher;
            }
            compile = Sizzle.compile = function (selector, match) {
                var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
                if (!cached) {
                    if (!match) {
                        match = tokenize(selector);
                    }
                    i = match.length;
                    while (i--) {
                        cached = matcherFromTokens(match[i]);
                        if (cached[expando]) {
                            setMatchers.push(cached);
                        } else {
                            elementMatchers.push(cached);
                        }
                    }
                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
                    cached.selector = selector;
                }
                return cached;
            };
            select = Sizzle.select = function (selector, context, results, seed) {
                var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
                results = results || [];
                if (match.length === 1) {
                    tokens = match[0] = match[0].slice(0);
                    if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
                        context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
                        if (!context) {
                            return results;
                        } else if (compiled) {
                            context = context.parentNode;
                        }
                        selector = selector.slice(tokens.shift().value.length);
                    }
                    i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
                    while (i--) {
                        token = tokens[i];
                        if (Expr.relative[type = token.type]) {
                            break;
                        }
                        if (find = Expr.find[type]) {
                            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
                                tokens.splice(i, 1);
                                selector = seed.length && toSelector(tokens);
                                if (!selector) {
                                    push.apply(results, seed);
                                    return results;
                                }
                                break;
                            }
                        }
                    }
                }
                (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
                return results;
            };
            support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
            support.detectDuplicates = !!hasDuplicate;
            setDocument();
            support.sortDetached = assert(function (div1) {
                return div1.compareDocumentPosition(document.createElement('div')) & 1;
            });
            if (!assert(function (div) {
                    div.innerHTML = '<a href=\'#\'></a>';
                    return div.firstChild.getAttribute('href') === '#';
                })) {
                addHandle('type|href|height|width', function (elem, name, isXML) {
                    if (!isXML) {
                        return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
                    }
                });
            }
            if (!support.attributes || !assert(function (div) {
                    div.innerHTML = '<input/>';
                    div.firstChild.setAttribute('value', '');
                    return div.firstChild.getAttribute('value') === '';
                })) {
                addHandle('value', function (elem, name, isXML) {
                    if (!isXML && elem.nodeName.toLowerCase() === 'input') {
                        return elem.defaultValue;
                    }
                });
            }
            if (!assert(function (div) {
                    return div.getAttribute('disabled') == null;
                })) {
                addHandle(booleans, function (elem, name, isXML) {
                    var val;
                    if (!isXML) {
                        return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                    }
                });
            }
            return Sizzle;
        }(window);
        jQuery.find = Sizzle;
        jQuery.expr = Sizzle.selectors;
        jQuery.expr[':'] = jQuery.expr.pseudos;
        jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
        jQuery.text = Sizzle.getText;
        jQuery.isXMLDoc = Sizzle.isXML;
        jQuery.contains = Sizzle.contains;
        var dir = function (elem, dir, until) {
            var matched = [], truncate = until !== undefined;
            while ((elem = elem[dir]) && elem.nodeType !== 9) {
                if (elem.nodeType === 1) {
                    if (truncate && jQuery(elem).is(until)) {
                        break;
                    }
                    matched.push(elem);
                }
            }
            return matched;
        };
        var siblings = function (n, elem) {
            var matched = [];
            for (; n; n = n.nextSibling) {
                if (n.nodeType === 1 && n !== elem) {
                    matched.push(n);
                }
            }
            return matched;
        };
        var rneedsContext = jQuery.expr.match.needsContext;
        var rsingleTag = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
        var risSimple = /^.[^:#\[\.,]*$/;
        function winnow(elements, qualifier, not) {
            if (jQuery.isFunction(qualifier)) {
                return jQuery.grep(elements, function (elem, i) {
                    return !!qualifier.call(elem, i, elem) !== not;
                });
            }
            if (qualifier.nodeType) {
                return jQuery.grep(elements, function (elem) {
                    return elem === qualifier !== not;
                });
            }
            if (typeof qualifier === 'string') {
                if (risSimple.test(qualifier)) {
                    return jQuery.filter(qualifier, elements, not);
                }
                qualifier = jQuery.filter(qualifier, elements);
            }
            return jQuery.grep(elements, function (elem) {
                return indexOf.call(qualifier, elem) > -1 !== not;
            });
        }
        jQuery.filter = function (expr, elems, not) {
            var elem = elems[0];
            if (not) {
                expr = ':not(' + expr + ')';
            }
            return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
                return elem.nodeType === 1;
            }));
        };
        jQuery.fn.extend({
            find: function (selector) {
                var i, len = this.length, ret = [], self = this;
                if (typeof selector !== 'string') {
                    return this.pushStack(jQuery(selector).filter(function () {
                        for (i = 0; i < len; i++) {
                            if (jQuery.contains(self[i], this)) {
                                return true;
                            }
                        }
                    }));
                }
                for (i = 0; i < len; i++) {
                    jQuery.find(selector, self[i], ret);
                }
                ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
                ret.selector = this.selector ? this.selector + ' ' + selector : selector;
                return ret;
            },
            filter: function (selector) {
                return this.pushStack(winnow(this, selector || [], false));
            },
            not: function (selector) {
                return this.pushStack(winnow(this, selector || [], true));
            },
            is: function (selector) {
                return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
            }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function (selector, context, root) {
                var match, elem;
                if (!selector) {
                    return this;
                }
                root = root || rootjQuery;
                if (typeof selector === 'string') {
                    if (selector[0] === '<' && selector[selector.length - 1] === '>' && selector.length >= 3) {
                        match = [
                            null,
                            selector,
                            null
                        ];
                    } else {
                        match = rquickExpr.exec(selector);
                    }
                    if (match && (match[1] || !context)) {
                        if (match[1]) {
                            context = context instanceof jQuery ? context[0] : context;
                            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
                            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                                for (match in context) {
                                    if (jQuery.isFunction(this[match])) {
                                        this[match](context[match]);
                                    } else {
                                        this.attr(match, context[match]);
                                    }
                                }
                            }
                            return this;
                        } else {
                            elem = document.getElementById(match[2]);
                            if (elem && elem.parentNode) {
                                this.length = 1;
                                this[0] = elem;
                            }
                            this.context = document;
                            this.selector = selector;
                            return this;
                        }
                    } else if (!context || context.jquery) {
                        return (context || root).find(selector);
                    } else {
                        return this.constructor(context).find(selector);
                    }
                } else if (selector.nodeType) {
                    this.context = this[0] = selector;
                    this.length = 1;
                    return this;
                } else if (jQuery.isFunction(selector)) {
                    return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
                }
                if (selector.selector !== undefined) {
                    this.selector = selector.selector;
                    this.context = selector.context;
                }
                return jQuery.makeArray(selector, this);
            };
        init.prototype = jQuery.fn;
        rootjQuery = jQuery(document);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
                children: true,
                contents: true,
                next: true,
                prev: true
            };
        jQuery.fn.extend({
            has: function (target) {
                var targets = jQuery(target, this), l = targets.length;
                return this.filter(function () {
                    var i = 0;
                    for (; i < l; i++) {
                        if (jQuery.contains(this, targets[i])) {
                            return true;
                        }
                    }
                });
            },
            closest: function (selectors, context) {
                var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
                for (; i < l; i++) {
                    for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
                        if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
                            matched.push(cur);
                            break;
                        }
                    }
                }
                return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
            },
            index: function (elem) {
                if (!elem) {
                    return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
                }
                if (typeof elem === 'string') {
                    return indexOf.call(jQuery(elem), this[0]);
                }
                return indexOf.call(this, elem.jquery ? elem[0] : elem);
            },
            add: function (selector, context) {
                return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
            },
            addBack: function (selector) {
                return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
            }
        });
        function sibling(cur, dir) {
            while ((cur = cur[dir]) && cur.nodeType !== 1) {
            }
            return cur;
        }
        jQuery.each({
            parent: function (elem) {
                var parent = elem.parentNode;
                return parent && parent.nodeType !== 11 ? parent : null;
            },
            parents: function (elem) {
                return dir(elem, 'parentNode');
            },
            parentsUntil: function (elem, i, until) {
                return dir(elem, 'parentNode', until);
            },
            next: function (elem) {
                return sibling(elem, 'nextSibling');
            },
            prev: function (elem) {
                return sibling(elem, 'previousSibling');
            },
            nextAll: function (elem) {
                return dir(elem, 'nextSibling');
            },
            prevAll: function (elem) {
                return dir(elem, 'previousSibling');
            },
            nextUntil: function (elem, i, until) {
                return dir(elem, 'nextSibling', until);
            },
            prevUntil: function (elem, i, until) {
                return dir(elem, 'previousSibling', until);
            },
            siblings: function (elem) {
                return siblings((elem.parentNode || {}).firstChild, elem);
            },
            children: function (elem) {
                return siblings(elem.firstChild);
            },
            contents: function (elem) {
                return elem.contentDocument || jQuery.merge([], elem.childNodes);
            }
        }, function (name, fn) {
            jQuery.fn[name] = function (until, selector) {
                var matched = jQuery.map(this, fn, until);
                if (name.slice(-5) !== 'Until') {
                    selector = until;
                }
                if (selector && typeof selector === 'string') {
                    matched = jQuery.filter(selector, matched);
                }
                if (this.length > 1) {
                    if (!guaranteedUnique[name]) {
                        jQuery.uniqueSort(matched);
                    }
                    if (rparentsprev.test(name)) {
                        matched.reverse();
                    }
                }
                return this.pushStack(matched);
            };
        });
        var rnotwhite = /\S+/g;
        function createOptions(options) {
            var object = {};
            jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
                object[flag] = true;
            });
            return object;
        }
        jQuery.Callbacks = function (options) {
            options = typeof options === 'string' ? createOptions(options) : jQuery.extend({}, options);
            var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function () {
                    locked = options.once;
                    fired = firing = true;
                    for (; queue.length; firingIndex = -1) {
                        memory = queue.shift();
                        while (++firingIndex < list.length) {
                            if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                                firingIndex = list.length;
                                memory = false;
                            }
                        }
                    }
                    if (!options.memory) {
                        memory = false;
                    }
                    firing = false;
                    if (locked) {
                        if (memory) {
                            list = [];
                        } else {
                            list = '';
                        }
                    }
                }, self = {
                    add: function () {
                        if (list) {
                            if (memory && !firing) {
                                firingIndex = list.length - 1;
                                queue.push(memory);
                            }
                            (function add(args) {
                                jQuery.each(args, function (_, arg) {
                                    if (jQuery.isFunction(arg)) {
                                        if (!options.unique || !self.has(arg)) {
                                            list.push(arg);
                                        }
                                    } else if (arg && arg.length && jQuery.type(arg) !== 'string') {
                                        add(arg);
                                    }
                                });
                            }(arguments));
                            if (memory && !firing) {
                                fire();
                            }
                        }
                        return this;
                    },
                    remove: function () {
                        jQuery.each(arguments, function (_, arg) {
                            var index;
                            while ((index = jQuery.inArray(arg, list, index)) > -1) {
                                list.splice(index, 1);
                                if (index <= firingIndex) {
                                    firingIndex--;
                                }
                            }
                        });
                        return this;
                    },
                    has: function (fn) {
                        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
                    },
                    empty: function () {
                        if (list) {
                            list = [];
                        }
                        return this;
                    },
                    disable: function () {
                        locked = queue = [];
                        list = memory = '';
                        return this;
                    },
                    disabled: function () {
                        return !list;
                    },
                    lock: function () {
                        locked = queue = [];
                        if (!memory) {
                            list = memory = '';
                        }
                        return this;
                    },
                    locked: function () {
                        return !!locked;
                    },
                    fireWith: function (context, args) {
                        if (!locked) {
                            args = args || [];
                            args = [
                                context,
                                args.slice ? args.slice() : args
                            ];
                            queue.push(args);
                            if (!firing) {
                                fire();
                            }
                        }
                        return this;
                    },
                    fire: function () {
                        self.fireWith(this, arguments);
                        return this;
                    },
                    fired: function () {
                        return !!fired;
                    }
                };
            return self;
        };
        jQuery.extend({
            Deferred: function (func) {
                var tuples = [
                        [
                            'resolve',
                            'done',
                            jQuery.Callbacks('once memory'),
                            'resolved'
                        ],
                        [
                            'reject',
                            'fail',
                            jQuery.Callbacks('once memory'),
                            'rejected'
                        ],
                        [
                            'notify',
                            'progress',
                            jQuery.Callbacks('memory')
                        ]
                    ], state = 'pending', promise = {
                        state: function () {
                            return state;
                        },
                        always: function () {
                            deferred.done(arguments).fail(arguments);
                            return this;
                        },
                        then: function () {
                            var fns = arguments;
                            return jQuery.Deferred(function (newDefer) {
                                jQuery.each(tuples, function (i, tuple) {
                                    var fn = jQuery.isFunction(fns[i]) && fns[i];
                                    deferred[tuple[1]](function () {
                                        var returned = fn && fn.apply(this, arguments);
                                        if (returned && jQuery.isFunction(returned.promise)) {
                                            returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                        } else {
                                            newDefer[tuple[0] + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                        }
                                    });
                                });
                                fns = null;
                            }).promise();
                        },
                        promise: function (obj) {
                            return obj != null ? jQuery.extend(obj, promise) : promise;
                        }
                    }, deferred = {};
                promise.pipe = promise.then;
                jQuery.each(tuples, function (i, tuple) {
                    var list = tuple[2], stateString = tuple[3];
                    promise[tuple[1]] = list.add;
                    if (stateString) {
                        list.add(function () {
                            state = stateString;
                        }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                    }
                    deferred[tuple[0]] = function () {
                        deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
                        return this;
                    };
                    deferred[tuple[0] + 'With'] = list.fireWith;
                });
                promise.promise(deferred);
                if (func) {
                    func.call(deferred, deferred);
                }
                return deferred;
            },
            when: function (subordinate) {
                var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function (i, contexts, values) {
                        return function (value) {
                            contexts[i] = this;
                            values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                            if (values === progressValues) {
                                deferred.notifyWith(contexts, values);
                            } else if (!--remaining) {
                                deferred.resolveWith(contexts, values);
                            }
                        };
                    }, progressValues, progressContexts, resolveContexts;
                if (length > 1) {
                    progressValues = new Array(length);
                    progressContexts = new Array(length);
                    resolveContexts = new Array(length);
                    for (; i < length; i++) {
                        if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                            resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
                        } else {
                            --remaining;
                        }
                    }
                }
                if (!remaining) {
                    deferred.resolveWith(resolveContexts, resolveValues);
                }
                return deferred.promise();
            }
        });
        var readyList;
        jQuery.fn.ready = function (fn) {
            jQuery.ready.promise().done(fn);
            return this;
        };
        jQuery.extend({
            isReady: false,
            readyWait: 1,
            holdReady: function (hold) {
                if (hold) {
                    jQuery.readyWait++;
                } else {
                    jQuery.ready(true);
                }
            },
            ready: function (wait) {
                if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                    return;
                }
                jQuery.isReady = true;
                if (wait !== true && --jQuery.readyWait > 0) {
                    return;
                }
                readyList.resolveWith(document, [jQuery]);
                if (jQuery.fn.triggerHandler) {
                    jQuery(document).triggerHandler('ready');
                    jQuery(document).off('ready');
                }
            }
        });
        function completed() {
            document.removeEventListener('DOMContentLoaded', completed);
            window.removeEventListener('load', completed);
            jQuery.ready();
        }
        jQuery.ready.promise = function (obj) {
            if (!readyList) {
                readyList = jQuery.Deferred();
                if (document.readyState === 'complete' || document.readyState !== 'loading' && !document.documentElement.doScroll) {
                    window.setTimeout(jQuery.ready);
                } else {
                    document.addEventListener('DOMContentLoaded', completed);
                    window.addEventListener('load', completed);
                }
            }
            return readyList.promise(obj);
        };
        jQuery.ready.promise();
        var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
            var i = 0, len = elems.length, bulk = key == null;
            if (jQuery.type(key) === 'object') {
                chainable = true;
                for (i in key) {
                    access(elems, fn, i, key[i], true, emptyGet, raw);
                }
            } else if (value !== undefined) {
                chainable = true;
                if (!jQuery.isFunction(value)) {
                    raw = true;
                }
                if (bulk) {
                    if (raw) {
                        fn.call(elems, value);
                        fn = null;
                    } else {
                        bulk = fn;
                        fn = function (elem, key, value) {
                            return bulk.call(jQuery(elem), value);
                        };
                    }
                }
                if (fn) {
                    for (; i < len; i++) {
                        fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                    }
                }
            }
            return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
        };
        var acceptData = function (owner) {
            return owner.nodeType === 1 || owner.nodeType === 9 || !+owner.nodeType;
        };
        function Data() {
            this.expando = jQuery.expando + Data.uid++;
        }
        Data.uid = 1;
        Data.prototype = {
            register: function (owner, initial) {
                var value = initial || {};
                if (owner.nodeType) {
                    owner[this.expando] = value;
                } else {
                    Object.defineProperty(owner, this.expando, {
                        value: value,
                        writable: true,
                        configurable: true
                    });
                }
                return owner[this.expando];
            },
            cache: function (owner) {
                if (!acceptData(owner)) {
                    return {};
                }
                var value = owner[this.expando];
                if (!value) {
                    value = {};
                    if (acceptData(owner)) {
                        if (owner.nodeType) {
                            owner[this.expando] = value;
                        } else {
                            Object.defineProperty(owner, this.expando, {
                                value: value,
                                configurable: true
                            });
                        }
                    }
                }
                return value;
            },
            set: function (owner, data, value) {
                var prop, cache = this.cache(owner);
                if (typeof data === 'string') {
                    cache[data] = value;
                } else {
                    for (prop in data) {
                        cache[prop] = data[prop];
                    }
                }
                return cache;
            },
            get: function (owner, key) {
                return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
            },
            access: function (owner, key, value) {
                var stored;
                if (key === undefined || key && typeof key === 'string' && value === undefined) {
                    stored = this.get(owner, key);
                    return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
                }
                this.set(owner, key, value);
                return value !== undefined ? value : key;
            },
            remove: function (owner, key) {
                var i, name, camel, cache = owner[this.expando];
                if (cache === undefined) {
                    return;
                }
                if (key === undefined) {
                    this.register(owner);
                } else {
                    if (jQuery.isArray(key)) {
                        name = key.concat(key.map(jQuery.camelCase));
                    } else {
                        camel = jQuery.camelCase(key);
                        if (key in cache) {
                            name = [
                                key,
                                camel
                            ];
                        } else {
                            name = camel;
                            name = name in cache ? [name] : name.match(rnotwhite) || [];
                        }
                    }
                    i = name.length;
                    while (i--) {
                        delete cache[name[i]];
                    }
                }
                if (key === undefined || jQuery.isEmptyObject(cache)) {
                    if (owner.nodeType) {
                        owner[this.expando] = undefined;
                    } else {
                        delete owner[this.expando];
                    }
                }
            },
            hasData: function (owner) {
                var cache = owner[this.expando];
                return cache !== undefined && !jQuery.isEmptyObject(cache);
            }
        };
        var dataPriv = new Data();
        var dataUser = new Data();
        var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        function dataAttr(elem, key, data) {
            var name;
            if (data === undefined && elem.nodeType === 1) {
                name = 'data-' + key.replace(rmultiDash, '-$&').toLowerCase();
                data = elem.getAttribute(name);
                if (typeof data === 'string') {
                    try {
                        data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                    } catch (e) {
                    }
                    dataUser.set(elem, key, data);
                } else {
                    data = undefined;
                }
            }
            return data;
        }
        jQuery.extend({
            hasData: function (elem) {
                return dataUser.hasData(elem) || dataPriv.hasData(elem);
            },
            data: function (elem, name, data) {
                return dataUser.access(elem, name, data);
            },
            removeData: function (elem, name) {
                dataUser.remove(elem, name);
            },
            _data: function (elem, name, data) {
                return dataPriv.access(elem, name, data);
            },
            _removeData: function (elem, name) {
                dataPriv.remove(elem, name);
            }
        });
        jQuery.fn.extend({
            data: function (key, value) {
                var i, name, data, elem = this[0], attrs = elem && elem.attributes;
                if (key === undefined) {
                    if (this.length) {
                        data = dataUser.get(elem);
                        if (elem.nodeType === 1 && !dataPriv.get(elem, 'hasDataAttrs')) {
                            i = attrs.length;
                            while (i--) {
                                if (attrs[i]) {
                                    name = attrs[i].name;
                                    if (name.indexOf('data-') === 0) {
                                        name = jQuery.camelCase(name.slice(5));
                                        dataAttr(elem, name, data[name]);
                                    }
                                }
                            }
                            dataPriv.set(elem, 'hasDataAttrs', true);
                        }
                    }
                    return data;
                }
                if (typeof key === 'object') {
                    return this.each(function () {
                        dataUser.set(this, key);
                    });
                }
                return access(this, function (value) {
                    var data, camelKey;
                    if (elem && value === undefined) {
                        data = dataUser.get(elem, key) || dataUser.get(elem, key.replace(rmultiDash, '-$&').toLowerCase());
                        if (data !== undefined) {
                            return data;
                        }
                        camelKey = jQuery.camelCase(key);
                        data = dataUser.get(elem, camelKey);
                        if (data !== undefined) {
                            return data;
                        }
                        data = dataAttr(elem, camelKey, undefined);
                        if (data !== undefined) {
                            return data;
                        }
                        return;
                    }
                    camelKey = jQuery.camelCase(key);
                    this.each(function () {
                        var data = dataUser.get(this, camelKey);
                        dataUser.set(this, camelKey, value);
                        if (key.indexOf('-') > -1 && data !== undefined) {
                            dataUser.set(this, key, value);
                        }
                    });
                }, null, value, arguments.length > 1, null, true);
            },
            removeData: function (key) {
                return this.each(function () {
                    dataUser.remove(this, key);
                });
            }
        });
        jQuery.extend({
            queue: function (elem, type, data) {
                var queue;
                if (elem) {
                    type = (type || 'fx') + 'queue';
                    queue = dataPriv.get(elem, type);
                    if (data) {
                        if (!queue || jQuery.isArray(data)) {
                            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                        } else {
                            queue.push(data);
                        }
                    }
                    return queue || [];
                }
            },
            dequeue: function (elem, type) {
                type = type || 'fx';
                var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                        jQuery.dequeue(elem, type);
                    };
                if (fn === 'inprogress') {
                    fn = queue.shift();
                    startLength--;
                }
                if (fn) {
                    if (type === 'fx') {
                        queue.unshift('inprogress');
                    }
                    delete hooks.stop;
                    fn.call(elem, next, hooks);
                }
                if (!startLength && hooks) {
                    hooks.empty.fire();
                }
            },
            _queueHooks: function (elem, type) {
                var key = type + 'queueHooks';
                return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                    empty: jQuery.Callbacks('once memory').add(function () {
                        dataPriv.remove(elem, [
                            type + 'queue',
                            key
                        ]);
                    })
                });
            }
        });
        jQuery.fn.extend({
            queue: function (type, data) {
                var setter = 2;
                if (typeof type !== 'string') {
                    data = type;
                    type = 'fx';
                    setter--;
                }
                if (arguments.length < setter) {
                    return jQuery.queue(this[0], type);
                }
                return data === undefined ? this : this.each(function () {
                    var queue = jQuery.queue(this, type, data);
                    jQuery._queueHooks(this, type);
                    if (type === 'fx' && queue[0] !== 'inprogress') {
                        jQuery.dequeue(this, type);
                    }
                });
            },
            dequeue: function (type) {
                return this.each(function () {
                    jQuery.dequeue(this, type);
                });
            },
            clearQueue: function (type) {
                return this.queue(type || 'fx', []);
            },
            promise: function (type, obj) {
                var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                        if (!--count) {
                            defer.resolveWith(elements, [elements]);
                        }
                    };
                if (typeof type !== 'string') {
                    obj = type;
                    type = undefined;
                }
                type = type || 'fx';
                while (i--) {
                    tmp = dataPriv.get(elements[i], type + 'queueHooks');
                    if (tmp && tmp.empty) {
                        count++;
                        tmp.empty.add(resolve);
                    }
                }
                resolve();
                return defer.promise(obj);
            }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
        var rcssNum = new RegExp('^(?:([+-])=|)(' + pnum + ')([a-z%]*)$', 'i');
        var cssExpand = [
            'Top',
            'Right',
            'Bottom',
            'Left'
        ];
        var isHidden = function (elem, el) {
            elem = el || elem;
            return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
        };
        function adjustCSS(elem, prop, valueParts, tween) {
            var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function () {
                    return tween.cur();
                } : function () {
                    return jQuery.css(elem, prop, '');
                }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), initialInUnit = (jQuery.cssNumber[prop] || unit !== 'px' && +initial) && rcssNum.exec(jQuery.css(elem, prop));
            if (initialInUnit && initialInUnit[3] !== unit) {
                unit = unit || initialInUnit[3];
                valueParts = valueParts || [];
                initialInUnit = +initial || 1;
                do {
                    scale = scale || '.5';
                    initialInUnit = initialInUnit / scale;
                    jQuery.style(elem, prop, initialInUnit + unit);
                } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
            }
            if (valueParts) {
                initialInUnit = +initialInUnit || +initial || 0;
                adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
                if (tween) {
                    tween.unit = unit;
                    tween.start = initialInUnit;
                    tween.end = adjusted;
                }
            }
            return adjusted;
        }
        var rcheckableType = /^(?:checkbox|radio)$/i;
        var rtagName = /<([\w:-]+)/;
        var rscriptType = /^$|\/(?:java|ecma)script/i;
        var wrapMap = {
            option: [
                1,
                '<select multiple=\'multiple\'>',
                '</select>'
            ],
            thead: [
                1,
                '<table>',
                '</table>'
            ],
            col: [
                2,
                '<table><colgroup>',
                '</colgroup></table>'
            ],
            tr: [
                2,
                '<table><tbody>',
                '</tbody></table>'
            ],
            td: [
                3,
                '<table><tbody><tr>',
                '</tr></tbody></table>'
            ],
            _default: [
                0,
                '',
                ''
            ]
        };
        wrapMap.optgroup = wrapMap.option;
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        function getAll(context, tag) {
            var ret = typeof context.getElementsByTagName !== 'undefined' ? context.getElementsByTagName(tag || '*') : typeof context.querySelectorAll !== 'undefined' ? context.querySelectorAll(tag || '*') : [];
            return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
        }
        function setGlobalEval(elems, refElements) {
            var i = 0, l = elems.length;
            for (; i < l; i++) {
                dataPriv.set(elems[i], 'globalEval', !refElements || dataPriv.get(refElements[i], 'globalEval'));
            }
        }
        var rhtml = /<|&#?\w+;/;
        function buildFragment(elems, context, scripts, selection, ignored) {
            var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;
            for (; i < l; i++) {
                elem = elems[i];
                if (elem || elem === 0) {
                    if (jQuery.type(elem) === 'object') {
                        jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                    } else if (!rhtml.test(elem)) {
                        nodes.push(context.createTextNode(elem));
                    } else {
                        tmp = tmp || fragment.appendChild(context.createElement('div'));
                        tag = (rtagName.exec(elem) || [
                            '',
                            ''
                        ])[1].toLowerCase();
                        wrap = wrapMap[tag] || wrapMap._default;
                        tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
                        j = wrap[0];
                        while (j--) {
                            tmp = tmp.lastChild;
                        }
                        jQuery.merge(nodes, tmp.childNodes);
                        tmp = fragment.firstChild;
                        tmp.textContent = '';
                    }
                }
            }
            fragment.textContent = '';
            i = 0;
            while (elem = nodes[i++]) {
                if (selection && jQuery.inArray(elem, selection) > -1) {
                    if (ignored) {
                        ignored.push(elem);
                    }
                    continue;
                }
                contains = jQuery.contains(elem.ownerDocument, elem);
                tmp = getAll(fragment.appendChild(elem), 'script');
                if (contains) {
                    setGlobalEval(tmp);
                }
                if (scripts) {
                    j = 0;
                    while (elem = tmp[j++]) {
                        if (rscriptType.test(elem.type || '')) {
                            scripts.push(elem);
                        }
                    }
                }
            }
            return fragment;
        }
        (function () {
            var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement('div')), input = document.createElement('input');
            input.setAttribute('type', 'radio');
            input.setAttribute('checked', 'checked');
            input.setAttribute('name', 't');
            div.appendChild(input);
            support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
            div.innerHTML = '<textarea>x</textarea>';
            support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
        }());
        var rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        function returnTrue() {
            return true;
        }
        function returnFalse() {
            return false;
        }
        function safeActiveElement() {
            try {
                return document.activeElement;
            } catch (err) {
            }
        }
        function on(elem, types, selector, data, fn, one) {
            var origFn, type;
            if (typeof types === 'object') {
                if (typeof selector !== 'string') {
                    data = data || selector;
                    selector = undefined;
                }
                for (type in types) {
                    on(elem, type, selector, data, types[type], one);
                }
                return elem;
            }
            if (data == null && fn == null) {
                fn = selector;
                data = selector = undefined;
            } else if (fn == null) {
                if (typeof selector === 'string') {
                    fn = data;
                    data = undefined;
                } else {
                    fn = data;
                    data = selector;
                    selector = undefined;
                }
            }
            if (fn === false) {
                fn = returnFalse;
            } else if (!fn) {
                return elem;
            }
            if (one === 1) {
                origFn = fn;
                fn = function (event) {
                    jQuery().off(event);
                    return origFn.apply(this, arguments);
                };
                fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
            }
            return elem.each(function () {
                jQuery.event.add(this, types, fn, data, selector);
            });
        }
        jQuery.event = {
            global: {},
            add: function (elem, types, handler, data, selector) {
                var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
                if (!elemData) {
                    return;
                }
                if (handler.handler) {
                    handleObjIn = handler;
                    handler = handleObjIn.handler;
                    selector = handleObjIn.selector;
                }
                if (!handler.guid) {
                    handler.guid = jQuery.guid++;
                }
                if (!(events = elemData.events)) {
                    events = elemData.events = {};
                }
                if (!(eventHandle = elemData.handle)) {
                    eventHandle = elemData.handle = function (e) {
                        return typeof jQuery !== 'undefined' && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                    };
                }
                types = (types || '').match(rnotwhite) || [''];
                t = types.length;
                while (t--) {
                    tmp = rtypenamespace.exec(types[t]) || [];
                    type = origType = tmp[1];
                    namespaces = (tmp[2] || '').split('.').sort();
                    if (!type) {
                        continue;
                    }
                    special = jQuery.event.special[type] || {};
                    type = (selector ? special.delegateType : special.bindType) || type;
                    special = jQuery.event.special[type] || {};
                    handleObj = jQuery.extend({
                        type: type,
                        origType: origType,
                        data: data,
                        handler: handler,
                        guid: handler.guid,
                        selector: selector,
                        needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                        namespace: namespaces.join('.')
                    }, handleObjIn);
                    if (!(handlers = events[type])) {
                        handlers = events[type] = [];
                        handlers.delegateCount = 0;
                        if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
                            if (elem.addEventListener) {
                                elem.addEventListener(type, eventHandle);
                            }
                        }
                    }
                    if (special.add) {
                        special.add.call(elem, handleObj);
                        if (!handleObj.handler.guid) {
                            handleObj.handler.guid = handler.guid;
                        }
                    }
                    if (selector) {
                        handlers.splice(handlers.delegateCount++, 0, handleObj);
                    } else {
                        handlers.push(handleObj);
                    }
                    jQuery.event.global[type] = true;
                }
            },
            remove: function (elem, types, handler, selector, mappedTypes) {
                var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
                if (!elemData || !(events = elemData.events)) {
                    return;
                }
                types = (types || '').match(rnotwhite) || [''];
                t = types.length;
                while (t--) {
                    tmp = rtypenamespace.exec(types[t]) || [];
                    type = origType = tmp[1];
                    namespaces = (tmp[2] || '').split('.').sort();
                    if (!type) {
                        for (type in events) {
                            jQuery.event.remove(elem, type + types[t], handler, selector, true);
                        }
                        continue;
                    }
                    special = jQuery.event.special[type] || {};
                    type = (selector ? special.delegateType : special.bindType) || type;
                    handlers = events[type] || [];
                    tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
                    origCount = j = handlers.length;
                    while (j--) {
                        handleObj = handlers[j];
                        if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
                            handlers.splice(j, 1);
                            if (handleObj.selector) {
                                handlers.delegateCount--;
                            }
                            if (special.remove) {
                                special.remove.call(elem, handleObj);
                            }
                        }
                    }
                    if (origCount && !handlers.length) {
                        if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
                            jQuery.removeEvent(elem, type, elemData.handle);
                        }
                        delete events[type];
                    }
                }
                if (jQuery.isEmptyObject(events)) {
                    dataPriv.remove(elem, 'handle events');
                }
            },
            dispatch: function (event) {
                event = jQuery.event.fix(event);
                var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (dataPriv.get(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
                args[0] = event;
                event.delegateTarget = this;
                if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                    return;
                }
                handlerQueue = jQuery.event.handlers.call(this, event, handlers);
                i = 0;
                while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                    event.currentTarget = matched.elem;
                    j = 0;
                    while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
                        if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
                            event.handleObj = handleObj;
                            event.data = handleObj.data;
                            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
                            if (ret !== undefined) {
                                if ((event.result = ret) === false) {
                                    event.preventDefault();
                                    event.stopPropagation();
                                }
                            }
                        }
                    }
                }
                if (special.postDispatch) {
                    special.postDispatch.call(this, event);
                }
                return event.result;
            },
            handlers: function (event, handlers) {
                var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
                if (delegateCount && cur.nodeType && (event.type !== 'click' || isNaN(event.button) || event.button < 1)) {
                    for (; cur !== this; cur = cur.parentNode || this) {
                        if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== 'click')) {
                            matches = [];
                            for (i = 0; i < delegateCount; i++) {
                                handleObj = handlers[i];
                                sel = handleObj.selector + ' ';
                                if (matches[sel] === undefined) {
                                    matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                                }
                                if (matches[sel]) {
                                    matches.push(handleObj);
                                }
                            }
                            if (matches.length) {
                                handlerQueue.push({
                                    elem: cur,
                                    handlers: matches
                                });
                            }
                        }
                    }
                }
                if (delegateCount < handlers.length) {
                    handlerQueue.push({
                        elem: this,
                        handlers: handlers.slice(delegateCount)
                    });
                }
                return handlerQueue;
            },
            props: ('altKey bubbles cancelable ctrlKey currentTarget detail eventPhase ' + 'metaKey relatedTarget shiftKey target timeStamp view which').split(' '),
            fixHooks: {},
            keyHooks: {
                props: 'char charCode key keyCode'.split(' '),
                filter: function (event, original) {
                    if (event.which == null) {
                        event.which = original.charCode != null ? original.charCode : original.keyCode;
                    }
                    return event;
                }
            },
            mouseHooks: {
                props: ('button buttons clientX clientY offsetX offsetY pageX pageY ' + 'screenX screenY toElement').split(' '),
                filter: function (event, original) {
                    var eventDoc, doc, body, button = original.button;
                    if (event.pageX == null && original.clientX != null) {
                        eventDoc = event.target.ownerDocument || document;
                        doc = eventDoc.documentElement;
                        body = eventDoc.body;
                        event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                        event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                    }
                    if (!event.which && button !== undefined) {
                        event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
                    }
                    return event;
                }
            },
            fix: function (event) {
                if (event[jQuery.expando]) {
                    return event;
                }
                var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
                if (!fixHook) {
                    this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
                }
                copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
                event = new jQuery.Event(originalEvent);
                i = copy.length;
                while (i--) {
                    prop = copy[i];
                    event[prop] = originalEvent[prop];
                }
                if (!event.target) {
                    event.target = document;
                }
                if (event.target.nodeType === 3) {
                    event.target = event.target.parentNode;
                }
                return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
            },
            special: {
                load: { noBubble: true },
                focus: {
                    trigger: function () {
                        if (this !== safeActiveElement() && this.focus) {
                            this.focus();
                            return false;
                        }
                    },
                    delegateType: 'focusin'
                },
                blur: {
                    trigger: function () {
                        if (this === safeActiveElement() && this.blur) {
                            this.blur();
                            return false;
                        }
                    },
                    delegateType: 'focusout'
                },
                click: {
                    trigger: function () {
                        if (this.type === 'checkbox' && this.click && jQuery.nodeName(this, 'input')) {
                            this.click();
                            return false;
                        }
                    },
                    _default: function (event) {
                        return jQuery.nodeName(event.target, 'a');
                    }
                },
                beforeunload: {
                    postDispatch: function (event) {
                        if (event.result !== undefined && event.originalEvent) {
                            event.originalEvent.returnValue = event.result;
                        }
                    }
                }
            }
        };
        jQuery.removeEvent = function (elem, type, handle) {
            if (elem.removeEventListener) {
                elem.removeEventListener(type, handle);
            }
        };
        jQuery.Event = function (src, props) {
            if (!(this instanceof jQuery.Event)) {
                return new jQuery.Event(src, props);
            }
            if (src && src.type) {
                this.originalEvent = src;
                this.type = src.type;
                this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
            } else {
                this.type = src;
            }
            if (props) {
                jQuery.extend(this, props);
            }
            this.timeStamp = src && src.timeStamp || jQuery.now();
            this[jQuery.expando] = true;
        };
        jQuery.Event.prototype = {
            constructor: jQuery.Event,
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            preventDefault: function () {
                var e = this.originalEvent;
                this.isDefaultPrevented = returnTrue;
                if (e) {
                    e.preventDefault();
                }
            },
            stopPropagation: function () {
                var e = this.originalEvent;
                this.isPropagationStopped = returnTrue;
                if (e) {
                    e.stopPropagation();
                }
            },
            stopImmediatePropagation: function () {
                var e = this.originalEvent;
                this.isImmediatePropagationStopped = returnTrue;
                if (e) {
                    e.stopImmediatePropagation();
                }
                this.stopPropagation();
            }
        };
        jQuery.each({
            mouseenter: 'mouseover',
            mouseleave: 'mouseout',
            pointerenter: 'pointerover',
            pointerleave: 'pointerout'
        }, function (orig, fix) {
            jQuery.event.special[orig] = {
                delegateType: fix,
                bindType: fix,
                handle: function (event) {
                    var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                    if (!related || related !== target && !jQuery.contains(target, related)) {
                        event.type = handleObj.origType;
                        ret = handleObj.handler.apply(this, arguments);
                        event.type = fix;
                    }
                    return ret;
                }
            };
        });
        jQuery.fn.extend({
            on: function (types, selector, data, fn) {
                return on(this, types, selector, data, fn);
            },
            one: function (types, selector, data, fn) {
                return on(this, types, selector, data, fn, 1);
            },
            off: function (types, selector, fn) {
                var handleObj, type;
                if (types && types.preventDefault && types.handleObj) {
                    handleObj = types.handleObj;
                    jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                    return this;
                }
                if (typeof types === 'object') {
                    for (type in types) {
                        this.off(type, selector, types[type]);
                    }
                    return this;
                }
                if (selector === false || typeof selector === 'function') {
                    fn = selector;
                    selector = undefined;
                }
                if (fn === false) {
                    fn = returnFalse;
                }
                return this.each(function () {
                    jQuery.event.remove(this, types, fn, selector);
                });
            }
        });
        var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
        function manipulationTarget(elem, content) {
            return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
        }
        function disableScript(elem) {
            elem.type = (elem.getAttribute('type') !== null) + '/' + elem.type;
            return elem;
        }
        function restoreScript(elem) {
            var match = rscriptTypeMasked.exec(elem.type);
            if (match) {
                elem.type = match[1];
            } else {
                elem.removeAttribute('type');
            }
            return elem;
        }
        function cloneCopyEvent(src, dest) {
            var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
            if (dest.nodeType !== 1) {
                return;
            }
            if (dataPriv.hasData(src)) {
                pdataOld = dataPriv.access(src);
                pdataCur = dataPriv.set(dest, pdataOld);
                events = pdataOld.events;
                if (events) {
                    delete pdataCur.handle;
                    pdataCur.events = {};
                    for (type in events) {
                        for (i = 0, l = events[type].length; i < l; i++) {
                            jQuery.event.add(dest, type, events[type][i]);
                        }
                    }
                }
            }
            if (dataUser.hasData(src)) {
                udataOld = dataUser.access(src);
                udataCur = jQuery.extend({}, udataOld);
                dataUser.set(dest, udataCur);
            }
        }
        function fixInput(src, dest) {
            var nodeName = dest.nodeName.toLowerCase();
            if (nodeName === 'input' && rcheckableType.test(src.type)) {
                dest.checked = src.checked;
            } else if (nodeName === 'input' || nodeName === 'textarea') {
                dest.defaultValue = src.defaultValue;
            }
        }
        function domManip(collection, args, callback, ignored) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
                return collection.each(function (index) {
                    var self = collection.eq(index);
                    if (isFunction) {
                        args[0] = value.call(this, index, self.html());
                    }
                    domManip(self, args, callback, ignored);
                });
            }
            if (l) {
                fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
                first = fragment.firstChild;
                if (fragment.childNodes.length === 1) {
                    fragment = first;
                }
                if (first || ignored) {
                    scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
                    hasScripts = scripts.length;
                    for (; i < l; i++) {
                        node = fragment;
                        if (i !== iNoClone) {
                            node = jQuery.clone(node, true, true);
                            if (hasScripts) {
                                jQuery.merge(scripts, getAll(node, 'script'));
                            }
                        }
                        callback.call(collection[i], node, i);
                    }
                    if (hasScripts) {
                        doc = scripts[scripts.length - 1].ownerDocument;
                        jQuery.map(scripts, restoreScript);
                        for (i = 0; i < hasScripts; i++) {
                            node = scripts[i];
                            if (rscriptType.test(node.type || '') && !dataPriv.access(node, 'globalEval') && jQuery.contains(doc, node)) {
                                if (node.src) {
                                    if (jQuery._evalUrl) {
                                        jQuery._evalUrl(node.src);
                                    }
                                } else {
                                    jQuery.globalEval(node.textContent.replace(rcleanScript, ''));
                                }
                            }
                        }
                    }
                }
            }
            return collection;
        }
        function remove(elem, selector, keepData) {
            var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;
            for (; (node = nodes[i]) != null; i++) {
                if (!keepData && node.nodeType === 1) {
                    jQuery.cleanData(getAll(node));
                }
                if (node.parentNode) {
                    if (keepData && jQuery.contains(node.ownerDocument, node)) {
                        setGlobalEval(getAll(node, 'script'));
                    }
                    node.parentNode.removeChild(node);
                }
            }
            return elem;
        }
        jQuery.extend({
            htmlPrefilter: function (html) {
                return html.replace(rxhtmlTag, '<$1></$2>');
            },
            clone: function (elem, dataAndEvents, deepDataAndEvents) {
                var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);
                if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
                    destElements = getAll(clone);
                    srcElements = getAll(elem);
                    for (i = 0, l = srcElements.length; i < l; i++) {
                        fixInput(srcElements[i], destElements[i]);
                    }
                }
                if (dataAndEvents) {
                    if (deepDataAndEvents) {
                        srcElements = srcElements || getAll(elem);
                        destElements = destElements || getAll(clone);
                        for (i = 0, l = srcElements.length; i < l; i++) {
                            cloneCopyEvent(srcElements[i], destElements[i]);
                        }
                    } else {
                        cloneCopyEvent(elem, clone);
                    }
                }
                destElements = getAll(clone, 'script');
                if (destElements.length > 0) {
                    setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
                }
                return clone;
            },
            cleanData: function (elems) {
                var data, elem, type, special = jQuery.event.special, i = 0;
                for (; (elem = elems[i]) !== undefined; i++) {
                    if (acceptData(elem)) {
                        if (data = elem[dataPriv.expando]) {
                            if (data.events) {
                                for (type in data.events) {
                                    if (special[type]) {
                                        jQuery.event.remove(elem, type);
                                    } else {
                                        jQuery.removeEvent(elem, type, data.handle);
                                    }
                                }
                            }
                            elem[dataPriv.expando] = undefined;
                        }
                        if (elem[dataUser.expando]) {
                            elem[dataUser.expando] = undefined;
                        }
                    }
                }
            }
        });
        jQuery.fn.extend({
            domManip: domManip,
            detach: function (selector) {
                return remove(this, selector, true);
            },
            remove: function (selector) {
                return remove(this, selector);
            },
            text: function (value) {
                return access(this, function (value) {
                    return value === undefined ? jQuery.text(this) : this.empty().each(function () {
                        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                            this.textContent = value;
                        }
                    });
                }, null, value, arguments.length);
            },
            append: function () {
                return domManip(this, arguments, function (elem) {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        var target = manipulationTarget(this, elem);
                        target.appendChild(elem);
                    }
                });
            },
            prepend: function () {
                return domManip(this, arguments, function (elem) {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        var target = manipulationTarget(this, elem);
                        target.insertBefore(elem, target.firstChild);
                    }
                });
            },
            before: function () {
                return domManip(this, arguments, function (elem) {
                    if (this.parentNode) {
                        this.parentNode.insertBefore(elem, this);
                    }
                });
            },
            after: function () {
                return domManip(this, arguments, function (elem) {
                    if (this.parentNode) {
                        this.parentNode.insertBefore(elem, this.nextSibling);
                    }
                });
            },
            empty: function () {
                var elem, i = 0;
                for (; (elem = this[i]) != null; i++) {
                    if (elem.nodeType === 1) {
                        jQuery.cleanData(getAll(elem, false));
                        elem.textContent = '';
                    }
                }
                return this;
            },
            clone: function (dataAndEvents, deepDataAndEvents) {
                dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
                deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
                return this.map(function () {
                    return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
                });
            },
            html: function (value) {
                return access(this, function (value) {
                    var elem = this[0] || {}, i = 0, l = this.length;
                    if (value === undefined && elem.nodeType === 1) {
                        return elem.innerHTML;
                    }
                    if (typeof value === 'string' && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || [
                            '',
                            ''
                        ])[1].toLowerCase()]) {
                        value = jQuery.htmlPrefilter(value);
                        try {
                            for (; i < l; i++) {
                                elem = this[i] || {};
                                if (elem.nodeType === 1) {
                                    jQuery.cleanData(getAll(elem, false));
                                    elem.innerHTML = value;
                                }
                            }
                            elem = 0;
                        } catch (e) {
                        }
                    }
                    if (elem) {
                        this.empty().append(value);
                    }
                }, null, value, arguments.length);
            },
            replaceWith: function () {
                var ignored = [];
                return domManip(this, arguments, function (elem) {
                    var parent = this.parentNode;
                    if (jQuery.inArray(this, ignored) < 0) {
                        jQuery.cleanData(getAll(this));
                        if (parent) {
                            parent.replaceChild(elem, this);
                        }
                    }
                }, ignored);
            }
        });
        jQuery.each({
            appendTo: 'append',
            prependTo: 'prepend',
            insertBefore: 'before',
            insertAfter: 'after',
            replaceAll: 'replaceWith'
        }, function (name, original) {
            jQuery.fn[name] = function (selector) {
                var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;
                for (; i <= last; i++) {
                    elems = i === last ? this : this.clone(true);
                    jQuery(insert[i])[original](elems);
                    push.apply(ret, elems.get());
                }
                return this.pushStack(ret);
            };
        });
        var iframe, elemdisplay = {
                HTML: 'block',
                BODY: 'block'
            };
        function actualDisplay(name, doc) {
            var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], 'display');
            elem.detach();
            return display;
        }
        function defaultDisplay(nodeName) {
            var doc = document, display = elemdisplay[nodeName];
            if (!display) {
                display = actualDisplay(nodeName, doc);
                if (display === 'none' || !display) {
                    iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>')).appendTo(doc.documentElement);
                    doc = iframe[0].contentDocument;
                    doc.write();
                    doc.close();
                    display = actualDisplay(nodeName, doc);
                    iframe.detach();
                }
                elemdisplay[nodeName] = display;
            }
            return display;
        }
        var rmargin = /^margin/;
        var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
        var getStyles = function (elem) {
            var view = elem.ownerDocument.defaultView;
            if (!view || !view.opener) {
                view = window;
            }
            return view.getComputedStyle(elem);
        };
        var swap = function (elem, options, callback, args) {
            var ret, name, old = {};
            for (name in options) {
                old[name] = elem.style[name];
                elem.style[name] = options[name];
            }
            ret = callback.apply(elem, args || []);
            for (name in options) {
                elem.style[name] = old[name];
            }
            return ret;
        };
        var documentElement = document.documentElement;
        (function () {
            var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement('div'), div = document.createElement('div');
            if (!div.style) {
                return;
            }
            div.style.backgroundClip = 'content-box';
            div.cloneNode(true).style.backgroundClip = '';
            support.clearCloneStyle = div.style.backgroundClip === 'content-box';
            container.style.cssText = 'border:0;width:8px;height:0;top:0;left:-9999px;' + 'padding:0;margin-top:1px;position:absolute';
            container.appendChild(div);
            function computeStyleTests() {
                div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;' + 'position:relative;display:block;' + 'margin:auto;border:1px;padding:1px;' + 'top:1%;width:50%';
                div.innerHTML = '';
                documentElement.appendChild(container);
                var divStyle = window.getComputedStyle(div);
                pixelPositionVal = divStyle.top !== '1%';
                reliableMarginLeftVal = divStyle.marginLeft === '2px';
                boxSizingReliableVal = divStyle.width === '4px';
                div.style.marginRight = '50%';
                pixelMarginRightVal = divStyle.marginRight === '4px';
                documentElement.removeChild(container);
            }
            jQuery.extend(support, {
                pixelPosition: function () {
                    computeStyleTests();
                    return pixelPositionVal;
                },
                boxSizingReliable: function () {
                    if (boxSizingReliableVal == null) {
                        computeStyleTests();
                    }
                    return boxSizingReliableVal;
                },
                pixelMarginRight: function () {
                    if (boxSizingReliableVal == null) {
                        computeStyleTests();
                    }
                    return pixelMarginRightVal;
                },
                reliableMarginLeft: function () {
                    if (boxSizingReliableVal == null) {
                        computeStyleTests();
                    }
                    return reliableMarginLeftVal;
                },
                reliableMarginRight: function () {
                    var ret, marginDiv = div.appendChild(document.createElement('div'));
                    marginDiv.style.cssText = div.style.cssText = '-webkit-box-sizing:content-box;box-sizing:content-box;' + 'display:block;margin:0;border:0;padding:0';
                    marginDiv.style.marginRight = marginDiv.style.width = '0';
                    div.style.width = '1px';
                    documentElement.appendChild(container);
                    ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);
                    documentElement.removeChild(container);
                    div.removeChild(marginDiv);
                    return ret;
                }
            });
        }());
        function curCSS(elem, name, computed) {
            var width, minWidth, maxWidth, ret, style = elem.style;
            computed = computed || getStyles(elem);
            ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
            if ((ret === '' || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
                ret = jQuery.style(elem, name);
            }
            if (computed) {
                if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
                    width = style.width;
                    minWidth = style.minWidth;
                    maxWidth = style.maxWidth;
                    style.minWidth = style.maxWidth = style.width = ret;
                    ret = computed.width;
                    style.width = width;
                    style.minWidth = minWidth;
                    style.maxWidth = maxWidth;
                }
            }
            return ret !== undefined ? ret + '' : ret;
        }
        function addGetHookIf(conditionFn, hookFn) {
            return {
                get: function () {
                    if (conditionFn()) {
                        delete this.get;
                        return;
                    }
                    return (this.get = hookFn).apply(this, arguments);
                }
            };
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {
                position: 'absolute',
                visibility: 'hidden',
                display: 'block'
            }, cssNormalTransform = {
                letterSpacing: '0',
                fontWeight: '400'
            }, cssPrefixes = [
                'Webkit',
                'O',
                'Moz',
                'ms'
            ], emptyStyle = document.createElement('div').style;
        function vendorPropName(name) {
            if (name in emptyStyle) {
                return name;
            }
            var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length;
            while (i--) {
                name = cssPrefixes[i] + capName;
                if (name in emptyStyle) {
                    return name;
                }
            }
        }
        function setPositiveNumber(elem, value, subtract) {
            var matches = rcssNum.exec(value);
            return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || 'px') : value;
        }
        function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
            var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
            for (; i < 4; i += 2) {
                if (extra === 'margin') {
                    val += jQuery.css(elem, extra + cssExpand[i], true, styles);
                }
                if (isBorderBox) {
                    if (extra === 'content') {
                        val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                    }
                    if (extra !== 'margin') {
                        val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                    }
                } else {
                    val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
                    if (extra !== 'padding') {
                        val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
                    }
                }
            }
            return val;
        }
        function getWidthOrHeight(elem, name, extra) {
            var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
            if (document.msFullscreenElement && window.top !== window) {
                if (elem.getClientRects().length) {
                    val = Math.round(elem.getBoundingClientRect()[name] * 100);
                }
            }
            if (val <= 0 || val == null) {
                val = curCSS(elem, name, styles);
                if (val < 0 || val == null) {
                    val = elem.style[name];
                }
                if (rnumnonpx.test(val)) {
                    return val;
                }
                valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
                val = parseFloat(val) || 0;
            }
            return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
        }
        function showHide(elements, show) {
            var display, elem, hidden, values = [], index = 0, length = elements.length;
            for (; index < length; index++) {
                elem = elements[index];
                if (!elem.style) {
                    continue;
                }
                values[index] = dataPriv.get(elem, 'olddisplay');
                display = elem.style.display;
                if (show) {
                    if (!values[index] && display === 'none') {
                        elem.style.display = '';
                    }
                    if (elem.style.display === '' && isHidden(elem)) {
                        values[index] = dataPriv.access(elem, 'olddisplay', defaultDisplay(elem.nodeName));
                    }
                } else {
                    hidden = isHidden(elem);
                    if (display !== 'none' || !hidden) {
                        dataPriv.set(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
                    }
                }
            }
            for (index = 0; index < length; index++) {
                elem = elements[index];
                if (!elem.style) {
                    continue;
                }
                if (!show || elem.style.display === 'none' || elem.style.display === '') {
                    elem.style.display = show ? values[index] || '' : 'none';
                }
            }
            return elements;
        }
        jQuery.extend({
            cssHooks: {
                opacity: {
                    get: function (elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, 'opacity');
                            return ret === '' ? '1' : ret;
                        }
                    }
                }
            },
            cssNumber: {
                'animationIterationCount': true,
                'columnCount': true,
                'fillOpacity': true,
                'flexGrow': true,
                'flexShrink': true,
                'fontWeight': true,
                'lineHeight': true,
                'opacity': true,
                'order': true,
                'orphans': true,
                'widows': true,
                'zIndex': true,
                'zoom': true
            },
            cssProps: { 'float': 'cssFloat' },
            style: function (elem, name, value, extra) {
                if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                    return;
                }
                var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
                name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                if (value !== undefined) {
                    type = typeof value;
                    if (type === 'string' && (ret = rcssNum.exec(value)) && ret[1]) {
                        value = adjustCSS(elem, name, ret);
                        type = 'number';
                    }
                    if (value == null || value !== value) {
                        return;
                    }
                    if (type === 'number') {
                        value += ret && ret[3] || (jQuery.cssNumber[origName] ? '' : 'px');
                    }
                    if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
                        style[name] = 'inherit';
                    }
                    if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
                        style[name] = value;
                    }
                } else {
                    if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
                        return ret;
                    }
                    return style[name];
                }
            },
            css: function (elem, name, extra, styles) {
                var val, num, hooks, origName = jQuery.camelCase(name);
                name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
                hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
                if (hooks && 'get' in hooks) {
                    val = hooks.get(elem, true, extra);
                }
                if (val === undefined) {
                    val = curCSS(elem, name, styles);
                }
                if (val === 'normal' && name in cssNormalTransform) {
                    val = cssNormalTransform[name];
                }
                if (extra === '' || extra) {
                    num = parseFloat(val);
                    return extra === true || isFinite(num) ? num || 0 : val;
                }
                return val;
            }
        });
        jQuery.each([
            'height',
            'width'
        ], function (i, name) {
            jQuery.cssHooks[name] = {
                get: function (elem, computed, extra) {
                    if (computed) {
                        return rdisplayswap.test(jQuery.css(elem, 'display')) && elem.offsetWidth === 0 ? swap(elem, cssShow, function () {
                            return getWidthOrHeight(elem, name, extra);
                        }) : getWidthOrHeight(elem, name, extra);
                    }
                },
                set: function (elem, value, extra) {
                    var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles);
                    if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || 'px') !== 'px') {
                        elem.style[name] = value;
                        value = jQuery.css(elem, name);
                    }
                    return setPositiveNumber(elem, value, subtract);
                }
            };
        });
        jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
            if (computed) {
                return (parseFloat(curCSS(elem, 'marginLeft')) || elem.getBoundingClientRect().left - swap(elem, { marginLeft: 0 }, function () {
                    return elem.getBoundingClientRect().left;
                })) + 'px';
            }
        });
        jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function (elem, computed) {
            if (computed) {
                return swap(elem, { 'display': 'inline-block' }, curCSS, [
                    elem,
                    'marginRight'
                ]);
            }
        });
        jQuery.each({
            margin: '',
            padding: '',
            border: 'Width'
        }, function (prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {
                expand: function (value) {
                    var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
                    for (; i < 4; i++) {
                        expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                    }
                    return expanded;
                }
            };
            if (!rmargin.test(prefix)) {
                jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
            }
        });
        jQuery.fn.extend({
            css: function (name, value) {
                return access(this, function (elem, name, value) {
                    var styles, len, map = {}, i = 0;
                    if (jQuery.isArray(name)) {
                        styles = getStyles(elem);
                        len = name.length;
                        for (; i < len; i++) {
                            map[name[i]] = jQuery.css(elem, name[i], false, styles);
                        }
                        return map;
                    }
                    return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
                }, name, value, arguments.length > 1);
            },
            show: function () {
                return showHide(this, true);
            },
            hide: function () {
                return showHide(this);
            },
            toggle: function (state) {
                if (typeof state === 'boolean') {
                    return state ? this.show() : this.hide();
                }
                return this.each(function () {
                    if (isHidden(this)) {
                        jQuery(this).show();
                    } else {
                        jQuery(this).hide();
                    }
                });
            }
        });
        function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing);
        }
        jQuery.Tween = Tween;
        Tween.prototype = {
            constructor: Tween,
            init: function (elem, options, prop, end, easing, unit) {
                this.elem = elem;
                this.prop = prop;
                this.easing = easing || jQuery.easing._default;
                this.options = options;
                this.start = this.now = this.cur();
                this.end = end;
                this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
            },
            cur: function () {
                var hooks = Tween.propHooks[this.prop];
                return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
            },
            run: function (percent) {
                var eased, hooks = Tween.propHooks[this.prop];
                if (this.options.duration) {
                    this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
                } else {
                    this.pos = eased = percent;
                }
                this.now = (this.end - this.start) * eased + this.start;
                if (this.options.step) {
                    this.options.step.call(this.elem, this.now, this);
                }
                if (hooks && hooks.set) {
                    hooks.set(this);
                } else {
                    Tween.propHooks._default.set(this);
                }
                return this;
            }
        };
        Tween.prototype.init.prototype = Tween.prototype;
        Tween.propHooks = {
            _default: {
                get: function (tween) {
                    var result;
                    if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                        return tween.elem[tween.prop];
                    }
                    result = jQuery.css(tween.elem, tween.prop, '');
                    return !result || result === 'auto' ? 0 : result;
                },
                set: function (tween) {
                    if (jQuery.fx.step[tween.prop]) {
                        jQuery.fx.step[tween.prop](tween);
                    } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                        jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                    } else {
                        tween.elem[tween.prop] = tween.now;
                    }
                }
            }
        };
        Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function (tween) {
                if (tween.elem.nodeType && tween.elem.parentNode) {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        };
        jQuery.easing = {
            linear: function (p) {
                return p;
            },
            swing: function (p) {
                return 0.5 - Math.cos(p * Math.PI) / 2;
            },
            _default: 'swing'
        };
        jQuery.fx = Tween.prototype.init;
        jQuery.fx.step = {};
        var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        function createFxNow() {
            window.setTimeout(function () {
                fxNow = undefined;
            });
            return fxNow = jQuery.now();
        }
        function genFx(type, includeWidth) {
            var which, i = 0, attrs = { height: type };
            includeWidth = includeWidth ? 1 : 0;
            for (; i < 4; i += 2 - includeWidth) {
                which = cssExpand[i];
                attrs['margin' + which] = attrs['padding' + which] = type;
            }
            if (includeWidth) {
                attrs.opacity = attrs.width = type;
            }
            return attrs;
        }
        function createTween(value, prop, animation) {
            var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners['*']), index = 0, length = collection.length;
            for (; index < length; index++) {
                if (tween = collection[index].call(animation, prop, value)) {
                    return tween;
                }
            }
        }
        function defaultPrefilter(elem, props, opts) {
            var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = dataPriv.get(elem, 'fxshow');
            if (!opts.queue) {
                hooks = jQuery._queueHooks(elem, 'fx');
                if (hooks.unqueued == null) {
                    hooks.unqueued = 0;
                    oldfire = hooks.empty.fire;
                    hooks.empty.fire = function () {
                        if (!hooks.unqueued) {
                            oldfire();
                        }
                    };
                }
                hooks.unqueued++;
                anim.always(function () {
                    anim.always(function () {
                        hooks.unqueued--;
                        if (!jQuery.queue(elem, 'fx').length) {
                            hooks.empty.fire();
                        }
                    });
                });
            }
            if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
                opts.overflow = [
                    style.overflow,
                    style.overflowX,
                    style.overflowY
                ];
                display = jQuery.css(elem, 'display');
                checkDisplay = display === 'none' ? dataPriv.get(elem, 'olddisplay') || defaultDisplay(elem.nodeName) : display;
                if (checkDisplay === 'inline' && jQuery.css(elem, 'float') === 'none') {
                    style.display = 'inline-block';
                }
            }
            if (opts.overflow) {
                style.overflow = 'hidden';
                anim.always(function () {
                    style.overflow = opts.overflow[0];
                    style.overflowX = opts.overflow[1];
                    style.overflowY = opts.overflow[2];
                });
            }
            for (prop in props) {
                value = props[prop];
                if (rfxtypes.exec(value)) {
                    delete props[prop];
                    toggle = toggle || value === 'toggle';
                    if (value === (hidden ? 'hide' : 'show')) {
                        if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
                            hidden = true;
                        } else {
                            continue;
                        }
                    }
                    orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
                } else {
                    display = undefined;
                }
            }
            if (!jQuery.isEmptyObject(orig)) {
                if (dataShow) {
                    if ('hidden' in dataShow) {
                        hidden = dataShow.hidden;
                    }
                } else {
                    dataShow = dataPriv.access(elem, 'fxshow', {});
                }
                if (toggle) {
                    dataShow.hidden = !hidden;
                }
                if (hidden) {
                    jQuery(elem).show();
                } else {
                    anim.done(function () {
                        jQuery(elem).hide();
                    });
                }
                anim.done(function () {
                    var prop;
                    dataPriv.remove(elem, 'fxshow');
                    for (prop in orig) {
                        jQuery.style(elem, prop, orig[prop]);
                    }
                });
                for (prop in orig) {
                    tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
                    if (!(prop in dataShow)) {
                        dataShow[prop] = tween.start;
                        if (hidden) {
                            tween.end = tween.start;
                            tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
                        }
                    }
                }
            } else if ((display === 'none' ? defaultDisplay(elem.nodeName) : display) === 'inline') {
                style.display = display;
            }
        }
        function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks;
            for (index in props) {
                name = jQuery.camelCase(index);
                easing = specialEasing[name];
                value = props[index];
                if (jQuery.isArray(value)) {
                    easing = value[1];
                    value = props[index] = value[0];
                }
                if (index !== name) {
                    props[name] = value;
                    delete props[index];
                }
                hooks = jQuery.cssHooks[name];
                if (hooks && 'expand' in hooks) {
                    value = hooks.expand(value);
                    delete props[name];
                    for (index in value) {
                        if (!(index in props)) {
                            props[index] = value[index];
                            specialEasing[index] = easing;
                        }
                    }
                } else {
                    specialEasing[name] = easing;
                }
            }
        }
        function Animation(elem, properties, options) {
            var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function () {
                    delete tick.elem;
                }), tick = function () {
                    if (stopped) {
                        return false;
                    }
                    var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
                    for (; index < length; index++) {
                        animation.tweens[index].run(percent);
                    }
                    deferred.notifyWith(elem, [
                        animation,
                        percent,
                        remaining
                    ]);
                    if (percent < 1 && length) {
                        return remaining;
                    } else {
                        deferred.resolveWith(elem, [animation]);
                        return false;
                    }
                }, animation = deferred.promise({
                    elem: elem,
                    props: jQuery.extend({}, properties),
                    opts: jQuery.extend(true, {
                        specialEasing: {},
                        easing: jQuery.easing._default
                    }, options),
                    originalProperties: properties,
                    originalOptions: options,
                    startTime: fxNow || createFxNow(),
                    duration: options.duration,
                    tweens: [],
                    createTween: function (prop, end) {
                        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                        animation.tweens.push(tween);
                        return tween;
                    },
                    stop: function (gotoEnd) {
                        var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                        if (stopped) {
                            return this;
                        }
                        stopped = true;
                        for (; index < length; index++) {
                            animation.tweens[index].run(1);
                        }
                        if (gotoEnd) {
                            deferred.notifyWith(elem, [
                                animation,
                                1,
                                0
                            ]);
                            deferred.resolveWith(elem, [
                                animation,
                                gotoEnd
                            ]);
                        } else {
                            deferred.rejectWith(elem, [
                                animation,
                                gotoEnd
                            ]);
                        }
                        return this;
                    }
                }), props = animation.props;
            propFilter(props, animation.opts.specialEasing);
            for (; index < length; index++) {
                result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
                if (result) {
                    if (jQuery.isFunction(result.stop)) {
                        jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
                    }
                    return result;
                }
            }
            jQuery.map(props, createTween, animation);
            if (jQuery.isFunction(animation.opts.start)) {
                animation.opts.start.call(elem, animation);
            }
            jQuery.fx.timer(jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            }));
            return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
        }
        jQuery.Animation = jQuery.extend(Animation, {
            tweeners: {
                '*': [function (prop, value) {
                        var tween = this.createTween(prop, value);
                        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                        return tween;
                    }]
            },
            tweener: function (props, callback) {
                if (jQuery.isFunction(props)) {
                    callback = props;
                    props = ['*'];
                } else {
                    props = props.match(rnotwhite);
                }
                var prop, index = 0, length = props.length;
                for (; index < length; index++) {
                    prop = props[index];
                    Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                    Animation.tweeners[prop].unshift(callback);
                }
            },
            prefilters: [defaultPrefilter],
            prefilter: function (callback, prepend) {
                if (prepend) {
                    Animation.prefilters.unshift(callback);
                } else {
                    Animation.prefilters.push(callback);
                }
            }
        });
        jQuery.speed = function (speed, easing, fn) {
            var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
                complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
                duration: speed,
                easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
            };
            opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
            if (opt.queue == null || opt.queue === true) {
                opt.queue = 'fx';
            }
            opt.old = opt.complete;
            opt.complete = function () {
                if (jQuery.isFunction(opt.old)) {
                    opt.old.call(this);
                }
                if (opt.queue) {
                    jQuery.dequeue(this, opt.queue);
                }
            };
            return opt;
        };
        jQuery.fn.extend({
            fadeTo: function (speed, to, easing, callback) {
                return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
            },
            animate: function (prop, speed, easing, callback) {
                var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                        var anim = Animation(this, jQuery.extend({}, prop), optall);
                        if (empty || dataPriv.get(this, 'finish')) {
                            anim.stop(true);
                        }
                    };
                doAnimation.finish = doAnimation;
                return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
            },
            stop: function (type, clearQueue, gotoEnd) {
                var stopQueue = function (hooks) {
                    var stop = hooks.stop;
                    delete hooks.stop;
                    stop(gotoEnd);
                };
                if (typeof type !== 'string') {
                    gotoEnd = clearQueue;
                    clearQueue = type;
                    type = undefined;
                }
                if (clearQueue && type !== false) {
                    this.queue(type || 'fx', []);
                }
                return this.each(function () {
                    var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = dataPriv.get(this);
                    if (index) {
                        if (data[index] && data[index].stop) {
                            stopQueue(data[index]);
                        }
                    } else {
                        for (index in data) {
                            if (data[index] && data[index].stop && rrun.test(index)) {
                                stopQueue(data[index]);
                            }
                        }
                    }
                    for (index = timers.length; index--;) {
                        if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
                            timers[index].anim.stop(gotoEnd);
                            dequeue = false;
                            timers.splice(index, 1);
                        }
                    }
                    if (dequeue || !gotoEnd) {
                        jQuery.dequeue(this, type);
                    }
                });
            },
            finish: function (type) {
                if (type !== false) {
                    type = type || 'fx';
                }
                return this.each(function () {
                    var index, data = dataPriv.get(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
                    data.finish = true;
                    jQuery.queue(this, type, []);
                    if (hooks && hooks.stop) {
                        hooks.stop.call(this, true);
                    }
                    for (index = timers.length; index--;) {
                        if (timers[index].elem === this && timers[index].queue === type) {
                            timers[index].anim.stop(true);
                            timers.splice(index, 1);
                        }
                    }
                    for (index = 0; index < length; index++) {
                        if (queue[index] && queue[index].finish) {
                            queue[index].finish.call(this);
                        }
                    }
                    delete data.finish;
                });
            }
        });
        jQuery.each([
            'toggle',
            'show',
            'hide'
        ], function (i, name) {
            var cssFn = jQuery.fn[name];
            jQuery.fn[name] = function (speed, easing, callback) {
                return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
            };
        });
        jQuery.each({
            slideDown: genFx('show'),
            slideUp: genFx('hide'),
            slideToggle: genFx('toggle'),
            fadeIn: { opacity: 'show' },
            fadeOut: { opacity: 'hide' },
            fadeToggle: { opacity: 'toggle' }
        }, function (name, props) {
            jQuery.fn[name] = function (speed, easing, callback) {
                return this.animate(props, speed, easing, callback);
            };
        });
        jQuery.timers = [];
        jQuery.fx.tick = function () {
            var timer, i = 0, timers = jQuery.timers;
            fxNow = jQuery.now();
            for (; i < timers.length; i++) {
                timer = timers[i];
                if (!timer() && timers[i] === timer) {
                    timers.splice(i--, 1);
                }
            }
            if (!timers.length) {
                jQuery.fx.stop();
            }
            fxNow = undefined;
        };
        jQuery.fx.timer = function (timer) {
            jQuery.timers.push(timer);
            if (timer()) {
                jQuery.fx.start();
            } else {
                jQuery.timers.pop();
            }
        };
        jQuery.fx.interval = 13;
        jQuery.fx.start = function () {
            if (!timerId) {
                timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
            }
        };
        jQuery.fx.stop = function () {
            window.clearInterval(timerId);
            timerId = null;
        };
        jQuery.fx.speeds = {
            slow: 600,
            fast: 200,
            _default: 400
        };
        jQuery.fn.delay = function (time, type) {
            time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
            type = type || 'fx';
            return this.queue(type, function (next, hooks) {
                var timeout = window.setTimeout(next, time);
                hooks.stop = function () {
                    window.clearTimeout(timeout);
                };
            });
        };
        (function () {
            var input = document.createElement('input'), select = document.createElement('select'), opt = select.appendChild(document.createElement('option'));
            input.type = 'checkbox';
            support.checkOn = input.value !== '';
            support.optSelected = opt.selected;
            select.disabled = true;
            support.optDisabled = !opt.disabled;
            input = document.createElement('input');
            input.value = 't';
            input.type = 'radio';
            support.radioValue = input.value === 't';
        }());
        var boolHook, attrHandle = jQuery.expr.attrHandle;
        jQuery.fn.extend({
            attr: function (name, value) {
                return access(this, jQuery.attr, name, value, arguments.length > 1);
            },
            removeAttr: function (name) {
                return this.each(function () {
                    jQuery.removeAttr(this, name);
                });
            }
        });
        jQuery.extend({
            attr: function (elem, name, value) {
                var ret, hooks, nType = elem.nodeType;
                if (nType === 3 || nType === 8 || nType === 2) {
                    return;
                }
                if (typeof elem.getAttribute === 'undefined') {
                    return jQuery.prop(elem, name, value);
                }
                if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                    name = name.toLowerCase();
                    hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
                }
                if (value !== undefined) {
                    if (value === null) {
                        jQuery.removeAttr(elem, name);
                        return;
                    }
                    if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                        return ret;
                    }
                    elem.setAttribute(name, value + '');
                    return value;
                }
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                    return ret;
                }
                ret = jQuery.find.attr(elem, name);
                return ret == null ? undefined : ret;
            },
            attrHooks: {
                type: {
                    set: function (elem, value) {
                        if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
                            var val = elem.value;
                            elem.setAttribute('type', value);
                            if (val) {
                                elem.value = val;
                            }
                            return value;
                        }
                    }
                }
            },
            removeAttr: function (elem, value) {
                var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
                if (attrNames && elem.nodeType === 1) {
                    while (name = attrNames[i++]) {
                        propName = jQuery.propFix[name] || name;
                        if (jQuery.expr.match.bool.test(name)) {
                            elem[propName] = false;
                        }
                        elem.removeAttribute(name);
                    }
                }
            }
        });
        boolHook = {
            set: function (elem, value, name) {
                if (value === false) {
                    jQuery.removeAttr(elem, name);
                } else {
                    elem.setAttribute(name, name);
                }
                return name;
            }
        };
        jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
            var getter = attrHandle[name] || jQuery.find.attr;
            attrHandle[name] = function (elem, name, isXML) {
                var ret, handle;
                if (!isXML) {
                    handle = attrHandle[name];
                    attrHandle[name] = ret;
                    ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                    attrHandle[name] = handle;
                }
                return ret;
            };
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery.fn.extend({
            prop: function (name, value) {
                return access(this, jQuery.prop, name, value, arguments.length > 1);
            },
            removeProp: function (name) {
                return this.each(function () {
                    delete this[jQuery.propFix[name] || name];
                });
            }
        });
        jQuery.extend({
            prop: function (elem, name, value) {
                var ret, hooks, nType = elem.nodeType;
                if (nType === 3 || nType === 8 || nType === 2) {
                    return;
                }
                if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                    name = jQuery.propFix[name] || name;
                    hooks = jQuery.propHooks[name];
                }
                if (value !== undefined) {
                    if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                        return ret;
                    }
                    return elem[name] = value;
                }
                if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
                    return ret;
                }
                return elem[name];
            },
            propHooks: {
                tabIndex: {
                    get: function (elem) {
                        var tabindex = jQuery.find.attr(elem, 'tabindex');
                        return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                    }
                }
            },
            propFix: {
                'for': 'htmlFor',
                'class': 'className'
            }
        });
        if (!support.optSelected) {
            jQuery.propHooks.selected = {
                get: function (elem) {
                    var parent = elem.parentNode;
                    if (parent && parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                    return null;
                },
                set: function (elem) {
                    var parent = elem.parentNode;
                    if (parent) {
                        parent.selectedIndex;
                        if (parent.parentNode) {
                            parent.parentNode.selectedIndex;
                        }
                    }
                }
            };
        }
        jQuery.each([
            'tabIndex',
            'readOnly',
            'maxLength',
            'cellSpacing',
            'cellPadding',
            'rowSpan',
            'colSpan',
            'useMap',
            'frameBorder',
            'contentEditable'
        ], function () {
            jQuery.propFix[this.toLowerCase()] = this;
        });
        var rclass = /[\t\r\n\f]/g;
        function getClass(elem) {
            return elem.getAttribute && elem.getAttribute('class') || '';
        }
        jQuery.fn.extend({
            addClass: function (value) {
                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                if (jQuery.isFunction(value)) {
                    return this.each(function (j) {
                        jQuery(this).addClass(value.call(this, j, getClass(this)));
                    });
                }
                if (typeof value === 'string' && value) {
                    classes = value.match(rnotwhite) || [];
                    while (elem = this[i++]) {
                        curValue = getClass(elem);
                        cur = elem.nodeType === 1 && (' ' + curValue + ' ').replace(rclass, ' ');
                        if (cur) {
                            j = 0;
                            while (clazz = classes[j++]) {
                                if (cur.indexOf(' ' + clazz + ' ') < 0) {
                                    cur += clazz + ' ';
                                }
                            }
                            finalValue = jQuery.trim(cur);
                            if (curValue !== finalValue) {
                                elem.setAttribute('class', finalValue);
                            }
                        }
                    }
                }
                return this;
            },
            removeClass: function (value) {
                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                if (jQuery.isFunction(value)) {
                    return this.each(function (j) {
                        jQuery(this).removeClass(value.call(this, j, getClass(this)));
                    });
                }
                if (!arguments.length) {
                    return this.attr('class', '');
                }
                if (typeof value === 'string' && value) {
                    classes = value.match(rnotwhite) || [];
                    while (elem = this[i++]) {
                        curValue = getClass(elem);
                        cur = elem.nodeType === 1 && (' ' + curValue + ' ').replace(rclass, ' ');
                        if (cur) {
                            j = 0;
                            while (clazz = classes[j++]) {
                                while (cur.indexOf(' ' + clazz + ' ') > -1) {
                                    cur = cur.replace(' ' + clazz + ' ', ' ');
                                }
                            }
                            finalValue = jQuery.trim(cur);
                            if (curValue !== finalValue) {
                                elem.setAttribute('class', finalValue);
                            }
                        }
                    }
                }
                return this;
            },
            toggleClass: function (value, stateVal) {
                var type = typeof value;
                if (typeof stateVal === 'boolean' && type === 'string') {
                    return stateVal ? this.addClass(value) : this.removeClass(value);
                }
                if (jQuery.isFunction(value)) {
                    return this.each(function (i) {
                        jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                    });
                }
                return this.each(function () {
                    var className, i, self, classNames;
                    if (type === 'string') {
                        i = 0;
                        self = jQuery(this);
                        classNames = value.match(rnotwhite) || [];
                        while (className = classNames[i++]) {
                            if (self.hasClass(className)) {
                                self.removeClass(className);
                            } else {
                                self.addClass(className);
                            }
                        }
                    } else if (value === undefined || type === 'boolean') {
                        className = getClass(this);
                        if (className) {
                            dataPriv.set(this, '__className__', className);
                        }
                        if (this.setAttribute) {
                            this.setAttribute('class', className || value === false ? '' : dataPriv.get(this, '__className__') || '');
                        }
                    }
                });
            },
            hasClass: function (selector) {
                var className, elem, i = 0;
                className = ' ' + selector + ' ';
                while (elem = this[i++]) {
                    if (elem.nodeType === 1 && (' ' + getClass(elem) + ' ').replace(rclass, ' ').indexOf(className) > -1) {
                        return true;
                    }
                }
                return false;
            }
        });
        var rreturn = /\r/g, rspaces = /[\x20\t\r\n\f]+/g;
        jQuery.fn.extend({
            val: function (value) {
                var hooks, ret, isFunction, elem = this[0];
                if (!arguments.length) {
                    if (elem) {
                        hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
                        if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
                            return ret;
                        }
                        ret = elem.value;
                        return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
                    }
                    return;
                }
                isFunction = jQuery.isFunction(value);
                return this.each(function (i) {
                    var val;
                    if (this.nodeType !== 1) {
                        return;
                    }
                    if (isFunction) {
                        val = value.call(this, i, jQuery(this).val());
                    } else {
                        val = value;
                    }
                    if (val == null) {
                        val = '';
                    } else if (typeof val === 'number') {
                        val += '';
                    } else if (jQuery.isArray(val)) {
                        val = jQuery.map(val, function (value) {
                            return value == null ? '' : value + '';
                        });
                    }
                    hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
                    if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
                        this.value = val;
                    }
                });
            }
        });
        jQuery.extend({
            valHooks: {
                option: {
                    get: function (elem) {
                        var val = jQuery.find.attr(elem, 'value');
                        return val != null ? val : jQuery.trim(jQuery.text(elem)).replace(rspaces, ' ');
                    }
                },
                select: {
                    get: function (elem) {
                        var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
                        for (; i < max; i++) {
                            option = options[i];
                            if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
                                value = jQuery(option).val();
                                if (one) {
                                    return value;
                                }
                                values.push(value);
                            }
                        }
                        return values;
                    },
                    set: function (elem, value) {
                        var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
                        while (i--) {
                            option = options[i];
                            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                                optionSet = true;
                            }
                        }
                        if (!optionSet) {
                            elem.selectedIndex = -1;
                        }
                        return values;
                    }
                }
            }
        });
        jQuery.each([
            'radio',
            'checkbox'
        ], function () {
            jQuery.valHooks[this] = {
                set: function (elem, value) {
                    if (jQuery.isArray(value)) {
                        return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1;
                    }
                }
            };
            if (!support.checkOn) {
                jQuery.valHooks[this].get = function (elem) {
                    return elem.getAttribute('value') === null ? 'on' : elem.value;
                };
            }
        });
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
        jQuery.extend(jQuery.event, {
            trigger: function (event, data, elem, onlyHandlers) {
                var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
                cur = tmp = elem = elem || document;
                if (elem.nodeType === 3 || elem.nodeType === 8) {
                    return;
                }
                if (rfocusMorph.test(type + jQuery.event.triggered)) {
                    return;
                }
                if (type.indexOf('.') > -1) {
                    namespaces = type.split('.');
                    type = namespaces.shift();
                    namespaces.sort();
                }
                ontype = type.indexOf(':') < 0 && 'on' + type;
                event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
                event.isTrigger = onlyHandlers ? 2 : 3;
                event.namespace = namespaces.join('.');
                event.rnamespace = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
                event.result = undefined;
                if (!event.target) {
                    event.target = elem;
                }
                data = data == null ? [event] : jQuery.makeArray(data, [event]);
                special = jQuery.event.special[type] || {};
                if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                    return;
                }
                if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                    bubbleType = special.delegateType || type;
                    if (!rfocusMorph.test(bubbleType + type)) {
                        cur = cur.parentNode;
                    }
                    for (; cur; cur = cur.parentNode) {
                        eventPath.push(cur);
                        tmp = cur;
                    }
                    if (tmp === (elem.ownerDocument || document)) {
                        eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                    }
                }
                i = 0;
                while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
                    event.type = i > 1 ? bubbleType : special.bindType || type;
                    handle = (dataPriv.get(cur, 'events') || {})[event.type] && dataPriv.get(cur, 'handle');
                    if (handle) {
                        handle.apply(cur, data);
                    }
                    handle = ontype && cur[ontype];
                    if (handle && handle.apply && acceptData(cur)) {
                        event.result = handle.apply(cur, data);
                        if (event.result === false) {
                            event.preventDefault();
                        }
                    }
                }
                event.type = type;
                if (!onlyHandlers && !event.isDefaultPrevented()) {
                    if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
                        if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
                            tmp = elem[ontype];
                            if (tmp) {
                                elem[ontype] = null;
                            }
                            jQuery.event.triggered = type;
                            elem[type]();
                            jQuery.event.triggered = undefined;
                            if (tmp) {
                                elem[ontype] = tmp;
                            }
                        }
                    }
                }
                return event.result;
            },
            simulate: function (type, elem, event) {
                var e = jQuery.extend(new jQuery.Event(), event, {
                    type: type,
                    isSimulated: true
                });
                jQuery.event.trigger(e, null, elem);
                if (e.isDefaultPrevented()) {
                    event.preventDefault();
                }
            }
        });
        jQuery.fn.extend({
            trigger: function (type, data) {
                return this.each(function () {
                    jQuery.event.trigger(type, data, this);
                });
            },
            triggerHandler: function (type, data) {
                var elem = this[0];
                if (elem) {
                    return jQuery.event.trigger(type, data, elem, true);
                }
            }
        });
        jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
            jQuery.fn[name] = function (data, fn) {
                return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
            };
        });
        jQuery.fn.extend({
            hover: function (fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
            }
        });
        support.focusin = 'onfocusin' in window;
        if (!support.focusin) {
            jQuery.each({
                focus: 'focusin',
                blur: 'focusout'
            }, function (orig, fix) {
                var handler = function (event) {
                    jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
                };
                jQuery.event.special[fix] = {
                    setup: function () {
                        var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                        if (!attaches) {
                            doc.addEventListener(orig, handler, true);
                        }
                        dataPriv.access(doc, fix, (attaches || 0) + 1);
                    },
                    teardown: function () {
                        var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                        if (!attaches) {
                            doc.removeEventListener(orig, handler, true);
                            dataPriv.remove(doc, fix);
                        } else {
                            dataPriv.access(doc, fix, attaches);
                        }
                    }
                };
            });
        }
        var location = window.location;
        var nonce = jQuery.now();
        var rquery = /\?/;
        jQuery.parseJSON = function (data) {
            return JSON.parse(data + '');
        };
        jQuery.parseXML = function (data) {
            var xml;
            if (!data || typeof data !== 'string') {
                return null;
            }
            try {
                xml = new window.DOMParser().parseFromString(data, 'text/xml');
            } catch (e) {
                xml = undefined;
            }
            if (!xml || xml.getElementsByTagName('parsererror').length) {
                jQuery.error('Invalid XML: ' + data);
            }
            return xml;
        };
        var rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = '*/'.concat('*'), originAnchor = document.createElement('a');
        originAnchor.href = location.href;
        function addToPrefiltersOrTransports(structure) {
            return function (dataTypeExpression, func) {
                if (typeof dataTypeExpression !== 'string') {
                    func = dataTypeExpression;
                    dataTypeExpression = '*';
                }
                var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
                if (jQuery.isFunction(func)) {
                    while (dataType = dataTypes[i++]) {
                        if (dataType[0] === '+') {
                            dataType = dataType.slice(1) || '*';
                            (structure[dataType] = structure[dataType] || []).unshift(func);
                        } else {
                            (structure[dataType] = structure[dataType] || []).push(func);
                        }
                    }
                }
            };
        }
        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            var inspected = {}, seekingTransport = structure === transports;
            function inspect(dataType) {
                var selected;
                inspected[dataType] = true;
                jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                    var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                    if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
                        options.dataTypes.unshift(dataTypeOrTransport);
                        inspect(dataTypeOrTransport);
                        return false;
                    } else if (seekingTransport) {
                        return !(selected = dataTypeOrTransport);
                    }
                });
                return selected;
            }
            return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
        }
        function ajaxExtend(target, src) {
            var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src) {
                if (src[key] !== undefined) {
                    (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
                }
            }
            if (deep) {
                jQuery.extend(true, target, deep);
            }
            return target;
        }
        function ajaxHandleResponses(s, jqXHR, responses) {
            var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
            while (dataTypes[0] === '*') {
                dataTypes.shift();
                if (ct === undefined) {
                    ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
                }
            }
            if (ct) {
                for (type in contents) {
                    if (contents[type] && contents[type].test(ct)) {
                        dataTypes.unshift(type);
                        break;
                    }
                }
            }
            if (dataTypes[0] in responses) {
                finalDataType = dataTypes[0];
            } else {
                for (type in responses) {
                    if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
                        finalDataType = type;
                        break;
                    }
                    if (!firstDataType) {
                        firstDataType = type;
                    }
                }
                finalDataType = finalDataType || firstDataType;
            }
            if (finalDataType) {
                if (finalDataType !== dataTypes[0]) {
                    dataTypes.unshift(finalDataType);
                }
                return responses[finalDataType];
            }
        }
        function ajaxConvert(s, response, jqXHR, isSuccess) {
            var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
            if (dataTypes[1]) {
                for (conv in s.converters) {
                    converters[conv.toLowerCase()] = s.converters[conv];
                }
            }
            current = dataTypes.shift();
            while (current) {
                if (s.responseFields[current]) {
                    jqXHR[s.responseFields[current]] = response;
                }
                if (!prev && isSuccess && s.dataFilter) {
                    response = s.dataFilter(response, s.dataType);
                }
                prev = current;
                current = dataTypes.shift();
                if (current) {
                    if (current === '*') {
                        current = prev;
                    } else if (prev !== '*' && prev !== current) {
                        conv = converters[prev + ' ' + current] || converters['* ' + current];
                        if (!conv) {
                            for (conv2 in converters) {
                                tmp = conv2.split(' ');
                                if (tmp[1] === current) {
                                    conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                                    if (conv) {
                                        if (conv === true) {
                                            conv = converters[conv2];
                                        } else if (converters[conv2] !== true) {
                                            current = tmp[0];
                                            dataTypes.unshift(tmp[1]);
                                        }
                                        break;
                                    }
                                }
                            }
                        }
                        if (conv !== true) {
                            if (conv && s.throws) {
                                response = conv(response);
                            } else {
                                try {
                                    response = conv(response);
                                } catch (e) {
                                    return {
                                        state: 'parsererror',
                                        error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                                    };
                                }
                            }
                        }
                    }
                }
            }
            return {
                state: 'success',
                data: response
            };
        }
        jQuery.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: location.href,
                type: 'GET',
                isLocal: rlocalProtocol.test(location.protocol),
                global: true,
                processData: true,
                async: true,
                contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
                accepts: {
                    '*': allTypes,
                    text: 'text/plain',
                    html: 'text/html',
                    xml: 'application/xml, text/xml',
                    json: 'application/json, text/javascript'
                },
                contents: {
                    xml: /\bxml\b/,
                    html: /\bhtml/,
                    json: /\bjson\b/
                },
                responseFields: {
                    xml: 'responseXML',
                    text: 'responseText',
                    json: 'responseJSON'
                },
                converters: {
                    '* text': String,
                    'text html': true,
                    'text json': jQuery.parseJSON,
                    'text xml': jQuery.parseXML
                },
                flatOptions: {
                    url: true,
                    context: true
                }
            },
            ajaxSetup: function (target, settings) {
                return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            ajax: function (url, options) {
                if (typeof url === 'object') {
                    options = url;
                    url = undefined;
                }
                options = options || {};
                var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, fireGlobals, i, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = {
                        readyState: 0,
                        getResponseHeader: function (key) {
                            var match;
                            if (state === 2) {
                                if (!responseHeaders) {
                                    responseHeaders = {};
                                    while (match = rheaders.exec(responseHeadersString)) {
                                        responseHeaders[match[1].toLowerCase()] = match[2];
                                    }
                                }
                                match = responseHeaders[key.toLowerCase()];
                            }
                            return match == null ? null : match;
                        },
                        getAllResponseHeaders: function () {
                            return state === 2 ? responseHeadersString : null;
                        },
                        setRequestHeader: function (name, value) {
                            var lname = name.toLowerCase();
                            if (!state) {
                                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                                requestHeaders[name] = value;
                            }
                            return this;
                        },
                        overrideMimeType: function (type) {
                            if (!state) {
                                s.mimeType = type;
                            }
                            return this;
                        },
                        statusCode: function (map) {
                            var code;
                            if (map) {
                                if (state < 2) {
                                    for (code in map) {
                                        statusCode[code] = [
                                            statusCode[code],
                                            map[code]
                                        ];
                                    }
                                } else {
                                    jqXHR.always(map[jqXHR.status]);
                                }
                            }
                            return this;
                        },
                        abort: function (statusText) {
                            var finalText = statusText || strAbort;
                            if (transport) {
                                transport.abort(finalText);
                            }
                            done(0, finalText);
                            return this;
                        }
                    };
                deferred.promise(jqXHR).complete = completeDeferred.add;
                jqXHR.success = jqXHR.done;
                jqXHR.error = jqXHR.fail;
                s.url = ((url || s.url || location.href) + '').replace(rhash, '').replace(rprotocol, location.protocol + '//');
                s.type = options.method || options.type || s.method || s.type;
                s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(rnotwhite) || [''];
                if (s.crossDomain == null) {
                    urlAnchor = document.createElement('a');
                    try {
                        urlAnchor.href = s.url;
                        urlAnchor.href = urlAnchor.href;
                        s.crossDomain = originAnchor.protocol + '//' + originAnchor.host !== urlAnchor.protocol + '//' + urlAnchor.host;
                    } catch (e) {
                        s.crossDomain = true;
                    }
                }
                if (s.data && s.processData && typeof s.data !== 'string') {
                    s.data = jQuery.param(s.data, s.traditional);
                }
                inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
                if (state === 2) {
                    return jqXHR;
                }
                fireGlobals = jQuery.event && s.global;
                if (fireGlobals && jQuery.active++ === 0) {
                    jQuery.event.trigger('ajaxStart');
                }
                s.type = s.type.toUpperCase();
                s.hasContent = !rnoContent.test(s.type);
                cacheURL = s.url;
                if (!s.hasContent) {
                    if (s.data) {
                        cacheURL = s.url += (rquery.test(cacheURL) ? '&' : '?') + s.data;
                        delete s.data;
                    }
                    if (s.cache === false) {
                        s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + nonce++) : cacheURL + (rquery.test(cacheURL) ? '&' : '?') + '_=' + nonce++;
                    }
                }
                if (s.ifModified) {
                    if (jQuery.lastModified[cacheURL]) {
                        jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
                    }
                    if (jQuery.etag[cacheURL]) {
                        jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
                    }
                }
                if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                    jqXHR.setRequestHeader('Content-Type', s.contentType);
                }
                jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
                for (i in s.headers) {
                    jqXHR.setRequestHeader(i, s.headers[i]);
                }
                if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
                    return jqXHR.abort();
                }
                strAbort = 'abort';
                for (i in {
                        success: 1,
                        error: 1,
                        complete: 1
                    }) {
                    jqXHR[i](s[i]);
                }
                transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
                if (!transport) {
                    done(-1, 'No Transport');
                } else {
                    jqXHR.readyState = 1;
                    if (fireGlobals) {
                        globalEventContext.trigger('ajaxSend', [
                            jqXHR,
                            s
                        ]);
                    }
                    if (state === 2) {
                        return jqXHR;
                    }
                    if (s.async && s.timeout > 0) {
                        timeoutTimer = window.setTimeout(function () {
                            jqXHR.abort('timeout');
                        }, s.timeout);
                    }
                    try {
                        state = 1;
                        transport.send(requestHeaders, done);
                    } catch (e) {
                        if (state < 2) {
                            done(-1, e);
                        } else {
                            throw e;
                        }
                    }
                }
                function done(status, nativeStatusText, responses, headers) {
                    var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                    if (state === 2) {
                        return;
                    }
                    state = 2;
                    if (timeoutTimer) {
                        window.clearTimeout(timeoutTimer);
                    }
                    transport = undefined;
                    responseHeadersString = headers || '';
                    jqXHR.readyState = status > 0 ? 4 : 0;
                    isSuccess = status >= 200 && status < 300 || status === 304;
                    if (responses) {
                        response = ajaxHandleResponses(s, jqXHR, responses);
                    }
                    response = ajaxConvert(s, response, jqXHR, isSuccess);
                    if (isSuccess) {
                        if (s.ifModified) {
                            modified = jqXHR.getResponseHeader('Last-Modified');
                            if (modified) {
                                jQuery.lastModified[cacheURL] = modified;
                            }
                            modified = jqXHR.getResponseHeader('etag');
                            if (modified) {
                                jQuery.etag[cacheURL] = modified;
                            }
                        }
                        if (status === 204 || s.type === 'HEAD') {
                            statusText = 'nocontent';
                        } else if (status === 304) {
                            statusText = 'notmodified';
                        } else {
                            statusText = response.state;
                            success = response.data;
                            error = response.error;
                            isSuccess = !error;
                        }
                    } else {
                        error = statusText;
                        if (status || !statusText) {
                            statusText = 'error';
                            if (status < 0) {
                                status = 0;
                            }
                        }
                    }
                    jqXHR.status = status;
                    jqXHR.statusText = (nativeStatusText || statusText) + '';
                    if (isSuccess) {
                        deferred.resolveWith(callbackContext, [
                            success,
                            statusText,
                            jqXHR
                        ]);
                    } else {
                        deferred.rejectWith(callbackContext, [
                            jqXHR,
                            statusText,
                            error
                        ]);
                    }
                    jqXHR.statusCode(statusCode);
                    statusCode = undefined;
                    if (fireGlobals) {
                        globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
                            jqXHR,
                            s,
                            isSuccess ? success : error
                        ]);
                    }
                    completeDeferred.fireWith(callbackContext, [
                        jqXHR,
                        statusText
                    ]);
                    if (fireGlobals) {
                        globalEventContext.trigger('ajaxComplete', [
                            jqXHR,
                            s
                        ]);
                        if (!--jQuery.active) {
                            jQuery.event.trigger('ajaxStop');
                        }
                    }
                }
                return jqXHR;
            },
            getJSON: function (url, data, callback) {
                return jQuery.get(url, data, callback, 'json');
            },
            getScript: function (url, callback) {
                return jQuery.get(url, undefined, callback, 'script');
            }
        });
        jQuery.each([
            'get',
            'post'
        ], function (i, method) {
            jQuery[method] = function (url, data, callback, type) {
                if (jQuery.isFunction(data)) {
                    type = type || callback;
                    callback = data;
                    data = undefined;
                }
                return jQuery.ajax(jQuery.extend({
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                }, jQuery.isPlainObject(url) && url));
            };
        });
        jQuery._evalUrl = function (url) {
            return jQuery.ajax({
                url: url,
                type: 'GET',
                dataType: 'script',
                async: false,
                global: false,
                'throws': true
            });
        };
        jQuery.fn.extend({
            wrapAll: function (html) {
                var wrap;
                if (jQuery.isFunction(html)) {
                    return this.each(function (i) {
                        jQuery(this).wrapAll(html.call(this, i));
                    });
                }
                if (this[0]) {
                    wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
                    if (this[0].parentNode) {
                        wrap.insertBefore(this[0]);
                    }
                    wrap.map(function () {
                        var elem = this;
                        while (elem.firstElementChild) {
                            elem = elem.firstElementChild;
                        }
                        return elem;
                    }).append(this);
                }
                return this;
            },
            wrapInner: function (html) {
                if (jQuery.isFunction(html)) {
                    return this.each(function (i) {
                        jQuery(this).wrapInner(html.call(this, i));
                    });
                }
                return this.each(function () {
                    var self = jQuery(this), contents = self.contents();
                    if (contents.length) {
                        contents.wrapAll(html);
                    } else {
                        self.append(html);
                    }
                });
            },
            wrap: function (html) {
                var isFunction = jQuery.isFunction(html);
                return this.each(function (i) {
                    jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
                });
            },
            unwrap: function () {
                return this.parent().each(function () {
                    if (!jQuery.nodeName(this, 'body')) {
                        jQuery(this).replaceWith(this.childNodes);
                    }
                }).end();
            }
        });
        jQuery.expr.filters.hidden = function (elem) {
            return !jQuery.expr.filters.visible(elem);
        };
        jQuery.expr.filters.visible = function (elem) {
            return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
        };
        var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        function buildParams(prefix, obj, traditional, add) {
            var name;
            if (jQuery.isArray(obj)) {
                jQuery.each(obj, function (i, v) {
                    if (traditional || rbracket.test(prefix)) {
                        add(prefix, v);
                    } else {
                        buildParams(prefix + '[' + (typeof v === 'object' && v != null ? i : '') + ']', v, traditional, add);
                    }
                });
            } else if (!traditional && jQuery.type(obj) === 'object') {
                for (name in obj) {
                    buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
                }
            } else {
                add(prefix, obj);
            }
        }
        jQuery.param = function (a, traditional) {
            var prefix, s = [], add = function (key, value) {
                    value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
                    s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
                };
            if (traditional === undefined) {
                traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
            }
            if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
                jQuery.each(a, function () {
                    add(this.name, this.value);
                });
            } else {
                for (prefix in a) {
                    buildParams(prefix, a[prefix], traditional, add);
                }
            }
            return s.join('&').replace(r20, '+');
        };
        jQuery.fn.extend({
            serialize: function () {
                return jQuery.param(this.serializeArray());
            },
            serializeArray: function () {
                return this.map(function () {
                    var elements = jQuery.prop(this, 'elements');
                    return elements ? jQuery.makeArray(elements) : this;
                }).filter(function () {
                    var type = this.type;
                    return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
                }).map(function (i, elem) {
                    var val = jQuery(this).val();
                    return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, '\r\n')
                        };
                    }) : {
                        name: elem.name,
                        value: val.replace(rCRLF, '\r\n')
                    };
                }).get();
            }
        });
        jQuery.ajaxSettings.xhr = function () {
            try {
                return new window.XMLHttpRequest();
            } catch (e) {
            }
        };
        var xhrSuccessStatus = {
                0: 200,
                1223: 204
            }, xhrSupported = jQuery.ajaxSettings.xhr();
        support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
        support.ajax = xhrSupported = !!xhrSupported;
        jQuery.ajaxTransport(function (options) {
            var callback, errorCallback;
            if (support.cors || xhrSupported && !options.crossDomain) {
                return {
                    send: function (headers, complete) {
                        var i, xhr = options.xhr();
                        xhr.open(options.type, options.url, options.async, options.username, options.password);
                        if (options.xhrFields) {
                            for (i in options.xhrFields) {
                                xhr[i] = options.xhrFields[i];
                            }
                        }
                        if (options.mimeType && xhr.overrideMimeType) {
                            xhr.overrideMimeType(options.mimeType);
                        }
                        if (!options.crossDomain && !headers['X-Requested-With']) {
                            headers['X-Requested-With'] = 'XMLHttpRequest';
                        }
                        for (i in headers) {
                            xhr.setRequestHeader(i, headers[i]);
                        }
                        callback = function (type) {
                            return function () {
                                if (callback) {
                                    callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                                    if (type === 'abort') {
                                        xhr.abort();
                                    } else if (type === 'error') {
                                        if (typeof xhr.status !== 'number') {
                                            complete(0, 'error');
                                        } else {
                                            complete(xhr.status, xhr.statusText);
                                        }
                                    } else {
                                        complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || 'text') !== 'text' || typeof xhr.responseText !== 'string' ? { binary: xhr.response } : { text: xhr.responseText }, xhr.getAllResponseHeaders());
                                    }
                                }
                            };
                        };
                        xhr.onload = callback();
                        errorCallback = xhr.onerror = callback('error');
                        if (xhr.onabort !== undefined) {
                            xhr.onabort = errorCallback;
                        } else {
                            xhr.onreadystatechange = function () {
                                if (xhr.readyState === 4) {
                                    window.setTimeout(function () {
                                        if (callback) {
                                            errorCallback();
                                        }
                                    });
                                }
                            };
                        }
                        callback = callback('abort');
                        try {
                            xhr.send(options.hasContent && options.data || null);
                        } catch (e) {
                            if (callback) {
                                throw e;
                            }
                        }
                    },
                    abort: function () {
                        if (callback) {
                            callback();
                        }
                    }
                };
            }
        });
        jQuery.ajaxSetup({
            accepts: { script: 'text/javascript, application/javascript, ' + 'application/ecmascript, application/x-ecmascript' },
            contents: { script: /\b(?:java|ecma)script\b/ },
            converters: {
                'text script': function (text) {
                    jQuery.globalEval(text);
                    return text;
                }
            }
        });
        jQuery.ajaxPrefilter('script', function (s) {
            if (s.cache === undefined) {
                s.cache = false;
            }
            if (s.crossDomain) {
                s.type = 'GET';
            }
        });
        jQuery.ajaxTransport('script', function (s) {
            if (s.crossDomain) {
                var script, callback;
                return {
                    send: function (_, complete) {
                        script = jQuery('<script>').prop({
                            charset: s.scriptCharset,
                            src: s.url
                        }).on('load error', callback = function (evt) {
                            script.remove();
                            callback = null;
                            if (evt) {
                                complete(evt.type === 'error' ? 404 : 200, evt.type);
                            }
                        });
                        document.head.appendChild(script[0]);
                    },
                    abort: function () {
                        if (callback) {
                            callback();
                        }
                    }
                };
            }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({
            jsonp: 'callback',
            jsonpCallback: function () {
                var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
                this[callback] = true;
                return callback;
            }
        });
        jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && (s.contentType || '').indexOf('application/x-www-form-urlencoded') === 0 && rjsonp.test(s.data) && 'data');
            if (jsonProp || s.dataTypes[0] === 'jsonp') {
                callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
                if (jsonProp) {
                    s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
                } else if (s.jsonp !== false) {
                    s.url += (rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
                }
                s.converters['script json'] = function () {
                    if (!responseContainer) {
                        jQuery.error(callbackName + ' was not called');
                    }
                    return responseContainer[0];
                };
                s.dataTypes[0] = 'json';
                overwritten = window[callbackName];
                window[callbackName] = function () {
                    responseContainer = arguments;
                };
                jqXHR.always(function () {
                    if (overwritten === undefined) {
                        jQuery(window).removeProp(callbackName);
                    } else {
                        window[callbackName] = overwritten;
                    }
                    if (s[callbackName]) {
                        s.jsonpCallback = originalSettings.jsonpCallback;
                        oldCallbacks.push(callbackName);
                    }
                    if (responseContainer && jQuery.isFunction(overwritten)) {
                        overwritten(responseContainer[0]);
                    }
                    responseContainer = overwritten = undefined;
                });
                return 'script';
            }
        });
        jQuery.parseHTML = function (data, context, keepScripts) {
            if (!data || typeof data !== 'string') {
                return null;
            }
            if (typeof context === 'boolean') {
                keepScripts = context;
                context = false;
            }
            context = context || document;
            var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
            if (parsed) {
                return [context.createElement(parsed[1])];
            }
            parsed = buildFragment([data], context, scripts);
            if (scripts && scripts.length) {
                jQuery(scripts).remove();
            }
            return jQuery.merge([], parsed.childNodes);
        };
        var _load = jQuery.fn.load;
        jQuery.fn.load = function (url, params, callback) {
            if (typeof url !== 'string' && _load) {
                return _load.apply(this, arguments);
            }
            var selector, type, response, self = this, off = url.indexOf(' ');
            if (off > -1) {
                selector = jQuery.trim(url.slice(off));
                url = url.slice(0, off);
            }
            if (jQuery.isFunction(params)) {
                callback = params;
                params = undefined;
            } else if (params && typeof params === 'object') {
                type = 'POST';
            }
            if (self.length > 0) {
                jQuery.ajax({
                    url: url,
                    type: type || 'GET',
                    dataType: 'html',
                    data: params
                }).done(function (responseText) {
                    response = arguments;
                    self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
                }).always(callback && function (jqXHR, status) {
                    self.each(function () {
                        callback.apply(this, response || [
                            jqXHR.responseText,
                            status,
                            jqXHR
                        ]);
                    });
                });
            }
            return this;
        };
        jQuery.each([
            'ajaxStart',
            'ajaxStop',
            'ajaxComplete',
            'ajaxError',
            'ajaxSuccess',
            'ajaxSend'
        ], function (i, type) {
            jQuery.fn[type] = function (fn) {
                return this.on(type, fn);
            };
        });
        jQuery.expr.filters.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem;
            }).length;
        };
        function getWindow(elem) {
            return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
        }
        jQuery.offset = {
            setOffset: function (elem, options, i) {
                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
                if (position === 'static') {
                    elem.style.position = 'relative';
                }
                curOffset = curElem.offset();
                curCSSTop = jQuery.css(elem, 'top');
                curCSSLeft = jQuery.css(elem, 'left');
                calculatePosition = (position === 'absolute' || position === 'fixed') && (curCSSTop + curCSSLeft).indexOf('auto') > -1;
                if (calculatePosition) {
                    curPosition = curElem.position();
                    curTop = curPosition.top;
                    curLeft = curPosition.left;
                } else {
                    curTop = parseFloat(curCSSTop) || 0;
                    curLeft = parseFloat(curCSSLeft) || 0;
                }
                if (jQuery.isFunction(options)) {
                    options = options.call(elem, i, jQuery.extend({}, curOffset));
                }
                if (options.top != null) {
                    props.top = options.top - curOffset.top + curTop;
                }
                if (options.left != null) {
                    props.left = options.left - curOffset.left + curLeft;
                }
                if ('using' in options) {
                    options.using.call(elem, props);
                } else {
                    curElem.css(props);
                }
            }
        };
        jQuery.fn.extend({
            offset: function (options) {
                if (arguments.length) {
                    return options === undefined ? this : this.each(function (i) {
                        jQuery.offset.setOffset(this, options, i);
                    });
                }
                var docElem, win, elem = this[0], box = {
                        top: 0,
                        left: 0
                    }, doc = elem && elem.ownerDocument;
                if (!doc) {
                    return;
                }
                docElem = doc.documentElement;
                if (!jQuery.contains(docElem, elem)) {
                    return box;
                }
                box = elem.getBoundingClientRect();
                win = getWindow(doc);
                return {
                    top: box.top + win.pageYOffset - docElem.clientTop,
                    left: box.left + win.pageXOffset - docElem.clientLeft
                };
            },
            position: function () {
                if (!this[0]) {
                    return;
                }
                var offsetParent, offset, elem = this[0], parentOffset = {
                        top: 0,
                        left: 0
                    };
                if (jQuery.css(elem, 'position') === 'fixed') {
                    offset = elem.getBoundingClientRect();
                } else {
                    offsetParent = this.offsetParent();
                    offset = this.offset();
                    if (!jQuery.nodeName(offsetParent[0], 'html')) {
                        parentOffset = offsetParent.offset();
                    }
                    parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
                    parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
                }
                return {
                    top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
                    left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
                };
            },
            offsetParent: function () {
                return this.map(function () {
                    var offsetParent = this.offsetParent;
                    while (offsetParent && jQuery.css(offsetParent, 'position') === 'static') {
                        offsetParent = offsetParent.offsetParent;
                    }
                    return offsetParent || documentElement;
                });
            }
        });
        jQuery.each({
            scrollLeft: 'pageXOffset',
            scrollTop: 'pageYOffset'
        }, function (method, prop) {
            var top = 'pageYOffset' === prop;
            jQuery.fn[method] = function (val) {
                return access(this, function (elem, method, val) {
                    var win = getWindow(elem);
                    if (val === undefined) {
                        return win ? win[prop] : elem[method];
                    }
                    if (win) {
                        win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
                    } else {
                        elem[method] = val;
                    }
                }, method, val, arguments.length);
            };
        });
        jQuery.each([
            'top',
            'left'
        ], function (i, prop) {
            jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
                if (computed) {
                    computed = curCSS(elem, prop);
                    return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
                }
            });
        });
        jQuery.each({
            Height: 'height',
            Width: 'width'
        }, function (name, type) {
            jQuery.each({
                padding: 'inner' + name,
                content: type,
                '': 'outer' + name
            }, function (defaultExtra, funcName) {
                jQuery.fn[funcName] = function (margin, value) {
                    var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
                    return access(this, function (elem, type, value) {
                        var doc;
                        if (jQuery.isWindow(elem)) {
                            return elem.document.documentElement['client' + name];
                        }
                        if (elem.nodeType === 9) {
                            doc = elem.documentElement;
                            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
                        }
                        return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
                    }, type, chainable ? margin : undefined, chainable, null);
                };
            });
        });
        jQuery.fn.extend({
            bind: function (types, data, fn) {
                return this.on(types, null, data, fn);
            },
            unbind: function (types, fn) {
                return this.off(types, null, fn);
            },
            delegate: function (selector, types, data, fn) {
                return this.on(types, selector, data, fn);
            },
            undelegate: function (selector, types, fn) {
                return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
            },
            size: function () {
                return this.length;
            }
        });
        jQuery.fn.andSelf = jQuery.fn.addBack;
        if (typeof define === 'function' && define.amd) {
            define('jquery', [], function () {
                return jQuery;
            });
        }
        var _jQuery = window.jQuery, _$ = window.$;
        jQuery.noConflict = function (deep) {
            if (window.$ === jQuery) {
                window.$ = _$;
            }
            if (deep && window.jQuery === jQuery) {
                window.jQuery = _jQuery;
            }
            return jQuery;
        };
        if (!noGlobal) {
            window.jQuery = window.$ = jQuery;
        }
        return jQuery;
    }));
}.call(this));
define('angular', ['jquery'], function () {
    (function (window) {
        'use strict';
        function minErr(module, ErrorConstructor) {
            ErrorConstructor = ErrorConstructor || Error;
            return function () {
                var SKIP_INDEXES = 2;
                var templateArgs = arguments, code = templateArgs[0], message = '[' + (module ? module + ':' : '') + code + '] ', template = templateArgs[1], paramPrefix, i;
                message += template.replace(/\{\d+\}/g, function (match) {
                    var index = +match.slice(1, -1), shiftedIndex = index + SKIP_INDEXES;
                    if (shiftedIndex < templateArgs.length) {
                        return toDebugString(templateArgs[shiftedIndex]);
                    }
                    return match;
                });
                message += '\nhttp://errors.angularjs.org/1.5.5/' + (module ? module + '/' : '') + code;
                for (i = SKIP_INDEXES, paramPrefix = '?'; i < templateArgs.length; i++, paramPrefix = '&') {
                    message += paramPrefix + 'p' + (i - SKIP_INDEXES) + '=' + encodeURIComponent(toDebugString(templateArgs[i]));
                }
                return new ErrorConstructor(message);
            };
        }
        var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/;
        var VALIDITY_STATE_PROPERTY = 'validity';
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var lowercase = function (string) {
            return isString(string) ? string.toLowerCase() : string;
        };
        var uppercase = function (string) {
            return isString(string) ? string.toUpperCase() : string;
        };
        var manualLowercase = function (s) {
            return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
                return String.fromCharCode(ch.charCodeAt(0) | 32);
            }) : s;
        };
        var manualUppercase = function (s) {
            return isString(s) ? s.replace(/[a-z]/g, function (ch) {
                return String.fromCharCode(ch.charCodeAt(0) & ~32);
            }) : s;
        };
        if ('i' !== 'I'.toLowerCase()) {
            lowercase = manualLowercase;
            uppercase = manualUppercase;
        }
        var msie, jqLite, jQuery, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr('ng'), angular = window.angular || (window.angular = {}), angularModule, uid = 0;
        msie = window.document.documentMode;
        function isArrayLike(obj) {
            if (obj == null || isWindow(obj))
                return false;
            if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite)
                return true;
            var length = 'length' in Object(obj) && obj.length;
            return isNumber(length) && (length >= 0 && (length - 1 in obj || obj instanceof Array) || typeof obj.item == 'function');
        }
        function forEach(obj, iterator, context) {
            var key, length;
            if (obj) {
                if (isFunction(obj)) {
                    for (key in obj) {
                        if (key != 'prototype' && key != 'length' && key != 'name' && (!obj.hasOwnProperty || obj.hasOwnProperty(key))) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                } else if (isArray(obj) || isArrayLike(obj)) {
                    var isPrimitive = typeof obj !== 'object';
                    for (key = 0, length = obj.length; key < length; key++) {
                        if (isPrimitive || key in obj) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                } else if (obj.forEach && obj.forEach !== forEach) {
                    obj.forEach(iterator, context, obj);
                } else if (isBlankObject(obj)) {
                    for (key in obj) {
                        iterator.call(context, obj[key], key, obj);
                    }
                } else if (typeof obj.hasOwnProperty === 'function') {
                    for (key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                } else {
                    for (key in obj) {
                        if (hasOwnProperty.call(obj, key)) {
                            iterator.call(context, obj[key], key, obj);
                        }
                    }
                }
            }
            return obj;
        }
        function forEachSorted(obj, iterator, context) {
            var keys = Object.keys(obj).sort();
            for (var i = 0; i < keys.length; i++) {
                iterator.call(context, obj[keys[i]], keys[i]);
            }
            return keys;
        }
        function reverseParams(iteratorFn) {
            return function (value, key) {
                iteratorFn(key, value);
            };
        }
        function nextUid() {
            return ++uid;
        }
        function setHashKey(obj, h) {
            if (h) {
                obj.$$hashKey = h;
            } else {
                delete obj.$$hashKey;
            }
        }
        function baseExtend(dst, objs, deep) {
            var h = dst.$$hashKey;
            for (var i = 0, ii = objs.length; i < ii; ++i) {
                var obj = objs[i];
                if (!isObject(obj) && !isFunction(obj))
                    continue;
                var keys = Object.keys(obj);
                for (var j = 0, jj = keys.length; j < jj; j++) {
                    var key = keys[j];
                    var src = obj[key];
                    if (deep && isObject(src)) {
                        if (isDate(src)) {
                            dst[key] = new Date(src.valueOf());
                        } else if (isRegExp(src)) {
                            dst[key] = new RegExp(src);
                        } else if (src.nodeName) {
                            dst[key] = src.cloneNode(true);
                        } else if (isElement(src)) {
                            dst[key] = src.clone();
                        } else {
                            if (!isObject(dst[key]))
                                dst[key] = isArray(src) ? [] : {};
                            baseExtend(dst[key], [src], true);
                        }
                    } else {
                        dst[key] = src;
                    }
                }
            }
            setHashKey(dst, h);
            return dst;
        }
        function extend(dst) {
            return baseExtend(dst, slice.call(arguments, 1), false);
        }
        function merge(dst) {
            return baseExtend(dst, slice.call(arguments, 1), true);
        }
        function toInt(str) {
            return parseInt(str, 10);
        }
        function inherit(parent, extra) {
            return extend(Object.create(parent), extra);
        }
        function noop() {
        }
        noop.$inject = [];
        function identity($) {
            return $;
        }
        identity.$inject = [];
        function valueFn(value) {
            return function valueRef() {
                return value;
            };
        }
        function hasCustomToString(obj) {
            return isFunction(obj.toString) && obj.toString !== toString;
        }
        function isUndefined(value) {
            return typeof value === 'undefined';
        }
        function isDefined(value) {
            return typeof value !== 'undefined';
        }
        function isObject(value) {
            return value !== null && typeof value === 'object';
        }
        function isBlankObject(value) {
            return value !== null && typeof value === 'object' && !getPrototypeOf(value);
        }
        function isString(value) {
            return typeof value === 'string';
        }
        function isNumber(value) {
            return typeof value === 'number';
        }
        function isDate(value) {
            return toString.call(value) === '[object Date]';
        }
        var isArray = Array.isArray;
        function isFunction(value) {
            return typeof value === 'function';
        }
        function isRegExp(value) {
            return toString.call(value) === '[object RegExp]';
        }
        function isWindow(obj) {
            return obj && obj.window === obj;
        }
        function isScope(obj) {
            return obj && obj.$evalAsync && obj.$watch;
        }
        function isFile(obj) {
            return toString.call(obj) === '[object File]';
        }
        function isFormData(obj) {
            return toString.call(obj) === '[object FormData]';
        }
        function isBlob(obj) {
            return toString.call(obj) === '[object Blob]';
        }
        function isBoolean(value) {
            return typeof value === 'boolean';
        }
        function isPromiseLike(obj) {
            return obj && isFunction(obj.then);
        }
        var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/;
        function isTypedArray(value) {
            return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value));
        }
        function isArrayBuffer(obj) {
            return toString.call(obj) === '[object ArrayBuffer]';
        }
        var trim = function (value) {
            return isString(value) ? value.trim() : value;
        };
        var escapeForRegexp = function (s) {
            return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, '\\$1').replace(/\x08/g, '\\x08');
        };
        function isElement(node) {
            return !!(node && (node.nodeName || node.prop && node.attr && node.find));
        }
        function makeMap(str) {
            var obj = {}, items = str.split(','), i;
            for (i = 0; i < items.length; i++) {
                obj[items[i]] = true;
            }
            return obj;
        }
        function nodeName_(element) {
            return lowercase(element.nodeName || element[0] && element[0].nodeName);
        }
        function includes(array, obj) {
            return Array.prototype.indexOf.call(array, obj) != -1;
        }
        function arrayRemove(array, value) {
            var index = array.indexOf(value);
            if (index >= 0) {
                array.splice(index, 1);
            }
            return index;
        }
        function copy(source, destination) {
            var stackSource = [];
            var stackDest = [];
            if (destination) {
                if (isTypedArray(destination) || isArrayBuffer(destination)) {
                    throw ngMinErr('cpta', 'Can\'t copy! TypedArray destination cannot be mutated.');
                }
                if (source === destination) {
                    throw ngMinErr('cpi', 'Can\'t copy! Source and destination are identical.');
                }
                if (isArray(destination)) {
                    destination.length = 0;
                } else {
                    forEach(destination, function (value, key) {
                        if (key !== '$$hashKey') {
                            delete destination[key];
                        }
                    });
                }
                stackSource.push(source);
                stackDest.push(destination);
                return copyRecurse(source, destination);
            }
            return copyElement(source);
            function copyRecurse(source, destination) {
                var h = destination.$$hashKey;
                var key;
                if (isArray(source)) {
                    for (var i = 0, ii = source.length; i < ii; i++) {
                        destination.push(copyElement(source[i]));
                    }
                } else if (isBlankObject(source)) {
                    for (key in source) {
                        destination[key] = copyElement(source[key]);
                    }
                } else if (source && typeof source.hasOwnProperty === 'function') {
                    for (key in source) {
                        if (source.hasOwnProperty(key)) {
                            destination[key] = copyElement(source[key]);
                        }
                    }
                } else {
                    for (key in source) {
                        if (hasOwnProperty.call(source, key)) {
                            destination[key] = copyElement(source[key]);
                        }
                    }
                }
                setHashKey(destination, h);
                return destination;
            }
            function copyElement(source) {
                if (!isObject(source)) {
                    return source;
                }
                var index = stackSource.indexOf(source);
                if (index !== -1) {
                    return stackDest[index];
                }
                if (isWindow(source) || isScope(source)) {
                    throw ngMinErr('cpws', 'Can\'t copy! Making copies of Window or Scope instances is not supported.');
                }
                var needsRecurse = false;
                var destination = copyType(source);
                if (destination === undefined) {
                    destination = isArray(source) ? [] : Object.create(getPrototypeOf(source));
                    needsRecurse = true;
                }
                stackSource.push(source);
                stackDest.push(destination);
                return needsRecurse ? copyRecurse(source, destination) : destination;
            }
            function copyType(source) {
                switch (toString.call(source)) {
                case '[object Int8Array]':
                case '[object Int16Array]':
                case '[object Int32Array]':
                case '[object Float32Array]':
                case '[object Float64Array]':
                case '[object Uint8Array]':
                case '[object Uint8ClampedArray]':
                case '[object Uint16Array]':
                case '[object Uint32Array]':
                    return new source.constructor(copyElement(source.buffer));
                case '[object ArrayBuffer]':
                    if (!source.slice) {
                        var copied = new ArrayBuffer(source.byteLength);
                        new Uint8Array(copied).set(new Uint8Array(source));
                        return copied;
                    }
                    return source.slice(0);
                case '[object Boolean]':
                case '[object Number]':
                case '[object String]':
                case '[object Date]':
                    return new source.constructor(source.valueOf());
                case '[object RegExp]':
                    var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                    re.lastIndex = source.lastIndex;
                    return re;
                case '[object Blob]':
                    return new source.constructor([source], { type: source.type });
                }
                if (isFunction(source.cloneNode)) {
                    return source.cloneNode(true);
                }
            }
        }
        function shallowCopy(src, dst) {
            if (isArray(src)) {
                dst = dst || [];
                for (var i = 0, ii = src.length; i < ii; i++) {
                    dst[i] = src[i];
                }
            } else if (isObject(src)) {
                dst = dst || {};
                for (var key in src) {
                    if (!(key.charAt(0) === '$' && key.charAt(1) === '$')) {
                        dst[key] = src[key];
                    }
                }
            }
            return dst || src;
        }
        function equals(o1, o2) {
            if (o1 === o2)
                return true;
            if (o1 === null || o2 === null)
                return false;
            if (o1 !== o1 && o2 !== o2)
                return true;
            var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
            if (t1 == t2 && t1 == 'object') {
                if (isArray(o1)) {
                    if (!isArray(o2))
                        return false;
                    if ((length = o1.length) == o2.length) {
                        for (key = 0; key < length; key++) {
                            if (!equals(o1[key], o2[key]))
                                return false;
                        }
                        return true;
                    }
                } else if (isDate(o1)) {
                    if (!isDate(o2))
                        return false;
                    return equals(o1.getTime(), o2.getTime());
                } else if (isRegExp(o1)) {
                    if (!isRegExp(o2))
                        return false;
                    return o1.toString() == o2.toString();
                } else {
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))
                        return false;
                    keySet = createMap();
                    for (key in o1) {
                        if (key.charAt(0) === '$' || isFunction(o1[key]))
                            continue;
                        if (!equals(o1[key], o2[key]))
                            return false;
                        keySet[key] = true;
                    }
                    for (key in o2) {
                        if (!(key in keySet) && key.charAt(0) !== '$' && isDefined(o2[key]) && !isFunction(o2[key]))
                            return false;
                    }
                    return true;
                }
            }
            return false;
        }
        var csp = function () {
            if (!isDefined(csp.rules)) {
                var ngCspElement = window.document.querySelector('[ng-csp]') || window.document.querySelector('[data-ng-csp]');
                if (ngCspElement) {
                    var ngCspAttribute = ngCspElement.getAttribute('ng-csp') || ngCspElement.getAttribute('data-ng-csp');
                    csp.rules = {
                        noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf('no-unsafe-eval') !== -1,
                        noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf('no-inline-style') !== -1
                    };
                } else {
                    csp.rules = {
                        noUnsafeEval: noUnsafeEval(),
                        noInlineStyle: false
                    };
                }
            }
            return csp.rules;
            function noUnsafeEval() {
                try {
                    new Function('');
                    return false;
                } catch (e) {
                    return true;
                }
            }
        };
        var jq = function () {
            if (isDefined(jq.name_))
                return jq.name_;
            var el;
            var i, ii = ngAttrPrefixes.length, prefix, name;
            for (i = 0; i < ii; ++i) {
                prefix = ngAttrPrefixes[i];
                if (el = window.document.querySelector('[' + prefix.replace(':', '\\:') + 'jq]')) {
                    name = el.getAttribute(prefix + 'jq');
                    break;
                }
            }
            return jq.name_ = name;
        };
        function concat(array1, array2, index) {
            return array1.concat(slice.call(array2, index));
        }
        function sliceArgs(args, startIndex) {
            return slice.call(args, startIndex || 0);
        }
        function bind(self, fn) {
            var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
            if (isFunction(fn) && !(fn instanceof RegExp)) {
                return curryArgs.length ? function () {
                    return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs);
                } : function () {
                    return arguments.length ? fn.apply(self, arguments) : fn.call(self);
                };
            } else {
                return fn;
            }
        }
        function toJsonReplacer(key, value) {
            var val = value;
            if (typeof key === 'string' && key.charAt(0) === '$' && key.charAt(1) === '$') {
                val = undefined;
            } else if (isWindow(value)) {
                val = '$WINDOW';
            } else if (value && window.document === value) {
                val = '$DOCUMENT';
            } else if (isScope(value)) {
                val = '$SCOPE';
            }
            return val;
        }
        function toJson(obj, pretty) {
            if (isUndefined(obj))
                return undefined;
            if (!isNumber(pretty)) {
                pretty = pretty ? 2 : null;
            }
            return JSON.stringify(obj, toJsonReplacer, pretty);
        }
        function fromJson(json) {
            return isString(json) ? JSON.parse(json) : json;
        }
        var ALL_COLONS = /:/g;
        function timezoneToOffset(timezone, fallback) {
            timezone = timezone.replace(ALL_COLONS, '');
            var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
            return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
        }
        function addDateMinutes(date, minutes) {
            date = new Date(date.getTime());
            date.setMinutes(date.getMinutes() + minutes);
            return date;
        }
        function convertTimezoneToLocal(date, timezone, reverse) {
            reverse = reverse ? -1 : 1;
            var dateTimezoneOffset = date.getTimezoneOffset();
            var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
        }
        function startingTag(element) {
            element = jqLite(element).clone();
            try {
                element.empty();
            } catch (e) {
            }
            var elemHtml = jqLite('<div>').append(element).html();
            try {
                return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
                    return '<' + lowercase(nodeName);
                });
            } catch (e) {
                return lowercase(elemHtml);
            }
        }
        function tryDecodeURIComponent(value) {
            try {
                return decodeURIComponent(value);
            } catch (e) {
            }
        }
        function parseKeyValue(keyValue) {
            var obj = {};
            forEach((keyValue || '').split('&'), function (keyValue) {
                var splitPoint, key, val;
                if (keyValue) {
                    key = keyValue = keyValue.replace(/\+/g, '%20');
                    splitPoint = keyValue.indexOf('=');
                    if (splitPoint !== -1) {
                        key = keyValue.substring(0, splitPoint);
                        val = keyValue.substring(splitPoint + 1);
                    }
                    key = tryDecodeURIComponent(key);
                    if (isDefined(key)) {
                        val = isDefined(val) ? tryDecodeURIComponent(val) : true;
                        if (!hasOwnProperty.call(obj, key)) {
                            obj[key] = val;
                        } else if (isArray(obj[key])) {
                            obj[key].push(val);
                        } else {
                            obj[key] = [
                                obj[key],
                                val
                            ];
                        }
                    }
                }
            });
            return obj;
        }
        function toKeyValue(obj) {
            var parts = [];
            forEach(obj, function (value, key) {
                if (isArray(value)) {
                    forEach(value, function (arrayValue) {
                        parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));
                    });
                } else {
                    parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));
                }
            });
            return parts.length ? parts.join('&') : '';
        }
        function encodeUriSegment(val) {
            return encodeUriQuery(val, true).replace(/%26/gi, '&').replace(/%3D/gi, '=').replace(/%2B/gi, '+');
        }
        function encodeUriQuery(val, pctEncodeSpaces) {
            return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%3B/gi, ';').replace(/%20/g, pctEncodeSpaces ? '%20' : '+');
        }
        var ngAttrPrefixes = [
            'ng-',
            'data-ng-',
            'ng:',
            'x-ng-'
        ];
        function getNgAttribute(element, ngAttr) {
            var attr, i, ii = ngAttrPrefixes.length;
            for (i = 0; i < ii; ++i) {
                attr = ngAttrPrefixes[i] + ngAttr;
                if (isString(attr = element.getAttribute(attr))) {
                    return attr;
                }
            }
            return null;
        }
        function angularInit(element, bootstrap) {
            var appElement, module, config = {};
            forEach(ngAttrPrefixes, function (prefix) {
                var name = prefix + 'app';
                if (!appElement && element.hasAttribute && element.hasAttribute(name)) {
                    appElement = element;
                    module = element.getAttribute(name);
                }
            });
            forEach(ngAttrPrefixes, function (prefix) {
                var name = prefix + 'app';
                var candidate;
                if (!appElement && (candidate = element.querySelector('[' + name.replace(':', '\\:') + ']'))) {
                    appElement = candidate;
                    module = candidate.getAttribute(name);
                }
            });
            if (appElement) {
                config.strictDi = getNgAttribute(appElement, 'strict-di') !== null;
                bootstrap(appElement, module ? [module] : [], config);
            }
        }
        function bootstrap(element, modules, config) {
            if (!isObject(config))
                config = {};
            var defaultConfig = { strictDi: false };
            config = extend(defaultConfig, config);
            var doBootstrap = function () {
                element = jqLite(element);
                if (element.injector()) {
                    var tag = element[0] === window.document ? 'document' : startingTag(element);
                    throw ngMinErr('btstrpd', 'App already bootstrapped with this element \'{0}\'', tag.replace(/</, '&lt;').replace(/>/, '&gt;'));
                }
                modules = modules || [];
                modules.unshift([
                    '$provide',
                    function ($provide) {
                        $provide.value('$rootElement', element);
                    }
                ]);
                if (config.debugInfoEnabled) {
                    modules.push([
                        '$compileProvider',
                        function ($compileProvider) {
                            $compileProvider.debugInfoEnabled(true);
                        }
                    ]);
                }
                modules.unshift('ng');
                var injector = createInjector(modules, config.strictDi);
                injector.invoke([
                    '$rootScope',
                    '$rootElement',
                    '$compile',
                    '$injector',
                    function bootstrapApply(scope, element, compile, injector) {
                        scope.$apply(function () {
                            element.data('$injector', injector);
                            compile(element)(scope);
                        });
                    }
                ]);
                return injector;
            };
            var NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/;
            var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
            if (window && NG_ENABLE_DEBUG_INFO.test(window.name)) {
                config.debugInfoEnabled = true;
                window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, '');
            }
            if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {
                return doBootstrap();
            }
            window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');
            angular.resumeBootstrap = function (extraModules) {
                forEach(extraModules, function (module) {
                    modules.push(module);
                });
                return doBootstrap();
            };
            if (isFunction(angular.resumeDeferredBootstrap)) {
                angular.resumeDeferredBootstrap();
            }
        }
        function reloadWithDebugInfo() {
            window.name = 'NG_ENABLE_DEBUG_INFO!' + window.name;
            window.location.reload();
        }
        function getTestability(rootElement) {
            var injector = angular.element(rootElement).injector();
            if (!injector) {
                throw ngMinErr('test', 'no injector found for element argument to getTestability');
            }
            return injector.get('$$testability');
        }
        var SNAKE_CASE_REGEXP = /[A-Z]/g;
        function snake_case(name, separator) {
            separator = separator || '_';
            return name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
                return (pos ? separator : '') + letter.toLowerCase();
            });
        }
        var bindJQueryFired = false;
        function bindJQuery() {
            var originalCleanData;
            if (bindJQueryFired) {
                return;
            }
            var jqName = jq();
            jQuery = isUndefined(jqName) ? window.jQuery : !jqName ? undefined : window[jqName];
            if (jQuery && jQuery.fn.on) {
                jqLite = jQuery;
                extend(jQuery.fn, {
                    scope: JQLitePrototype.scope,
                    isolateScope: JQLitePrototype.isolateScope,
                    controller: JQLitePrototype.controller,
                    injector: JQLitePrototype.injector,
                    inheritedData: JQLitePrototype.inheritedData
                });
                originalCleanData = jQuery.cleanData;
                jQuery.cleanData = function (elems) {
                    var events;
                    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
                        events = jQuery._data(elem, 'events');
                        if (events && events.$destroy) {
                            jQuery(elem).triggerHandler('$destroy');
                        }
                    }
                    originalCleanData(elems);
                };
            } else {
                jqLite = JQLite;
            }
            angular.element = jqLite;
            bindJQueryFired = true;
        }
        function assertArg(arg, name, reason) {
            if (!arg) {
                throw ngMinErr('areq', 'Argument \'{0}\' is {1}', name || '?', reason || 'required');
            }
            return arg;
        }
        function assertArgFn(arg, name, acceptArrayAnnotation) {
            if (acceptArrayAnnotation && isArray(arg)) {
                arg = arg[arg.length - 1];
            }
            assertArg(isFunction(arg), name, 'not a function, got ' + (arg && typeof arg === 'object' ? arg.constructor.name || 'Object' : typeof arg));
            return arg;
        }
        function assertNotHasOwnProperty(name, context) {
            if (name === 'hasOwnProperty') {
                throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
            }
        }
        function getter(obj, path, bindFnToScope) {
            if (!path)
                return obj;
            var keys = path.split('.');
            var key;
            var lastInstance = obj;
            var len = keys.length;
            for (var i = 0; i < len; i++) {
                key = keys[i];
                if (obj) {
                    obj = (lastInstance = obj)[key];
                }
            }
            if (!bindFnToScope && isFunction(obj)) {
                return bind(lastInstance, obj);
            }
            return obj;
        }
        function getBlockNodes(nodes) {
            var node = nodes[0];
            var endNode = nodes[nodes.length - 1];
            var blockNodes;
            for (var i = 1; node !== endNode && (node = node.nextSibling); i++) {
                if (blockNodes || nodes[i] !== node) {
                    if (!blockNodes) {
                        blockNodes = jqLite(slice.call(nodes, 0, i));
                    }
                    blockNodes.push(node);
                }
            }
            return blockNodes || nodes;
        }
        function createMap() {
            return Object.create(null);
        }
        var NODE_TYPE_ELEMENT = 1;
        var NODE_TYPE_ATTRIBUTE = 2;
        var NODE_TYPE_TEXT = 3;
        var NODE_TYPE_COMMENT = 8;
        var NODE_TYPE_DOCUMENT = 9;
        var NODE_TYPE_DOCUMENT_FRAGMENT = 11;
        function setupModuleLoader(window) {
            var $injectorMinErr = minErr('$injector');
            var ngMinErr = minErr('ng');
            function ensure(obj, name, factory) {
                return obj[name] || (obj[name] = factory());
            }
            var angular = ensure(window, 'angular', Object);
            angular.$$minErr = angular.$$minErr || minErr;
            return ensure(angular, 'module', function () {
                var modules = {};
                return function module(name, requires, configFn) {
                    var assertNotHasOwnProperty = function (name, context) {
                        if (name === 'hasOwnProperty') {
                            throw ngMinErr('badname', 'hasOwnProperty is not a valid {0} name', context);
                        }
                    };
                    assertNotHasOwnProperty(name, 'module');
                    if (requires && modules.hasOwnProperty(name)) {
                        modules[name] = null;
                    }
                    return ensure(modules, name, function () {
                        if (!requires) {
                            throw $injectorMinErr('nomod', 'Module \'{0}\' is not available! You either misspelled ' + 'the module name or forgot to load it. If registering a module ensure that you ' + 'specify the dependencies as the second argument.', name);
                        }
                        var invokeQueue = [];
                        var configBlocks = [];
                        var runBlocks = [];
                        var config = invokeLater('$injector', 'invoke', 'push', configBlocks);
                        var moduleInstance = {
                            _invokeQueue: invokeQueue,
                            _configBlocks: configBlocks,
                            _runBlocks: runBlocks,
                            requires: requires,
                            name: name,
                            provider: invokeLaterAndSetModuleName('$provide', 'provider'),
                            factory: invokeLaterAndSetModuleName('$provide', 'factory'),
                            service: invokeLaterAndSetModuleName('$provide', 'service'),
                            value: invokeLater('$provide', 'value'),
                            constant: invokeLater('$provide', 'constant', 'unshift'),
                            decorator: invokeLaterAndSetModuleName('$provide', 'decorator'),
                            animation: invokeLaterAndSetModuleName('$animateProvider', 'register'),
                            filter: invokeLaterAndSetModuleName('$filterProvider', 'register'),
                            controller: invokeLaterAndSetModuleName('$controllerProvider', 'register'),
                            directive: invokeLaterAndSetModuleName('$compileProvider', 'directive'),
                            component: invokeLaterAndSetModuleName('$compileProvider', 'component'),
                            config: config,
                            run: function (block) {
                                runBlocks.push(block);
                                return this;
                            }
                        };
                        if (configFn) {
                            config(configFn);
                        }
                        return moduleInstance;
                        function invokeLater(provider, method, insertMethod, queue) {
                            if (!queue)
                                queue = invokeQueue;
                            return function () {
                                queue[insertMethod || 'push']([
                                    provider,
                                    method,
                                    arguments
                                ]);
                                return moduleInstance;
                            };
                        }
                        function invokeLaterAndSetModuleName(provider, method) {
                            return function (recipeName, factoryFunction) {
                                if (factoryFunction && isFunction(factoryFunction))
                                    factoryFunction.$$moduleName = name;
                                invokeQueue.push([
                                    provider,
                                    method,
                                    arguments
                                ]);
                                return moduleInstance;
                            };
                        }
                    });
                };
            });
        }
        function serializeObject(obj) {
            var seen = [];
            return JSON.stringify(obj, function (key, val) {
                val = toJsonReplacer(key, val);
                if (isObject(val)) {
                    if (seen.indexOf(val) >= 0)
                        return '...';
                    seen.push(val);
                }
                return val;
            });
        }
        function toDebugString(obj) {
            if (typeof obj === 'function') {
                return obj.toString().replace(/ \{[\s\S]*$/, '');
            } else if (isUndefined(obj)) {
                return 'undefined';
            } else if (typeof obj !== 'string') {
                return serializeObject(obj);
            }
            return obj;
        }
        var version = {
            full: '1.5.5',
            major: 1,
            minor: 5,
            dot: 5,
            codeName: 'material-conspiration'
        };
        function publishExternalAPI(angular) {
            extend(angular, {
                'bootstrap': bootstrap,
                'copy': copy,
                'extend': extend,
                'merge': merge,
                'equals': equals,
                'element': jqLite,
                'forEach': forEach,
                'injector': createInjector,
                'noop': noop,
                'bind': bind,
                'toJson': toJson,
                'fromJson': fromJson,
                'identity': identity,
                'isUndefined': isUndefined,
                'isDefined': isDefined,
                'isString': isString,
                'isFunction': isFunction,
                'isObject': isObject,
                'isNumber': isNumber,
                'isElement': isElement,
                'isArray': isArray,
                'version': version,
                'isDate': isDate,
                'lowercase': lowercase,
                'uppercase': uppercase,
                'callbacks': { counter: 0 },
                'getTestability': getTestability,
                '$$minErr': minErr,
                '$$csp': csp,
                'reloadWithDebugInfo': reloadWithDebugInfo
            });
            angularModule = setupModuleLoader(window);
            angularModule('ng', ['ngLocale'], [
                '$provide',
                function ngModule($provide) {
                    $provide.provider({ $$sanitizeUri: $$SanitizeUriProvider });
                    $provide.provider('$compile', $CompileProvider).directive({
                        a: htmlAnchorDirective,
                        input: inputDirective,
                        textarea: inputDirective,
                        form: formDirective,
                        script: scriptDirective,
                        select: selectDirective,
                        style: styleDirective,
                        option: optionDirective,
                        ngBind: ngBindDirective,
                        ngBindHtml: ngBindHtmlDirective,
                        ngBindTemplate: ngBindTemplateDirective,
                        ngClass: ngClassDirective,
                        ngClassEven: ngClassEvenDirective,
                        ngClassOdd: ngClassOddDirective,
                        ngCloak: ngCloakDirective,
                        ngController: ngControllerDirective,
                        ngForm: ngFormDirective,
                        ngHide: ngHideDirective,
                        ngIf: ngIfDirective,
                        ngInclude: ngIncludeDirective,
                        ngInit: ngInitDirective,
                        ngNonBindable: ngNonBindableDirective,
                        ngPluralize: ngPluralizeDirective,
                        ngRepeat: ngRepeatDirective,
                        ngShow: ngShowDirective,
                        ngStyle: ngStyleDirective,
                        ngSwitch: ngSwitchDirective,
                        ngSwitchWhen: ngSwitchWhenDirective,
                        ngSwitchDefault: ngSwitchDefaultDirective,
                        ngOptions: ngOptionsDirective,
                        ngTransclude: ngTranscludeDirective,
                        ngModel: ngModelDirective,
                        ngList: ngListDirective,
                        ngChange: ngChangeDirective,
                        pattern: patternDirective,
                        ngPattern: patternDirective,
                        required: requiredDirective,
                        ngRequired: requiredDirective,
                        minlength: minlengthDirective,
                        ngMinlength: minlengthDirective,
                        maxlength: maxlengthDirective,
                        ngMaxlength: maxlengthDirective,
                        ngValue: ngValueDirective,
                        ngModelOptions: ngModelOptionsDirective
                    }).directive({ ngInclude: ngIncludeFillContentDirective }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives);
                    $provide.provider({
                        $anchorScroll: $AnchorScrollProvider,
                        $animate: $AnimateProvider,
                        $animateCss: $CoreAnimateCssProvider,
                        $$animateJs: $$CoreAnimateJsProvider,
                        $$animateQueue: $$CoreAnimateQueueProvider,
                        $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                        $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                        $browser: $BrowserProvider,
                        $cacheFactory: $CacheFactoryProvider,
                        $controller: $ControllerProvider,
                        $document: $DocumentProvider,
                        $exceptionHandler: $ExceptionHandlerProvider,
                        $filter: $FilterProvider,
                        $$forceReflow: $$ForceReflowProvider,
                        $interpolate: $InterpolateProvider,
                        $interval: $IntervalProvider,
                        $http: $HttpProvider,
                        $httpParamSerializer: $HttpParamSerializerProvider,
                        $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                        $httpBackend: $HttpBackendProvider,
                        $xhrFactory: $xhrFactoryProvider,
                        $location: $LocationProvider,
                        $log: $LogProvider,
                        $parse: $ParseProvider,
                        $rootScope: $RootScopeProvider,
                        $q: $QProvider,
                        $$q: $$QProvider,
                        $sce: $SceProvider,
                        $sceDelegate: $SceDelegateProvider,
                        $sniffer: $SnifferProvider,
                        $templateCache: $TemplateCacheProvider,
                        $templateRequest: $TemplateRequestProvider,
                        $$testability: $$TestabilityProvider,
                        $timeout: $TimeoutProvider,
                        $window: $WindowProvider,
                        $$rAF: $$RAFProvider,
                        $$jqLite: $$jqLiteProvider,
                        $$HashMap: $$HashMapProvider,
                        $$cookieReader: $$CookieReaderProvider
                    });
                }
            ]);
        }
        JQLite.expando = 'ng339';
        var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function (element, type, fn) {
                element.addEventListener(type, fn, false);
            }, removeEventListenerFn = function (element, type, fn) {
                element.removeEventListener(type, fn, false);
            };
        JQLite._data = function (node) {
            return this.cache[node[this.expando]] || {};
        };
        function jqNextId() {
            return ++jqId;
        }
        var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
        var MOZ_HACK_REGEXP = /^moz([A-Z])/;
        var MOUSE_EVENT_MAP = {
            mouseleave: 'mouseout',
            mouseenter: 'mouseover'
        };
        var jqLiteMinErr = minErr('jqLite');
        function camelCase(name) {
            return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter;
            }).replace(MOZ_HACK_REGEXP, 'Moz$1');
        }
        var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/;
        var HTML_REGEXP = /<|&#?\w+;/;
        var TAG_NAME_REGEXP = /<([\w:-]+)/;
        var XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi;
        var wrapMap = {
            'option': [
                1,
                '<select multiple="multiple">',
                '</select>'
            ],
            'thead': [
                1,
                '<table>',
                '</table>'
            ],
            'col': [
                2,
                '<table><colgroup>',
                '</colgroup></table>'
            ],
            'tr': [
                2,
                '<table><tbody>',
                '</tbody></table>'
            ],
            'td': [
                3,
                '<table><tbody><tr>',
                '</tr></tbody></table>'
            ],
            '_default': [
                0,
                '',
                ''
            ]
        };
        wrapMap.optgroup = wrapMap.option;
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
        wrapMap.th = wrapMap.td;
        function jqLiteIsTextNode(html) {
            return !HTML_REGEXP.test(html);
        }
        function jqLiteAcceptsData(node) {
            var nodeType = node.nodeType;
            return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT;
        }
        function jqLiteHasData(node) {
            for (var key in jqCache[node.ng339]) {
                return true;
            }
            return false;
        }
        function jqLiteCleanData(nodes) {
            for (var i = 0, ii = nodes.length; i < ii; i++) {
                jqLiteRemoveData(nodes[i]);
            }
        }
        function jqLiteBuildFragment(html, context) {
            var tmp, tag, wrap, fragment = context.createDocumentFragment(), nodes = [], i;
            if (jqLiteIsTextNode(html)) {
                nodes.push(context.createTextNode(html));
            } else {
                tmp = tmp || fragment.appendChild(context.createElement('div'));
                tag = (TAG_NAME_REGEXP.exec(html) || [
                    '',
                    ''
                ])[1].toLowerCase();
                wrap = wrapMap[tag] || wrapMap._default;
                tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, '<$1></$2>') + wrap[2];
                i = wrap[0];
                while (i--) {
                    tmp = tmp.lastChild;
                }
                nodes = concat(nodes, tmp.childNodes);
                tmp = fragment.firstChild;
                tmp.textContent = '';
            }
            fragment.textContent = '';
            fragment.innerHTML = '';
            forEach(nodes, function (node) {
                fragment.appendChild(node);
            });
            return fragment;
        }
        function jqLiteParseHTML(html, context) {
            context = context || window.document;
            var parsed;
            if (parsed = SINGLE_TAG_REGEXP.exec(html)) {
                return [context.createElement(parsed[1])];
            }
            if (parsed = jqLiteBuildFragment(html, context)) {
                return parsed.childNodes;
            }
            return [];
        }
        function jqLiteWrapNode(node, wrapper) {
            var parent = node.parentNode;
            if (parent) {
                parent.replaceChild(wrapper, node);
            }
            wrapper.appendChild(node);
        }
        var jqLiteContains = window.Node.prototype.contains || function (arg) {
            return !!(this.compareDocumentPosition(arg) & 16);
        };
        function JQLite(element) {
            if (element instanceof JQLite) {
                return element;
            }
            var argIsString;
            if (isString(element)) {
                element = trim(element);
                argIsString = true;
            }
            if (!(this instanceof JQLite)) {
                if (argIsString && element.charAt(0) != '<') {
                    throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');
                }
                return new JQLite(element);
            }
            if (argIsString) {
                jqLiteAddNodes(this, jqLiteParseHTML(element));
            } else {
                jqLiteAddNodes(this, element);
            }
        }
        function jqLiteClone(element) {
            return element.cloneNode(true);
        }
        function jqLiteDealoc(element, onlyDescendants) {
            if (!onlyDescendants)
                jqLiteRemoveData(element);
            if (element.querySelectorAll) {
                var descendants = element.querySelectorAll('*');
                for (var i = 0, l = descendants.length; i < l; i++) {
                    jqLiteRemoveData(descendants[i]);
                }
            }
        }
        function jqLiteOff(element, type, fn, unsupported) {
            if (isDefined(unsupported))
                throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');
            var expandoStore = jqLiteExpandoStore(element);
            var events = expandoStore && expandoStore.events;
            var handle = expandoStore && expandoStore.handle;
            if (!handle)
                return;
            if (!type) {
                for (type in events) {
                    if (type !== '$destroy') {
                        removeEventListenerFn(element, type, handle);
                    }
                    delete events[type];
                }
            } else {
                var removeHandler = function (type) {
                    var listenerFns = events[type];
                    if (isDefined(fn)) {
                        arrayRemove(listenerFns || [], fn);
                    }
                    if (!(isDefined(fn) && listenerFns && listenerFns.length > 0)) {
                        removeEventListenerFn(element, type, handle);
                        delete events[type];
                    }
                };
                forEach(type.split(' '), function (type) {
                    removeHandler(type);
                    if (MOUSE_EVENT_MAP[type]) {
                        removeHandler(MOUSE_EVENT_MAP[type]);
                    }
                });
            }
        }
        function jqLiteRemoveData(element, name) {
            var expandoId = element.ng339;
            var expandoStore = expandoId && jqCache[expandoId];
            if (expandoStore) {
                if (name) {
                    delete expandoStore.data[name];
                    return;
                }
                if (expandoStore.handle) {
                    if (expandoStore.events.$destroy) {
                        expandoStore.handle({}, '$destroy');
                    }
                    jqLiteOff(element);
                }
                delete jqCache[expandoId];
                element.ng339 = undefined;
            }
        }
        function jqLiteExpandoStore(element, createIfNecessary) {
            var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
            if (createIfNecessary && !expandoStore) {
                element.ng339 = expandoId = jqNextId();
                expandoStore = jqCache[expandoId] = {
                    events: {},
                    data: {},
                    handle: undefined
                };
            }
            return expandoStore;
        }
        function jqLiteData(element, key, value) {
            if (jqLiteAcceptsData(element)) {
                var isSimpleSetter = isDefined(value);
                var isSimpleGetter = !isSimpleSetter && key && !isObject(key);
                var massGetter = !key;
                var expandoStore = jqLiteExpandoStore(element, !isSimpleGetter);
                var data = expandoStore && expandoStore.data;
                if (isSimpleSetter) {
                    data[key] = value;
                } else {
                    if (massGetter) {
                        return data;
                    } else {
                        if (isSimpleGetter) {
                            return data && data[key];
                        } else {
                            extend(data, key);
                        }
                    }
                }
            }
        }
        function jqLiteHasClass(element, selector) {
            if (!element.getAttribute)
                return false;
            return (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').indexOf(' ' + selector + ' ') > -1;
        }
        function jqLiteRemoveClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                forEach(cssClasses.split(' '), function (cssClass) {
                    element.setAttribute('class', trim((' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ').replace(' ' + trim(cssClass) + ' ', ' ')));
                });
            }
        }
        function jqLiteAddClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                var existingClasses = (' ' + (element.getAttribute('class') || '') + ' ').replace(/[\n\t]/g, ' ');
                forEach(cssClasses.split(' '), function (cssClass) {
                    cssClass = trim(cssClass);
                    if (existingClasses.indexOf(' ' + cssClass + ' ') === -1) {
                        existingClasses += cssClass + ' ';
                    }
                });
                element.setAttribute('class', trim(existingClasses));
            }
        }
        function jqLiteAddNodes(root, elements) {
            if (elements) {
                if (elements.nodeType) {
                    root[root.length++] = elements;
                } else {
                    var length = elements.length;
                    if (typeof length === 'number' && elements.window !== elements) {
                        if (length) {
                            for (var i = 0; i < length; i++) {
                                root[root.length++] = elements[i];
                            }
                        }
                    } else {
                        root[root.length++] = elements;
                    }
                }
            }
        }
        function jqLiteController(element, name) {
            return jqLiteInheritedData(element, '$' + (name || 'ngController') + 'Controller');
        }
        function jqLiteInheritedData(element, name, value) {
            if (element.nodeType == NODE_TYPE_DOCUMENT) {
                element = element.documentElement;
            }
            var names = isArray(name) ? name : [name];
            while (element) {
                for (var i = 0, ii = names.length; i < ii; i++) {
                    if (isDefined(value = jqLite.data(element, names[i])))
                        return value;
                }
                element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host;
            }
        }
        function jqLiteEmpty(element) {
            jqLiteDealoc(element, true);
            while (element.firstChild) {
                element.removeChild(element.firstChild);
            }
        }
        function jqLiteRemove(element, keepData) {
            if (!keepData)
                jqLiteDealoc(element);
            var parent = element.parentNode;
            if (parent)
                parent.removeChild(element);
        }
        function jqLiteDocumentLoaded(action, win) {
            win = win || window;
            if (win.document.readyState === 'complete') {
                win.setTimeout(action);
            } else {
                jqLite(win).on('load', action);
            }
        }
        var JQLitePrototype = JQLite.prototype = {
            ready: function (fn) {
                var fired = false;
                function trigger() {
                    if (fired)
                        return;
                    fired = true;
                    fn();
                }
                if (window.document.readyState === 'complete') {
                    window.setTimeout(trigger);
                } else {
                    this.on('DOMContentLoaded', trigger);
                    JQLite(window).on('load', trigger);
                }
            },
            toString: function () {
                var value = [];
                forEach(this, function (e) {
                    value.push('' + e);
                });
                return '[' + value.join(', ') + ']';
            },
            eq: function (index) {
                return index >= 0 ? jqLite(this[index]) : jqLite(this[this.length + index]);
            },
            length: 0,
            push: push,
            sort: [].sort,
            splice: [].splice
        };
        var BOOLEAN_ATTR = {};
        forEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function (value) {
            BOOLEAN_ATTR[lowercase(value)] = value;
        });
        var BOOLEAN_ELEMENTS = {};
        forEach('input,select,option,textarea,button,form,details'.split(','), function (value) {
            BOOLEAN_ELEMENTS[value] = true;
        });
        var ALIASED_ATTR = {
            'ngMinlength': 'minlength',
            'ngMaxlength': 'maxlength',
            'ngMin': 'min',
            'ngMax': 'max',
            'ngPattern': 'pattern'
        };
        function getBooleanAttrName(element, name) {
            var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
            return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr;
        }
        function getAliasedAttrName(name) {
            return ALIASED_ATTR[name];
        }
        forEach({
            data: jqLiteData,
            removeData: jqLiteRemoveData,
            hasData: jqLiteHasData,
            cleanData: jqLiteCleanData
        }, function (fn, name) {
            JQLite[name] = fn;
        });
        forEach({
            data: jqLiteData,
            inheritedData: jqLiteInheritedData,
            scope: function (element) {
                return jqLite.data(element, '$scope') || jqLiteInheritedData(element.parentNode || element, [
                    '$isolateScope',
                    '$scope'
                ]);
            },
            isolateScope: function (element) {
                return jqLite.data(element, '$isolateScope') || jqLite.data(element, '$isolateScopeNoTemplate');
            },
            controller: jqLiteController,
            injector: function (element) {
                return jqLiteInheritedData(element, '$injector');
            },
            removeAttr: function (element, name) {
                element.removeAttribute(name);
            },
            hasClass: jqLiteHasClass,
            css: function (element, name, value) {
                name = camelCase(name);
                if (isDefined(value)) {
                    element.style[name] = value;
                } else {
                    return element.style[name];
                }
            },
            attr: function (element, name, value) {
                var nodeType = element.nodeType;
                if (nodeType === NODE_TYPE_TEXT || nodeType === NODE_TYPE_ATTRIBUTE || nodeType === NODE_TYPE_COMMENT) {
                    return;
                }
                var lowercasedName = lowercase(name);
                if (BOOLEAN_ATTR[lowercasedName]) {
                    if (isDefined(value)) {
                        if (!!value) {
                            element[name] = true;
                            element.setAttribute(name, lowercasedName);
                        } else {
                            element[name] = false;
                            element.removeAttribute(lowercasedName);
                        }
                    } else {
                        return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : undefined;
                    }
                } else if (isDefined(value)) {
                    element.setAttribute(name, value);
                } else if (element.getAttribute) {
                    var ret = element.getAttribute(name, 2);
                    return ret === null ? undefined : ret;
                }
            },
            prop: function (element, name, value) {
                if (isDefined(value)) {
                    element[name] = value;
                } else {
                    return element[name];
                }
            },
            text: function () {
                getText.$dv = '';
                return getText;
                function getText(element, value) {
                    if (isUndefined(value)) {
                        var nodeType = element.nodeType;
                        return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : '';
                    }
                    element.textContent = value;
                }
            }(),
            val: function (element, value) {
                if (isUndefined(value)) {
                    if (element.multiple && nodeName_(element) === 'select') {
                        var result = [];
                        forEach(element.options, function (option) {
                            if (option.selected) {
                                result.push(option.value || option.text);
                            }
                        });
                        return result.length === 0 ? null : result;
                    }
                    return element.value;
                }
                element.value = value;
            },
            html: function (element, value) {
                if (isUndefined(value)) {
                    return element.innerHTML;
                }
                jqLiteDealoc(element, true);
                element.innerHTML = value;
            },
            empty: jqLiteEmpty
        }, function (fn, name) {
            JQLite.prototype[name] = function (arg1, arg2) {
                var i, key;
                var nodeCount = this.length;
                if (fn !== jqLiteEmpty && isUndefined(fn.length == 2 && (fn !== jqLiteHasClass && fn !== jqLiteController) ? arg1 : arg2)) {
                    if (isObject(arg1)) {
                        for (i = 0; i < nodeCount; i++) {
                            if (fn === jqLiteData) {
                                fn(this[i], arg1);
                            } else {
                                for (key in arg1) {
                                    fn(this[i], key, arg1[key]);
                                }
                            }
                        }
                        return this;
                    } else {
                        var value = fn.$dv;
                        var jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount;
                        for (var j = 0; j < jj; j++) {
                            var nodeValue = fn(this[j], arg1, arg2);
                            value = value ? value + nodeValue : nodeValue;
                        }
                        return value;
                    }
                } else {
                    for (i = 0; i < nodeCount; i++) {
                        fn(this[i], arg1, arg2);
                    }
                    return this;
                }
            };
        });
        function createEventHandler(element, events) {
            var eventHandler = function (event, type) {
                event.isDefaultPrevented = function () {
                    return event.defaultPrevented;
                };
                var eventFns = events[type || event.type];
                var eventFnsLength = eventFns ? eventFns.length : 0;
                if (!eventFnsLength)
                    return;
                if (isUndefined(event.immediatePropagationStopped)) {
                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                    event.stopImmediatePropagation = function () {
                        event.immediatePropagationStopped = true;
                        if (event.stopPropagation) {
                            event.stopPropagation();
                        }
                        if (originalStopImmediatePropagation) {
                            originalStopImmediatePropagation.call(event);
                        }
                    };
                }
                event.isImmediatePropagationStopped = function () {
                    return event.immediatePropagationStopped === true;
                };
                var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                if (eventFnsLength > 1) {
                    eventFns = shallowCopy(eventFns);
                }
                for (var i = 0; i < eventFnsLength; i++) {
                    if (!event.isImmediatePropagationStopped()) {
                        handlerWrapper(element, event, eventFns[i]);
                    }
                }
            };
            eventHandler.elem = element;
            return eventHandler;
        }
        function defaultHandlerWrapper(element, event, handler) {
            handler.call(element, event);
        }
        function specialMouseHandlerWrapper(target, event, handler) {
            var related = event.relatedTarget;
            if (!related || related !== target && !jqLiteContains.call(target, related)) {
                handler.call(target, event);
            }
        }
        forEach({
            removeData: jqLiteRemoveData,
            on: function jqLiteOn(element, type, fn, unsupported) {
                if (isDefined(unsupported))
                    throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');
                if (!jqLiteAcceptsData(element)) {
                    return;
                }
                var expandoStore = jqLiteExpandoStore(element, true);
                var events = expandoStore.events;
                var handle = expandoStore.handle;
                if (!handle) {
                    handle = expandoStore.handle = createEventHandler(element, events);
                }
                var types = type.indexOf(' ') >= 0 ? type.split(' ') : [type];
                var i = types.length;
                var addHandler = function (type, specialHandlerWrapper, noEventListener) {
                    var eventFns = events[type];
                    if (!eventFns) {
                        eventFns = events[type] = [];
                        eventFns.specialHandlerWrapper = specialHandlerWrapper;
                        if (type !== '$destroy' && !noEventListener) {
                            addEventListenerFn(element, type, handle);
                        }
                    }
                    eventFns.push(fn);
                };
                while (i--) {
                    type = types[i];
                    if (MOUSE_EVENT_MAP[type]) {
                        addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper);
                        addHandler(type, undefined, true);
                    } else {
                        addHandler(type);
                    }
                }
            },
            off: jqLiteOff,
            one: function (element, type, fn) {
                element = jqLite(element);
                element.on(type, function onFn() {
                    element.off(type, fn);
                    element.off(type, onFn);
                });
                element.on(type, fn);
            },
            replaceWith: function (element, replaceNode) {
                var index, parent = element.parentNode;
                jqLiteDealoc(element);
                forEach(new JQLite(replaceNode), function (node) {
                    if (index) {
                        parent.insertBefore(node, index.nextSibling);
                    } else {
                        parent.replaceChild(node, element);
                    }
                    index = node;
                });
            },
            children: function (element) {
                var children = [];
                forEach(element.childNodes, function (element) {
                    if (element.nodeType === NODE_TYPE_ELEMENT) {
                        children.push(element);
                    }
                });
                return children;
            },
            contents: function (element) {
                return element.contentDocument || element.childNodes || [];
            },
            append: function (element, node) {
                var nodeType = element.nodeType;
                if (nodeType !== NODE_TYPE_ELEMENT && nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT)
                    return;
                node = new JQLite(node);
                for (var i = 0, ii = node.length; i < ii; i++) {
                    var child = node[i];
                    element.appendChild(child);
                }
            },
            prepend: function (element, node) {
                if (element.nodeType === NODE_TYPE_ELEMENT) {
                    var index = element.firstChild;
                    forEach(new JQLite(node), function (child) {
                        element.insertBefore(child, index);
                    });
                }
            },
            wrap: function (element, wrapNode) {
                jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0]);
            },
            remove: jqLiteRemove,
            detach: function (element) {
                jqLiteRemove(element, true);
            },
            after: function (element, newElement) {
                var index = element, parent = element.parentNode;
                newElement = new JQLite(newElement);
                for (var i = 0, ii = newElement.length; i < ii; i++) {
                    var node = newElement[i];
                    parent.insertBefore(node, index.nextSibling);
                    index = node;
                }
            },
            addClass: jqLiteAddClass,
            removeClass: jqLiteRemoveClass,
            toggleClass: function (element, selector, condition) {
                if (selector) {
                    forEach(selector.split(' '), function (className) {
                        var classCondition = condition;
                        if (isUndefined(classCondition)) {
                            classCondition = !jqLiteHasClass(element, className);
                        }
                        (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className);
                    });
                }
            },
            parent: function (element) {
                var parent = element.parentNode;
                return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null;
            },
            next: function (element) {
                return element.nextElementSibling;
            },
            find: function (element, selector) {
                if (element.getElementsByTagName) {
                    return element.getElementsByTagName(selector);
                } else {
                    return [];
                }
            },
            clone: jqLiteClone,
            triggerHandler: function (element, event, extraParameters) {
                var dummyEvent, eventFnsCopy, handlerArgs;
                var eventName = event.type || event;
                var expandoStore = jqLiteExpandoStore(element);
                var events = expandoStore && expandoStore.events;
                var eventFns = events && events[eventName];
                if (eventFns) {
                    dummyEvent = {
                        preventDefault: function () {
                            this.defaultPrevented = true;
                        },
                        isDefaultPrevented: function () {
                            return this.defaultPrevented === true;
                        },
                        stopImmediatePropagation: function () {
                            this.immediatePropagationStopped = true;
                        },
                        isImmediatePropagationStopped: function () {
                            return this.immediatePropagationStopped === true;
                        },
                        stopPropagation: noop,
                        type: eventName,
                        target: element
                    };
                    if (event.type) {
                        dummyEvent = extend(dummyEvent, event);
                    }
                    eventFnsCopy = shallowCopy(eventFns);
                    handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent];
                    forEach(eventFnsCopy, function (fn) {
                        if (!dummyEvent.isImmediatePropagationStopped()) {
                            fn.apply(element, handlerArgs);
                        }
                    });
                }
            }
        }, function (fn, name) {
            JQLite.prototype[name] = function (arg1, arg2, arg3) {
                var value;
                for (var i = 0, ii = this.length; i < ii; i++) {
                    if (isUndefined(value)) {
                        value = fn(this[i], arg1, arg2, arg3);
                        if (isDefined(value)) {
                            value = jqLite(value);
                        }
                    } else {
                        jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                    }
                }
                return isDefined(value) ? value : this;
            };
            JQLite.prototype.bind = JQLite.prototype.on;
            JQLite.prototype.unbind = JQLite.prototype.off;
        });
        function $$jqLiteProvider() {
            this.$get = function $$jqLite() {
                return extend(JQLite, {
                    hasClass: function (node, classes) {
                        if (node.attr)
                            node = node[0];
                        return jqLiteHasClass(node, classes);
                    },
                    addClass: function (node, classes) {
                        if (node.attr)
                            node = node[0];
                        return jqLiteAddClass(node, classes);
                    },
                    removeClass: function (node, classes) {
                        if (node.attr)
                            node = node[0];
                        return jqLiteRemoveClass(node, classes);
                    }
                });
            };
        }
        function hashKey(obj, nextUidFn) {
            var key = obj && obj.$$hashKey;
            if (key) {
                if (typeof key === 'function') {
                    key = obj.$$hashKey();
                }
                return key;
            }
            var objType = typeof obj;
            if (objType == 'function' || objType == 'object' && obj !== null) {
                key = obj.$$hashKey = objType + ':' + (nextUidFn || nextUid)();
            } else {
                key = objType + ':' + obj;
            }
            return key;
        }
        function HashMap(array, isolatedUid) {
            if (isolatedUid) {
                var uid = 0;
                this.nextUid = function () {
                    return ++uid;
                };
            }
            forEach(array, this.put, this);
        }
        HashMap.prototype = {
            put: function (key, value) {
                this[hashKey(key, this.nextUid)] = value;
            },
            get: function (key) {
                return this[hashKey(key, this.nextUid)];
            },
            remove: function (key) {
                var value = this[key = hashKey(key, this.nextUid)];
                delete this[key];
                return value;
            }
        };
        var $$HashMapProvider = [function () {
                this.$get = [function () {
                        return HashMap;
                    }];
            }];
        var ARROW_ARG = /^([^\(]+?)=>/;
        var FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m;
        var FN_ARG_SPLIT = /,/;
        var FN_ARG = /^\s*(_?)(\S+?)\1\s*$/;
        var STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm;
        var $injectorMinErr = minErr('$injector');
        function extractArgs(fn) {
            var fnText = Function.prototype.toString.call(fn).replace(STRIP_COMMENTS, ''), args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
            return args;
        }
        function anonFn(fn) {
            var args = extractArgs(fn);
            if (args) {
                return 'function(' + (args[1] || '').replace(/[\s\r\n]+/, ' ') + ')';
            }
            return 'fn';
        }
        function annotate(fn, strictDi, name) {
            var $inject, argDecl, last;
            if (typeof fn === 'function') {
                if (!($inject = fn.$inject)) {
                    $inject = [];
                    if (fn.length) {
                        if (strictDi) {
                            if (!isString(name) || !name) {
                                name = fn.name || anonFn(fn);
                            }
                            throw $injectorMinErr('strictdi', '{0} is not using explicit annotation and cannot be invoked in strict mode', name);
                        }
                        argDecl = extractArgs(fn);
                        forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
                            arg.replace(FN_ARG, function (all, underscore, name) {
                                $inject.push(name);
                            });
                        });
                    }
                    fn.$inject = $inject;
                }
            } else if (isArray(fn)) {
                last = fn.length - 1;
                assertArgFn(fn[last], 'fn');
                $inject = fn.slice(0, last);
            } else {
                assertArgFn(fn, 'fn', true);
            }
            return $inject;
        }
        function createInjector(modulesToLoad, strictDi) {
            strictDi = strictDi === true;
            var INSTANTIATING = {}, providerSuffix = 'Provider', path = [], loadedModules = new HashMap([], true), providerCache = {
                    $provide: {
                        provider: supportObject(provider),
                        factory: supportObject(factory),
                        service: supportObject(service),
                        value: supportObject(value),
                        constant: supportObject(constant),
                        decorator: decorator
                    }
                }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function (serviceName, caller) {
                    if (angular.isString(caller)) {
                        path.push(caller);
                    }
                    throw $injectorMinErr('unpr', 'Unknown provider: {0}', path.join(' <- '));
                }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function (serviceName, caller) {
                    var provider = providerInjector.get(serviceName + providerSuffix, caller);
                    return instanceInjector.invoke(provider.$get, provider, undefined, serviceName);
                }), instanceInjector = protoInstanceInjector;
            providerCache['$injector' + providerSuffix] = { $get: valueFn(protoInstanceInjector) };
            var runBlocks = loadModules(modulesToLoad);
            instanceInjector = protoInstanceInjector.get('$injector');
            instanceInjector.strictDi = strictDi;
            forEach(runBlocks, function (fn) {
                if (fn)
                    instanceInjector.invoke(fn);
            });
            return instanceInjector;
            function supportObject(delegate) {
                return function (key, value) {
                    if (isObject(key)) {
                        forEach(key, reverseParams(delegate));
                    } else {
                        return delegate(key, value);
                    }
                };
            }
            function provider(name, provider_) {
                assertNotHasOwnProperty(name, 'service');
                if (isFunction(provider_) || isArray(provider_)) {
                    provider_ = providerInjector.instantiate(provider_);
                }
                if (!provider_.$get) {
                    throw $injectorMinErr('pget', 'Provider \'{0}\' must define $get factory method.', name);
                }
                return providerCache[name + providerSuffix] = provider_;
            }
            function enforceReturnValue(name, factory) {
                return function enforcedReturnValue() {
                    var result = instanceInjector.invoke(factory, this);
                    if (isUndefined(result)) {
                        throw $injectorMinErr('undef', 'Provider \'{0}\' must return a value from $get factory method.', name);
                    }
                    return result;
                };
            }
            function factory(name, factoryFn, enforce) {
                return provider(name, { $get: enforce !== false ? enforceReturnValue(name, factoryFn) : factoryFn });
            }
            function service(name, constructor) {
                return factory(name, [
                    '$injector',
                    function ($injector) {
                        return $injector.instantiate(constructor);
                    }
                ]);
            }
            function value(name, val) {
                return factory(name, valueFn(val), false);
            }
            function constant(name, value) {
                assertNotHasOwnProperty(name, 'constant');
                providerCache[name] = value;
                instanceCache[name] = value;
            }
            function decorator(serviceName, decorFn) {
                var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
                origProvider.$get = function () {
                    var origInstance = instanceInjector.invoke(orig$get, origProvider);
                    return instanceInjector.invoke(decorFn, null, { $delegate: origInstance });
                };
            }
            function loadModules(modulesToLoad) {
                assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), 'modulesToLoad', 'not an array');
                var runBlocks = [], moduleFn;
                forEach(modulesToLoad, function (module) {
                    if (loadedModules.get(module))
                        return;
                    loadedModules.put(module, true);
                    function runInvokeQueue(queue) {
                        var i, ii;
                        for (i = 0, ii = queue.length; i < ii; i++) {
                            var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);
                        }
                    }
                    try {
                        if (isString(module)) {
                            moduleFn = angularModule(module);
                            runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);
                            runInvokeQueue(moduleFn._invokeQueue);
                            runInvokeQueue(moduleFn._configBlocks);
                        } else if (isFunction(module)) {
                            runBlocks.push(providerInjector.invoke(module));
                        } else if (isArray(module)) {
                            runBlocks.push(providerInjector.invoke(module));
                        } else {
                            assertArgFn(module, 'module');
                        }
                    } catch (e) {
                        if (isArray(module)) {
                            module = module[module.length - 1];
                        }
                        if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {
                            e = e.message + '\n' + e.stack;
                        }
                        throw $injectorMinErr('modulerr', 'Failed to instantiate module {0} due to:\n{1}', module, e.stack || e.message || e);
                    }
                });
                return runBlocks;
            }
            function createInternalInjector(cache, factory) {
                function getService(serviceName, caller) {
                    if (cache.hasOwnProperty(serviceName)) {
                        if (cache[serviceName] === INSTANTIATING) {
                            throw $injectorMinErr('cdep', 'Circular dependency found: {0}', serviceName + ' <- ' + path.join(' <- '));
                        }
                        return cache[serviceName];
                    } else {
                        try {
                            path.unshift(serviceName);
                            cache[serviceName] = INSTANTIATING;
                            return cache[serviceName] = factory(serviceName, caller);
                        } catch (err) {
                            if (cache[serviceName] === INSTANTIATING) {
                                delete cache[serviceName];
                            }
                            throw err;
                        } finally {
                            path.shift();
                        }
                    }
                }
                function injectionArgs(fn, locals, serviceName) {
                    var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName);
                    for (var i = 0, length = $inject.length; i < length; i++) {
                        var key = $inject[i];
                        if (typeof key !== 'string') {
                            throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);
                        }
                        args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName));
                    }
                    return args;
                }
                function isClass(func) {
                    if (msie <= 11) {
                        return false;
                    }
                    return typeof func === 'function' && /^(?:class\s|constructor\()/.test(Function.prototype.toString.call(func));
                }
                function invoke(fn, self, locals, serviceName) {
                    if (typeof locals === 'string') {
                        serviceName = locals;
                        locals = null;
                    }
                    var args = injectionArgs(fn, locals, serviceName);
                    if (isArray(fn)) {
                        fn = fn[fn.length - 1];
                    }
                    if (!isClass(fn)) {
                        return fn.apply(self, args);
                    } else {
                        args.unshift(null);
                        return new (Function.prototype.bind.apply(fn, args))();
                    }
                }
                function instantiate(Type, locals, serviceName) {
                    var ctor = isArray(Type) ? Type[Type.length - 1] : Type;
                    var args = injectionArgs(Type, locals, serviceName);
                    args.unshift(null);
                    return new (Function.prototype.bind.apply(ctor, args))();
                }
                return {
                    invoke: invoke,
                    instantiate: instantiate,
                    get: getService,
                    annotate: createInjector.$$annotate,
                    has: function (name) {
                        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);
                    }
                };
            }
        }
        createInjector.$$annotate = annotate;
        function $AnchorScrollProvider() {
            var autoScrollingEnabled = true;
            this.disableAutoScrolling = function () {
                autoScrollingEnabled = false;
            };
            this.$get = [
                '$window',
                '$location',
                '$rootScope',
                function ($window, $location, $rootScope) {
                    var document = $window.document;
                    function getFirstAnchor(list) {
                        var result = null;
                        Array.prototype.some.call(list, function (element) {
                            if (nodeName_(element) === 'a') {
                                result = element;
                                return true;
                            }
                        });
                        return result;
                    }
                    function getYOffset() {
                        var offset = scroll.yOffset;
                        if (isFunction(offset)) {
                            offset = offset();
                        } else if (isElement(offset)) {
                            var elem = offset[0];
                            var style = $window.getComputedStyle(elem);
                            if (style.position !== 'fixed') {
                                offset = 0;
                            } else {
                                offset = elem.getBoundingClientRect().bottom;
                            }
                        } else if (!isNumber(offset)) {
                            offset = 0;
                        }
                        return offset;
                    }
                    function scrollTo(elem) {
                        if (elem) {
                            elem.scrollIntoView();
                            var offset = getYOffset();
                            if (offset) {
                                var elemTop = elem.getBoundingClientRect().top;
                                $window.scrollBy(0, elemTop - offset);
                            }
                        } else {
                            $window.scrollTo(0, 0);
                        }
                    }
                    function scroll(hash) {
                        hash = isString(hash) ? hash : $location.hash();
                        var elm;
                        if (!hash)
                            scrollTo(null);
                        else if (elm = document.getElementById(hash))
                            scrollTo(elm);
                        else if (elm = getFirstAnchor(document.getElementsByName(hash)))
                            scrollTo(elm);
                        else if (hash === 'top')
                            scrollTo(null);
                    }
                    if (autoScrollingEnabled) {
                        $rootScope.$watch(function autoScrollWatch() {
                            return $location.hash();
                        }, function autoScrollWatchAction(newVal, oldVal) {
                            if (newVal === oldVal && newVal === '')
                                return;
                            jqLiteDocumentLoaded(function () {
                                $rootScope.$evalAsync(scroll);
                            });
                        });
                    }
                    return scroll;
                }
            ];
        }
        var $animateMinErr = minErr('$animate');
        var ELEMENT_NODE = 1;
        var NG_ANIMATE_CLASSNAME = 'ng-animate';
        function mergeClasses(a, b) {
            if (!a && !b)
                return '';
            if (!a)
                return b;
            if (!b)
                return a;
            if (isArray(a))
                a = a.join(' ');
            if (isArray(b))
                b = b.join(' ');
            return a + ' ' + b;
        }
        function extractElementNode(element) {
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType === ELEMENT_NODE) {
                    return elm;
                }
            }
        }
        function splitClasses(classes) {
            if (isString(classes)) {
                classes = classes.split(' ');
            }
            var obj = createMap();
            forEach(classes, function (klass) {
                if (klass.length) {
                    obj[klass] = true;
                }
            });
            return obj;
        }
        function prepareAnimateOptions(options) {
            return isObject(options) ? options : {};
        }
        var $$CoreAnimateJsProvider = function () {
            this.$get = noop;
        };
        var $$CoreAnimateQueueProvider = function () {
            var postDigestQueue = new HashMap();
            var postDigestElements = [];
            this.$get = [
                '$$AnimateRunner',
                '$rootScope',
                function ($$AnimateRunner, $rootScope) {
                    return {
                        enabled: noop,
                        on: noop,
                        off: noop,
                        pin: noop,
                        push: function (element, event, options, domOperation) {
                            domOperation && domOperation();
                            options = options || {};
                            options.from && element.css(options.from);
                            options.to && element.css(options.to);
                            if (options.addClass || options.removeClass) {
                                addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                            }
                            var runner = new $$AnimateRunner();
                            runner.complete();
                            return runner;
                        }
                    };
                    function updateData(data, classes, value) {
                        var changed = false;
                        if (classes) {
                            classes = isString(classes) ? classes.split(' ') : isArray(classes) ? classes : [];
                            forEach(classes, function (className) {
                                if (className) {
                                    changed = true;
                                    data[className] = value;
                                }
                            });
                        }
                        return changed;
                    }
                    function handleCSSClassChanges() {
                        forEach(postDigestElements, function (element) {
                            var data = postDigestQueue.get(element);
                            if (data) {
                                var existing = splitClasses(element.attr('class'));
                                var toAdd = '';
                                var toRemove = '';
                                forEach(data, function (status, className) {
                                    var hasClass = !!existing[className];
                                    if (status !== hasClass) {
                                        if (status) {
                                            toAdd += (toAdd.length ? ' ' : '') + className;
                                        } else {
                                            toRemove += (toRemove.length ? ' ' : '') + className;
                                        }
                                    }
                                });
                                forEach(element, function (elm) {
                                    toAdd && jqLiteAddClass(elm, toAdd);
                                    toRemove && jqLiteRemoveClass(elm, toRemove);
                                });
                                postDigestQueue.remove(element);
                            }
                        });
                        postDigestElements.length = 0;
                    }
                    function addRemoveClassesPostDigest(element, add, remove) {
                        var data = postDigestQueue.get(element) || {};
                        var classesAdded = updateData(data, add, true);
                        var classesRemoved = updateData(data, remove, false);
                        if (classesAdded || classesRemoved) {
                            postDigestQueue.put(element, data);
                            postDigestElements.push(element);
                            if (postDigestElements.length === 1) {
                                $rootScope.$$postDigest(handleCSSClassChanges);
                            }
                        }
                    }
                }
            ];
        };
        var $AnimateProvider = [
            '$provide',
            function ($provide) {
                var provider = this;
                this.$$registeredAnimations = Object.create(null);
                this.register = function (name, factory) {
                    if (name && name.charAt(0) !== '.') {
                        throw $animateMinErr('notcsel', 'Expecting class selector starting with \'.\' got \'{0}\'.', name);
                    }
                    var key = name + '-animation';
                    provider.$$registeredAnimations[name.substr(1)] = key;
                    $provide.factory(key, factory);
                };
                this.classNameFilter = function (expression) {
                    if (arguments.length === 1) {
                        this.$$classNameFilter = expression instanceof RegExp ? expression : null;
                        if (this.$$classNameFilter) {
                            var reservedRegex = new RegExp('(\\s+|\\/)' + NG_ANIMATE_CLASSNAME + '(\\s+|\\/)');
                            if (reservedRegex.test(this.$$classNameFilter.toString())) {
                                throw $animateMinErr('nongcls', '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME);
                            }
                        }
                    }
                    return this.$$classNameFilter;
                };
                this.$get = [
                    '$$animateQueue',
                    function ($$animateQueue) {
                        function domInsert(element, parentElement, afterElement) {
                            if (afterElement) {
                                var afterNode = extractElementNode(afterElement);
                                if (afterNode && !afterNode.parentNode && !afterNode.previousElementSibling) {
                                    afterElement = null;
                                }
                            }
                            afterElement ? afterElement.after(element) : parentElement.prepend(element);
                        }
                        return {
                            on: $$animateQueue.on,
                            off: $$animateQueue.off,
                            pin: $$animateQueue.pin,
                            enabled: $$animateQueue.enabled,
                            cancel: function (runner) {
                                runner.end && runner.end();
                            },
                            enter: function (element, parent, after, options) {
                                parent = parent && jqLite(parent);
                                after = after && jqLite(after);
                                parent = parent || after.parent();
                                domInsert(element, parent, after);
                                return $$animateQueue.push(element, 'enter', prepareAnimateOptions(options));
                            },
                            move: function (element, parent, after, options) {
                                parent = parent && jqLite(parent);
                                after = after && jqLite(after);
                                parent = parent || after.parent();
                                domInsert(element, parent, after);
                                return $$animateQueue.push(element, 'move', prepareAnimateOptions(options));
                            },
                            leave: function (element, options) {
                                return $$animateQueue.push(element, 'leave', prepareAnimateOptions(options), function () {
                                    element.remove();
                                });
                            },
                            addClass: function (element, className, options) {
                                options = prepareAnimateOptions(options);
                                options.addClass = mergeClasses(options.addclass, className);
                                return $$animateQueue.push(element, 'addClass', options);
                            },
                            removeClass: function (element, className, options) {
                                options = prepareAnimateOptions(options);
                                options.removeClass = mergeClasses(options.removeClass, className);
                                return $$animateQueue.push(element, 'removeClass', options);
                            },
                            setClass: function (element, add, remove, options) {
                                options = prepareAnimateOptions(options);
                                options.addClass = mergeClasses(options.addClass, add);
                                options.removeClass = mergeClasses(options.removeClass, remove);
                                return $$animateQueue.push(element, 'setClass', options);
                            },
                            animate: function (element, from, to, className, options) {
                                options = prepareAnimateOptions(options);
                                options.from = options.from ? extend(options.from, from) : from;
                                options.to = options.to ? extend(options.to, to) : to;
                                className = className || 'ng-inline-animate';
                                options.tempClasses = mergeClasses(options.tempClasses, className);
                                return $$animateQueue.push(element, 'animate', options);
                            }
                        };
                    }
                ];
            }
        ];
        var $$AnimateAsyncRunFactoryProvider = function () {
            this.$get = [
                '$$rAF',
                function ($$rAF) {
                    var waitQueue = [];
                    function waitForTick(fn) {
                        waitQueue.push(fn);
                        if (waitQueue.length > 1)
                            return;
                        $$rAF(function () {
                            for (var i = 0; i < waitQueue.length; i++) {
                                waitQueue[i]();
                            }
                            waitQueue = [];
                        });
                    }
                    return function () {
                        var passed = false;
                        waitForTick(function () {
                            passed = true;
                        });
                        return function (callback) {
                            passed ? callback() : waitForTick(callback);
                        };
                    };
                }
            ];
        };
        var $$AnimateRunnerFactoryProvider = function () {
            this.$get = [
                '$q',
                '$sniffer',
                '$$animateAsyncRun',
                '$document',
                '$timeout',
                function ($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
                    var INITIAL_STATE = 0;
                    var DONE_PENDING_STATE = 1;
                    var DONE_COMPLETE_STATE = 2;
                    AnimateRunner.chain = function (chain, callback) {
                        var index = 0;
                        next();
                        function next() {
                            if (index === chain.length) {
                                callback(true);
                                return;
                            }
                            chain[index](function (response) {
                                if (response === false) {
                                    callback(false);
                                    return;
                                }
                                index++;
                                next();
                            });
                        }
                    };
                    AnimateRunner.all = function (runners, callback) {
                        var count = 0;
                        var status = true;
                        forEach(runners, function (runner) {
                            runner.done(onProgress);
                        });
                        function onProgress(response) {
                            status = status && response;
                            if (++count === runners.length) {
                                callback(status);
                            }
                        }
                    };
                    function AnimateRunner(host) {
                        this.setHost(host);
                        var rafTick = $$animateAsyncRun();
                        var timeoutTick = function (fn) {
                            $timeout(fn, 0, false);
                        };
                        this._doneCallbacks = [];
                        this._tick = function (fn) {
                            var doc = $document[0];
                            if (doc && doc.hidden) {
                                timeoutTick(fn);
                            } else {
                                rafTick(fn);
                            }
                        };
                        this._state = 0;
                    }
                    AnimateRunner.prototype = {
                        setHost: function (host) {
                            this.host = host || {};
                        },
                        done: function (fn) {
                            if (this._state === DONE_COMPLETE_STATE) {
                                fn();
                            } else {
                                this._doneCallbacks.push(fn);
                            }
                        },
                        progress: noop,
                        getPromise: function () {
                            if (!this.promise) {
                                var self = this;
                                this.promise = $q(function (resolve, reject) {
                                    self.done(function (status) {
                                        status === false ? reject() : resolve();
                                    });
                                });
                            }
                            return this.promise;
                        },
                        then: function (resolveHandler, rejectHandler) {
                            return this.getPromise().then(resolveHandler, rejectHandler);
                        },
                        'catch': function (handler) {
                            return this.getPromise()['catch'](handler);
                        },
                        'finally': function (handler) {
                            return this.getPromise()['finally'](handler);
                        },
                        pause: function () {
                            if (this.host.pause) {
                                this.host.pause();
                            }
                        },
                        resume: function () {
                            if (this.host.resume) {
                                this.host.resume();
                            }
                        },
                        end: function () {
                            if (this.host.end) {
                                this.host.end();
                            }
                            this._resolve(true);
                        },
                        cancel: function () {
                            if (this.host.cancel) {
                                this.host.cancel();
                            }
                            this._resolve(false);
                        },
                        complete: function (response) {
                            var self = this;
                            if (self._state === INITIAL_STATE) {
                                self._state = DONE_PENDING_STATE;
                                self._tick(function () {
                                    self._resolve(response);
                                });
                            }
                        },
                        _resolve: function (response) {
                            if (this._state !== DONE_COMPLETE_STATE) {
                                forEach(this._doneCallbacks, function (fn) {
                                    fn(response);
                                });
                                this._doneCallbacks.length = 0;
                                this._state = DONE_COMPLETE_STATE;
                            }
                        }
                    };
                    return AnimateRunner;
                }
            ];
        };
        var $CoreAnimateCssProvider = function () {
            this.$get = [
                '$$rAF',
                '$q',
                '$$AnimateRunner',
                function ($$rAF, $q, $$AnimateRunner) {
                    return function (element, initialOptions) {
                        var options = initialOptions || {};
                        if (!options.$$prepared) {
                            options = copy(options);
                        }
                        if (options.cleanupStyles) {
                            options.from = options.to = null;
                        }
                        if (options.from) {
                            element.css(options.from);
                            options.from = null;
                        }
                        var closed, runner = new $$AnimateRunner();
                        return {
                            start: run,
                            end: run
                        };
                        function run() {
                            $$rAF(function () {
                                applyAnimationContents();
                                if (!closed) {
                                    runner.complete();
                                }
                                closed = true;
                            });
                            return runner;
                        }
                        function applyAnimationContents() {
                            if (options.addClass) {
                                element.addClass(options.addClass);
                                options.addClass = null;
                            }
                            if (options.removeClass) {
                                element.removeClass(options.removeClass);
                                options.removeClass = null;
                            }
                            if (options.to) {
                                element.css(options.to);
                                options.to = null;
                            }
                        }
                    };
                }
            ];
        };
        function Browser(window, document, $log, $sniffer) {
            var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
            self.isMock = false;
            var outstandingRequestCount = 0;
            var outstandingRequestCallbacks = [];
            self.$$completeOutstandingRequest = completeOutstandingRequest;
            self.$$incOutstandingRequestCount = function () {
                outstandingRequestCount++;
            };
            function completeOutstandingRequest(fn) {
                try {
                    fn.apply(null, sliceArgs(arguments, 1));
                } finally {
                    outstandingRequestCount--;
                    if (outstandingRequestCount === 0) {
                        while (outstandingRequestCallbacks.length) {
                            try {
                                outstandingRequestCallbacks.pop()();
                            } catch (e) {
                                $log.error(e);
                            }
                        }
                    }
                }
            }
            function getHash(url) {
                var index = url.indexOf('#');
                return index === -1 ? '' : url.substr(index);
            }
            self.notifyWhenNoOutstandingRequests = function (callback) {
                if (outstandingRequestCount === 0) {
                    callback();
                } else {
                    outstandingRequestCallbacks.push(callback);
                }
            };
            var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find('base'), pendingLocation = null, getCurrentState = !$sniffer.history ? noop : function getCurrentState() {
                    try {
                        return history.state;
                    } catch (e) {
                    }
                };
            cacheState();
            lastHistoryState = cachedState;
            self.url = function (url, replace, state) {
                if (isUndefined(state)) {
                    state = null;
                }
                if (location !== window.location)
                    location = window.location;
                if (history !== window.history)
                    history = window.history;
                if (url) {
                    var sameState = lastHistoryState === state;
                    if (lastBrowserUrl === url && (!$sniffer.history || sameState)) {
                        return self;
                    }
                    var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                    lastBrowserUrl = url;
                    lastHistoryState = state;
                    if ($sniffer.history && (!sameBase || !sameState)) {
                        history[replace ? 'replaceState' : 'pushState'](state, '', url);
                        cacheState();
                        lastHistoryState = cachedState;
                    } else {
                        if (!sameBase || pendingLocation) {
                            pendingLocation = url;
                        }
                        if (replace) {
                            location.replace(url);
                        } else if (!sameBase) {
                            location.href = url;
                        } else {
                            location.hash = getHash(url);
                        }
                        if (location.href !== url) {
                            pendingLocation = url;
                        }
                    }
                    return self;
                } else {
                    return pendingLocation || location.href.replace(/%27/g, '\'');
                }
            };
            self.state = function () {
                return cachedState;
            };
            var urlChangeListeners = [], urlChangeInit = false;
            function cacheStateAndFireUrlChange() {
                pendingLocation = null;
                cacheState();
                fireUrlChange();
            }
            var lastCachedState = null;
            function cacheState() {
                cachedState = getCurrentState();
                cachedState = isUndefined(cachedState) ? null : cachedState;
                if (equals(cachedState, lastCachedState)) {
                    cachedState = lastCachedState;
                }
                lastCachedState = cachedState;
            }
            function fireUrlChange() {
                if (lastBrowserUrl === self.url() && lastHistoryState === cachedState) {
                    return;
                }
                lastBrowserUrl = self.url();
                lastHistoryState = cachedState;
                forEach(urlChangeListeners, function (listener) {
                    listener(self.url(), cachedState);
                });
            }
            self.onUrlChange = function (callback) {
                if (!urlChangeInit) {
                    if ($sniffer.history)
                        jqLite(window).on('popstate', cacheStateAndFireUrlChange);
                    jqLite(window).on('hashchange', cacheStateAndFireUrlChange);
                    urlChangeInit = true;
                }
                urlChangeListeners.push(callback);
                return callback;
            };
            self.$$applicationDestroyed = function () {
                jqLite(window).off('hashchange popstate', cacheStateAndFireUrlChange);
            };
            self.$$checkUrlChange = fireUrlChange;
            self.baseHref = function () {
                var href = baseElement.attr('href');
                return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, '') : '';
            };
            self.defer = function (fn, delay) {
                var timeoutId;
                outstandingRequestCount++;
                timeoutId = setTimeout(function () {
                    delete pendingDeferIds[timeoutId];
                    completeOutstandingRequest(fn);
                }, delay || 0);
                pendingDeferIds[timeoutId] = true;
                return timeoutId;
            };
            self.defer.cancel = function (deferId) {
                if (pendingDeferIds[deferId]) {
                    delete pendingDeferIds[deferId];
                    clearTimeout(deferId);
                    completeOutstandingRequest(noop);
                    return true;
                }
                return false;
            };
        }
        function $BrowserProvider() {
            this.$get = [
                '$window',
                '$log',
                '$sniffer',
                '$document',
                function ($window, $log, $sniffer, $document) {
                    return new Browser($window, $document, $log, $sniffer);
                }
            ];
        }
        function $CacheFactoryProvider() {
            this.$get = function () {
                var caches = {};
                function cacheFactory(cacheId, options) {
                    if (cacheId in caches) {
                        throw minErr('$cacheFactory')('iid', 'CacheId \'{0}\' is already taken!', cacheId);
                    }
                    var size = 0, stats = extend({}, options, { id: cacheId }), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                    return caches[cacheId] = {
                        put: function (key, value) {
                            if (isUndefined(value))
                                return;
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key] || (lruHash[key] = { key: key });
                                refresh(lruEntry);
                            }
                            if (!(key in data))
                                size++;
                            data[key] = value;
                            if (size > capacity) {
                                this.remove(staleEnd.key);
                            }
                            return value;
                        },
                        get: function (key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry)
                                    return;
                                refresh(lruEntry);
                            }
                            return data[key];
                        },
                        remove: function (key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry)
                                    return;
                                if (lruEntry == freshEnd)
                                    freshEnd = lruEntry.p;
                                if (lruEntry == staleEnd)
                                    staleEnd = lruEntry.n;
                                link(lruEntry.n, lruEntry.p);
                                delete lruHash[key];
                            }
                            if (!(key in data))
                                return;
                            delete data[key];
                            size--;
                        },
                        removeAll: function () {
                            data = createMap();
                            size = 0;
                            lruHash = createMap();
                            freshEnd = staleEnd = null;
                        },
                        destroy: function () {
                            data = null;
                            stats = null;
                            lruHash = null;
                            delete caches[cacheId];
                        },
                        info: function () {
                            return extend({}, stats, { size: size });
                        }
                    };
                    function refresh(entry) {
                        if (entry != freshEnd) {
                            if (!staleEnd) {
                                staleEnd = entry;
                            } else if (staleEnd == entry) {
                                staleEnd = entry.n;
                            }
                            link(entry.n, entry.p);
                            link(entry, freshEnd);
                            freshEnd = entry;
                            freshEnd.n = null;
                        }
                    }
                    function link(nextEntry, prevEntry) {
                        if (nextEntry != prevEntry) {
                            if (nextEntry)
                                nextEntry.p = prevEntry;
                            if (prevEntry)
                                prevEntry.n = nextEntry;
                        }
                    }
                }
                cacheFactory.info = function () {
                    var info = {};
                    forEach(caches, function (cache, cacheId) {
                        info[cacheId] = cache.info();
                    });
                    return info;
                };
                cacheFactory.get = function (cacheId) {
                    return caches[cacheId];
                };
                return cacheFactory;
            };
        }
        function $TemplateCacheProvider() {
            this.$get = [
                '$cacheFactory',
                function ($cacheFactory) {
                    return $cacheFactory('templates');
                }
            ];
        }
        var $compileMinErr = minErr('$compile');
        function UNINITIALIZED_VALUE() {
        }
        var _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE();
        $CompileProvider.$inject = [
            '$provide',
            '$$sanitizeUriProvider'
        ];
        function $CompileProvider($provide, $$sanitizeUriProvider) {
            var hasDirectives = {}, Suffix = 'Directive', COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap('ngSrc,ngSrcset,src,srcset'), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/;
            var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/;
            var bindingCache = createMap();
            function parseIsolateBindings(scope, directiveName, isController) {
                var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/;
                var bindings = createMap();
                forEach(scope, function (definition, scopeName) {
                    if (definition in bindingCache) {
                        bindings[scopeName] = bindingCache[definition];
                        return;
                    }
                    var match = definition.match(LOCAL_REGEXP);
                    if (!match) {
                        throw $compileMinErr('iscp', 'Invalid {3} for directive \'{0}\'.' + ' Definition: {... {1}: \'{2}\' ...}', directiveName, scopeName, definition, isController ? 'controller bindings definition' : 'isolate scope definition');
                    }
                    bindings[scopeName] = {
                        mode: match[1][0],
                        collection: match[2] === '*',
                        optional: match[3] === '?',
                        attrName: match[4] || scopeName
                    };
                    if (match[4]) {
                        bindingCache[definition] = bindings[scopeName];
                    }
                });
                return bindings;
            }
            function parseDirectiveBindings(directive, directiveName) {
                var bindings = {
                    isolateScope: null,
                    bindToController: null
                };
                if (isObject(directive.scope)) {
                    if (directive.bindToController === true) {
                        bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, true);
                        bindings.isolateScope = {};
                    } else {
                        bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, false);
                    }
                }
                if (isObject(directive.bindToController)) {
                    bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, true);
                }
                if (isObject(bindings.bindToController)) {
                    var controller = directive.controller;
                    var controllerAs = directive.controllerAs;
                    if (!controller) {
                        throw $compileMinErr('noctrl', 'Cannot bind to controller without directive \'{0}\'s controller.', directiveName);
                    } else if (!identifierForController(controller, controllerAs)) {
                        throw $compileMinErr('noident', 'Cannot bind to controller without identifier for directive \'{0}\'.', directiveName);
                    }
                }
                return bindings;
            }
            function assertValidDirectiveName(name) {
                var letter = name.charAt(0);
                if (!letter || letter !== lowercase(letter)) {
                    throw $compileMinErr('baddir', 'Directive/Component name \'{0}\' is invalid. The first character must be a lowercase letter', name);
                }
                if (name !== name.trim()) {
                    throw $compileMinErr('baddir', 'Directive/Component name \'{0}\' is invalid. The name should not contain leading or trailing whitespaces', name);
                }
            }
            this.directive = function registerDirective(name, directiveFactory) {
                assertNotHasOwnProperty(name, 'directive');
                if (isString(name)) {
                    assertValidDirectiveName(name);
                    assertArg(directiveFactory, 'directiveFactory');
                    if (!hasDirectives.hasOwnProperty(name)) {
                        hasDirectives[name] = [];
                        $provide.factory(name + Suffix, [
                            '$injector',
                            '$exceptionHandler',
                            function ($injector, $exceptionHandler) {
                                var directives = [];
                                forEach(hasDirectives[name], function (directiveFactory, index) {
                                    try {
                                        var directive = $injector.invoke(directiveFactory);
                                        if (isFunction(directive)) {
                                            directive = { compile: valueFn(directive) };
                                        } else if (!directive.compile && directive.link) {
                                            directive.compile = valueFn(directive.link);
                                        }
                                        directive.priority = directive.priority || 0;
                                        directive.index = index;
                                        directive.name = directive.name || name;
                                        directive.require = directive.require || directive.controller && directive.name;
                                        directive.restrict = directive.restrict || 'EA';
                                        directive.$$moduleName = directiveFactory.$$moduleName;
                                        directives.push(directive);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                });
                                return directives;
                            }
                        ]);
                    }
                    hasDirectives[name].push(directiveFactory);
                } else {
                    forEach(name, reverseParams(registerDirective));
                }
                return this;
            };
            this.component = function registerComponent(name, options) {
                var controller = options.controller || function () {
                };
                function factory($injector) {
                    function makeInjectable(fn) {
                        if (isFunction(fn) || isArray(fn)) {
                            return function (tElement, tAttrs) {
                                return $injector.invoke(fn, this, {
                                    $element: tElement,
                                    $attrs: tAttrs
                                });
                            };
                        } else {
                            return fn;
                        }
                    }
                    var template = !options.template && !options.templateUrl ? '' : options.template;
                    var ddo = {
                        controller: controller,
                        controllerAs: identifierForController(options.controller) || options.controllerAs || '$ctrl',
                        template: makeInjectable(template),
                        templateUrl: makeInjectable(options.templateUrl),
                        transclude: options.transclude,
                        scope: {},
                        bindToController: options.bindings || {},
                        restrict: 'E',
                        require: options.require
                    };
                    forEach(options, function (val, key) {
                        if (key.charAt(0) === '$')
                            ddo[key] = val;
                    });
                    return ddo;
                }
                forEach(options, function (val, key) {
                    if (key.charAt(0) === '$') {
                        factory[key] = val;
                        if (isFunction(controller))
                            controller[key] = val;
                    }
                });
                factory.$inject = ['$injector'];
                return this.directive(name, factory);
            };
            this.aHrefSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    $$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp);
                    return this;
                } else {
                    return $$sanitizeUriProvider.aHrefSanitizationWhitelist();
                }
            };
            this.imgSrcSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    $$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp);
                    return this;
                } else {
                    return $$sanitizeUriProvider.imgSrcSanitizationWhitelist();
                }
            };
            var debugInfoEnabled = true;
            this.debugInfoEnabled = function (enabled) {
                if (isDefined(enabled)) {
                    debugInfoEnabled = enabled;
                    return this;
                }
                return debugInfoEnabled;
            };
            var TTL = 10;
            this.onChangesTtl = function (value) {
                if (arguments.length) {
                    TTL = value;
                    return this;
                }
                return TTL;
            };
            this.$get = [
                '$injector',
                '$interpolate',
                '$exceptionHandler',
                '$templateRequest',
                '$parse',
                '$controller',
                '$rootScope',
                '$sce',
                '$animate',
                '$$sanitizeUri',
                function ($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
                    var SIMPLE_ATTR_NAME = /^\w/;
                    var specialAttrHolder = window.document.createElement('div');
                    var onChangesTtl = TTL;
                    var onChangesQueue;
                    function flushOnChangesQueue() {
                        try {
                            if (!--onChangesTtl) {
                                onChangesQueue = undefined;
                                throw $compileMinErr('infchng', '{0} $onChanges() iterations reached. Aborting!\n', TTL);
                            }
                            $rootScope.$apply(function () {
                                for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) {
                                    onChangesQueue[i]();
                                }
                                onChangesQueue = undefined;
                            });
                        } finally {
                            onChangesTtl++;
                        }
                    }
                    function Attributes(element, attributesToCopy) {
                        if (attributesToCopy) {
                            var keys = Object.keys(attributesToCopy);
                            var i, l, key;
                            for (i = 0, l = keys.length; i < l; i++) {
                                key = keys[i];
                                this[key] = attributesToCopy[key];
                            }
                        } else {
                            this.$attr = {};
                        }
                        this.$$element = element;
                    }
                    Attributes.prototype = {
                        $normalize: directiveNormalize,
                        $addClass: function (classVal) {
                            if (classVal && classVal.length > 0) {
                                $animate.addClass(this.$$element, classVal);
                            }
                        },
                        $removeClass: function (classVal) {
                            if (classVal && classVal.length > 0) {
                                $animate.removeClass(this.$$element, classVal);
                            }
                        },
                        $updateClass: function (newClasses, oldClasses) {
                            var toAdd = tokenDifference(newClasses, oldClasses);
                            if (toAdd && toAdd.length) {
                                $animate.addClass(this.$$element, toAdd);
                            }
                            var toRemove = tokenDifference(oldClasses, newClasses);
                            if (toRemove && toRemove.length) {
                                $animate.removeClass(this.$$element, toRemove);
                            }
                        },
                        $set: function (key, value, writeAttr, attrName) {
                            var node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key, nodeName;
                            if (booleanKey) {
                                this.$$element.prop(key, value);
                                attrName = booleanKey;
                            } else if (aliasedKey) {
                                this[aliasedKey] = value;
                                observer = aliasedKey;
                            }
                            this[key] = value;
                            if (attrName) {
                                this.$attr[key] = attrName;
                            } else {
                                attrName = this.$attr[key];
                                if (!attrName) {
                                    this.$attr[key] = attrName = snake_case(key, '-');
                                }
                            }
                            nodeName = nodeName_(this.$$element);
                            if (nodeName === 'a' && (key === 'href' || key === 'xlinkHref') || nodeName === 'img' && key === 'src') {
                                this[key] = value = $$sanitizeUri(value, key === 'src');
                            } else if (nodeName === 'img' && key === 'srcset') {
                                var result = '';
                                var trimmedSrcset = trim(value);
                                var srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/;
                                var pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/;
                                var rawUris = trimmedSrcset.split(pattern);
                                var nbrUrisWith2parts = Math.floor(rawUris.length / 2);
                                for (var i = 0; i < nbrUrisWith2parts; i++) {
                                    var innerIdx = i * 2;
                                    result += $$sanitizeUri(trim(rawUris[innerIdx]), true);
                                    result += ' ' + trim(rawUris[innerIdx + 1]);
                                }
                                var lastTuple = trim(rawUris[i * 2]).split(/\s/);
                                result += $$sanitizeUri(trim(lastTuple[0]), true);
                                if (lastTuple.length === 2) {
                                    result += ' ' + trim(lastTuple[1]);
                                }
                                this[key] = value = result;
                            }
                            if (writeAttr !== false) {
                                if (value === null || isUndefined(value)) {
                                    this.$$element.removeAttr(attrName);
                                } else {
                                    if (SIMPLE_ATTR_NAME.test(attrName)) {
                                        this.$$element.attr(attrName, value);
                                    } else {
                                        setSpecialAttr(this.$$element[0], attrName, value);
                                    }
                                }
                            }
                            var $$observers = this.$$observers;
                            $$observers && forEach($$observers[observer], function (fn) {
                                try {
                                    fn(value);
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            });
                        },
                        $observe: function (key, fn) {
                            var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                            listeners.push(fn);
                            $rootScope.$evalAsync(function () {
                                if (!listeners.$$inter && attrs.hasOwnProperty(key) && !isUndefined(attrs[key])) {
                                    fn(attrs[key]);
                                }
                            });
                            return function () {
                                arrayRemove(listeners, fn);
                            };
                        }
                    };
                    function setSpecialAttr(element, attrName, value) {
                        specialAttrHolder.innerHTML = '<span ' + attrName + '>';
                        var attributes = specialAttrHolder.firstChild.attributes;
                        var attribute = attributes[0];
                        attributes.removeNamedItem(attribute.name);
                        attribute.value = value;
                        element.attributes.setNamedItem(attribute);
                    }
                    function safeAddClass($element, className) {
                        try {
                            $element.addClass(className);
                        } catch (e) {
                        }
                    }
                    var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = startSymbol == '{{' && endSymbol == '}}' ? identity : function denormalizeTemplate(template) {
                            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol);
                        }, NG_ATTR_BINDING = /^ngAttr[A-Z]/;
                    var MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
                    compile.$$addBindingInfo = debugInfoEnabled ? function $$addBindingInfo($element, binding) {
                        var bindings = $element.data('$binding') || [];
                        if (isArray(binding)) {
                            bindings = bindings.concat(binding);
                        } else {
                            bindings.push(binding);
                        }
                        $element.data('$binding', bindings);
                    } : noop;
                    compile.$$addBindingClass = debugInfoEnabled ? function $$addBindingClass($element) {
                        safeAddClass($element, 'ng-binding');
                    } : noop;
                    compile.$$addScopeInfo = debugInfoEnabled ? function $$addScopeInfo($element, scope, isolated, noTemplate) {
                        var dataName = isolated ? noTemplate ? '$isolateScopeNoTemplate' : '$isolateScope' : '$scope';
                        $element.data(dataName, scope);
                    } : noop;
                    compile.$$addScopeClass = debugInfoEnabled ? function $$addScopeClass($element, isolated) {
                        safeAddClass($element, isolated ? 'ng-isolate-scope' : 'ng-scope');
                    } : noop;
                    compile.$$createComment = function (directiveName, comment) {
                        var content = '';
                        if (debugInfoEnabled) {
                            content = ' ' + (directiveName || '') + ': ' + (comment || '') + ' ';
                        }
                        return window.document.createComment(content);
                    };
                    return compile;
                    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        if (!($compileNodes instanceof jqLite)) {
                            $compileNodes = jqLite($compileNodes);
                        }
                        var NOT_EMPTY = /\S+/;
                        for (var i = 0, len = $compileNodes.length; i < len; i++) {
                            var domNode = $compileNodes[i];
                            if (domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY)) {
                                jqLiteWrapNode(domNode, $compileNodes[i] = window.document.createElement('span'));
                            }
                        }
                        var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                        compile.$$addScopeClass($compileNodes);
                        var namespace = null;
                        return function publicLinkFn(scope, cloneConnectFn, options) {
                            assertArg(scope, 'scope');
                            if (previousCompileContext && previousCompileContext.needsNewScope) {
                                scope = scope.$parent.$new();
                            }
                            options = options || {};
                            var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                            if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude) {
                                parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude;
                            }
                            if (!namespace) {
                                namespace = detectNamespaceForChildElements(futureParentElement);
                            }
                            var $linkNode;
                            if (namespace !== 'html') {
                                $linkNode = jqLite(wrapTemplate(namespace, jqLite('<div>').append($compileNodes).html()));
                            } else if (cloneConnectFn) {
                                $linkNode = JQLitePrototype.clone.call($compileNodes);
                            } else {
                                $linkNode = $compileNodes;
                            }
                            if (transcludeControllers) {
                                for (var controllerName in transcludeControllers) {
                                    $linkNode.data('$' + controllerName + 'Controller', transcludeControllers[controllerName].instance);
                                }
                            }
                            compile.$$addScopeInfo($linkNode, scope);
                            if (cloneConnectFn)
                                cloneConnectFn($linkNode, scope);
                            if (compositeLinkFn)
                                compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn);
                            return $linkNode;
                        };
                    }
                    function detectNamespaceForChildElements(parentElement) {
                        var node = parentElement && parentElement[0];
                        if (!node) {
                            return 'html';
                        } else {
                            return nodeName_(node) !== 'foreignobject' && toString.call(node).match(/SVG/) ? 'svg' : 'html';
                        }
                    }
                    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                        var linkFns = [], attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound;
                        for (var i = 0; i < nodeList.length; i++) {
                            attrs = new Attributes();
                            directives = collectDirectives(nodeList[i], [], attrs, i === 0 ? maxPriority : undefined, ignoreDirective);
                            nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null;
                            if (nodeLinkFn && nodeLinkFn.scope) {
                                compile.$$addScopeClass(attrs.$$element);
                            }
                            childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn);
                            if (nodeLinkFn || childLinkFn) {
                                linkFns.push(i, nodeLinkFn, childLinkFn);
                                linkFnFound = true;
                                nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn;
                            }
                            previousCompileContext = null;
                        }
                        return linkFnFound ? compositeLinkFn : null;
                        function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                            var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn;
                            var stableNodeList;
                            if (nodeLinkFnFound) {
                                var nodeListLength = nodeList.length;
                                stableNodeList = new Array(nodeListLength);
                                for (i = 0; i < linkFns.length; i += 3) {
                                    idx = linkFns[i];
                                    stableNodeList[idx] = nodeList[idx];
                                }
                            } else {
                                stableNodeList = nodeList;
                            }
                            for (i = 0, ii = linkFns.length; i < ii;) {
                                node = stableNodeList[linkFns[i++]];
                                nodeLinkFn = linkFns[i++];
                                childLinkFn = linkFns[i++];
                                if (nodeLinkFn) {
                                    if (nodeLinkFn.scope) {
                                        childScope = scope.$new();
                                        compile.$$addScopeInfo(jqLite(node), childScope);
                                    } else {
                                        childScope = scope;
                                    }
                                    if (nodeLinkFn.transcludeOnThisElement) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn);
                                    } else if (!nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn) {
                                        childBoundTranscludeFn = parentBoundTranscludeFn;
                                    } else if (!parentBoundTranscludeFn && transcludeFn) {
                                        childBoundTranscludeFn = createBoundTranscludeFn(scope, transcludeFn);
                                    } else {
                                        childBoundTranscludeFn = null;
                                    }
                                    nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn);
                                } else if (childLinkFn) {
                                    childLinkFn(scope, node.childNodes, undefined, parentBoundTranscludeFn);
                                }
                            }
                        }
                    }
                    function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                        function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                            if (!transcludedScope) {
                                transcludedScope = scope.$new(false, containingScope);
                                transcludedScope.$$transcluded = true;
                            }
                            return transcludeFn(transcludedScope, cloneFn, {
                                parentBoundTranscludeFn: previousBoundTranscludeFn,
                                transcludeControllers: controllers,
                                futureParentElement: futureParentElement
                            });
                        }
                        var boundSlots = boundTranscludeFn.$$slots = createMap();
                        for (var slotName in transcludeFn.$$slots) {
                            if (transcludeFn.$$slots[slotName]) {
                                boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn);
                            } else {
                                boundSlots[slotName] = null;
                            }
                        }
                        return boundTranscludeFn;
                    }
                    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        var nodeType = node.nodeType, attrsMap = attrs.$attr, match, className;
                        switch (nodeType) {
                        case NODE_TYPE_ELEMENT:
                            addDirective(directives, directiveNormalize(nodeName_(node)), 'E', maxPriority, ignoreDirective);
                            for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                                var attrStartName = false;
                                var attrEndName = false;
                                attr = nAttrs[j];
                                name = attr.name;
                                value = trim(attr.value);
                                ngAttrName = directiveNormalize(name);
                                if (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) {
                                    name = name.replace(PREFIX_REGEXP, '').substr(8).replace(/_(.)/g, function (match, letter) {
                                        return letter.toUpperCase();
                                    });
                                }
                                var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                                if (multiElementMatch && directiveIsMultiElement(multiElementMatch[1])) {
                                    attrStartName = name;
                                    attrEndName = name.substr(0, name.length - 5) + 'end';
                                    name = name.substr(0, name.length - 6);
                                }
                                nName = directiveNormalize(name.toLowerCase());
                                attrsMap[nName] = name;
                                if (isNgAttr || !attrs.hasOwnProperty(nName)) {
                                    attrs[nName] = value;
                                    if (getBooleanAttrName(node, nName)) {
                                        attrs[nName] = true;
                                    }
                                }
                                addAttrInterpolateDirective(node, directives, value, nName, isNgAttr);
                                addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);
                            }
                            className = node.className;
                            if (isObject(className)) {
                                className = className.animVal;
                            }
                            if (isString(className) && className !== '') {
                                while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {
                                    nName = directiveNormalize(match[2]);
                                    if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {
                                        attrs[nName] = trim(match[3]);
                                    }
                                    className = className.substr(match.index + match[0].length);
                                }
                            }
                            break;
                        case NODE_TYPE_TEXT:
                            if (msie === 11) {
                                while (node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT) {
                                    node.nodeValue = node.nodeValue + node.nextSibling.nodeValue;
                                    node.parentNode.removeChild(node.nextSibling);
                                }
                            }
                            addTextInterpolateDirective(directives, node.nodeValue);
                            break;
                        case NODE_TYPE_COMMENT:
                            try {
                                match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                                if (match) {
                                    nName = directiveNormalize(match[1]);
                                    if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {
                                        attrs[nName] = trim(match[2]);
                                    }
                                }
                            } catch (e) {
                            }
                            break;
                        }
                        directives.sort(byPriority);
                        return directives;
                    }
                    function groupScan(node, attrStart, attrEnd) {
                        var nodes = [];
                        var depth = 0;
                        if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                            do {
                                if (!node) {
                                    throw $compileMinErr('uterdir', 'Unterminated attribute, found \'{0}\' but no matching \'{1}\' found.', attrStart, attrEnd);
                                }
                                if (node.nodeType == NODE_TYPE_ELEMENT) {
                                    if (node.hasAttribute(attrStart))
                                        depth++;
                                    if (node.hasAttribute(attrEnd))
                                        depth--;
                                }
                                nodes.push(node);
                                node = node.nextSibling;
                            } while (depth > 0);
                        } else {
                            nodes.push(node);
                        }
                        return jqLite(nodes);
                    }
                    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                        return function groupedElementsLink(scope, element, attrs, controllers, transcludeFn) {
                            element = groupScan(element[0], attrStart, attrEnd);
                            return linkFn(scope, element, attrs, controllers, transcludeFn);
                        };
                    }
                    function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        var compiled;
                        if (eager) {
                            return compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                        }
                        return function lazyCompilation() {
                            if (!compiled) {
                                compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext);
                                $compileNodes = transcludeFn = previousCompileContext = null;
                            }
                            return compiled.apply(this, arguments);
                        };
                    }
                    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                        previousCompileContext = previousCompileContext || {};
                        var terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = false, hasTemplate = false, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), directive, directiveName, $template, replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, linkFn, didScanForMultipleTransclusion = false, mightHaveMultipleTransclusionError = false, directiveValue;
                        for (var i = 0, ii = directives.length; i < ii; i++) {
                            directive = directives[i];
                            var attrStart = directive.$$start;
                            var attrEnd = directive.$$end;
                            if (attrStart) {
                                $compileNode = groupScan(compileNode, attrStart, attrEnd);
                            }
                            $template = undefined;
                            if (terminalPriority > directive.priority) {
                                break;
                            }
                            if (directiveValue = directive.scope) {
                                if (!directive.templateUrl) {
                                    if (isObject(directiveValue)) {
                                        assertNoDuplicate('new/isolated scope', newIsolateScopeDirective || newScopeDirective, directive, $compileNode);
                                        newIsolateScopeDirective = directive;
                                    } else {
                                        assertNoDuplicate('new/isolated scope', newIsolateScopeDirective, directive, $compileNode);
                                    }
                                }
                                newScopeDirective = newScopeDirective || directive;
                            }
                            directiveName = directive.name;
                            if (!didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                                var candidateDirective;
                                for (var scanningIndex = i + 1; candidateDirective = directives[scanningIndex++];) {
                                    if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                                        mightHaveMultipleTransclusionError = true;
                                        break;
                                    }
                                }
                                didScanForMultipleTransclusion = true;
                            }
                            if (!directive.templateUrl && directive.controller) {
                                directiveValue = directive.controller;
                                controllerDirectives = controllerDirectives || createMap();
                                assertNoDuplicate('\'' + directiveName + '\' controller', controllerDirectives[directiveName], directive, $compileNode);
                                controllerDirectives[directiveName] = directive;
                            }
                            if (directiveValue = directive.transclude) {
                                hasTranscludeDirective = true;
                                if (!directive.$$tlb) {
                                    assertNoDuplicate('transclusion', nonTlbTranscludeDirective, directive, $compileNode);
                                    nonTlbTranscludeDirective = directive;
                                }
                                if (directiveValue == 'element') {
                                    hasElementTranscludeDirective = true;
                                    terminalPriority = directive.priority;
                                    $template = $compileNode;
                                    $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName]));
                                    compileNode = $compileNode[0];
                                    replaceWith(jqCollection, sliceArgs($template), compileNode);
                                    $template[0].$$parentNode = $template[0].parentNode;
                                    childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, { nonTlbTranscludeDirective: nonTlbTranscludeDirective });
                                } else {
                                    var slots = createMap();
                                    $template = jqLite(jqLiteClone(compileNode)).contents();
                                    if (isObject(directiveValue)) {
                                        $template = [];
                                        var slotMap = createMap();
                                        var filledSlots = createMap();
                                        forEach(directiveValue, function (elementSelector, slotName) {
                                            var optional = elementSelector.charAt(0) === '?';
                                            elementSelector = optional ? elementSelector.substring(1) : elementSelector;
                                            slotMap[elementSelector] = slotName;
                                            slots[slotName] = null;
                                            filledSlots[slotName] = optional;
                                        });
                                        forEach($compileNode.contents(), function (node) {
                                            var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                            if (slotName) {
                                                filledSlots[slotName] = true;
                                                slots[slotName] = slots[slotName] || [];
                                                slots[slotName].push(node);
                                            } else {
                                                $template.push(node);
                                            }
                                        });
                                        forEach(filledSlots, function (filled, slotName) {
                                            if (!filled) {
                                                throw $compileMinErr('reqslot', 'Required transclusion slot `{0}` was not filled.', slotName);
                                            }
                                        });
                                        for (var slotName in slots) {
                                            if (slots[slotName]) {
                                                slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn);
                                            }
                                        }
                                    }
                                    $compileNode.empty();
                                    childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, undefined, undefined, { needsNewScope: directive.$$isolateScope || directive.$$newScope });
                                    childTranscludeFn.$$slots = slots;
                                }
                            }
                            if (directive.template) {
                                hasTemplate = true;
                                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                                templateDirective = directive;
                                directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template;
                                directiveValue = denormalizeTemplate(directiveValue);
                                if (directive.replace) {
                                    replaceDirective = directive;
                                    if (jqLiteIsTextNode(directiveValue)) {
                                        $template = [];
                                    } else {
                                        $template = removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue)));
                                    }
                                    compileNode = $template[0];
                                    if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                        throw $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', directiveName, '');
                                    }
                                    replaceWith(jqCollection, $compileNode, compileNode);
                                    var newTemplateAttrs = { $attr: {} };
                                    var templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs);
                                    var unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                    if (newIsolateScopeDirective || newScopeDirective) {
                                        markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective);
                                    }
                                    directives = directives.concat(templateDirectives).concat(unprocessedDirectives);
                                    mergeTemplateAttributes(templateAttrs, newTemplateAttrs);
                                    ii = directives.length;
                                } else {
                                    $compileNode.html(directiveValue);
                                }
                            }
                            if (directive.templateUrl) {
                                hasTemplate = true;
                                assertNoDuplicate('template', templateDirective, directive, $compileNode);
                                templateDirective = directive;
                                if (directive.replace) {
                                    replaceDirective = directive;
                                }
                                nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                                    controllerDirectives: controllerDirectives,
                                    newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                                    newIsolateScopeDirective: newIsolateScopeDirective,
                                    templateDirective: templateDirective,
                                    nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                });
                                ii = directives.length;
                            } else if (directive.compile) {
                                try {
                                    linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                                    if (isFunction(linkFn)) {
                                        addLinkFns(null, linkFn, attrStart, attrEnd);
                                    } else if (linkFn) {
                                        addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);
                                    }
                                } catch (e) {
                                    $exceptionHandler(e, startingTag($compileNode));
                                }
                            }
                            if (directive.terminal) {
                                nodeLinkFn.terminal = true;
                                terminalPriority = Math.max(terminalPriority, directive.priority);
                            }
                        }
                        nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === true;
                        nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective;
                        nodeLinkFn.templateOnThisElement = hasTemplate;
                        nodeLinkFn.transclude = childTranscludeFn;
                        previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective;
                        return nodeLinkFn;
                        function addLinkFns(pre, post, attrStart, attrEnd) {
                            if (pre) {
                                if (attrStart)
                                    pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);
                                pre.require = directive.require;
                                pre.directiveName = directiveName;
                                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                                    pre = cloneAndAnnotateFn(pre, { isolateScope: true });
                                }
                                preLinkFns.push(pre);
                            }
                            if (post) {
                                if (attrStart)
                                    post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);
                                post.require = directive.require;
                                post.directiveName = directiveName;
                                if (newIsolateScopeDirective === directive || directive.$$isolateScope) {
                                    post = cloneAndAnnotateFn(post, { isolateScope: true });
                                }
                                postLinkFns.push(post);
                            }
                        }
                        function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                            var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                            if (compileNode === linkNode) {
                                attrs = templateAttrs;
                                $element = templateAttrs.$$element;
                            } else {
                                $element = jqLite(linkNode);
                                attrs = new Attributes($element, templateAttrs);
                            }
                            controllerScope = scope;
                            if (newIsolateScopeDirective) {
                                isolateScope = scope.$new(true);
                            } else if (newScopeDirective) {
                                controllerScope = scope.$parent;
                            }
                            if (boundTranscludeFn) {
                                transcludeFn = controllersBoundTransclude;
                                transcludeFn.$$boundTransclude = boundTranscludeFn;
                                transcludeFn.isSlotFilled = function (slotName) {
                                    return !!boundTranscludeFn.$$slots[slotName];
                                };
                            }
                            if (controllerDirectives) {
                                elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective);
                            }
                            if (newIsolateScopeDirective) {
                                compile.$$addScopeInfo($element, isolateScope, true, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective)));
                                compile.$$addScopeClass($element, true);
                                isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings;
                                scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective);
                                if (scopeBindingInfo.removeWatches) {
                                    isolateScope.$on('$destroy', scopeBindingInfo.removeWatches);
                                }
                            }
                            for (var name in elementControllers) {
                                var controllerDirective = controllerDirectives[name];
                                var controller = elementControllers[name];
                                var bindings = controllerDirective.$$bindings.bindToController;
                                if (controller.identifier && bindings) {
                                    controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                } else {
                                    controller.bindingInfo = {};
                                }
                                var controllerResult = controller();
                                if (controllerResult !== controller.instance) {
                                    controller.instance = controllerResult;
                                    $element.data('$' + controllerDirective.name + 'Controller', controllerResult);
                                    controller.bindingInfo.removeWatches && controller.bindingInfo.removeWatches();
                                    controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective);
                                }
                            }
                            forEach(controllerDirectives, function (controllerDirective, name) {
                                var require = controllerDirective.require;
                                if (controllerDirective.bindToController && !isArray(require) && isObject(require)) {
                                    extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers));
                                }
                            });
                            forEach(elementControllers, function (controller) {
                                var controllerInstance = controller.instance;
                                if (isFunction(controllerInstance.$onChanges)) {
                                    controllerInstance.$onChanges(controller.bindingInfo.initialChanges);
                                }
                                if (isFunction(controllerInstance.$onInit)) {
                                    controllerInstance.$onInit();
                                }
                                if (isFunction(controllerInstance.$onDestroy)) {
                                    controllerScope.$on('$destroy', function callOnDestroyHook() {
                                        controllerInstance.$onDestroy();
                                    });
                                }
                            });
                            for (i = 0, ii = preLinkFns.length; i < ii; i++) {
                                linkFn = preLinkFns[i];
                                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            }
                            var scopeToChild = scope;
                            if (newIsolateScopeDirective && (newIsolateScopeDirective.template || newIsolateScopeDirective.templateUrl === null)) {
                                scopeToChild = isolateScope;
                            }
                            childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, undefined, boundTranscludeFn);
                            for (i = postLinkFns.length - 1; i >= 0; i--) {
                                linkFn = postLinkFns[i];
                                invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            }
                            forEach(elementControllers, function (controller) {
                                var controllerInstance = controller.instance;
                                if (isFunction(controllerInstance.$postLink)) {
                                    controllerInstance.$postLink();
                                }
                            });
                            function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                                var transcludeControllers;
                                if (!isScope(scope)) {
                                    slotName = futureParentElement;
                                    futureParentElement = cloneAttachFn;
                                    cloneAttachFn = scope;
                                    scope = undefined;
                                }
                                if (hasElementTranscludeDirective) {
                                    transcludeControllers = elementControllers;
                                }
                                if (!futureParentElement) {
                                    futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element;
                                }
                                if (slotName) {
                                    var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                                    if (slotTranscludeFn) {
                                        return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                    } else if (isUndefined(slotTranscludeFn)) {
                                        throw $compileMinErr('noslot', 'No parent directive that requires a transclusion with slot name "{0}". ' + 'Element: {1}', slotName, startingTag($element));
                                    }
                                } else {
                                    return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                }
                            }
                        }
                    }
                    function getControllers(directiveName, require, $element, elementControllers) {
                        var value;
                        if (isString(require)) {
                            var match = require.match(REQUIRE_PREFIX_REGEXP);
                            var name = require.substring(match[0].length);
                            var inheritType = match[1] || match[3];
                            var optional = match[2] === '?';
                            if (inheritType === '^^') {
                                $element = $element.parent();
                            } else {
                                value = elementControllers && elementControllers[name];
                                value = value && value.instance;
                            }
                            if (!value) {
                                var dataName = '$' + name + 'Controller';
                                value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                            }
                            if (!value && !optional) {
                                throw $compileMinErr('ctreq', 'Controller \'{0}\', required by directive \'{1}\', can\'t be found!', name, directiveName);
                            }
                        } else if (isArray(require)) {
                            value = [];
                            for (var i = 0, ii = require.length; i < ii; i++) {
                                value[i] = getControllers(directiveName, require[i], $element, elementControllers);
                            }
                        } else if (isObject(require)) {
                            value = {};
                            forEach(require, function (controller, property) {
                                value[property] = getControllers(directiveName, controller, $element, elementControllers);
                            });
                        }
                        return value || null;
                    }
                    function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                        var elementControllers = createMap();
                        for (var controllerKey in controllerDirectives) {
                            var directive = controllerDirectives[controllerKey];
                            var locals = {
                                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                $element: $element,
                                $attrs: attrs,
                                $transclude: transcludeFn
                            };
                            var controller = directive.controller;
                            if (controller == '@') {
                                controller = attrs[directive.name];
                            }
                            var controllerInstance = $controller(controller, locals, true, directive.controllerAs);
                            elementControllers[directive.name] = controllerInstance;
                            $element.data('$' + directive.name + 'Controller', controllerInstance.instance);
                        }
                        return elementControllers;
                    }
                    function markDirectiveScope(directives, isolateScope, newScope) {
                        for (var j = 0, jj = directives.length; j < jj; j++) {
                            directives[j] = inherit(directives[j], {
                                $$isolateScope: isolateScope,
                                $$newScope: newScope
                            });
                        }
                    }
                    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                        if (name === ignoreDirective)
                            return null;
                        var match = null;
                        if (hasDirectives.hasOwnProperty(name)) {
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                                try {
                                    directive = directives[i];
                                    if ((isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) != -1) {
                                        if (startAttrName) {
                                            directive = inherit(directive, {
                                                $$start: startAttrName,
                                                $$end: endAttrName
                                            });
                                        }
                                        if (!directive.$$bindings) {
                                            var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                            if (isObject(bindings.isolateScope)) {
                                                directive.$$isolateBindings = bindings.isolateScope;
                                            }
                                        }
                                        tDirectives.push(directive);
                                        match = directive;
                                    }
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            }
                        }
                        return match;
                    }
                    function directiveIsMultiElement(name) {
                        if (hasDirectives.hasOwnProperty(name)) {
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++) {
                                directive = directives[i];
                                if (directive.multiElement) {
                                    return true;
                                }
                            }
                        }
                        return false;
                    }
                    function mergeTemplateAttributes(dst, src) {
                        var srcAttr = src.$attr, dstAttr = dst.$attr, $element = dst.$$element;
                        forEach(dst, function (value, key) {
                            if (key.charAt(0) != '$') {
                                if (src[key] && src[key] !== value) {
                                    value += (key === 'style' ? ';' : ' ') + src[key];
                                }
                                dst.$set(key, value, true, srcAttr[key]);
                            }
                        });
                        forEach(src, function (value, key) {
                            if (key == 'class') {
                                safeAddClass($element, value);
                                dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;
                            } else if (key == 'style') {
                                $element.attr('style', $element.attr('style') + ';' + value);
                                dst['style'] = (dst['style'] ? dst['style'] + ';' : '') + value;
                            } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {
                                dst[key] = value;
                                dstAttr[key] = srcAttr[key];
                            }
                        });
                    }
                    function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                        var linkQueue = [], afterTemplateNodeLinkFn, afterTemplateChildLinkFn, beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                                templateUrl: null,
                                transclude: null,
                                replace: null,
                                $$originalDirective: origAsyncDirective
                            }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                        $compileNode.empty();
                        $templateRequest(templateUrl).then(function (content) {
                            var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                            content = denormalizeTemplate(content);
                            if (origAsyncDirective.replace) {
                                if (jqLiteIsTextNode(content)) {
                                    $template = [];
                                } else {
                                    $template = removeComments(wrapTemplate(templateNamespace, trim(content)));
                                }
                                compileNode = $template[0];
                                if ($template.length != 1 || compileNode.nodeType !== NODE_TYPE_ELEMENT) {
                                    throw $compileMinErr('tplrt', 'Template for directive \'{0}\' must have exactly one root element. {1}', origAsyncDirective.name, templateUrl);
                                }
                                tempTemplateAttrs = { $attr: {} };
                                replaceWith($rootElement, $compileNode, compileNode);
                                var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                if (isObject(origAsyncDirective.scope)) {
                                    markDirectiveScope(templateDirectives, true);
                                }
                                directives = templateDirectives.concat(directives);
                                mergeTemplateAttributes(tAttrs, tempTemplateAttrs);
                            } else {
                                compileNode = beforeTemplateCompileNode;
                                $compileNode.html(content);
                            }
                            directives.unshift(derivedSyncDirective);
                            afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext);
                            forEach($rootElement, function (node, i) {
                                if (node == compileNode) {
                                    $rootElement[i] = $compileNode[0];
                                }
                            });
                            afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);
                            while (linkQueue.length) {
                                var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                                if (scope.$$destroyed)
                                    continue;
                                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                    var oldClasses = beforeTemplateLinkNode.className;
                                    if (!(previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace)) {
                                        linkNode = jqLiteClone(compileNode);
                                    }
                                    replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);
                                    safeAddClass(jqLite(linkNode), oldClasses);
                                }
                                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                                    childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                                } else {
                                    childBoundTranscludeFn = boundTranscludeFn;
                                }
                                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn);
                            }
                            linkQueue = null;
                        });
                        return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                            var childBoundTranscludeFn = boundTranscludeFn;
                            if (scope.$$destroyed)
                                return;
                            if (linkQueue) {
                                linkQueue.push(scope, node, rootElement, childBoundTranscludeFn);
                            } else {
                                if (afterTemplateNodeLinkFn.transcludeOnThisElement) {
                                    childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn);
                                }
                                afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn);
                            }
                        };
                    }
                    function byPriority(a, b) {
                        var diff = b.priority - a.priority;
                        if (diff !== 0)
                            return diff;
                        if (a.name !== b.name)
                            return a.name < b.name ? -1 : 1;
                        return a.index - b.index;
                    }
                    function assertNoDuplicate(what, previousDirective, directive, element) {
                        function wrapModuleNameIfDefined(moduleName) {
                            return moduleName ? ' (module: ' + moduleName + ')' : '';
                        }
                        if (previousDirective) {
                            throw $compileMinErr('multidir', 'Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}', previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element));
                        }
                    }
                    function addTextInterpolateDirective(directives, text) {
                        var interpolateFn = $interpolate(text, true);
                        if (interpolateFn) {
                            directives.push({
                                priority: 0,
                                compile: function textInterpolateCompileFn(templateNode) {
                                    var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                                    if (hasCompileParent)
                                        compile.$$addBindingClass(templateNodeParent);
                                    return function textInterpolateLinkFn(scope, node) {
                                        var parent = node.parent();
                                        if (!hasCompileParent)
                                            compile.$$addBindingClass(parent);
                                        compile.$$addBindingInfo(parent, interpolateFn.expressions);
                                        scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {
                                            node[0].nodeValue = value;
                                        });
                                    };
                                }
                            });
                        }
                    }
                    function wrapTemplate(type, template) {
                        type = lowercase(type || 'html');
                        switch (type) {
                        case 'svg':
                        case 'math':
                            var wrapper = window.document.createElement('div');
                            wrapper.innerHTML = '<' + type + '>' + template + '</' + type + '>';
                            return wrapper.childNodes[0].childNodes;
                        default:
                            return template;
                        }
                    }
                    function getTrustedContext(node, attrNormalizedName) {
                        if (attrNormalizedName == 'srcdoc') {
                            return $sce.HTML;
                        }
                        var tag = nodeName_(node);
                        if (attrNormalizedName == 'xlinkHref' || tag == 'form' && attrNormalizedName == 'action' || tag != 'img' && (attrNormalizedName == 'src' || attrNormalizedName == 'ngSrc')) {
                            return $sce.RESOURCE_URL;
                        }
                    }
                    function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                        var trustedContext = getTrustedContext(node, name);
                        allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                        var interpolateFn = $interpolate(value, true, trustedContext, allOrNothing);
                        if (!interpolateFn)
                            return;
                        if (name === 'multiple' && nodeName_(node) === 'select') {
                            throw $compileMinErr('selmulti', 'Binding to the \'multiple\' attribute is not supported. Element: {0}', startingTag(node));
                        }
                        directives.push({
                            priority: 100,
                            compile: function () {
                                return {
                                    pre: function attrInterpolatePreLinkFn(scope, element, attr) {
                                        var $$observers = attr.$$observers || (attr.$$observers = createMap());
                                        if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {
                                            throw $compileMinErr('nodomevents', 'Interpolations for HTML DOM event attributes are disallowed.  Please use the ' + 'ng- versions (such as ng-click instead of onclick) instead.');
                                        }
                                        var newValue = attr[name];
                                        if (newValue !== value) {
                                            interpolateFn = newValue && $interpolate(newValue, true, trustedContext, allOrNothing);
                                            value = newValue;
                                        }
                                        if (!interpolateFn)
                                            return;
                                        attr[name] = interpolateFn(scope);
                                        ($$observers[name] || ($$observers[name] = [])).$$inter = true;
                                        (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function interpolateFnWatchAction(newValue, oldValue) {
                                            if (name === 'class' && newValue != oldValue) {
                                                attr.$updateClass(newValue, oldValue);
                                            } else {
                                                attr.$set(name, newValue);
                                            }
                                        });
                                    }
                                };
                            }
                        });
                    }
                    function replaceWith($rootElement, elementsToRemove, newNode) {
                        var firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode, i, ii;
                        if ($rootElement) {
                            for (i = 0, ii = $rootElement.length; i < ii; i++) {
                                if ($rootElement[i] == firstElementToRemove) {
                                    $rootElement[i++] = newNode;
                                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, j2++) {
                                        if (j2 < jj) {
                                            $rootElement[j] = $rootElement[j2];
                                        } else {
                                            delete $rootElement[j];
                                        }
                                    }
                                    $rootElement.length -= removeCount - 1;
                                    if ($rootElement.context === firstElementToRemove) {
                                        $rootElement.context = newNode;
                                    }
                                    break;
                                }
                            }
                        }
                        if (parent) {
                            parent.replaceChild(newNode, firstElementToRemove);
                        }
                        var fragment = window.document.createDocumentFragment();
                        for (i = 0; i < removeCount; i++) {
                            fragment.appendChild(elementsToRemove[i]);
                        }
                        if (jqLite.hasData(firstElementToRemove)) {
                            jqLite.data(newNode, jqLite.data(firstElementToRemove));
                            jqLite(firstElementToRemove).off('$destroy');
                        }
                        jqLite.cleanData(fragment.querySelectorAll('*'));
                        for (i = 1; i < removeCount; i++) {
                            delete elementsToRemove[i];
                        }
                        elementsToRemove[0] = newNode;
                        elementsToRemove.length = 1;
                    }
                    function cloneAndAnnotateFn(fn, annotation) {
                        return extend(function () {
                            return fn.apply(null, arguments);
                        }, fn, annotation);
                    }
                    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                        try {
                            linkFn(scope, $element, attrs, controllers, transcludeFn);
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element));
                        }
                    }
                    function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                        var removeWatchCollection = [];
                        var initialChanges = {};
                        var changes;
                        forEach(bindings, function initializeBinding(definition, scopeName) {
                            var attrName = definition.attrName, optional = definition.optional, mode = definition.mode, lastValue, parentGet, parentSet, compare, removeWatch;
                            switch (mode) {
                            case '@':
                                if (!optional && !hasOwnProperty.call(attrs, attrName)) {
                                    destination[scopeName] = attrs[attrName] = void 0;
                                }
                                attrs.$observe(attrName, function (value) {
                                    if (isString(value) || isBoolean(value)) {
                                        var oldValue = destination[scopeName];
                                        recordChanges(scopeName, value, oldValue);
                                        destination[scopeName] = value;
                                    }
                                });
                                attrs.$$observers[attrName].$$scope = scope;
                                lastValue = attrs[attrName];
                                if (isString(lastValue)) {
                                    destination[scopeName] = $interpolate(lastValue)(scope);
                                } else if (isBoolean(lastValue)) {
                                    destination[scopeName] = lastValue;
                                }
                                initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                                break;
                            case '=':
                                if (!hasOwnProperty.call(attrs, attrName)) {
                                    if (optional)
                                        break;
                                    attrs[attrName] = void 0;
                                }
                                if (optional && !attrs[attrName])
                                    break;
                                parentGet = $parse(attrs[attrName]);
                                if (parentGet.literal) {
                                    compare = equals;
                                } else {
                                    compare = function simpleCompare(a, b) {
                                        return a === b || a !== a && b !== b;
                                    };
                                }
                                parentSet = parentGet.assign || function () {
                                    lastValue = destination[scopeName] = parentGet(scope);
                                    throw $compileMinErr('nonassign', 'Expression \'{0}\' in attribute \'{1}\' used with directive \'{2}\' is non-assignable!', attrs[attrName], attrName, directive.name);
                                };
                                lastValue = destination[scopeName] = parentGet(scope);
                                var parentValueWatch = function parentValueWatch(parentValue) {
                                    if (!compare(parentValue, destination[scopeName])) {
                                        if (!compare(parentValue, lastValue)) {
                                            destination[scopeName] = parentValue;
                                        } else {
                                            parentSet(scope, parentValue = destination[scopeName]);
                                        }
                                    }
                                    return lastValue = parentValue;
                                };
                                parentValueWatch.$stateful = true;
                                if (definition.collection) {
                                    removeWatch = scope.$watchCollection(attrs[attrName], parentValueWatch);
                                } else {
                                    removeWatch = scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal);
                                }
                                removeWatchCollection.push(removeWatch);
                                break;
                            case '<':
                                if (!hasOwnProperty.call(attrs, attrName)) {
                                    if (optional)
                                        break;
                                    attrs[attrName] = void 0;
                                }
                                if (optional && !attrs[attrName])
                                    break;
                                parentGet = $parse(attrs[attrName]);
                                destination[scopeName] = parentGet(scope);
                                initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                                removeWatch = scope.$watch(parentGet, function parentValueWatchAction(newValue, oldValue) {
                                    if (newValue === oldValue) {
                                        oldValue = destination[scopeName];
                                    }
                                    recordChanges(scopeName, newValue, oldValue);
                                    destination[scopeName] = newValue;
                                }, parentGet.literal);
                                removeWatchCollection.push(removeWatch);
                                break;
                            case '&':
                                parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop;
                                if (parentGet === noop && optional)
                                    break;
                                destination[scopeName] = function (locals) {
                                    return parentGet(scope, locals);
                                };
                                break;
                            }
                        });
                        function recordChanges(key, currentValue, previousValue) {
                            if (isFunction(destination.$onChanges) && currentValue !== previousValue) {
                                if (!onChangesQueue) {
                                    scope.$$postDigest(flushOnChangesQueue);
                                    onChangesQueue = [];
                                }
                                if (!changes) {
                                    changes = {};
                                    onChangesQueue.push(triggerOnChangesHook);
                                }
                                if (changes[key]) {
                                    previousValue = changes[key].previousValue;
                                }
                                changes[key] = new SimpleChange(previousValue, currentValue);
                            }
                        }
                        function triggerOnChangesHook() {
                            destination.$onChanges(changes);
                            changes = undefined;
                        }
                        return {
                            initialChanges: initialChanges,
                            removeWatches: removeWatchCollection.length && function removeWatches() {
                                for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) {
                                    removeWatchCollection[i]();
                                }
                            }
                        };
                    }
                }
            ];
        }
        function SimpleChange(previous, current) {
            this.previousValue = previous;
            this.currentValue = current;
        }
        SimpleChange.prototype.isFirstChange = function () {
            return this.previousValue === _UNINITIALIZED_VALUE;
        };
        var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i;
        function directiveNormalize(name) {
            return camelCase(name.replace(PREFIX_REGEXP, ''));
        }
        function nodesetLinkingFn(scope, nodeList, rootElement, boundTranscludeFn) {
        }
        function directiveLinkingFn(nodesetLinkingFn, scope, node, rootElement, boundTranscludeFn) {
        }
        function tokenDifference(str1, str2) {
            var values = '', tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
            outer:
                for (var i = 0; i < tokens1.length; i++) {
                    var token = tokens1[i];
                    for (var j = 0; j < tokens2.length; j++) {
                        if (token == tokens2[j])
                            continue outer;
                    }
                    values += (values.length > 0 ? ' ' : '') + token;
                }
            return values;
        }
        function removeComments(jqNodes) {
            jqNodes = jqLite(jqNodes);
            var i = jqNodes.length;
            if (i <= 1) {
                return jqNodes;
            }
            while (i--) {
                var node = jqNodes[i];
                if (node.nodeType === NODE_TYPE_COMMENT) {
                    splice.call(jqNodes, i, 1);
                }
            }
            return jqNodes;
        }
        var $controllerMinErr = minErr('$controller');
        var CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;
        function identifierForController(controller, ident) {
            if (ident && isString(ident))
                return ident;
            if (isString(controller)) {
                var match = CNTRL_REG.exec(controller);
                if (match)
                    return match[3];
            }
        }
        function $ControllerProvider() {
            var controllers = {}, globals = false;
            this.has = function (name) {
                return controllers.hasOwnProperty(name);
            };
            this.register = function (name, constructor) {
                assertNotHasOwnProperty(name, 'controller');
                if (isObject(name)) {
                    extend(controllers, name);
                } else {
                    controllers[name] = constructor;
                }
            };
            this.allowGlobals = function () {
                globals = true;
            };
            this.$get = [
                '$injector',
                '$window',
                function ($injector, $window) {
                    return function $controller(expression, locals, later, ident) {
                        var instance, match, constructor, identifier;
                        later = later === true;
                        if (ident && isString(ident)) {
                            identifier = ident;
                        }
                        if (isString(expression)) {
                            match = expression.match(CNTRL_REG);
                            if (!match) {
                                throw $controllerMinErr('ctrlfmt', 'Badly formed controller string \'{0}\'. ' + 'Must match `__name__ as __id__` or `__name__`.', expression);
                            }
                            constructor = match[1], identifier = identifier || match[3];
                            expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, true) || (globals ? getter($window, constructor, true) : undefined);
                            assertArgFn(expression, constructor, true);
                        }
                        if (later) {
                            var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                            instance = Object.create(controllerPrototype || null);
                            if (identifier) {
                                addIdentifier(locals, identifier, instance, constructor || expression.name);
                            }
                            var instantiate;
                            return instantiate = extend(function $controllerInit() {
                                var result = $injector.invoke(expression, instance, locals, constructor);
                                if (result !== instance && (isObject(result) || isFunction(result))) {
                                    instance = result;
                                    if (identifier) {
                                        addIdentifier(locals, identifier, instance, constructor || expression.name);
                                    }
                                }
                                return instance;
                            }, {
                                instance: instance,
                                identifier: identifier
                            });
                        }
                        instance = $injector.instantiate(expression, locals, constructor);
                        if (identifier) {
                            addIdentifier(locals, identifier, instance, constructor || expression.name);
                        }
                        return instance;
                    };
                    function addIdentifier(locals, identifier, instance, name) {
                        if (!(locals && isObject(locals.$scope))) {
                            throw minErr('$controller')('noscp', 'Cannot export controller \'{0}\' as \'{1}\'! No $scope object provided via `locals`.', name, identifier);
                        }
                        locals.$scope[identifier] = instance;
                    }
                }
            ];
        }
        function $DocumentProvider() {
            this.$get = [
                '$window',
                function (window) {
                    return jqLite(window.document);
                }
            ];
        }
        function $ExceptionHandlerProvider() {
            this.$get = [
                '$log',
                function ($log) {
                    return function (exception, cause) {
                        $log.error.apply($log, arguments);
                    };
                }
            ];
        }
        var $$ForceReflowProvider = function () {
            this.$get = [
                '$document',
                function ($document) {
                    return function (domNode) {
                        if (domNode) {
                            if (!domNode.nodeType && domNode instanceof jqLite) {
                                domNode = domNode[0];
                            }
                        } else {
                            domNode = $document[0].body;
                        }
                        return domNode.offsetWidth + 1;
                    };
                }
            ];
        };
        var APPLICATION_JSON = 'application/json';
        var CONTENT_TYPE_APPLICATION_JSON = { 'Content-Type': APPLICATION_JSON + ';charset=utf-8' };
        var JSON_START = /^\[|^\{(?!\{)/;
        var JSON_ENDS = {
            '[': /]$/,
            '{': /}$/
        };
        var JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/;
        var $httpMinErr = minErr('$http');
        var $httpMinErrLegacyFn = function (method) {
            return function () {
                throw $httpMinErr('legacy', 'The method `{0}` on the promise returned from `$http` has been disabled.', method);
            };
        };
        function serializeValue(v) {
            if (isObject(v)) {
                return isDate(v) ? v.toISOString() : toJson(v);
            }
            return v;
        }
        function $HttpParamSerializerProvider() {
            this.$get = function () {
                return function ngParamSerializer(params) {
                    if (!params)
                        return '';
                    var parts = [];
                    forEachSorted(params, function (value, key) {
                        if (value === null || isUndefined(value))
                            return;
                        if (isArray(value)) {
                            forEach(value, function (v) {
                                parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(v)));
                            });
                        } else {
                            parts.push(encodeUriQuery(key) + '=' + encodeUriQuery(serializeValue(value)));
                        }
                    });
                    return parts.join('&');
                };
            };
        }
        function $HttpParamSerializerJQLikeProvider() {
            this.$get = function () {
                return function jQueryLikeParamSerializer(params) {
                    if (!params)
                        return '';
                    var parts = [];
                    serialize(params, '', true);
                    return parts.join('&');
                    function serialize(toSerialize, prefix, topLevel) {
                        if (toSerialize === null || isUndefined(toSerialize))
                            return;
                        if (isArray(toSerialize)) {
                            forEach(toSerialize, function (value, index) {
                                serialize(value, prefix + '[' + (isObject(value) ? index : '') + ']');
                            });
                        } else if (isObject(toSerialize) && !isDate(toSerialize)) {
                            forEachSorted(toSerialize, function (value, key) {
                                serialize(value, prefix + (topLevel ? '' : '[') + key + (topLevel ? '' : ']'));
                            });
                        } else {
                            parts.push(encodeUriQuery(prefix) + '=' + encodeUriQuery(serializeValue(toSerialize)));
                        }
                    }
                };
            };
        }
        function defaultHttpResponseTransform(data, headers) {
            if (isString(data)) {
                var tempData = data.replace(JSON_PROTECTION_PREFIX, '').trim();
                if (tempData) {
                    var contentType = headers('Content-Type');
                    if (contentType && contentType.indexOf(APPLICATION_JSON) === 0 || isJsonLike(tempData)) {
                        data = fromJson(tempData);
                    }
                }
            }
            return data;
        }
        function isJsonLike(str) {
            var jsonStart = str.match(JSON_START);
            return jsonStart && JSON_ENDS[jsonStart[0]].test(str);
        }
        function parseHeaders(headers) {
            var parsed = createMap(), i;
            function fillInParsed(key, val) {
                if (key) {
                    parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
                }
            }
            if (isString(headers)) {
                forEach(headers.split('\n'), function (line) {
                    i = line.indexOf(':');
                    fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)));
                });
            } else if (isObject(headers)) {
                forEach(headers, function (headerVal, headerKey) {
                    fillInParsed(lowercase(headerKey), trim(headerVal));
                });
            }
            return parsed;
        }
        function headersGetter(headers) {
            var headersObj;
            return function (name) {
                if (!headersObj)
                    headersObj = parseHeaders(headers);
                if (name) {
                    var value = headersObj[lowercase(name)];
                    if (value === void 0) {
                        value = null;
                    }
                    return value;
                }
                return headersObj;
            };
        }
        function transformData(data, headers, status, fns) {
            if (isFunction(fns)) {
                return fns(data, headers, status);
            }
            forEach(fns, function (fn) {
                data = fn(data, headers, status);
            });
            return data;
        }
        function isSuccess(status) {
            return 200 <= status && status < 300;
        }
        function $HttpProvider() {
            var defaults = this.defaults = {
                transformResponse: [defaultHttpResponseTransform],
                transformRequest: [function (d) {
                        return isObject(d) && !isFile(d) && !isBlob(d) && !isFormData(d) ? toJson(d) : d;
                    }],
                headers: {
                    common: { 'Accept': 'application/json, text/plain, */*' },
                    post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                    put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                    patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
                },
                xsrfCookieName: 'XSRF-TOKEN',
                xsrfHeaderName: 'X-XSRF-TOKEN',
                paramSerializer: '$httpParamSerializer'
            };
            var useApplyAsync = false;
            this.useApplyAsync = function (value) {
                if (isDefined(value)) {
                    useApplyAsync = !!value;
                    return this;
                }
                return useApplyAsync;
            };
            var useLegacyPromise = true;
            this.useLegacyPromiseExtensions = function (value) {
                if (isDefined(value)) {
                    useLegacyPromise = !!value;
                    return this;
                }
                return useLegacyPromise;
            };
            var interceptorFactories = this.interceptors = [];
            this.$get = [
                '$httpBackend',
                '$$cookieReader',
                '$cacheFactory',
                '$rootScope',
                '$q',
                '$injector',
                function ($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
                    var defaultCache = $cacheFactory('$http');
                    defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
                    var reversedInterceptors = [];
                    forEach(interceptorFactories, function (interceptorFactory) {
                        reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));
                    });
                    function $http(requestConfig) {
                        if (!isObject(requestConfig)) {
                            throw minErr('$http')('badreq', 'Http request configuration must be an object.  Received: {0}', requestConfig);
                        }
                        if (!isString(requestConfig.url)) {
                            throw minErr('$http')('badreq', 'Http request configuration url must be a string.  Received: {0}', requestConfig.url);
                        }
                        var config = extend({
                            method: 'get',
                            transformRequest: defaults.transformRequest,
                            transformResponse: defaults.transformResponse,
                            paramSerializer: defaults.paramSerializer
                        }, requestConfig);
                        config.headers = mergeHeaders(requestConfig);
                        config.method = uppercase(config.method);
                        config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
                        var serverRequest = function (config) {
                            var headers = config.headers;
                            var reqData = transformData(config.data, headersGetter(headers), undefined, config.transformRequest);
                            if (isUndefined(reqData)) {
                                forEach(headers, function (value, header) {
                                    if (lowercase(header) === 'content-type') {
                                        delete headers[header];
                                    }
                                });
                            }
                            if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {
                                config.withCredentials = defaults.withCredentials;
                            }
                            return sendReq(config, reqData).then(transformResponse, transformResponse);
                        };
                        var chain = [
                            serverRequest,
                            undefined
                        ];
                        var promise = $q.when(config);
                        forEach(reversedInterceptors, function (interceptor) {
                            if (interceptor.request || interceptor.requestError) {
                                chain.unshift(interceptor.request, interceptor.requestError);
                            }
                            if (interceptor.response || interceptor.responseError) {
                                chain.push(interceptor.response, interceptor.responseError);
                            }
                        });
                        while (chain.length) {
                            var thenFn = chain.shift();
                            var rejectFn = chain.shift();
                            promise = promise.then(thenFn, rejectFn);
                        }
                        if (useLegacyPromise) {
                            promise.success = function (fn) {
                                assertArgFn(fn, 'fn');
                                promise.then(function (response) {
                                    fn(response.data, response.status, response.headers, config);
                                });
                                return promise;
                            };
                            promise.error = function (fn) {
                                assertArgFn(fn, 'fn');
                                promise.then(null, function (response) {
                                    fn(response.data, response.status, response.headers, config);
                                });
                                return promise;
                            };
                        } else {
                            promise.success = $httpMinErrLegacyFn('success');
                            promise.error = $httpMinErrLegacyFn('error');
                        }
                        return promise;
                        function transformResponse(response) {
                            var resp = extend({}, response);
                            resp.data = transformData(response.data, response.headers, response.status, config.transformResponse);
                            return isSuccess(response.status) ? resp : $q.reject(resp);
                        }
                        function executeHeaderFns(headers, config) {
                            var headerContent, processedHeaders = {};
                            forEach(headers, function (headerFn, header) {
                                if (isFunction(headerFn)) {
                                    headerContent = headerFn(config);
                                    if (headerContent != null) {
                                        processedHeaders[header] = headerContent;
                                    }
                                } else {
                                    processedHeaders[header] = headerFn;
                                }
                            });
                            return processedHeaders;
                        }
                        function mergeHeaders(config) {
                            var defHeaders = defaults.headers, reqHeaders = extend({}, config.headers), defHeaderName, lowercaseDefHeaderName, reqHeaderName;
                            defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                            defaultHeadersIteration:
                                for (defHeaderName in defHeaders) {
                                    lowercaseDefHeaderName = lowercase(defHeaderName);
                                    for (reqHeaderName in reqHeaders) {
                                        if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {
                                            continue defaultHeadersIteration;
                                        }
                                    }
                                    reqHeaders[defHeaderName] = defHeaders[defHeaderName];
                                }
                            return executeHeaderFns(reqHeaders, shallowCopy(config));
                        }
                    }
                    $http.pendingRequests = [];
                    createShortMethods('get', 'delete', 'head', 'jsonp');
                    createShortMethodsWithData('post', 'put', 'patch');
                    $http.defaults = defaults;
                    return $http;
                    function createShortMethods(names) {
                        forEach(arguments, function (name) {
                            $http[name] = function (url, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url: url
                                }));
                            };
                        });
                    }
                    function createShortMethodsWithData(name) {
                        forEach(arguments, function (name) {
                            $http[name] = function (url, data, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url: url,
                                    data: data
                                }));
                            };
                        });
                    }
                    function sendReq(config, reqData) {
                        var deferred = $q.defer(), promise = deferred.promise, cache, cachedResp, reqHeaders = config.headers, url = buildUrl(config.url, config.paramSerializer(config.params));
                        $http.pendingRequests.push(config);
                        promise.then(removePendingReq, removePendingReq);
                        if ((config.cache || defaults.cache) && config.cache !== false && (config.method === 'GET' || config.method === 'JSONP')) {
                            cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache;
                        }
                        if (cache) {
                            cachedResp = cache.get(url);
                            if (isDefined(cachedResp)) {
                                if (isPromiseLike(cachedResp)) {
                                    cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult);
                                } else {
                                    if (isArray(cachedResp)) {
                                        resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]);
                                    } else {
                                        resolvePromise(cachedResp, 200, {}, 'OK');
                                    }
                                }
                            } else {
                                cache.put(url, promise);
                            }
                        }
                        if (isUndefined(cachedResp)) {
                            var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : undefined;
                            if (xsrfValue) {
                                reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue;
                            }
                            $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers));
                        }
                        return promise;
                        function createApplyHandlers(eventHandlers) {
                            if (eventHandlers) {
                                var applyHandlers = {};
                                forEach(eventHandlers, function (eventHandler, key) {
                                    applyHandlers[key] = function (event) {
                                        if (useApplyAsync) {
                                            $rootScope.$applyAsync(callEventHandler);
                                        } else if ($rootScope.$$phase) {
                                            callEventHandler();
                                        } else {
                                            $rootScope.$apply(callEventHandler);
                                        }
                                        function callEventHandler() {
                                            eventHandler(event);
                                        }
                                    };
                                });
                                return applyHandlers;
                            }
                        }
                        function done(status, response, headersString, statusText) {
                            if (cache) {
                                if (isSuccess(status)) {
                                    cache.put(url, [
                                        status,
                                        response,
                                        parseHeaders(headersString),
                                        statusText
                                    ]);
                                } else {
                                    cache.remove(url);
                                }
                            }
                            function resolveHttpPromise() {
                                resolvePromise(response, status, headersString, statusText);
                            }
                            if (useApplyAsync) {
                                $rootScope.$applyAsync(resolveHttpPromise);
                            } else {
                                resolveHttpPromise();
                                if (!$rootScope.$$phase)
                                    $rootScope.$apply();
                            }
                        }
                        function resolvePromise(response, status, headers, statusText) {
                            status = status >= -1 ? status : 0;
                            (isSuccess(status) ? deferred.resolve : deferred.reject)({
                                data: response,
                                status: status,
                                headers: headersGetter(headers),
                                config: config,
                                statusText: statusText
                            });
                        }
                        function resolvePromiseWithResult(result) {
                            resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText);
                        }
                        function removePendingReq() {
                            var idx = $http.pendingRequests.indexOf(config);
                            if (idx !== -1)
                                $http.pendingRequests.splice(idx, 1);
                        }
                    }
                    function buildUrl(url, serializedParams) {
                        if (serializedParams.length > 0) {
                            url += (url.indexOf('?') == -1 ? '?' : '&') + serializedParams;
                        }
                        return url;
                    }
                }
            ];
        }
        function $xhrFactoryProvider() {
            this.$get = function () {
                return function createXhr() {
                    return new window.XMLHttpRequest();
                };
            };
        }
        function $HttpBackendProvider() {
            this.$get = [
                '$browser',
                '$window',
                '$document',
                '$xhrFactory',
                function ($browser, $window, $document, $xhrFactory) {
                    return createHttpBackend($browser, $xhrFactory, $browser.defer, $window.angular.callbacks, $document[0]);
                }
            ];
        }
        function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
            return function (method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
                $browser.$$incOutstandingRequestCount();
                url = url || $browser.url();
                if (lowercase(method) == 'jsonp') {
                    var callbackId = '_' + (callbacks.counter++).toString(36);
                    callbacks[callbackId] = function (data) {
                        callbacks[callbackId].data = data;
                        callbacks[callbackId].called = true;
                    };
                    var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId), callbackId, function (status, text) {
                        completeRequest(callback, status, callbacks[callbackId].data, '', text);
                        callbacks[callbackId] = noop;
                    });
                } else {
                    var xhr = createXhr(method, url);
                    xhr.open(method, url, true);
                    forEach(headers, function (value, key) {
                        if (isDefined(value)) {
                            xhr.setRequestHeader(key, value);
                        }
                    });
                    xhr.onload = function requestLoaded() {
                        var statusText = xhr.statusText || '';
                        var response = 'response' in xhr ? xhr.response : xhr.responseText;
                        var status = xhr.status === 1223 ? 204 : xhr.status;
                        if (status === 0) {
                            status = response ? 200 : urlResolve(url).protocol == 'file' ? 404 : 0;
                        }
                        completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText);
                    };
                    var requestError = function () {
                        completeRequest(callback, -1, null, null, '');
                    };
                    xhr.onerror = requestError;
                    xhr.onabort = requestError;
                    forEach(eventHandlers, function (value, key) {
                        xhr.addEventListener(key, value);
                    });
                    forEach(uploadEventHandlers, function (value, key) {
                        xhr.upload.addEventListener(key, value);
                    });
                    if (withCredentials) {
                        xhr.withCredentials = true;
                    }
                    if (responseType) {
                        try {
                            xhr.responseType = responseType;
                        } catch (e) {
                            if (responseType !== 'json') {
                                throw e;
                            }
                        }
                    }
                    xhr.send(isUndefined(post) ? null : post);
                }
                if (timeout > 0) {
                    var timeoutId = $browserDefer(timeoutRequest, timeout);
                } else if (isPromiseLike(timeout)) {
                    timeout.then(timeoutRequest);
                }
                function timeoutRequest() {
                    jsonpDone && jsonpDone();
                    xhr && xhr.abort();
                }
                function completeRequest(callback, status, response, headersString, statusText) {
                    if (isDefined(timeoutId)) {
                        $browserDefer.cancel(timeoutId);
                    }
                    jsonpDone = xhr = null;
                    callback(status, response, headersString, statusText);
                    $browser.$$completeOutstandingRequest(noop);
                }
            };
            function jsonpReq(url, callbackId, done) {
                var script = rawDocument.createElement('script'), callback = null;
                script.type = 'text/javascript';
                script.src = url;
                script.async = true;
                callback = function (event) {
                    removeEventListenerFn(script, 'load', callback);
                    removeEventListenerFn(script, 'error', callback);
                    rawDocument.body.removeChild(script);
                    script = null;
                    var status = -1;
                    var text = 'unknown';
                    if (event) {
                        if (event.type === 'load' && !callbacks[callbackId].called) {
                            event = { type: 'error' };
                        }
                        text = event.type;
                        status = event.type === 'error' ? 404 : 200;
                    }
                    if (done) {
                        done(status, text);
                    }
                };
                addEventListenerFn(script, 'load', callback);
                addEventListenerFn(script, 'error', callback);
                rawDocument.body.appendChild(script);
                return callback;
            }
        }
        var $interpolateMinErr = angular.$interpolateMinErr = minErr('$interpolate');
        $interpolateMinErr.throwNoconcat = function (text) {
            throw $interpolateMinErr('noconcat', 'Error while interpolating: {0}\nStrict Contextual Escaping disallows ' + 'interpolations that concatenate multiple expressions when a trusted value is ' + 'required.  See http://docs.angularjs.org/api/ng.$sce', text);
        };
        $interpolateMinErr.interr = function (text, err) {
            return $interpolateMinErr('interr', 'Can\'t interpolate: {0}\n{1}', text, err.toString());
        };
        function $InterpolateProvider() {
            var startSymbol = '{{';
            var endSymbol = '}}';
            this.startSymbol = function (value) {
                if (value) {
                    startSymbol = value;
                    return this;
                } else {
                    return startSymbol;
                }
            };
            this.endSymbol = function (value) {
                if (value) {
                    endSymbol = value;
                    return this;
                } else {
                    return endSymbol;
                }
            };
            this.$get = [
                '$parse',
                '$exceptionHandler',
                '$sce',
                function ($parse, $exceptionHandler, $sce) {
                    var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), 'g'), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), 'g');
                    function escape(ch) {
                        return '\\\\\\' + ch;
                    }
                    function unescapeText(text) {
                        return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol);
                    }
                    function stringify(value) {
                        if (value == null) {
                            return '';
                        }
                        switch (typeof value) {
                        case 'string':
                            break;
                        case 'number':
                            value = '' + value;
                            break;
                        default:
                            value = toJson(value);
                        }
                        return value;
                    }
                    function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                        var unwatch;
                        return unwatch = scope.$watch(function constantInterpolateWatch(scope) {
                            unwatch();
                            return constantInterp(scope);
                        }, listener, objectEquality);
                    }
                    function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                        if (!text.length || text.indexOf(startSymbol) === -1) {
                            var constantInterp;
                            if (!mustHaveExpression) {
                                var unescapedText = unescapeText(text);
                                constantInterp = valueFn(unescapedText);
                                constantInterp.exp = text;
                                constantInterp.expressions = [];
                                constantInterp.$$watchDelegate = constantWatchDelegate;
                            }
                            return constantInterp;
                        }
                        allOrNothing = !!allOrNothing;
                        var startIndex, endIndex, index = 0, expressions = [], parseFns = [], textLength = text.length, exp, concat = [], expressionPositions = [];
                        while (index < textLength) {
                            if ((startIndex = text.indexOf(startSymbol, index)) != -1 && (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) {
                                if (index !== startIndex) {
                                    concat.push(unescapeText(text.substring(index, startIndex)));
                                }
                                exp = text.substring(startIndex + startSymbolLength, endIndex);
                                expressions.push(exp);
                                parseFns.push($parse(exp, parseStringifyInterceptor));
                                index = endIndex + endSymbolLength;
                                expressionPositions.push(concat.length);
                                concat.push('');
                            } else {
                                if (index !== textLength) {
                                    concat.push(unescapeText(text.substring(index)));
                                }
                                break;
                            }
                        }
                        if (trustedContext && concat.length > 1) {
                            $interpolateMinErr.throwNoconcat(text);
                        }
                        if (!mustHaveExpression || expressions.length) {
                            var compute = function (values) {
                                for (var i = 0, ii = expressions.length; i < ii; i++) {
                                    if (allOrNothing && isUndefined(values[i]))
                                        return;
                                    concat[expressionPositions[i]] = values[i];
                                }
                                return concat.join('');
                            };
                            var getValue = function (value) {
                                return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value);
                            };
                            return extend(function interpolationFn(context) {
                                var i = 0;
                                var ii = expressions.length;
                                var values = new Array(ii);
                                try {
                                    for (; i < ii; i++) {
                                        values[i] = parseFns[i](context);
                                    }
                                    return compute(values);
                                } catch (err) {
                                    $exceptionHandler($interpolateMinErr.interr(text, err));
                                }
                            }, {
                                exp: text,
                                expressions: expressions,
                                $$watchDelegate: function (scope, listener) {
                                    var lastValue;
                                    return scope.$watchGroup(parseFns, function interpolateFnWatcher(values, oldValues) {
                                        var currValue = compute(values);
                                        if (isFunction(listener)) {
                                            listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope);
                                        }
                                        lastValue = currValue;
                                    });
                                }
                            });
                        }
                        function parseStringifyInterceptor(value) {
                            try {
                                value = getValue(value);
                                return allOrNothing && !isDefined(value) ? value : stringify(value);
                            } catch (err) {
                                $exceptionHandler($interpolateMinErr.interr(text, err));
                            }
                        }
                    }
                    $interpolate.startSymbol = function () {
                        return startSymbol;
                    };
                    $interpolate.endSymbol = function () {
                        return endSymbol;
                    };
                    return $interpolate;
                }
            ];
        }
        function $IntervalProvider() {
            this.$get = [
                '$rootScope',
                '$window',
                '$q',
                '$$q',
                '$browser',
                function ($rootScope, $window, $q, $$q, $browser) {
                    var intervals = {};
                    function interval(fn, delay, count, invokeApply) {
                        var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                        count = isDefined(count) ? count : 0;
                        promise.$$intervalId = setInterval(function tick() {
                            if (skipApply) {
                                $browser.defer(callback);
                            } else {
                                $rootScope.$evalAsync(callback);
                            }
                            deferred.notify(iteration++);
                            if (count > 0 && iteration >= count) {
                                deferred.resolve(iteration);
                                clearInterval(promise.$$intervalId);
                                delete intervals[promise.$$intervalId];
                            }
                            if (!skipApply)
                                $rootScope.$apply();
                        }, delay);
                        intervals[promise.$$intervalId] = deferred;
                        return promise;
                        function callback() {
                            if (!hasParams) {
                                fn(iteration);
                            } else {
                                fn.apply(null, args);
                            }
                        }
                    }
                    interval.cancel = function (promise) {
                        if (promise && promise.$$intervalId in intervals) {
                            intervals[promise.$$intervalId].reject('canceled');
                            $window.clearInterval(promise.$$intervalId);
                            delete intervals[promise.$$intervalId];
                            return true;
                        }
                        return false;
                    };
                    return interval;
                }
            ];
        }
        var PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
                'http': 80,
                'https': 443,
                'ftp': 21
            };
        var $locationMinErr = minErr('$location');
        function encodePath(path) {
            var segments = path.split('/'), i = segments.length;
            while (i--) {
                segments[i] = encodeUriSegment(segments[i]);
            }
            return segments.join('/');
        }
        function parseAbsoluteUrl(absoluteUrl, locationObj) {
            var parsedUrl = urlResolve(absoluteUrl);
            locationObj.$$protocol = parsedUrl.protocol;
            locationObj.$$host = parsedUrl.hostname;
            locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;
        }
        function parseAppUrl(relativeUrl, locationObj) {
            var prefixed = relativeUrl.charAt(0) !== '/';
            if (prefixed) {
                relativeUrl = '/' + relativeUrl;
            }
            var match = urlResolve(relativeUrl);
            locationObj.$$path = decodeURIComponent(prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname);
            locationObj.$$search = parseKeyValue(match.search);
            locationObj.$$hash = decodeURIComponent(match.hash);
            if (locationObj.$$path && locationObj.$$path.charAt(0) != '/') {
                locationObj.$$path = '/' + locationObj.$$path;
            }
        }
        function beginsWith(begin, whole) {
            if (whole.indexOf(begin) === 0) {
                return whole.substr(begin.length);
            }
        }
        function stripHash(url) {
            var index = url.indexOf('#');
            return index == -1 ? url : url.substr(0, index);
        }
        function trimEmptyHash(url) {
            return url.replace(/(#.+)|#$/, '$1');
        }
        function stripFile(url) {
            return url.substr(0, stripHash(url).lastIndexOf('/') + 1);
        }
        function serverBase(url) {
            return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));
        }
        function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
            this.$$html5 = true;
            basePrefix = basePrefix || '';
            parseAbsoluteUrl(appBase, this);
            this.$$parse = function (url) {
                var pathUrl = beginsWith(appBaseNoFile, url);
                if (!isString(pathUrl)) {
                    throw $locationMinErr('ipthprfx', 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                }
                parseAppUrl(pathUrl, this);
                if (!this.$$path) {
                    this.$$path = '/';
                }
                this.$$compose();
            };
            this.$$compose = function () {
                var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
                this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
                this.$$absUrl = appBaseNoFile + this.$$url.substr(1);
            };
            this.$$parseLinkUrl = function (url, relHref) {
                if (relHref && relHref[0] === '#') {
                    this.hash(relHref.slice(1));
                    return true;
                }
                var appUrl, prevAppUrl;
                var rewrittenUrl;
                if (isDefined(appUrl = beginsWith(appBase, url))) {
                    prevAppUrl = appUrl;
                    if (isDefined(appUrl = beginsWith(basePrefix, appUrl))) {
                        rewrittenUrl = appBaseNoFile + (beginsWith('/', appUrl) || appUrl);
                    } else {
                        rewrittenUrl = appBase + prevAppUrl;
                    }
                } else if (isDefined(appUrl = beginsWith(appBaseNoFile, url))) {
                    rewrittenUrl = appBaseNoFile + appUrl;
                } else if (appBaseNoFile == url + '/') {
                    rewrittenUrl = appBaseNoFile;
                }
                if (rewrittenUrl) {
                    this.$$parse(rewrittenUrl);
                }
                return !!rewrittenUrl;
            };
        }
        function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
            parseAbsoluteUrl(appBase, this);
            this.$$parse = function (url) {
                var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);
                var withoutHashUrl;
                if (!isUndefined(withoutBaseUrl) && withoutBaseUrl.charAt(0) === '#') {
                    withoutHashUrl = beginsWith(hashPrefix, withoutBaseUrl);
                    if (isUndefined(withoutHashUrl)) {
                        withoutHashUrl = withoutBaseUrl;
                    }
                } else {
                    if (this.$$html5) {
                        withoutHashUrl = withoutBaseUrl;
                    } else {
                        withoutHashUrl = '';
                        if (isUndefined(withoutBaseUrl)) {
                            appBase = url;
                            this.replace();
                        }
                    }
                }
                parseAppUrl(withoutHashUrl, this);
                this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase);
                this.$$compose();
                function removeWindowsDriveName(path, url, base) {
                    var windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                    var firstPathSegmentMatch;
                    if (url.indexOf(base) === 0) {
                        url = url.replace(base, '');
                    }
                    if (windowsFilePathExp.exec(url)) {
                        return path;
                    }
                    firstPathSegmentMatch = windowsFilePathExp.exec(path);
                    return firstPathSegmentMatch ? firstPathSegmentMatch[1] : path;
                }
            };
            this.$$compose = function () {
                var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
                this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
                this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');
            };
            this.$$parseLinkUrl = function (url, relHref) {
                if (stripHash(appBase) == stripHash(url)) {
                    this.$$parse(url);
                    return true;
                }
                return false;
            };
        }
        function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
            this.$$html5 = true;
            LocationHashbangUrl.apply(this, arguments);
            this.$$parseLinkUrl = function (url, relHref) {
                if (relHref && relHref[0] === '#') {
                    this.hash(relHref.slice(1));
                    return true;
                }
                var rewrittenUrl;
                var appUrl;
                if (appBase == stripHash(url)) {
                    rewrittenUrl = url;
                } else if (appUrl = beginsWith(appBaseNoFile, url)) {
                    rewrittenUrl = appBase + hashPrefix + appUrl;
                } else if (appBaseNoFile === url + '/') {
                    rewrittenUrl = appBaseNoFile;
                }
                if (rewrittenUrl) {
                    this.$$parse(rewrittenUrl);
                }
                return !!rewrittenUrl;
            };
            this.$$compose = function () {
                var search = toKeyValue(this.$$search), hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';
                this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;
                this.$$absUrl = appBase + hashPrefix + this.$$url;
            };
        }
        var locationPrototype = {
            $$html5: false,
            $$replace: false,
            absUrl: locationGetter('$$absUrl'),
            url: function (url) {
                if (isUndefined(url)) {
                    return this.$$url;
                }
                var match = PATH_MATCH.exec(url);
                if (match[1] || url === '')
                    this.path(decodeURIComponent(match[1]));
                if (match[2] || match[1] || url === '')
                    this.search(match[3] || '');
                this.hash(match[5] || '');
                return this;
            },
            protocol: locationGetter('$$protocol'),
            host: locationGetter('$$host'),
            port: locationGetter('$$port'),
            path: locationGetterSetter('$$path', function (path) {
                path = path !== null ? path.toString() : '';
                return path.charAt(0) == '/' ? path : '/' + path;
            }),
            search: function (search, paramValue) {
                switch (arguments.length) {
                case 0:
                    return this.$$search;
                case 1:
                    if (isString(search) || isNumber(search)) {
                        search = search.toString();
                        this.$$search = parseKeyValue(search);
                    } else if (isObject(search)) {
                        search = copy(search, {});
                        forEach(search, function (value, key) {
                            if (value == null)
                                delete search[key];
                        });
                        this.$$search = search;
                    } else {
                        throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');
                    }
                    break;
                default:
                    if (isUndefined(paramValue) || paramValue === null) {
                        delete this.$$search[search];
                    } else {
                        this.$$search[search] = paramValue;
                    }
                }
                this.$$compose();
                return this;
            },
            hash: locationGetterSetter('$$hash', function (hash) {
                return hash !== null ? hash.toString() : '';
            }),
            replace: function () {
                this.$$replace = true;
                return this;
            }
        };
        forEach([
            LocationHashbangInHtml5Url,
            LocationHashbangUrl,
            LocationHtml5Url
        ], function (Location) {
            Location.prototype = Object.create(locationPrototype);
            Location.prototype.state = function (state) {
                if (!arguments.length) {
                    return this.$$state;
                }
                if (Location !== LocationHtml5Url || !this.$$html5) {
                    throw $locationMinErr('nostate', 'History API state support is available only ' + 'in HTML5 mode and only in browsers supporting HTML5 History API');
                }
                this.$$state = isUndefined(state) ? null : state;
                return this;
            };
        });
        function locationGetter(property) {
            return function () {
                return this[property];
            };
        }
        function locationGetterSetter(property, preprocess) {
            return function (value) {
                if (isUndefined(value)) {
                    return this[property];
                }
                this[property] = preprocess(value);
                this.$$compose();
                return this;
            };
        }
        function $LocationProvider() {
            var hashPrefix = '', html5Mode = {
                    enabled: false,
                    requireBase: true,
                    rewriteLinks: true
                };
            this.hashPrefix = function (prefix) {
                if (isDefined(prefix)) {
                    hashPrefix = prefix;
                    return this;
                } else {
                    return hashPrefix;
                }
            };
            this.html5Mode = function (mode) {
                if (isBoolean(mode)) {
                    html5Mode.enabled = mode;
                    return this;
                } else if (isObject(mode)) {
                    if (isBoolean(mode.enabled)) {
                        html5Mode.enabled = mode.enabled;
                    }
                    if (isBoolean(mode.requireBase)) {
                        html5Mode.requireBase = mode.requireBase;
                    }
                    if (isBoolean(mode.rewriteLinks)) {
                        html5Mode.rewriteLinks = mode.rewriteLinks;
                    }
                    return this;
                } else {
                    return html5Mode;
                }
            };
            this.$get = [
                '$rootScope',
                '$browser',
                '$sniffer',
                '$rootElement',
                '$window',
                function ($rootScope, $browser, $sniffer, $rootElement, $window) {
                    var $location, LocationMode, baseHref = $browser.baseHref(), initialUrl = $browser.url(), appBase;
                    if (html5Mode.enabled) {
                        if (!baseHref && html5Mode.requireBase) {
                            throw $locationMinErr('nobase', '$location in HTML5 mode requires a <base> tag to be present!');
                        }
                        appBase = serverBase(initialUrl) + (baseHref || '/');
                        LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;
                    } else {
                        appBase = stripHash(initialUrl);
                        LocationMode = LocationHashbangUrl;
                    }
                    var appBaseNoFile = stripFile(appBase);
                    $location = new LocationMode(appBase, appBaseNoFile, '#' + hashPrefix);
                    $location.$$parseLinkUrl(initialUrl, initialUrl);
                    $location.$$state = $browser.state();
                    var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
                    function setBrowserUrlWithFallback(url, replace, state) {
                        var oldUrl = $location.url();
                        var oldState = $location.$$state;
                        try {
                            $browser.url(url, replace, state);
                            $location.$$state = $browser.state();
                        } catch (e) {
                            $location.url(oldUrl);
                            $location.$$state = oldState;
                            throw e;
                        }
                    }
                    $rootElement.on('click', function (event) {
                        if (!html5Mode.rewriteLinks || event.ctrlKey || event.metaKey || event.shiftKey || event.which == 2 || event.button == 2)
                            return;
                        var elm = jqLite(event.target);
                        while (nodeName_(elm[0]) !== 'a') {
                            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])
                                return;
                        }
                        var absHref = elm.prop('href');
                        var relHref = elm.attr('href') || elm.attr('xlink:href');
                        if (isObject(absHref) && absHref.toString() === '[object SVGAnimatedString]') {
                            absHref = urlResolve(absHref.animVal).href;
                        }
                        if (IGNORE_URI_REGEXP.test(absHref))
                            return;
                        if (absHref && !elm.attr('target') && !event.isDefaultPrevented()) {
                            if ($location.$$parseLinkUrl(absHref, relHref)) {
                                event.preventDefault();
                                if ($location.absUrl() != $browser.url()) {
                                    $rootScope.$apply();
                                    $window.angular['ff-684208-preventDefault'] = true;
                                }
                            }
                        }
                    });
                    if (trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl)) {
                        $browser.url($location.absUrl(), true);
                    }
                    var initializing = true;
                    $browser.onUrlChange(function (newUrl, newState) {
                        if (isUndefined(beginsWith(appBaseNoFile, newUrl))) {
                            $window.location.href = newUrl;
                            return;
                        }
                        $rootScope.$evalAsync(function () {
                            var oldUrl = $location.absUrl();
                            var oldState = $location.$$state;
                            var defaultPrevented;
                            newUrl = trimEmptyHash(newUrl);
                            $location.$$parse(newUrl);
                            $location.$$state = newState;
                            defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState).defaultPrevented;
                            if ($location.absUrl() !== newUrl)
                                return;
                            if (defaultPrevented) {
                                $location.$$parse(oldUrl);
                                $location.$$state = oldState;
                                setBrowserUrlWithFallback(oldUrl, false, oldState);
                            } else {
                                initializing = false;
                                afterLocationChange(oldUrl, oldState);
                            }
                        });
                        if (!$rootScope.$$phase)
                            $rootScope.$digest();
                    });
                    $rootScope.$watch(function $locationWatch() {
                        var oldUrl = trimEmptyHash($browser.url());
                        var newUrl = trimEmptyHash($location.absUrl());
                        var oldState = $browser.state();
                        var currentReplace = $location.$$replace;
                        var urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                        if (initializing || urlOrStateChanged) {
                            initializing = false;
                            $rootScope.$evalAsync(function () {
                                var newUrl = $location.absUrl();
                                var defaultPrevented = $rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                                if ($location.absUrl() !== newUrl)
                                    return;
                                if (defaultPrevented) {
                                    $location.$$parse(oldUrl);
                                    $location.$$state = oldState;
                                } else {
                                    if (urlOrStateChanged) {
                                        setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state);
                                    }
                                    afterLocationChange(oldUrl, oldState);
                                }
                            });
                        }
                        $location.$$replace = false;
                    });
                    return $location;
                    function afterLocationChange(oldUrl, oldState) {
                        $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl, $location.$$state, oldState);
                    }
                }
            ];
        }
        function $LogProvider() {
            var debug = true, self = this;
            this.debugEnabled = function (flag) {
                if (isDefined(flag)) {
                    debug = flag;
                    return this;
                } else {
                    return debug;
                }
            };
            this.$get = [
                '$window',
                function ($window) {
                    return {
                        log: consoleLog('log'),
                        info: consoleLog('info'),
                        warn: consoleLog('warn'),
                        error: consoleLog('error'),
                        debug: function () {
                            var fn = consoleLog('debug');
                            return function () {
                                if (debug) {
                                    fn.apply(self, arguments);
                                }
                            };
                        }()
                    };
                    function formatError(arg) {
                        if (arg instanceof Error) {
                            if (arg.stack) {
                                arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? 'Error: ' + arg.message + '\n' + arg.stack : arg.stack;
                            } else if (arg.sourceURL) {
                                arg = arg.message + '\n' + arg.sourceURL + ':' + arg.line;
                            }
                        }
                        return arg;
                    }
                    function consoleLog(type) {
                        var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = false;
                        try {
                            hasApply = !!logFn.apply;
                        } catch (e) {
                        }
                        if (hasApply) {
                            return function () {
                                var args = [];
                                forEach(arguments, function (arg) {
                                    args.push(formatError(arg));
                                });
                                return logFn.apply(console, args);
                            };
                        }
                        return function (arg1, arg2) {
                            logFn(arg1, arg2 == null ? '' : arg2);
                        };
                    }
                }
            ];
        }
        var $parseMinErr = minErr('$parse');
        function ensureSafeMemberName(name, fullExpression) {
            if (name === '__defineGetter__' || name === '__defineSetter__' || name === '__lookupGetter__' || name === '__lookupSetter__' || name === '__proto__') {
                throw $parseMinErr('isecfld', 'Attempting to access a disallowed field in Angular expressions! ' + 'Expression: {0}', fullExpression);
            }
            return name;
        }
        function getStringValue(name) {
            return name + '';
        }
        function ensureSafeObject(obj, fullExpression) {
            if (obj) {
                if (obj.constructor === obj) {
                    throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
                } else if (obj.window === obj) {
                    throw $parseMinErr('isecwindow', 'Referencing the Window in Angular expressions is disallowed! Expression: {0}', fullExpression);
                } else if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find)) {
                    throw $parseMinErr('isecdom', 'Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}', fullExpression);
                } else if (obj === Object) {
                    throw $parseMinErr('isecobj', 'Referencing Object in Angular expressions is disallowed! Expression: {0}', fullExpression);
                }
            }
            return obj;
        }
        var CALL = Function.prototype.call;
        var APPLY = Function.prototype.apply;
        var BIND = Function.prototype.bind;
        function ensureSafeFunction(obj, fullExpression) {
            if (obj) {
                if (obj.constructor === obj) {
                    throw $parseMinErr('isecfn', 'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);
                } else if (obj === CALL || obj === APPLY || obj === BIND) {
                    throw $parseMinErr('isecff', 'Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}', fullExpression);
                }
            }
        }
        function ensureSafeAssignContext(obj, fullExpression) {
            if (obj) {
                if (obj === 0..constructor || obj === false.constructor || obj === ''.constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor) {
                    throw $parseMinErr('isecaf', 'Assigning to a constructor is disallowed! Expression: {0}', fullExpression);
                }
            }
        }
        var OPERATORS = createMap();
        forEach('+ - * / % === !== == != < > <= >= && || ! = |'.split(' '), function (operator) {
            OPERATORS[operator] = true;
        });
        var ESCAPE = {
            'n': '\n',
            'f': '\f',
            'r': '\r',
            't': '\t',
            'v': '\x0B',
            '\'': '\'',
            '"': '"'
        };
        var Lexer = function (options) {
            this.options = options;
        };
        Lexer.prototype = {
            constructor: Lexer,
            lex: function (text) {
                this.text = text;
                this.index = 0;
                this.tokens = [];
                while (this.index < this.text.length) {
                    var ch = this.text.charAt(this.index);
                    if (ch === '"' || ch === '\'') {
                        this.readString(ch);
                    } else if (this.isNumber(ch) || ch === '.' && this.isNumber(this.peek())) {
                        this.readNumber();
                    } else if (this.isIdentifierStart(this.peekMultichar())) {
                        this.readIdent();
                    } else if (this.is(ch, '(){}[].,;:?')) {
                        this.tokens.push({
                            index: this.index,
                            text: ch
                        });
                        this.index++;
                    } else if (this.isWhitespace(ch)) {
                        this.index++;
                    } else {
                        var ch2 = ch + this.peek();
                        var ch3 = ch2 + this.peek(2);
                        var op1 = OPERATORS[ch];
                        var op2 = OPERATORS[ch2];
                        var op3 = OPERATORS[ch3];
                        if (op1 || op2 || op3) {
                            var token = op3 ? ch3 : op2 ? ch2 : ch;
                            this.tokens.push({
                                index: this.index,
                                text: token,
                                operator: true
                            });
                            this.index += token.length;
                        } else {
                            this.throwError('Unexpected next character ', this.index, this.index + 1);
                        }
                    }
                }
                return this.tokens;
            },
            is: function (ch, chars) {
                return chars.indexOf(ch) !== -1;
            },
            peek: function (i) {
                var num = i || 1;
                return this.index + num < this.text.length ? this.text.charAt(this.index + num) : false;
            },
            isNumber: function (ch) {
                return '0' <= ch && ch <= '9' && typeof ch === 'string';
            },
            isWhitespace: function (ch) {
                return ch === ' ' || ch === '\r' || ch === '\t' || ch === '\n' || ch === '\x0B' || ch === '\xA0';
            },
            isIdentifierStart: function (ch) {
                return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch);
            },
            isValidIdentifierStart: function (ch) {
                return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || '_' === ch || ch === '$';
            },
            isIdentifierContinue: function (ch) {
                return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch);
            },
            isValidIdentifierContinue: function (ch, cp) {
                return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch);
            },
            codePointAt: function (ch) {
                if (ch.length === 1)
                    return ch.charCodeAt(0);
                return (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888;
            },
            peekMultichar: function () {
                var ch = this.text.charAt(this.index);
                var peek = this.peek();
                if (!peek) {
                    return ch;
                }
                var cp1 = ch.charCodeAt(0);
                var cp2 = peek.charCodeAt(0);
                if (cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343) {
                    return ch + peek;
                }
                return ch;
            },
            isExpOperator: function (ch) {
                return ch === '-' || ch === '+' || this.isNumber(ch);
            },
            throwError: function (error, start, end) {
                end = end || this.index;
                var colStr = isDefined(start) ? 's ' + start + '-' + this.index + ' [' + this.text.substring(start, end) + ']' : ' ' + end;
                throw $parseMinErr('lexerr', 'Lexer Error: {0} at column{1} in expression [{2}].', error, colStr, this.text);
            },
            readNumber: function () {
                var number = '';
                var start = this.index;
                while (this.index < this.text.length) {
                    var ch = lowercase(this.text.charAt(this.index));
                    if (ch == '.' || this.isNumber(ch)) {
                        number += ch;
                    } else {
                        var peekCh = this.peek();
                        if (ch == 'e' && this.isExpOperator(peekCh)) {
                            number += ch;
                        } else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && number.charAt(number.length - 1) == 'e') {
                            number += ch;
                        } else if (this.isExpOperator(ch) && (!peekCh || !this.isNumber(peekCh)) && number.charAt(number.length - 1) == 'e') {
                            this.throwError('Invalid exponent');
                        } else {
                            break;
                        }
                    }
                    this.index++;
                }
                this.tokens.push({
                    index: start,
                    text: number,
                    constant: true,
                    value: Number(number)
                });
            },
            readIdent: function () {
                var start = this.index;
                this.index += this.peekMultichar().length;
                while (this.index < this.text.length) {
                    var ch = this.peekMultichar();
                    if (!this.isIdentifierContinue(ch)) {
                        break;
                    }
                    this.index += ch.length;
                }
                this.tokens.push({
                    index: start,
                    text: this.text.slice(start, this.index),
                    identifier: true
                });
            },
            readString: function (quote) {
                var start = this.index;
                this.index++;
                var string = '';
                var rawString = quote;
                var escape = false;
                while (this.index < this.text.length) {
                    var ch = this.text.charAt(this.index);
                    rawString += ch;
                    if (escape) {
                        if (ch === 'u') {
                            var hex = this.text.substring(this.index + 1, this.index + 5);
                            if (!hex.match(/[\da-f]{4}/i)) {
                                this.throwError('Invalid unicode escape [\\u' + hex + ']');
                            }
                            this.index += 4;
                            string += String.fromCharCode(parseInt(hex, 16));
                        } else {
                            var rep = ESCAPE[ch];
                            string = string + (rep || ch);
                        }
                        escape = false;
                    } else if (ch === '\\') {
                        escape = true;
                    } else if (ch === quote) {
                        this.index++;
                        this.tokens.push({
                            index: start,
                            text: rawString,
                            constant: true,
                            value: string
                        });
                        return;
                    } else {
                        string += ch;
                    }
                    this.index++;
                }
                this.throwError('Unterminated quote', start);
            }
        };
        var AST = function (lexer, options) {
            this.lexer = lexer;
            this.options = options;
        };
        AST.Program = 'Program';
        AST.ExpressionStatement = 'ExpressionStatement';
        AST.AssignmentExpression = 'AssignmentExpression';
        AST.ConditionalExpression = 'ConditionalExpression';
        AST.LogicalExpression = 'LogicalExpression';
        AST.BinaryExpression = 'BinaryExpression';
        AST.UnaryExpression = 'UnaryExpression';
        AST.CallExpression = 'CallExpression';
        AST.MemberExpression = 'MemberExpression';
        AST.Identifier = 'Identifier';
        AST.Literal = 'Literal';
        AST.ArrayExpression = 'ArrayExpression';
        AST.Property = 'Property';
        AST.ObjectExpression = 'ObjectExpression';
        AST.ThisExpression = 'ThisExpression';
        AST.LocalsExpression = 'LocalsExpression';
        AST.NGValueParameter = 'NGValueParameter';
        AST.prototype = {
            ast: function (text) {
                this.text = text;
                this.tokens = this.lexer.lex(text);
                var value = this.program();
                if (this.tokens.length !== 0) {
                    this.throwError('is an unexpected token', this.tokens[0]);
                }
                return value;
            },
            program: function () {
                var body = [];
                while (true) {
                    if (this.tokens.length > 0 && !this.peek('}', ')', ';', ']'))
                        body.push(this.expressionStatement());
                    if (!this.expect(';')) {
                        return {
                            type: AST.Program,
                            body: body
                        };
                    }
                }
            },
            expressionStatement: function () {
                return {
                    type: AST.ExpressionStatement,
                    expression: this.filterChain()
                };
            },
            filterChain: function () {
                var left = this.expression();
                var token;
                while (token = this.expect('|')) {
                    left = this.filter(left);
                }
                return left;
            },
            expression: function () {
                return this.assignment();
            },
            assignment: function () {
                var result = this.ternary();
                if (this.expect('=')) {
                    result = {
                        type: AST.AssignmentExpression,
                        left: result,
                        right: this.assignment(),
                        operator: '='
                    };
                }
                return result;
            },
            ternary: function () {
                var test = this.logicalOR();
                var alternate;
                var consequent;
                if (this.expect('?')) {
                    alternate = this.expression();
                    if (this.consume(':')) {
                        consequent = this.expression();
                        return {
                            type: AST.ConditionalExpression,
                            test: test,
                            alternate: alternate,
                            consequent: consequent
                        };
                    }
                }
                return test;
            },
            logicalOR: function () {
                var left = this.logicalAND();
                while (this.expect('||')) {
                    left = {
                        type: AST.LogicalExpression,
                        operator: '||',
                        left: left,
                        right: this.logicalAND()
                    };
                }
                return left;
            },
            logicalAND: function () {
                var left = this.equality();
                while (this.expect('&&')) {
                    left = {
                        type: AST.LogicalExpression,
                        operator: '&&',
                        left: left,
                        right: this.equality()
                    };
                }
                return left;
            },
            equality: function () {
                var left = this.relational();
                var token;
                while (token = this.expect('==', '!=', '===', '!==')) {
                    left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.relational()
                    };
                }
                return left;
            },
            relational: function () {
                var left = this.additive();
                var token;
                while (token = this.expect('<', '>', '<=', '>=')) {
                    left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.additive()
                    };
                }
                return left;
            },
            additive: function () {
                var left = this.multiplicative();
                var token;
                while (token = this.expect('+', '-')) {
                    left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.multiplicative()
                    };
                }
                return left;
            },
            multiplicative: function () {
                var left = this.unary();
                var token;
                while (token = this.expect('*', '/', '%')) {
                    left = {
                        type: AST.BinaryExpression,
                        operator: token.text,
                        left: left,
                        right: this.unary()
                    };
                }
                return left;
            },
            unary: function () {
                var token;
                if (token = this.expect('+', '-', '!')) {
                    return {
                        type: AST.UnaryExpression,
                        operator: token.text,
                        prefix: true,
                        argument: this.unary()
                    };
                } else {
                    return this.primary();
                }
            },
            primary: function () {
                var primary;
                if (this.expect('(')) {
                    primary = this.filterChain();
                    this.consume(')');
                } else if (this.expect('[')) {
                    primary = this.arrayDeclaration();
                } else if (this.expect('{')) {
                    primary = this.object();
                } else if (this.selfReferential.hasOwnProperty(this.peek().text)) {
                    primary = copy(this.selfReferential[this.consume().text]);
                } else if (this.options.literals.hasOwnProperty(this.peek().text)) {
                    primary = {
                        type: AST.Literal,
                        value: this.options.literals[this.consume().text]
                    };
                } else if (this.peek().identifier) {
                    primary = this.identifier();
                } else if (this.peek().constant) {
                    primary = this.constant();
                } else {
                    this.throwError('not a primary expression', this.peek());
                }
                var next;
                while (next = this.expect('(', '[', '.')) {
                    if (next.text === '(') {
                        primary = {
                            type: AST.CallExpression,
                            callee: primary,
                            arguments: this.parseArguments()
                        };
                        this.consume(')');
                    } else if (next.text === '[') {
                        primary = {
                            type: AST.MemberExpression,
                            object: primary,
                            property: this.expression(),
                            computed: true
                        };
                        this.consume(']');
                    } else if (next.text === '.') {
                        primary = {
                            type: AST.MemberExpression,
                            object: primary,
                            property: this.identifier(),
                            computed: false
                        };
                    } else {
                        this.throwError('IMPOSSIBLE');
                    }
                }
                return primary;
            },
            filter: function (baseExpression) {
                var args = [baseExpression];
                var result = {
                    type: AST.CallExpression,
                    callee: this.identifier(),
                    arguments: args,
                    filter: true
                };
                while (this.expect(':')) {
                    args.push(this.expression());
                }
                return result;
            },
            parseArguments: function () {
                var args = [];
                if (this.peekToken().text !== ')') {
                    do {
                        args.push(this.expression());
                    } while (this.expect(','));
                }
                return args;
            },
            identifier: function () {
                var token = this.consume();
                if (!token.identifier) {
                    this.throwError('is not a valid identifier', token);
                }
                return {
                    type: AST.Identifier,
                    name: token.text
                };
            },
            constant: function () {
                return {
                    type: AST.Literal,
                    value: this.consume().value
                };
            },
            arrayDeclaration: function () {
                var elements = [];
                if (this.peekToken().text !== ']') {
                    do {
                        if (this.peek(']')) {
                            break;
                        }
                        elements.push(this.expression());
                    } while (this.expect(','));
                }
                this.consume(']');
                return {
                    type: AST.ArrayExpression,
                    elements: elements
                };
            },
            object: function () {
                var properties = [], property;
                if (this.peekToken().text !== '}') {
                    do {
                        if (this.peek('}')) {
                            break;
                        }
                        property = {
                            type: AST.Property,
                            kind: 'init'
                        };
                        if (this.peek().constant) {
                            property.key = this.constant();
                        } else if (this.peek().identifier) {
                            property.key = this.identifier();
                        } else {
                            this.throwError('invalid key', this.peek());
                        }
                        this.consume(':');
                        property.value = this.expression();
                        properties.push(property);
                    } while (this.expect(','));
                }
                this.consume('}');
                return {
                    type: AST.ObjectExpression,
                    properties: properties
                };
            },
            throwError: function (msg, token) {
                throw $parseMinErr('syntax', 'Syntax Error: Token \'{0}\' {1} at column {2} of the expression [{3}] starting at [{4}].', token.text, msg, token.index + 1, this.text, this.text.substring(token.index));
            },
            consume: function (e1) {
                if (this.tokens.length === 0) {
                    throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
                }
                var token = this.expect(e1);
                if (!token) {
                    this.throwError('is unexpected, expecting [' + e1 + ']', this.peek());
                }
                return token;
            },
            peekToken: function () {
                if (this.tokens.length === 0) {
                    throw $parseMinErr('ueoe', 'Unexpected end of expression: {0}', this.text);
                }
                return this.tokens[0];
            },
            peek: function (e1, e2, e3, e4) {
                return this.peekAhead(0, e1, e2, e3, e4);
            },
            peekAhead: function (i, e1, e2, e3, e4) {
                if (this.tokens.length > i) {
                    var token = this.tokens[i];
                    var t = token.text;
                    if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) {
                        return token;
                    }
                }
                return false;
            },
            expect: function (e1, e2, e3, e4) {
                var token = this.peek(e1, e2, e3, e4);
                if (token) {
                    this.tokens.shift();
                    return token;
                }
                return false;
            },
            selfReferential: {
                'this': { type: AST.ThisExpression },
                '$locals': { type: AST.LocalsExpression }
            }
        };
        function ifDefined(v, d) {
            return typeof v !== 'undefined' ? v : d;
        }
        function plusFn(l, r) {
            if (typeof l === 'undefined')
                return r;
            if (typeof r === 'undefined')
                return l;
            return l + r;
        }
        function isStateless($filter, filterName) {
            var fn = $filter(filterName);
            return !fn.$stateful;
        }
        function findConstantAndWatchExpressions(ast, $filter) {
            var allConstants;
            var argsToWatch;
            switch (ast.type) {
            case AST.Program:
                allConstants = true;
                forEach(ast.body, function (expr) {
                    findConstantAndWatchExpressions(expr.expression, $filter);
                    allConstants = allConstants && expr.expression.constant;
                });
                ast.constant = allConstants;
                break;
            case AST.Literal:
                ast.constant = true;
                ast.toWatch = [];
                break;
            case AST.UnaryExpression:
                findConstantAndWatchExpressions(ast.argument, $filter);
                ast.constant = ast.argument.constant;
                ast.toWatch = ast.argument.toWatch;
                break;
            case AST.BinaryExpression:
                findConstantAndWatchExpressions(ast.left, $filter);
                findConstantAndWatchExpressions(ast.right, $filter);
                ast.constant = ast.left.constant && ast.right.constant;
                ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
                break;
            case AST.LogicalExpression:
                findConstantAndWatchExpressions(ast.left, $filter);
                findConstantAndWatchExpressions(ast.right, $filter);
                ast.constant = ast.left.constant && ast.right.constant;
                ast.toWatch = ast.constant ? [] : [ast];
                break;
            case AST.ConditionalExpression:
                findConstantAndWatchExpressions(ast.test, $filter);
                findConstantAndWatchExpressions(ast.alternate, $filter);
                findConstantAndWatchExpressions(ast.consequent, $filter);
                ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant;
                ast.toWatch = ast.constant ? [] : [ast];
                break;
            case AST.Identifier:
                ast.constant = false;
                ast.toWatch = [ast];
                break;
            case AST.MemberExpression:
                findConstantAndWatchExpressions(ast.object, $filter);
                if (ast.computed) {
                    findConstantAndWatchExpressions(ast.property, $filter);
                }
                ast.constant = ast.object.constant && (!ast.computed || ast.property.constant);
                ast.toWatch = [ast];
                break;
            case AST.CallExpression:
                allConstants = ast.filter ? isStateless($filter, ast.callee.name) : false;
                argsToWatch = [];
                forEach(ast.arguments, function (expr) {
                    findConstantAndWatchExpressions(expr, $filter);
                    allConstants = allConstants && expr.constant;
                    if (!expr.constant) {
                        argsToWatch.push.apply(argsToWatch, expr.toWatch);
                    }
                });
                ast.constant = allConstants;
                ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
                break;
            case AST.AssignmentExpression:
                findConstantAndWatchExpressions(ast.left, $filter);
                findConstantAndWatchExpressions(ast.right, $filter);
                ast.constant = ast.left.constant && ast.right.constant;
                ast.toWatch = [ast];
                break;
            case AST.ArrayExpression:
                allConstants = true;
                argsToWatch = [];
                forEach(ast.elements, function (expr) {
                    findConstantAndWatchExpressions(expr, $filter);
                    allConstants = allConstants && expr.constant;
                    if (!expr.constant) {
                        argsToWatch.push.apply(argsToWatch, expr.toWatch);
                    }
                });
                ast.constant = allConstants;
                ast.toWatch = argsToWatch;
                break;
            case AST.ObjectExpression:
                allConstants = true;
                argsToWatch = [];
                forEach(ast.properties, function (property) {
                    findConstantAndWatchExpressions(property.value, $filter);
                    allConstants = allConstants && property.value.constant;
                    if (!property.value.constant) {
                        argsToWatch.push.apply(argsToWatch, property.value.toWatch);
                    }
                });
                ast.constant = allConstants;
                ast.toWatch = argsToWatch;
                break;
            case AST.ThisExpression:
                ast.constant = false;
                ast.toWatch = [];
                break;
            case AST.LocalsExpression:
                ast.constant = false;
                ast.toWatch = [];
                break;
            }
        }
        function getInputs(body) {
            if (body.length != 1)
                return;
            var lastExpression = body[0].expression;
            var candidate = lastExpression.toWatch;
            if (candidate.length !== 1)
                return candidate;
            return candidate[0] !== lastExpression ? candidate : undefined;
        }
        function isAssignable(ast) {
            return ast.type === AST.Identifier || ast.type === AST.MemberExpression;
        }
        function assignableAST(ast) {
            if (ast.body.length === 1 && isAssignable(ast.body[0].expression)) {
                return {
                    type: AST.AssignmentExpression,
                    left: ast.body[0].expression,
                    right: { type: AST.NGValueParameter },
                    operator: '='
                };
            }
        }
        function isLiteral(ast) {
            return ast.body.length === 0 || ast.body.length === 1 && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression);
        }
        function isConstant(ast) {
            return ast.constant;
        }
        function ASTCompiler(astBuilder, $filter) {
            this.astBuilder = astBuilder;
            this.$filter = $filter;
        }
        ASTCompiler.prototype = {
            compile: function (expression, expensiveChecks) {
                var self = this;
                var ast = this.astBuilder.ast(expression);
                this.state = {
                    nextId: 0,
                    filters: {},
                    expensiveChecks: expensiveChecks,
                    fn: {
                        vars: [],
                        body: [],
                        own: {}
                    },
                    assign: {
                        vars: [],
                        body: [],
                        own: {}
                    },
                    inputs: []
                };
                findConstantAndWatchExpressions(ast, self.$filter);
                var extra = '';
                var assignable;
                this.stage = 'assign';
                if (assignable = assignableAST(ast)) {
                    this.state.computing = 'assign';
                    var result = this.nextId();
                    this.recurse(assignable, result);
                    this.return_(result);
                    extra = 'fn.assign=' + this.generateFunction('assign', 's,v,l');
                }
                var toWatch = getInputs(ast.body);
                self.stage = 'inputs';
                forEach(toWatch, function (watch, key) {
                    var fnKey = 'fn' + key;
                    self.state[fnKey] = {
                        vars: [],
                        body: [],
                        own: {}
                    };
                    self.state.computing = fnKey;
                    var intoId = self.nextId();
                    self.recurse(watch, intoId);
                    self.return_(intoId);
                    self.state.inputs.push(fnKey);
                    watch.watchId = key;
                });
                this.state.computing = 'fn';
                this.stage = 'main';
                this.recurse(ast);
                var fnString = '"' + this.USE + ' ' + this.STRICT + '";\n' + this.filterPrefix() + 'var fn=' + this.generateFunction('fn', 's,l,a,i') + extra + this.watchFns() + 'return fn;';
                var fn = new Function('$filter', 'ensureSafeMemberName', 'ensureSafeObject', 'ensureSafeFunction', 'getStringValue', 'ensureSafeAssignContext', 'ifDefined', 'plus', 'text', fnString)(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
                this.state = this.stage = undefined;
                fn.literal = isLiteral(ast);
                fn.constant = isConstant(ast);
                return fn;
            },
            USE: 'use',
            STRICT: 'strict',
            watchFns: function () {
                var result = [];
                var fns = this.state.inputs;
                var self = this;
                forEach(fns, function (name) {
                    result.push('var ' + name + '=' + self.generateFunction(name, 's'));
                });
                if (fns.length) {
                    result.push('fn.inputs=[' + fns.join(',') + '];');
                }
                return result.join('');
            },
            generateFunction: function (name, params) {
                return 'function(' + params + '){' + this.varsPrefix(name) + this.body(name) + '};';
            },
            filterPrefix: function () {
                var parts = [];
                var self = this;
                forEach(this.state.filters, function (id, filter) {
                    parts.push(id + '=$filter(' + self.escape(filter) + ')');
                });
                if (parts.length)
                    return 'var ' + parts.join(',') + ';';
                return '';
            },
            varsPrefix: function (section) {
                return this.state[section].vars.length ? 'var ' + this.state[section].vars.join(',') + ';' : '';
            },
            body: function (section) {
                return this.state[section].body.join('');
            },
            recurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var left, right, self = this, args, expression;
                recursionFn = recursionFn || noop;
                if (!skipWatchIdCheck && isDefined(ast.watchId)) {
                    intoId = intoId || this.nextId();
                    this.if_('i', this.lazyAssign(intoId, this.computedMember('i', ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, true));
                    return;
                }
                switch (ast.type) {
                case AST.Program:
                    forEach(ast.body, function (expression, pos) {
                        self.recurse(expression.expression, undefined, undefined, function (expr) {
                            right = expr;
                        });
                        if (pos !== ast.body.length - 1) {
                            self.current().body.push(right, ';');
                        } else {
                            self.return_(right);
                        }
                    });
                    break;
                case AST.Literal:
                    expression = this.escape(ast.value);
                    this.assign(intoId, expression);
                    recursionFn(expression);
                    break;
                case AST.UnaryExpression:
                    this.recurse(ast.argument, undefined, undefined, function (expr) {
                        right = expr;
                    });
                    expression = ast.operator + '(' + this.ifDefined(right, 0) + ')';
                    this.assign(intoId, expression);
                    recursionFn(expression);
                    break;
                case AST.BinaryExpression:
                    this.recurse(ast.left, undefined, undefined, function (expr) {
                        left = expr;
                    });
                    this.recurse(ast.right, undefined, undefined, function (expr) {
                        right = expr;
                    });
                    if (ast.operator === '+') {
                        expression = this.plus(left, right);
                    } else if (ast.operator === '-') {
                        expression = this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0);
                    } else {
                        expression = '(' + left + ')' + ast.operator + '(' + right + ')';
                    }
                    this.assign(intoId, expression);
                    recursionFn(expression);
                    break;
                case AST.LogicalExpression:
                    intoId = intoId || this.nextId();
                    self.recurse(ast.left, intoId);
                    self.if_(ast.operator === '&&' ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId));
                    recursionFn(intoId);
                    break;
                case AST.ConditionalExpression:
                    intoId = intoId || this.nextId();
                    self.recurse(ast.test, intoId);
                    self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId));
                    recursionFn(intoId);
                    break;
                case AST.Identifier:
                    intoId = intoId || this.nextId();
                    if (nameId) {
                        nameId.context = self.stage === 'inputs' ? 's' : this.assign(this.nextId(), this.getHasOwnProperty('l', ast.name) + '?l:s');
                        nameId.computed = false;
                        nameId.name = ast.name;
                    }
                    ensureSafeMemberName(ast.name);
                    self.if_(self.stage === 'inputs' || self.not(self.getHasOwnProperty('l', ast.name)), function () {
                        self.if_(self.stage === 'inputs' || 's', function () {
                            if (create && create !== 1) {
                                self.if_(self.not(self.nonComputedMember('s', ast.name)), self.lazyAssign(self.nonComputedMember('s', ast.name), '{}'));
                            }
                            self.assign(intoId, self.nonComputedMember('s', ast.name));
                        });
                    }, intoId && self.lazyAssign(intoId, self.nonComputedMember('l', ast.name)));
                    if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) {
                        self.addEnsureSafeObject(intoId);
                    }
                    recursionFn(intoId);
                    break;
                case AST.MemberExpression:
                    left = nameId && (nameId.context = this.nextId()) || this.nextId();
                    intoId = intoId || this.nextId();
                    self.recurse(ast.object, left, undefined, function () {
                        self.if_(self.notNull(left), function () {
                            if (create && create !== 1) {
                                self.addEnsureSafeAssignContext(left);
                            }
                            if (ast.computed) {
                                right = self.nextId();
                                self.recurse(ast.property, right);
                                self.getStringValue(right);
                                self.addEnsureSafeMemberName(right);
                                if (create && create !== 1) {
                                    self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), '{}'));
                                }
                                expression = self.ensureSafeObject(self.computedMember(left, right));
                                self.assign(intoId, expression);
                                if (nameId) {
                                    nameId.computed = true;
                                    nameId.name = right;
                                }
                            } else {
                                ensureSafeMemberName(ast.property.name);
                                if (create && create !== 1) {
                                    self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), '{}'));
                                }
                                expression = self.nonComputedMember(left, ast.property.name);
                                if (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) {
                                    expression = self.ensureSafeObject(expression);
                                }
                                self.assign(intoId, expression);
                                if (nameId) {
                                    nameId.computed = false;
                                    nameId.name = ast.property.name;
                                }
                            }
                        }, function () {
                            self.assign(intoId, 'undefined');
                        });
                        recursionFn(intoId);
                    }, !!create);
                    break;
                case AST.CallExpression:
                    intoId = intoId || this.nextId();
                    if (ast.filter) {
                        right = self.filter(ast.callee.name);
                        args = [];
                        forEach(ast.arguments, function (expr) {
                            var argument = self.nextId();
                            self.recurse(expr, argument);
                            args.push(argument);
                        });
                        expression = right + '(' + args.join(',') + ')';
                        self.assign(intoId, expression);
                        recursionFn(intoId);
                    } else {
                        right = self.nextId();
                        left = {};
                        args = [];
                        self.recurse(ast.callee, right, left, function () {
                            self.if_(self.notNull(right), function () {
                                self.addEnsureSafeFunction(right);
                                forEach(ast.arguments, function (expr) {
                                    self.recurse(expr, self.nextId(), undefined, function (argument) {
                                        args.push(self.ensureSafeObject(argument));
                                    });
                                });
                                if (left.name) {
                                    if (!self.state.expensiveChecks) {
                                        self.addEnsureSafeObject(left.context);
                                    }
                                    expression = self.member(left.context, left.name, left.computed) + '(' + args.join(',') + ')';
                                } else {
                                    expression = right + '(' + args.join(',') + ')';
                                }
                                expression = self.ensureSafeObject(expression);
                                self.assign(intoId, expression);
                            }, function () {
                                self.assign(intoId, 'undefined');
                            });
                            recursionFn(intoId);
                        });
                    }
                    break;
                case AST.AssignmentExpression:
                    right = this.nextId();
                    left = {};
                    if (!isAssignable(ast.left)) {
                        throw $parseMinErr('lval', 'Trying to assign a value to a non l-value');
                    }
                    this.recurse(ast.left, undefined, left, function () {
                        self.if_(self.notNull(left.context), function () {
                            self.recurse(ast.right, right);
                            self.addEnsureSafeObject(self.member(left.context, left.name, left.computed));
                            self.addEnsureSafeAssignContext(left.context);
                            expression = self.member(left.context, left.name, left.computed) + ast.operator + right;
                            self.assign(intoId, expression);
                            recursionFn(intoId || expression);
                        });
                    }, 1);
                    break;
                case AST.ArrayExpression:
                    args = [];
                    forEach(ast.elements, function (expr) {
                        self.recurse(expr, self.nextId(), undefined, function (argument) {
                            args.push(argument);
                        });
                    });
                    expression = '[' + args.join(',') + ']';
                    this.assign(intoId, expression);
                    recursionFn(expression);
                    break;
                case AST.ObjectExpression:
                    args = [];
                    forEach(ast.properties, function (property) {
                        self.recurse(property.value, self.nextId(), undefined, function (expr) {
                            args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : '' + property.key.value) + ':' + expr);
                        });
                    });
                    expression = '{' + args.join(',') + '}';
                    this.assign(intoId, expression);
                    recursionFn(expression);
                    break;
                case AST.ThisExpression:
                    this.assign(intoId, 's');
                    recursionFn('s');
                    break;
                case AST.LocalsExpression:
                    this.assign(intoId, 'l');
                    recursionFn('l');
                    break;
                case AST.NGValueParameter:
                    this.assign(intoId, 'v');
                    recursionFn('v');
                    break;
                }
            },
            getHasOwnProperty: function (element, property) {
                var key = element + '.' + property;
                var own = this.current().own;
                if (!own.hasOwnProperty(key)) {
                    own[key] = this.nextId(false, element + '&&(' + this.escape(property) + ' in ' + element + ')');
                }
                return own[key];
            },
            assign: function (id, value) {
                if (!id)
                    return;
                this.current().body.push(id, '=', value, ';');
                return id;
            },
            filter: function (filterName) {
                if (!this.state.filters.hasOwnProperty(filterName)) {
                    this.state.filters[filterName] = this.nextId(true);
                }
                return this.state.filters[filterName];
            },
            ifDefined: function (id, defaultValue) {
                return 'ifDefined(' + id + ',' + this.escape(defaultValue) + ')';
            },
            plus: function (left, right) {
                return 'plus(' + left + ',' + right + ')';
            },
            return_: function (id) {
                this.current().body.push('return ', id, ';');
            },
            if_: function (test, alternate, consequent) {
                if (test === true) {
                    alternate();
                } else {
                    var body = this.current().body;
                    body.push('if(', test, '){');
                    alternate();
                    body.push('}');
                    if (consequent) {
                        body.push('else{');
                        consequent();
                        body.push('}');
                    }
                }
            },
            not: function (expression) {
                return '!(' + expression + ')';
            },
            notNull: function (expression) {
                return expression + '!=null';
            },
            nonComputedMember: function (left, right) {
                var SAFE_IDENTIFIER = /[$_a-zA-Z][$_a-zA-Z0-9]*/;
                var UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
                if (SAFE_IDENTIFIER.test(right)) {
                    return left + '.' + right;
                } else {
                    return left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]';
                }
            },
            computedMember: function (left, right) {
                return left + '[' + right + ']';
            },
            member: function (left, right, computed) {
                if (computed)
                    return this.computedMember(left, right);
                return this.nonComputedMember(left, right);
            },
            addEnsureSafeObject: function (item) {
                this.current().body.push(this.ensureSafeObject(item), ';');
            },
            addEnsureSafeMemberName: function (item) {
                this.current().body.push(this.ensureSafeMemberName(item), ';');
            },
            addEnsureSafeFunction: function (item) {
                this.current().body.push(this.ensureSafeFunction(item), ';');
            },
            addEnsureSafeAssignContext: function (item) {
                this.current().body.push(this.ensureSafeAssignContext(item), ';');
            },
            ensureSafeObject: function (item) {
                return 'ensureSafeObject(' + item + ',text)';
            },
            ensureSafeMemberName: function (item) {
                return 'ensureSafeMemberName(' + item + ',text)';
            },
            ensureSafeFunction: function (item) {
                return 'ensureSafeFunction(' + item + ',text)';
            },
            getStringValue: function (item) {
                this.assign(item, 'getStringValue(' + item + ')');
            },
            ensureSafeAssignContext: function (item) {
                return 'ensureSafeAssignContext(' + item + ',text)';
            },
            lazyRecurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var self = this;
                return function () {
                    self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck);
                };
            },
            lazyAssign: function (id, value) {
                var self = this;
                return function () {
                    self.assign(id, value);
                };
            },
            stringEscapeRegex: /[^ a-zA-Z0-9]/g,
            stringEscapeFn: function (c) {
                return '\\u' + ('0000' + c.charCodeAt(0).toString(16)).slice(-4);
            },
            escape: function (value) {
                if (isString(value))
                    return '\'' + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + '\'';
                if (isNumber(value))
                    return value.toString();
                if (value === true)
                    return 'true';
                if (value === false)
                    return 'false';
                if (value === null)
                    return 'null';
                if (typeof value === 'undefined')
                    return 'undefined';
                throw $parseMinErr('esc', 'IMPOSSIBLE');
            },
            nextId: function (skip, init) {
                var id = 'v' + this.state.nextId++;
                if (!skip) {
                    this.current().vars.push(id + (init ? '=' + init : ''));
                }
                return id;
            },
            current: function () {
                return this.state[this.state.computing];
            }
        };
        function ASTInterpreter(astBuilder, $filter) {
            this.astBuilder = astBuilder;
            this.$filter = $filter;
        }
        ASTInterpreter.prototype = {
            compile: function (expression, expensiveChecks) {
                var self = this;
                var ast = this.astBuilder.ast(expression);
                this.expression = expression;
                this.expensiveChecks = expensiveChecks;
                findConstantAndWatchExpressions(ast, self.$filter);
                var assignable;
                var assign;
                if (assignable = assignableAST(ast)) {
                    assign = this.recurse(assignable);
                }
                var toWatch = getInputs(ast.body);
                var inputs;
                if (toWatch) {
                    inputs = [];
                    forEach(toWatch, function (watch, key) {
                        var input = self.recurse(watch);
                        watch.input = input;
                        inputs.push(input);
                        watch.watchId = key;
                    });
                }
                var expressions = [];
                forEach(ast.body, function (expression) {
                    expressions.push(self.recurse(expression.expression));
                });
                var fn = ast.body.length === 0 ? noop : ast.body.length === 1 ? expressions[0] : function (scope, locals) {
                    var lastValue;
                    forEach(expressions, function (exp) {
                        lastValue = exp(scope, locals);
                    });
                    return lastValue;
                };
                if (assign) {
                    fn.assign = function (scope, value, locals) {
                        return assign(scope, locals, value);
                    };
                }
                if (inputs) {
                    fn.inputs = inputs;
                }
                fn.literal = isLiteral(ast);
                fn.constant = isConstant(ast);
                return fn;
            },
            recurse: function (ast, context, create) {
                var left, right, self = this, args, expression;
                if (ast.input) {
                    return this.inputs(ast.input, ast.watchId);
                }
                switch (ast.type) {
                case AST.Literal:
                    return this.value(ast.value, context);
                case AST.UnaryExpression:
                    right = this.recurse(ast.argument);
                    return this['unary' + ast.operator](right, context);
                case AST.BinaryExpression:
                    left = this.recurse(ast.left);
                    right = this.recurse(ast.right);
                    return this['binary' + ast.operator](left, right, context);
                case AST.LogicalExpression:
                    left = this.recurse(ast.left);
                    right = this.recurse(ast.right);
                    return this['binary' + ast.operator](left, right, context);
                case AST.ConditionalExpression:
                    return this['ternary?:'](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
                case AST.Identifier:
                    ensureSafeMemberName(ast.name, self.expression);
                    return self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
                case AST.MemberExpression:
                    left = this.recurse(ast.object, false, !!create);
                    if (!ast.computed) {
                        ensureSafeMemberName(ast.property.name, self.expression);
                        right = ast.property.name;
                    }
                    if (ast.computed)
                        right = this.recurse(ast.property);
                    return ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
                case AST.CallExpression:
                    args = [];
                    forEach(ast.arguments, function (expr) {
                        args.push(self.recurse(expr));
                    });
                    if (ast.filter)
                        right = this.$filter(ast.callee.name);
                    if (!ast.filter)
                        right = this.recurse(ast.callee, true);
                    return ast.filter ? function (scope, locals, assign, inputs) {
                        var values = [];
                        for (var i = 0; i < args.length; ++i) {
                            values.push(args[i](scope, locals, assign, inputs));
                        }
                        var value = right.apply(undefined, values, inputs);
                        return context ? {
                            context: undefined,
                            name: undefined,
                            value: value
                        } : value;
                    } : function (scope, locals, assign, inputs) {
                        var rhs = right(scope, locals, assign, inputs);
                        var value;
                        if (rhs.value != null) {
                            ensureSafeObject(rhs.context, self.expression);
                            ensureSafeFunction(rhs.value, self.expression);
                            var values = [];
                            for (var i = 0; i < args.length; ++i) {
                                values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                            }
                            value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression);
                        }
                        return context ? { value: value } : value;
                    };
                case AST.AssignmentExpression:
                    left = this.recurse(ast.left, true, 1);
                    right = this.recurse(ast.right);
                    return function (scope, locals, assign, inputs) {
                        var lhs = left(scope, locals, assign, inputs);
                        var rhs = right(scope, locals, assign, inputs);
                        ensureSafeObject(lhs.value, self.expression);
                        ensureSafeAssignContext(lhs.context);
                        lhs.context[lhs.name] = rhs;
                        return context ? { value: rhs } : rhs;
                    };
                case AST.ArrayExpression:
                    args = [];
                    forEach(ast.elements, function (expr) {
                        args.push(self.recurse(expr));
                    });
                    return function (scope, locals, assign, inputs) {
                        var value = [];
                        for (var i = 0; i < args.length; ++i) {
                            value.push(args[i](scope, locals, assign, inputs));
                        }
                        return context ? { value: value } : value;
                    };
                case AST.ObjectExpression:
                    args = [];
                    forEach(ast.properties, function (property) {
                        args.push({
                            key: property.key.type === AST.Identifier ? property.key.name : '' + property.key.value,
                            value: self.recurse(property.value)
                        });
                    });
                    return function (scope, locals, assign, inputs) {
                        var value = {};
                        for (var i = 0; i < args.length; ++i) {
                            value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                        }
                        return context ? { value: value } : value;
                    };
                case AST.ThisExpression:
                    return function (scope) {
                        return context ? { value: scope } : scope;
                    };
                case AST.LocalsExpression:
                    return function (scope, locals) {
                        return context ? { value: locals } : locals;
                    };
                case AST.NGValueParameter:
                    return function (scope, locals, assign) {
                        return context ? { value: assign } : assign;
                    };
                }
            },
            'unary+': function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    if (isDefined(arg)) {
                        arg = +arg;
                    } else {
                        arg = 0;
                    }
                    return context ? { value: arg } : arg;
                };
            },
            'unary-': function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    if (isDefined(arg)) {
                        arg = -arg;
                    } else {
                        arg = 0;
                    }
                    return context ? { value: arg } : arg;
                };
            },
            'unary!': function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = !argument(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary+': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs = right(scope, locals, assign, inputs);
                    var arg = plusFn(lhs, rhs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary-': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs = right(scope, locals, assign, inputs);
                    var arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                    return context ? { value: arg } : arg;
                };
            },
            'binary*': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary/': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary%': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary===': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary!==': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary==': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary!=': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary<': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary>': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary<=': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary>=': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary&&': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'binary||': function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            'ternary?:': function (test, alternate, consequent, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                    return context ? { value: arg } : arg;
                };
            },
            value: function (value, context) {
                return function () {
                    return context ? {
                        context: undefined,
                        name: undefined,
                        value: value
                    } : value;
                };
            },
            identifier: function (name, expensiveChecks, context, create, expression) {
                return function (scope, locals, assign, inputs) {
                    var base = locals && name in locals ? locals : scope;
                    if (create && create !== 1 && base && !base[name]) {
                        base[name] = {};
                    }
                    var value = base ? base[name] : undefined;
                    if (expensiveChecks) {
                        ensureSafeObject(value, expression);
                    }
                    if (context) {
                        return {
                            context: base,
                            name: name,
                            value: value
                        };
                    } else {
                        return value;
                    }
                };
            },
            computedMember: function (left, right, context, create, expression) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    var rhs;
                    var value;
                    if (lhs != null) {
                        rhs = right(scope, locals, assign, inputs);
                        rhs = getStringValue(rhs);
                        ensureSafeMemberName(rhs, expression);
                        if (create && create !== 1) {
                            ensureSafeAssignContext(lhs);
                            if (lhs && !lhs[rhs]) {
                                lhs[rhs] = {};
                            }
                        }
                        value = lhs[rhs];
                        ensureSafeObject(value, expression);
                    }
                    if (context) {
                        return {
                            context: lhs,
                            name: rhs,
                            value: value
                        };
                    } else {
                        return value;
                    }
                };
            },
            nonComputedMember: function (left, right, expensiveChecks, context, create, expression) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    if (create && create !== 1) {
                        ensureSafeAssignContext(lhs);
                        if (lhs && !lhs[right]) {
                            lhs[right] = {};
                        }
                    }
                    var value = lhs != null ? lhs[right] : undefined;
                    if (expensiveChecks || isPossiblyDangerousMemberName(right)) {
                        ensureSafeObject(value, expression);
                    }
                    if (context) {
                        return {
                            context: lhs,
                            name: right,
                            value: value
                        };
                    } else {
                        return value;
                    }
                };
            },
            inputs: function (input, watchId) {
                return function (scope, value, locals, inputs) {
                    if (inputs)
                        return inputs[watchId];
                    return input(scope, value, locals);
                };
            }
        };
        var Parser = function (lexer, $filter, options) {
            this.lexer = lexer;
            this.$filter = $filter;
            this.options = options;
            this.ast = new AST(lexer, options);
            this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter);
        };
        Parser.prototype = {
            constructor: Parser,
            parse: function (text) {
                return this.astCompiler.compile(text, this.options.expensiveChecks);
            }
        };
        function isPossiblyDangerousMemberName(name) {
            return name == 'constructor';
        }
        var objectValueOf = Object.prototype.valueOf;
        function getValueOf(value) {
            return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value);
        }
        function $ParseProvider() {
            var cacheDefault = createMap();
            var cacheExpensive = createMap();
            var literals = {
                'true': true,
                'false': false,
                'null': null,
                'undefined': undefined
            };
            var identStart, identContinue;
            this.addLiteral = function (literalName, literalValue) {
                literals[literalName] = literalValue;
            };
            this.setIdentifierFns = function (identifierStart, identifierContinue) {
                identStart = identifierStart;
                identContinue = identifierContinue;
                return this;
            };
            this.$get = [
                '$filter',
                function ($filter) {
                    var noUnsafeEval = csp().noUnsafeEval;
                    var $parseOptions = {
                            csp: noUnsafeEval,
                            expensiveChecks: false,
                            literals: copy(literals),
                            isIdentifierStart: isFunction(identStart) && identStart,
                            isIdentifierContinue: isFunction(identContinue) && identContinue
                        }, $parseOptionsExpensive = {
                            csp: noUnsafeEval,
                            expensiveChecks: true,
                            literals: copy(literals),
                            isIdentifierStart: isFunction(identStart) && identStart,
                            isIdentifierContinue: isFunction(identContinue) && identContinue
                        };
                    var runningChecksEnabled = false;
                    $parse.$$runningExpensiveChecks = function () {
                        return runningChecksEnabled;
                    };
                    return $parse;
                    function $parse(exp, interceptorFn, expensiveChecks) {
                        var parsedExpression, oneTime, cacheKey;
                        expensiveChecks = expensiveChecks || runningChecksEnabled;
                        switch (typeof exp) {
                        case 'string':
                            exp = exp.trim();
                            cacheKey = exp;
                            var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                            parsedExpression = cache[cacheKey];
                            if (!parsedExpression) {
                                if (exp.charAt(0) === ':' && exp.charAt(1) === ':') {
                                    oneTime = true;
                                    exp = exp.substring(2);
                                }
                                var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions;
                                var lexer = new Lexer(parseOptions);
                                var parser = new Parser(lexer, $filter, parseOptions);
                                parsedExpression = parser.parse(exp);
                                if (parsedExpression.constant) {
                                    parsedExpression.$$watchDelegate = constantWatchDelegate;
                                } else if (oneTime) {
                                    parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate;
                                } else if (parsedExpression.inputs) {
                                    parsedExpression.$$watchDelegate = inputsWatchDelegate;
                                }
                                if (expensiveChecks) {
                                    parsedExpression = expensiveChecksInterceptor(parsedExpression);
                                }
                                cache[cacheKey] = parsedExpression;
                            }
                            return addInterceptor(parsedExpression, interceptorFn);
                        case 'function':
                            return addInterceptor(exp, interceptorFn);
                        default:
                            return addInterceptor(noop, interceptorFn);
                        }
                    }
                    function expensiveChecksInterceptor(fn) {
                        if (!fn)
                            return fn;
                        expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate;
                        expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign);
                        expensiveCheckFn.constant = fn.constant;
                        expensiveCheckFn.literal = fn.literal;
                        for (var i = 0; fn.inputs && i < fn.inputs.length; ++i) {
                            fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
                        }
                        expensiveCheckFn.inputs = fn.inputs;
                        return expensiveCheckFn;
                        function expensiveCheckFn(scope, locals, assign, inputs) {
                            var expensiveCheckOldValue = runningChecksEnabled;
                            runningChecksEnabled = true;
                            try {
                                return fn(scope, locals, assign, inputs);
                            } finally {
                                runningChecksEnabled = expensiveCheckOldValue;
                            }
                        }
                    }
                    function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                        if (newValue == null || oldValueOfValue == null) {
                            return newValue === oldValueOfValue;
                        }
                        if (typeof newValue === 'object') {
                            newValue = getValueOf(newValue);
                            if (typeof newValue === 'object') {
                                return false;
                            }
                        }
                        return newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue;
                    }
                    function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                        var inputExpressions = parsedExpression.inputs;
                        var lastResult;
                        if (inputExpressions.length === 1) {
                            var oldInputValueOf = expressionInputDirtyCheck;
                            inputExpressions = inputExpressions[0];
                            return scope.$watch(function expressionInputWatch(scope) {
                                var newInputValue = inputExpressions(scope);
                                if (!expressionInputDirtyCheck(newInputValue, oldInputValueOf)) {
                                    lastResult = parsedExpression(scope, undefined, undefined, [newInputValue]);
                                    oldInputValueOf = newInputValue && getValueOf(newInputValue);
                                }
                                return lastResult;
                            }, listener, objectEquality, prettyPrintExpression);
                        }
                        var oldInputValueOfValues = [];
                        var oldInputValues = [];
                        for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                            oldInputValueOfValues[i] = expressionInputDirtyCheck;
                            oldInputValues[i] = null;
                        }
                        return scope.$watch(function expressionInputsWatch(scope) {
                            var changed = false;
                            for (var i = 0, ii = inputExpressions.length; i < ii; i++) {
                                var newInputValue = inputExpressions[i](scope);
                                if (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) {
                                    oldInputValues[i] = newInputValue;
                                    oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue);
                                }
                            }
                            if (changed) {
                                lastResult = parsedExpression(scope, undefined, undefined, oldInputValues);
                            }
                            return lastResult;
                        }, listener, objectEquality, prettyPrintExpression);
                    }
                    function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                        var unwatch, lastValue;
                        return unwatch = scope.$watch(function oneTimeWatch(scope) {
                            return parsedExpression(scope);
                        }, function oneTimeListener(value, old, scope) {
                            lastValue = value;
                            if (isFunction(listener)) {
                                listener.apply(this, arguments);
                            }
                            if (isDefined(value)) {
                                scope.$$postDigest(function () {
                                    if (isDefined(lastValue)) {
                                        unwatch();
                                    }
                                });
                            }
                        }, objectEquality);
                    }
                    function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                        var unwatch, lastValue;
                        return unwatch = scope.$watch(function oneTimeWatch(scope) {
                            return parsedExpression(scope);
                        }, function oneTimeListener(value, old, scope) {
                            lastValue = value;
                            if (isFunction(listener)) {
                                listener.call(this, value, old, scope);
                            }
                            if (isAllDefined(value)) {
                                scope.$$postDigest(function () {
                                    if (isAllDefined(lastValue))
                                        unwatch();
                                });
                            }
                        }, objectEquality);
                        function isAllDefined(value) {
                            var allDefined = true;
                            forEach(value, function (val) {
                                if (!isDefined(val))
                                    allDefined = false;
                            });
                            return allDefined;
                        }
                    }
                    function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                        var unwatch;
                        return unwatch = scope.$watch(function constantWatch(scope) {
                            unwatch();
                            return parsedExpression(scope);
                        }, listener, objectEquality);
                    }
                    function addInterceptor(parsedExpression, interceptorFn) {
                        if (!interceptorFn)
                            return parsedExpression;
                        var watchDelegate = parsedExpression.$$watchDelegate;
                        var useInputs = false;
                        var regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate;
                        var fn = regularWatch ? function regularInterceptedExpression(scope, locals, assign, inputs) {
                            var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                            return interceptorFn(value, scope, locals);
                        } : function oneTimeInterceptedExpression(scope, locals, assign, inputs) {
                            var value = parsedExpression(scope, locals, assign, inputs);
                            var result = interceptorFn(value, scope, locals);
                            return isDefined(value) ? result : value;
                        };
                        if (parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate) {
                            fn.$$watchDelegate = parsedExpression.$$watchDelegate;
                        } else if (!interceptorFn.$stateful) {
                            fn.$$watchDelegate = inputsWatchDelegate;
                            useInputs = !parsedExpression.inputs;
                            fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression];
                        }
                        return fn;
                    }
                }
            ];
        }
        function $QProvider() {
            this.$get = [
                '$rootScope',
                '$exceptionHandler',
                function ($rootScope, $exceptionHandler) {
                    return qFactory(function (callback) {
                        $rootScope.$evalAsync(callback);
                    }, $exceptionHandler);
                }
            ];
        }
        function $$QProvider() {
            this.$get = [
                '$browser',
                '$exceptionHandler',
                function ($browser, $exceptionHandler) {
                    return qFactory(function (callback) {
                        $browser.defer(callback);
                    }, $exceptionHandler);
                }
            ];
        }
        function qFactory(nextTick, exceptionHandler) {
            var $qMinErr = minErr('$q', TypeError);
            var defer = function () {
                var d = new Deferred();
                d.resolve = simpleBind(d, d.resolve);
                d.reject = simpleBind(d, d.reject);
                d.notify = simpleBind(d, d.notify);
                return d;
            };
            function Promise() {
                this.$$state = { status: 0 };
            }
            extend(Promise.prototype, {
                then: function (onFulfilled, onRejected, progressBack) {
                    if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) {
                        return this;
                    }
                    var result = new Deferred();
                    this.$$state.pending = this.$$state.pending || [];
                    this.$$state.pending.push([
                        result,
                        onFulfilled,
                        onRejected,
                        progressBack
                    ]);
                    if (this.$$state.status > 0)
                        scheduleProcessQueue(this.$$state);
                    return result.promise;
                },
                'catch': function (callback) {
                    return this.then(null, callback);
                },
                'finally': function (callback, progressBack) {
                    return this.then(function (value) {
                        return handleCallback(value, true, callback);
                    }, function (error) {
                        return handleCallback(error, false, callback);
                    }, progressBack);
                }
            });
            function simpleBind(context, fn) {
                return function (value) {
                    fn.call(context, value);
                };
            }
            function processQueue(state) {
                var fn, deferred, pending;
                pending = state.pending;
                state.processScheduled = false;
                state.pending = undefined;
                for (var i = 0, ii = pending.length; i < ii; ++i) {
                    deferred = pending[i][0];
                    fn = pending[i][state.status];
                    try {
                        if (isFunction(fn)) {
                            deferred.resolve(fn(state.value));
                        } else if (state.status === 1) {
                            deferred.resolve(state.value);
                        } else {
                            deferred.reject(state.value);
                        }
                    } catch (e) {
                        deferred.reject(e);
                        exceptionHandler(e);
                    }
                }
            }
            function scheduleProcessQueue(state) {
                if (state.processScheduled || !state.pending)
                    return;
                state.processScheduled = true;
                nextTick(function () {
                    processQueue(state);
                });
            }
            function Deferred() {
                this.promise = new Promise();
            }
            extend(Deferred.prototype, {
                resolve: function (val) {
                    if (this.promise.$$state.status)
                        return;
                    if (val === this.promise) {
                        this.$$reject($qMinErr('qcycle', 'Expected promise to be resolved with value other than itself \'{0}\'', val));
                    } else {
                        this.$$resolve(val);
                    }
                },
                $$resolve: function (val) {
                    var then;
                    var that = this;
                    var done = false;
                    try {
                        if (isObject(val) || isFunction(val))
                            then = val && val.then;
                        if (isFunction(then)) {
                            this.promise.$$state.status = -1;
                            then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify));
                        } else {
                            this.promise.$$state.value = val;
                            this.promise.$$state.status = 1;
                            scheduleProcessQueue(this.promise.$$state);
                        }
                    } catch (e) {
                        rejectPromise(e);
                        exceptionHandler(e);
                    }
                    function resolvePromise(val) {
                        if (done)
                            return;
                        done = true;
                        that.$$resolve(val);
                    }
                    function rejectPromise(val) {
                        if (done)
                            return;
                        done = true;
                        that.$$reject(val);
                    }
                },
                reject: function (reason) {
                    if (this.promise.$$state.status)
                        return;
                    this.$$reject(reason);
                },
                $$reject: function (reason) {
                    this.promise.$$state.value = reason;
                    this.promise.$$state.status = 2;
                    scheduleProcessQueue(this.promise.$$state);
                },
                notify: function (progress) {
                    var callbacks = this.promise.$$state.pending;
                    if (this.promise.$$state.status <= 0 && callbacks && callbacks.length) {
                        nextTick(function () {
                            var callback, result;
                            for (var i = 0, ii = callbacks.length; i < ii; i++) {
                                result = callbacks[i][0];
                                callback = callbacks[i][3];
                                try {
                                    result.notify(isFunction(callback) ? callback(progress) : progress);
                                } catch (e) {
                                    exceptionHandler(e);
                                }
                            }
                        });
                    }
                }
            });
            var reject = function (reason) {
                var result = new Deferred();
                result.reject(reason);
                return result.promise;
            };
            var makePromise = function makePromise(value, resolved) {
                var result = new Deferred();
                if (resolved) {
                    result.resolve(value);
                } else {
                    result.reject(value);
                }
                return result.promise;
            };
            var handleCallback = function handleCallback(value, isResolved, callback) {
                var callbackOutput = null;
                try {
                    if (isFunction(callback))
                        callbackOutput = callback();
                } catch (e) {
                    return makePromise(e, false);
                }
                if (isPromiseLike(callbackOutput)) {
                    return callbackOutput.then(function () {
                        return makePromise(value, isResolved);
                    }, function (error) {
                        return makePromise(error, false);
                    });
                } else {
                    return makePromise(value, isResolved);
                }
            };
            var when = function (value, callback, errback, progressBack) {
                var result = new Deferred();
                result.resolve(value);
                return result.promise.then(callback, errback, progressBack);
            };
            var resolve = when;
            function all(promises) {
                var deferred = new Deferred(), counter = 0, results = isArray(promises) ? [] : {};
                forEach(promises, function (promise, key) {
                    counter++;
                    when(promise).then(function (value) {
                        if (results.hasOwnProperty(key))
                            return;
                        results[key] = value;
                        if (!--counter)
                            deferred.resolve(results);
                    }, function (reason) {
                        if (results.hasOwnProperty(key))
                            return;
                        deferred.reject(reason);
                    });
                });
                if (counter === 0) {
                    deferred.resolve(results);
                }
                return deferred.promise;
            }
            var $Q = function Q(resolver) {
                if (!isFunction(resolver)) {
                    throw $qMinErr('norslvr', 'Expected resolverFn, got \'{0}\'', resolver);
                }
                var deferred = new Deferred();
                function resolveFn(value) {
                    deferred.resolve(value);
                }
                function rejectFn(reason) {
                    deferred.reject(reason);
                }
                resolver(resolveFn, rejectFn);
                return deferred.promise;
            };
            $Q.prototype = Promise.prototype;
            $Q.defer = defer;
            $Q.reject = reject;
            $Q.when = when;
            $Q.resolve = resolve;
            $Q.all = all;
            return $Q;
        }
        function $$RAFProvider() {
            this.$get = [
                '$window',
                '$timeout',
                function ($window, $timeout) {
                    var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame;
                    var cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame;
                    var rafSupported = !!requestAnimationFrame;
                    var raf = rafSupported ? function (fn) {
                        var id = requestAnimationFrame(fn);
                        return function () {
                            cancelAnimationFrame(id);
                        };
                    } : function (fn) {
                        var timer = $timeout(fn, 16.66, false);
                        return function () {
                            $timeout.cancel(timer);
                        };
                    };
                    raf.supported = rafSupported;
                    return raf;
                }
            ];
        }
        function $RootScopeProvider() {
            var TTL = 10;
            var $rootScopeMinErr = minErr('$rootScope');
            var lastDirtyWatch = null;
            var applyAsyncId = null;
            this.digestTtl = function (value) {
                if (arguments.length) {
                    TTL = value;
                }
                return TTL;
            };
            function createChildScopeClass(parent) {
                function ChildScope() {
                    this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null;
                    this.$$listeners = {};
                    this.$$listenerCount = {};
                    this.$$watchersCount = 0;
                    this.$id = nextUid();
                    this.$$ChildScope = null;
                }
                ChildScope.prototype = parent;
                return ChildScope;
            }
            this.$get = [
                '$exceptionHandler',
                '$parse',
                '$browser',
                function ($exceptionHandler, $parse, $browser) {
                    function destroyChildScope($event) {
                        $event.currentScope.$$destroyed = true;
                    }
                    function cleanUpScope($scope) {
                        if (msie === 9) {
                            $scope.$$childHead && cleanUpScope($scope.$$childHead);
                            $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling);
                        }
                        $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null;
                    }
                    function Scope() {
                        this.$id = nextUid();
                        this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null;
                        this.$root = this;
                        this.$$destroyed = false;
                        this.$$listeners = {};
                        this.$$listenerCount = {};
                        this.$$watchersCount = 0;
                        this.$$isolateBindings = null;
                    }
                    Scope.prototype = {
                        constructor: Scope,
                        $new: function (isolate, parent) {
                            var child;
                            parent = parent || this;
                            if (isolate) {
                                child = new Scope();
                                child.$root = this.$root;
                            } else {
                                if (!this.$$ChildScope) {
                                    this.$$ChildScope = createChildScopeClass(this);
                                }
                                child = new this.$$ChildScope();
                            }
                            child.$parent = parent;
                            child.$$prevSibling = parent.$$childTail;
                            if (parent.$$childHead) {
                                parent.$$childTail.$$nextSibling = child;
                                parent.$$childTail = child;
                            } else {
                                parent.$$childHead = parent.$$childTail = child;
                            }
                            if (isolate || parent != this)
                                child.$on('$destroy', destroyChildScope);
                            return child;
                        },
                        $watch: function (watchExp, listener, objectEquality, prettyPrintExpression) {
                            var get = $parse(watchExp);
                            if (get.$$watchDelegate) {
                                return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                            }
                            var scope = this, array = scope.$$watchers, watcher = {
                                    fn: listener,
                                    last: initWatchVal,
                                    get: get,
                                    exp: prettyPrintExpression || watchExp,
                                    eq: !!objectEquality
                                };
                            lastDirtyWatch = null;
                            if (!isFunction(listener)) {
                                watcher.fn = noop;
                            }
                            if (!array) {
                                array = scope.$$watchers = [];
                            }
                            array.unshift(watcher);
                            incrementWatchersCount(this, 1);
                            return function deregisterWatch() {
                                if (arrayRemove(array, watcher) >= 0) {
                                    incrementWatchersCount(scope, -1);
                                }
                                lastDirtyWatch = null;
                            };
                        },
                        $watchGroup: function (watchExpressions, listener) {
                            var oldValues = new Array(watchExpressions.length);
                            var newValues = new Array(watchExpressions.length);
                            var deregisterFns = [];
                            var self = this;
                            var changeReactionScheduled = false;
                            var firstRun = true;
                            if (!watchExpressions.length) {
                                var shouldCall = true;
                                self.$evalAsync(function () {
                                    if (shouldCall)
                                        listener(newValues, newValues, self);
                                });
                                return function deregisterWatchGroup() {
                                    shouldCall = false;
                                };
                            }
                            if (watchExpressions.length === 1) {
                                return this.$watch(watchExpressions[0], function watchGroupAction(value, oldValue, scope) {
                                    newValues[0] = value;
                                    oldValues[0] = oldValue;
                                    listener(newValues, value === oldValue ? newValues : oldValues, scope);
                                });
                            }
                            forEach(watchExpressions, function (expr, i) {
                                var unwatchFn = self.$watch(expr, function watchGroupSubAction(value, oldValue) {
                                    newValues[i] = value;
                                    oldValues[i] = oldValue;
                                    if (!changeReactionScheduled) {
                                        changeReactionScheduled = true;
                                        self.$evalAsync(watchGroupAction);
                                    }
                                });
                                deregisterFns.push(unwatchFn);
                            });
                            function watchGroupAction() {
                                changeReactionScheduled = false;
                                if (firstRun) {
                                    firstRun = false;
                                    listener(newValues, newValues, self);
                                } else {
                                    listener(newValues, oldValues, self);
                                }
                            }
                            return function deregisterWatchGroup() {
                                while (deregisterFns.length) {
                                    deregisterFns.shift()();
                                }
                            };
                        },
                        $watchCollection: function (obj, listener) {
                            $watchCollectionInterceptor.$stateful = true;
                            var self = this;
                            var newValue;
                            var oldValue;
                            var veryOldValue;
                            var trackVeryOldValue = listener.length > 1;
                            var changeDetected = 0;
                            var changeDetector = $parse(obj, $watchCollectionInterceptor);
                            var internalArray = [];
                            var internalObject = {};
                            var initRun = true;
                            var oldLength = 0;
                            function $watchCollectionInterceptor(_value) {
                                newValue = _value;
                                var newLength, key, bothNaN, newItem, oldItem;
                                if (isUndefined(newValue))
                                    return;
                                if (!isObject(newValue)) {
                                    if (oldValue !== newValue) {
                                        oldValue = newValue;
                                        changeDetected++;
                                    }
                                } else if (isArrayLike(newValue)) {
                                    if (oldValue !== internalArray) {
                                        oldValue = internalArray;
                                        oldLength = oldValue.length = 0;
                                        changeDetected++;
                                    }
                                    newLength = newValue.length;
                                    if (oldLength !== newLength) {
                                        changeDetected++;
                                        oldValue.length = oldLength = newLength;
                                    }
                                    for (var i = 0; i < newLength; i++) {
                                        oldItem = oldValue[i];
                                        newItem = newValue[i];
                                        bothNaN = oldItem !== oldItem && newItem !== newItem;
                                        if (!bothNaN && oldItem !== newItem) {
                                            changeDetected++;
                                            oldValue[i] = newItem;
                                        }
                                    }
                                } else {
                                    if (oldValue !== internalObject) {
                                        oldValue = internalObject = {};
                                        oldLength = 0;
                                        changeDetected++;
                                    }
                                    newLength = 0;
                                    for (key in newValue) {
                                        if (hasOwnProperty.call(newValue, key)) {
                                            newLength++;
                                            newItem = newValue[key];
                                            oldItem = oldValue[key];
                                            if (key in oldValue) {
                                                bothNaN = oldItem !== oldItem && newItem !== newItem;
                                                if (!bothNaN && oldItem !== newItem) {
                                                    changeDetected++;
                                                    oldValue[key] = newItem;
                                                }
                                            } else {
                                                oldLength++;
                                                oldValue[key] = newItem;
                                                changeDetected++;
                                            }
                                        }
                                    }
                                    if (oldLength > newLength) {
                                        changeDetected++;
                                        for (key in oldValue) {
                                            if (!hasOwnProperty.call(newValue, key)) {
                                                oldLength--;
                                                delete oldValue[key];
                                            }
                                        }
                                    }
                                }
                                return changeDetected;
                            }
                            function $watchCollectionAction() {
                                if (initRun) {
                                    initRun = false;
                                    listener(newValue, newValue, self);
                                } else {
                                    listener(newValue, veryOldValue, self);
                                }
                                if (trackVeryOldValue) {
                                    if (!isObject(newValue)) {
                                        veryOldValue = newValue;
                                    } else if (isArrayLike(newValue)) {
                                        veryOldValue = new Array(newValue.length);
                                        for (var i = 0; i < newValue.length; i++) {
                                            veryOldValue[i] = newValue[i];
                                        }
                                    } else {
                                        veryOldValue = {};
                                        for (var key in newValue) {
                                            if (hasOwnProperty.call(newValue, key)) {
                                                veryOldValue[key] = newValue[key];
                                            }
                                        }
                                    }
                                }
                            }
                            return this.$watch(changeDetector, $watchCollectionAction);
                        },
                        $digest: function () {
                            var watch, value, last, fn, get, watchers, length, dirty, ttl = TTL, next, current, target = this, watchLog = [], logIdx, asyncTask;
                            beginPhase('$digest');
                            $browser.$$checkUrlChange();
                            if (this === $rootScope && applyAsyncId !== null) {
                                $browser.defer.cancel(applyAsyncId);
                                flushApplyAsync();
                            }
                            lastDirtyWatch = null;
                            do {
                                dirty = false;
                                current = target;
                                while (asyncQueue.length) {
                                    try {
                                        asyncTask = asyncQueue.shift();
                                        asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                    lastDirtyWatch = null;
                                }
                                traverseScopesLoop:
                                    do {
                                        if (watchers = current.$$watchers) {
                                            length = watchers.length;
                                            while (length--) {
                                                try {
                                                    watch = watchers[length];
                                                    if (watch) {
                                                        get = watch.get;
                                                        if ((value = get(current)) !== (last = watch.last) && !(watch.eq ? equals(value, last) : typeof value === 'number' && typeof last === 'number' && isNaN(value) && isNaN(last))) {
                                                            dirty = true;
                                                            lastDirtyWatch = watch;
                                                            watch.last = watch.eq ? copy(value, null) : value;
                                                            fn = watch.fn;
                                                            fn(value, last === initWatchVal ? value : last, current);
                                                            if (ttl < 5) {
                                                                logIdx = 4 - ttl;
                                                                if (!watchLog[logIdx])
                                                                    watchLog[logIdx] = [];
                                                                watchLog[logIdx].push({
                                                                    msg: isFunction(watch.exp) ? 'fn: ' + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                                    newVal: value,
                                                                    oldVal: last
                                                                });
                                                            }
                                                        } else if (watch === lastDirtyWatch) {
                                                            dirty = false;
                                                            break traverseScopesLoop;
                                                        }
                                                    }
                                                } catch (e) {
                                                    $exceptionHandler(e);
                                                }
                                            }
                                        }
                                        if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling)) {
                                            while (current !== target && !(next = current.$$nextSibling)) {
                                                current = current.$parent;
                                            }
                                        }
                                    } while (current = next);
                                if ((dirty || asyncQueue.length) && !ttl--) {
                                    clearPhase();
                                    throw $rootScopeMinErr('infdig', '{0} $digest() iterations reached. Aborting!\n' + 'Watchers fired in the last 5 iterations: {1}', TTL, watchLog);
                                }
                            } while (dirty || asyncQueue.length);
                            clearPhase();
                            while (postDigestQueue.length) {
                                try {
                                    postDigestQueue.shift()();
                                } catch (e) {
                                    $exceptionHandler(e);
                                }
                            }
                        },
                        $destroy: function () {
                            if (this.$$destroyed)
                                return;
                            var parent = this.$parent;
                            this.$broadcast('$destroy');
                            this.$$destroyed = true;
                            if (this === $rootScope) {
                                $browser.$$applicationDestroyed();
                            }
                            incrementWatchersCount(this, -this.$$watchersCount);
                            for (var eventName in this.$$listenerCount) {
                                decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                            }
                            if (parent && parent.$$childHead == this)
                                parent.$$childHead = this.$$nextSibling;
                            if (parent && parent.$$childTail == this)
                                parent.$$childTail = this.$$prevSibling;
                            if (this.$$prevSibling)
                                this.$$prevSibling.$$nextSibling = this.$$nextSibling;
                            if (this.$$nextSibling)
                                this.$$nextSibling.$$prevSibling = this.$$prevSibling;
                            this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop;
                            this.$on = this.$watch = this.$watchGroup = function () {
                                return noop;
                            };
                            this.$$listeners = {};
                            this.$$nextSibling = null;
                            cleanUpScope(this);
                        },
                        $eval: function (expr, locals) {
                            return $parse(expr)(this, locals);
                        },
                        $evalAsync: function (expr, locals) {
                            if (!$rootScope.$$phase && !asyncQueue.length) {
                                $browser.defer(function () {
                                    if (asyncQueue.length) {
                                        $rootScope.$digest();
                                    }
                                });
                            }
                            asyncQueue.push({
                                scope: this,
                                expression: $parse(expr),
                                locals: locals
                            });
                        },
                        $$postDigest: function (fn) {
                            postDigestQueue.push(fn);
                        },
                        $apply: function (expr) {
                            try {
                                beginPhase('$apply');
                                try {
                                    return this.$eval(expr);
                                } finally {
                                    clearPhase();
                                }
                            } catch (e) {
                                $exceptionHandler(e);
                            } finally {
                                try {
                                    $rootScope.$digest();
                                } catch (e) {
                                    $exceptionHandler(e);
                                    throw e;
                                }
                            }
                        },
                        $applyAsync: function (expr) {
                            var scope = this;
                            expr && applyAsyncQueue.push($applyAsyncExpression);
                            expr = $parse(expr);
                            scheduleApplyAsync();
                            function $applyAsyncExpression() {
                                scope.$eval(expr);
                            }
                        },
                        $on: function (name, listener) {
                            var namedListeners = this.$$listeners[name];
                            if (!namedListeners) {
                                this.$$listeners[name] = namedListeners = [];
                            }
                            namedListeners.push(listener);
                            var current = this;
                            do {
                                if (!current.$$listenerCount[name]) {
                                    current.$$listenerCount[name] = 0;
                                }
                                current.$$listenerCount[name]++;
                            } while (current = current.$parent);
                            var self = this;
                            return function () {
                                var indexOfListener = namedListeners.indexOf(listener);
                                if (indexOfListener !== -1) {
                                    namedListeners[indexOfListener] = null;
                                    decrementListenerCount(self, 1, name);
                                }
                            };
                        },
                        $emit: function (name, args) {
                            var empty = [], namedListeners, scope = this, stopPropagation = false, event = {
                                    name: name,
                                    targetScope: scope,
                                    stopPropagation: function () {
                                        stopPropagation = true;
                                    },
                                    preventDefault: function () {
                                        event.defaultPrevented = true;
                                    },
                                    defaultPrevented: false
                                }, listenerArgs = concat([event], arguments, 1), i, length;
                            do {
                                namedListeners = scope.$$listeners[name] || empty;
                                event.currentScope = scope;
                                for (i = 0, length = namedListeners.length; i < length; i++) {
                                    if (!namedListeners[i]) {
                                        namedListeners.splice(i, 1);
                                        i--;
                                        length--;
                                        continue;
                                    }
                                    try {
                                        namedListeners[i].apply(null, listenerArgs);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (stopPropagation) {
                                    event.currentScope = null;
                                    return event;
                                }
                                scope = scope.$parent;
                            } while (scope);
                            event.currentScope = null;
                            return event;
                        },
                        $broadcast: function (name, args) {
                            var target = this, current = target, next = target, event = {
                                    name: name,
                                    targetScope: target,
                                    preventDefault: function () {
                                        event.defaultPrevented = true;
                                    },
                                    defaultPrevented: false
                                };
                            if (!target.$$listenerCount[name])
                                return event;
                            var listenerArgs = concat([event], arguments, 1), listeners, i, length;
                            while (current = next) {
                                event.currentScope = current;
                                listeners = current.$$listeners[name] || [];
                                for (i = 0, length = listeners.length; i < length; i++) {
                                    if (!listeners[i]) {
                                        listeners.splice(i, 1);
                                        i--;
                                        length--;
                                        continue;
                                    }
                                    try {
                                        listeners[i].apply(null, listenerArgs);
                                    } catch (e) {
                                        $exceptionHandler(e);
                                    }
                                }
                                if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling)) {
                                    while (current !== target && !(next = current.$$nextSibling)) {
                                        current = current.$parent;
                                    }
                                }
                            }
                            event.currentScope = null;
                            return event;
                        }
                    };
                    var $rootScope = new Scope();
                    var asyncQueue = $rootScope.$$asyncQueue = [];
                    var postDigestQueue = $rootScope.$$postDigestQueue = [];
                    var applyAsyncQueue = $rootScope.$$applyAsyncQueue = [];
                    return $rootScope;
                    function beginPhase(phase) {
                        if ($rootScope.$$phase) {
                            throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);
                        }
                        $rootScope.$$phase = phase;
                    }
                    function clearPhase() {
                        $rootScope.$$phase = null;
                    }
                    function incrementWatchersCount(current, count) {
                        do {
                            current.$$watchersCount += count;
                        } while (current = current.$parent);
                    }
                    function decrementListenerCount(current, count, name) {
                        do {
                            current.$$listenerCount[name] -= count;
                            if (current.$$listenerCount[name] === 0) {
                                delete current.$$listenerCount[name];
                            }
                        } while (current = current.$parent);
                    }
                    function initWatchVal() {
                    }
                    function flushApplyAsync() {
                        while (applyAsyncQueue.length) {
                            try {
                                applyAsyncQueue.shift()();
                            } catch (e) {
                                $exceptionHandler(e);
                            }
                        }
                        applyAsyncId = null;
                    }
                    function scheduleApplyAsync() {
                        if (applyAsyncId === null) {
                            applyAsyncId = $browser.defer(function () {
                                $rootScope.$apply(flushApplyAsync);
                            });
                        }
                    }
                }
            ];
        }
        function $$SanitizeUriProvider() {
            var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
            this.aHrefSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    aHrefSanitizationWhitelist = regexp;
                    return this;
                }
                return aHrefSanitizationWhitelist;
            };
            this.imgSrcSanitizationWhitelist = function (regexp) {
                if (isDefined(regexp)) {
                    imgSrcSanitizationWhitelist = regexp;
                    return this;
                }
                return imgSrcSanitizationWhitelist;
            };
            this.$get = function () {
                return function sanitizeUri(uri, isImage) {
                    var regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                    var normalizedVal;
                    normalizedVal = urlResolve(uri).href;
                    if (normalizedVal !== '' && !normalizedVal.match(regex)) {
                        return 'unsafe:' + normalizedVal;
                    }
                    return uri;
                };
            };
        }
        var $sceMinErr = minErr('$sce');
        var SCE_CONTEXTS = {
            HTML: 'html',
            CSS: 'css',
            URL: 'url',
            RESOURCE_URL: 'resourceUrl',
            JS: 'js'
        };
        function adjustMatcher(matcher) {
            if (matcher === 'self') {
                return matcher;
            } else if (isString(matcher)) {
                if (matcher.indexOf('***') > -1) {
                    throw $sceMinErr('iwcard', 'Illegal sequence *** in string matcher.  String: {0}', matcher);
                }
                matcher = escapeForRegexp(matcher).replace('\\*\\*', '.*').replace('\\*', '[^:/.?&;]*');
                return new RegExp('^' + matcher + '$');
            } else if (isRegExp(matcher)) {
                return new RegExp('^' + matcher.source + '$');
            } else {
                throw $sceMinErr('imatcher', 'Matchers may only be "self", string patterns or RegExp objects');
            }
        }
        function adjustMatchers(matchers) {
            var adjustedMatchers = [];
            if (isDefined(matchers)) {
                forEach(matchers, function (matcher) {
                    adjustedMatchers.push(adjustMatcher(matcher));
                });
            }
            return adjustedMatchers;
        }
        function $SceDelegateProvider() {
            this.SCE_CONTEXTS = SCE_CONTEXTS;
            var resourceUrlWhitelist = ['self'], resourceUrlBlacklist = [];
            this.resourceUrlWhitelist = function (value) {
                if (arguments.length) {
                    resourceUrlWhitelist = adjustMatchers(value);
                }
                return resourceUrlWhitelist;
            };
            this.resourceUrlBlacklist = function (value) {
                if (arguments.length) {
                    resourceUrlBlacklist = adjustMatchers(value);
                }
                return resourceUrlBlacklist;
            };
            this.$get = [
                '$injector',
                function ($injector) {
                    var htmlSanitizer = function htmlSanitizer(html) {
                        throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
                    };
                    if ($injector.has('$sanitize')) {
                        htmlSanitizer = $injector.get('$sanitize');
                    }
                    function matchUrl(matcher, parsedUrl) {
                        if (matcher === 'self') {
                            return urlIsSameOrigin(parsedUrl);
                        } else {
                            return !!matcher.exec(parsedUrl.href);
                        }
                    }
                    function isResourceUrlAllowedByPolicy(url) {
                        var parsedUrl = urlResolve(url.toString());
                        var i, n, allowed = false;
                        for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {
                            if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                                allowed = true;
                                break;
                            }
                        }
                        if (allowed) {
                            for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {
                                if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                                    allowed = false;
                                    break;
                                }
                            }
                        }
                        return allowed;
                    }
                    function generateHolderType(Base) {
                        var holderType = function TrustedValueHolderType(trustedValue) {
                            this.$$unwrapTrustedValue = function () {
                                return trustedValue;
                            };
                        };
                        if (Base) {
                            holderType.prototype = new Base();
                        }
                        holderType.prototype.valueOf = function sceValueOf() {
                            return this.$$unwrapTrustedValue();
                        };
                        holderType.prototype.toString = function sceToString() {
                            return this.$$unwrapTrustedValue().toString();
                        };
                        return holderType;
                    }
                    var trustedValueHolderBase = generateHolderType(), byType = {};
                    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);
                    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);
                    function trustAs(type, trustedValue) {
                        var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (!Constructor) {
                            throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}', type, trustedValue);
                        }
                        if (trustedValue === null || isUndefined(trustedValue) || trustedValue === '') {
                            return trustedValue;
                        }
                        if (typeof trustedValue !== 'string') {
                            throw $sceMinErr('itype', 'Attempted to trust a non-string value in a content requiring a string: Context: {0}', type);
                        }
                        return new Constructor(trustedValue);
                    }
                    function valueOf(maybeTrusted) {
                        if (maybeTrusted instanceof trustedValueHolderBase) {
                            return maybeTrusted.$$unwrapTrustedValue();
                        } else {
                            return maybeTrusted;
                        }
                    }
                    function getTrusted(type, maybeTrusted) {
                        if (maybeTrusted === null || isUndefined(maybeTrusted) || maybeTrusted === '') {
                            return maybeTrusted;
                        }
                        var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (constructor && maybeTrusted instanceof constructor) {
                            return maybeTrusted.$$unwrapTrustedValue();
                        }
                        if (type === SCE_CONTEXTS.RESOURCE_URL) {
                            if (isResourceUrlAllowedByPolicy(maybeTrusted)) {
                                return maybeTrusted;
                            } else {
                                throw $sceMinErr('insecurl', 'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());
                            }
                        } else if (type === SCE_CONTEXTS.HTML) {
                            return htmlSanitizer(maybeTrusted);
                        }
                        throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');
                    }
                    return {
                        trustAs: trustAs,
                        getTrusted: getTrusted,
                        valueOf: valueOf
                    };
                }
            ];
        }
        function $SceProvider() {
            var enabled = true;
            this.enabled = function (value) {
                if (arguments.length) {
                    enabled = !!value;
                }
                return enabled;
            };
            this.$get = [
                '$parse',
                '$sceDelegate',
                function ($parse, $sceDelegate) {
                    if (enabled && msie < 8) {
                        throw $sceMinErr('iequirks', 'Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks ' + 'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' + 'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');
                    }
                    var sce = shallowCopy(SCE_CONTEXTS);
                    sce.isEnabled = function () {
                        return enabled;
                    };
                    sce.trustAs = $sceDelegate.trustAs;
                    sce.getTrusted = $sceDelegate.getTrusted;
                    sce.valueOf = $sceDelegate.valueOf;
                    if (!enabled) {
                        sce.trustAs = sce.getTrusted = function (type, value) {
                            return value;
                        };
                        sce.valueOf = identity;
                    }
                    sce.parseAs = function sceParseAs(type, expr) {
                        var parsed = $parse(expr);
                        if (parsed.literal && parsed.constant) {
                            return parsed;
                        } else {
                            return $parse(expr, function (value) {
                                return sce.getTrusted(type, value);
                            });
                        }
                    };
                    var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
                    forEach(SCE_CONTEXTS, function (enumValue, name) {
                        var lName = lowercase(name);
                        sce[camelCase('parse_as_' + lName)] = function (expr) {
                            return parse(enumValue, expr);
                        };
                        sce[camelCase('get_trusted_' + lName)] = function (value) {
                            return getTrusted(enumValue, value);
                        };
                        sce[camelCase('trust_as_' + lName)] = function (value) {
                            return trustAs(enumValue, value);
                        };
                    });
                    return sce;
                }
            ];
        }
        function $SnifferProvider() {
            this.$get = [
                '$window',
                '$document',
                function ($window, $document) {
                    var eventSupport = {}, isChromePackagedApp = $window.chrome && $window.chrome.app && $window.chrome.app.runtime, hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorPrefix, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = false, animations = false, match;
                    if (bodyStyle) {
                        for (var prop in bodyStyle) {
                            if (match = vendorRegex.exec(prop)) {
                                vendorPrefix = match[0];
                                vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);
                                break;
                            }
                        }
                        if (!vendorPrefix) {
                            vendorPrefix = 'WebkitOpacity' in bodyStyle && 'webkit';
                        }
                        transitions = !!('transition' in bodyStyle || vendorPrefix + 'Transition' in bodyStyle);
                        animations = !!('animation' in bodyStyle || vendorPrefix + 'Animation' in bodyStyle);
                        if (android && (!transitions || !animations)) {
                            transitions = isString(bodyStyle.webkitTransition);
                            animations = isString(bodyStyle.webkitAnimation);
                        }
                    }
                    return {
                        history: !!(hasHistoryPushState && !(android < 4) && !boxee),
                        hasEvent: function (event) {
                            if (event === 'input' && msie <= 11)
                                return false;
                            if (isUndefined(eventSupport[event])) {
                                var divElm = document.createElement('div');
                                eventSupport[event] = 'on' + event in divElm;
                            }
                            return eventSupport[event];
                        },
                        csp: csp(),
                        vendorPrefix: vendorPrefix,
                        transitions: transitions,
                        animations: animations,
                        android: android
                    };
                }
            ];
        }
        var $templateRequestMinErr = minErr('$compile');
        function $TemplateRequestProvider() {
            var httpOptions;
            this.httpOptions = function (val) {
                if (val) {
                    httpOptions = val;
                    return this;
                }
                return httpOptions;
            };
            this.$get = [
                '$templateCache',
                '$http',
                '$q',
                '$sce',
                function ($templateCache, $http, $q, $sce) {
                    function handleRequestFn(tpl, ignoreRequestError) {
                        handleRequestFn.totalPendingRequests++;
                        if (!isString(tpl) || !$templateCache.get(tpl)) {
                            tpl = $sce.getTrustedResourceUrl(tpl);
                        }
                        var transformResponse = $http.defaults && $http.defaults.transformResponse;
                        if (isArray(transformResponse)) {
                            transformResponse = transformResponse.filter(function (transformer) {
                                return transformer !== defaultHttpResponseTransform;
                            });
                        } else if (transformResponse === defaultHttpResponseTransform) {
                            transformResponse = null;
                        }
                        return $http.get(tpl, extend({
                            cache: $templateCache,
                            transformResponse: transformResponse
                        }, httpOptions))['finally'](function () {
                            handleRequestFn.totalPendingRequests--;
                        }).then(function (response) {
                            $templateCache.put(tpl, response.data);
                            return response.data;
                        }, handleError);
                        function handleError(resp) {
                            if (!ignoreRequestError) {
                                throw $templateRequestMinErr('tpload', 'Failed to load template: {0} (HTTP status: {1} {2})', tpl, resp.status, resp.statusText);
                            }
                            return $q.reject(resp);
                        }
                    }
                    handleRequestFn.totalPendingRequests = 0;
                    return handleRequestFn;
                }
            ];
        }
        function $$TestabilityProvider() {
            this.$get = [
                '$rootScope',
                '$browser',
                '$location',
                function ($rootScope, $browser, $location) {
                    var testability = {};
                    testability.findBindings = function (element, expression, opt_exactMatch) {
                        var bindings = element.getElementsByClassName('ng-binding');
                        var matches = [];
                        forEach(bindings, function (binding) {
                            var dataBinding = angular.element(binding).data('$binding');
                            if (dataBinding) {
                                forEach(dataBinding, function (bindingName) {
                                    if (opt_exactMatch) {
                                        var matcher = new RegExp('(^|\\s)' + escapeForRegexp(expression) + '(\\s|\\||$)');
                                        if (matcher.test(bindingName)) {
                                            matches.push(binding);
                                        }
                                    } else {
                                        if (bindingName.indexOf(expression) != -1) {
                                            matches.push(binding);
                                        }
                                    }
                                });
                            }
                        });
                        return matches;
                    };
                    testability.findModels = function (element, expression, opt_exactMatch) {
                        var prefixes = [
                            'ng-',
                            'data-ng-',
                            'ng\\:'
                        ];
                        for (var p = 0; p < prefixes.length; ++p) {
                            var attributeEquals = opt_exactMatch ? '=' : '*=';
                            var selector = '[' + prefixes[p] + 'model' + attributeEquals + '"' + expression + '"]';
                            var elements = element.querySelectorAll(selector);
                            if (elements.length) {
                                return elements;
                            }
                        }
                    };
                    testability.getLocation = function () {
                        return $location.url();
                    };
                    testability.setLocation = function (url) {
                        if (url !== $location.url()) {
                            $location.url(url);
                            $rootScope.$digest();
                        }
                    };
                    testability.whenStable = function (callback) {
                        $browser.notifyWhenNoOutstandingRequests(callback);
                    };
                    return testability;
                }
            ];
        }
        function $TimeoutProvider() {
            this.$get = [
                '$rootScope',
                '$browser',
                '$q',
                '$$q',
                '$exceptionHandler',
                function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
                    var deferreds = {};
                    function timeout(fn, delay, invokeApply) {
                        if (!isFunction(fn)) {
                            invokeApply = delay;
                            delay = fn;
                            fn = noop;
                        }
                        var args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise, timeoutId;
                        timeoutId = $browser.defer(function () {
                            try {
                                deferred.resolve(fn.apply(null, args));
                            } catch (e) {
                                deferred.reject(e);
                                $exceptionHandler(e);
                            } finally {
                                delete deferreds[promise.$$timeoutId];
                            }
                            if (!skipApply)
                                $rootScope.$apply();
                        }, delay);
                        promise.$$timeoutId = timeoutId;
                        deferreds[timeoutId] = deferred;
                        return promise;
                    }
                    timeout.cancel = function (promise) {
                        if (promise && promise.$$timeoutId in deferreds) {
                            deferreds[promise.$$timeoutId].reject('canceled');
                            delete deferreds[promise.$$timeoutId];
                            return $browser.defer.cancel(promise.$$timeoutId);
                        }
                        return false;
                    };
                    return timeout;
                }
            ];
        }
        var urlParsingNode = window.document.createElement('a');
        var originUrl = urlResolve(window.location.href);
        function urlResolve(url) {
            var href = url;
            if (msie) {
                urlParsingNode.setAttribute('href', href);
                href = urlParsingNode.href;
            }
            urlParsingNode.setAttribute('href', href);
            return {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
                host: urlParsingNode.host,
                search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
                hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
                hostname: urlParsingNode.hostname,
                port: urlParsingNode.port,
                pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
            };
        }
        function urlIsSameOrigin(requestUrl) {
            var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
            return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host;
        }
        function $WindowProvider() {
            this.$get = valueFn(window);
        }
        function $$CookieReader($document) {
            var rawDocument = $document[0] || {};
            var lastCookies = {};
            var lastCookieString = '';
            function safeDecodeURIComponent(str) {
                try {
                    return decodeURIComponent(str);
                } catch (e) {
                    return str;
                }
            }
            return function () {
                var cookieArray, cookie, i, index, name;
                var currentCookieString = rawDocument.cookie || '';
                if (currentCookieString !== lastCookieString) {
                    lastCookieString = currentCookieString;
                    cookieArray = lastCookieString.split('; ');
                    lastCookies = {};
                    for (i = 0; i < cookieArray.length; i++) {
                        cookie = cookieArray[i];
                        index = cookie.indexOf('=');
                        if (index > 0) {
                            name = safeDecodeURIComponent(cookie.substring(0, index));
                            if (isUndefined(lastCookies[name])) {
                                lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1));
                            }
                        }
                    }
                }
                return lastCookies;
            };
        }
        $$CookieReader.$inject = ['$document'];
        function $$CookieReaderProvider() {
            this.$get = $$CookieReader;
        }
        $FilterProvider.$inject = ['$provide'];
        function $FilterProvider($provide) {
            var suffix = 'Filter';
            function register(name, factory) {
                if (isObject(name)) {
                    var filters = {};
                    forEach(name, function (filter, key) {
                        filters[key] = register(key, filter);
                    });
                    return filters;
                } else {
                    return $provide.factory(name + suffix, factory);
                }
            }
            this.register = register;
            this.$get = [
                '$injector',
                function ($injector) {
                    return function (name) {
                        return $injector.get(name + suffix);
                    };
                }
            ];
            register('currency', currencyFilter);
            register('date', dateFilter);
            register('filter', filterFilter);
            register('json', jsonFilter);
            register('limitTo', limitToFilter);
            register('lowercase', lowercaseFilter);
            register('number', numberFilter);
            register('orderBy', orderByFilter);
            register('uppercase', uppercaseFilter);
        }
        function filterFilter() {
            return function (array, expression, comparator) {
                if (!isArrayLike(array)) {
                    if (array == null) {
                        return array;
                    } else {
                        throw minErr('filter')('notarray', 'Expected array but received: {0}', array);
                    }
                }
                var expressionType = getTypeForFilter(expression);
                var predicateFn;
                var matchAgainstAnyProp;
                switch (expressionType) {
                case 'function':
                    predicateFn = expression;
                    break;
                case 'boolean':
                case 'null':
                case 'number':
                case 'string':
                    matchAgainstAnyProp = true;
                case 'object':
                    predicateFn = createPredicateFn(expression, comparator, matchAgainstAnyProp);
                    break;
                default:
                    return array;
                }
                return Array.prototype.filter.call(array, predicateFn);
            };
        }
        function createPredicateFn(expression, comparator, matchAgainstAnyProp) {
            var shouldMatchPrimitives = isObject(expression) && '$' in expression;
            var predicateFn;
            if (comparator === true) {
                comparator = equals;
            } else if (!isFunction(comparator)) {
                comparator = function (actual, expected) {
                    if (isUndefined(actual)) {
                        return false;
                    }
                    if (actual === null || expected === null) {
                        return actual === expected;
                    }
                    if (isObject(expected) || isObject(actual) && !hasCustomToString(actual)) {
                        return false;
                    }
                    actual = lowercase('' + actual);
                    expected = lowercase('' + expected);
                    return actual.indexOf(expected) !== -1;
                };
            }
            predicateFn = function (item) {
                if (shouldMatchPrimitives && !isObject(item)) {
                    return deepCompare(item, expression.$, comparator, false);
                }
                return deepCompare(item, expression, comparator, matchAgainstAnyProp);
            };
            return predicateFn;
        }
        function deepCompare(actual, expected, comparator, matchAgainstAnyProp, dontMatchWholeObject) {
            var actualType = getTypeForFilter(actual);
            var expectedType = getTypeForFilter(expected);
            if (expectedType === 'string' && expected.charAt(0) === '!') {
                return !deepCompare(actual, expected.substring(1), comparator, matchAgainstAnyProp);
            } else if (isArray(actual)) {
                return actual.some(function (item) {
                    return deepCompare(item, expected, comparator, matchAgainstAnyProp);
                });
            }
            switch (actualType) {
            case 'object':
                var key;
                if (matchAgainstAnyProp) {
                    for (key in actual) {
                        if (key.charAt(0) !== '$' && deepCompare(actual[key], expected, comparator, true)) {
                            return true;
                        }
                    }
                    return dontMatchWholeObject ? false : deepCompare(actual, expected, comparator, false);
                } else if (expectedType === 'object') {
                    for (key in expected) {
                        var expectedVal = expected[key];
                        if (isFunction(expectedVal) || isUndefined(expectedVal)) {
                            continue;
                        }
                        var matchAnyProperty = key === '$';
                        var actualVal = matchAnyProperty ? actual : actual[key];
                        if (!deepCompare(actualVal, expectedVal, comparator, matchAnyProperty, matchAnyProperty)) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return comparator(actual, expected);
                }
                break;
            case 'function':
                return false;
            default:
                return comparator(actual, expected);
            }
        }
        function getTypeForFilter(val) {
            return val === null ? 'null' : typeof val;
        }
        var MAX_DIGITS = 22;
        var DECIMAL_SEP = '.';
        var ZERO_CHAR = '0';
        currencyFilter.$inject = ['$locale'];
        function currencyFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function (amount, currencySymbol, fractionSize) {
                if (isUndefined(currencySymbol)) {
                    currencySymbol = formats.CURRENCY_SYM;
                }
                if (isUndefined(fractionSize)) {
                    fractionSize = formats.PATTERNS[1].maxFrac;
                }
                return amount == null ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol);
            };
        }
        numberFilter.$inject = ['$locale'];
        function numberFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function (number, fractionSize) {
                return number == null ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize);
            };
        }
        function parse(numStr) {
            var exponent = 0, digits, numberOfIntegerDigits;
            var i, j, zeros;
            if ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1) {
                numStr = numStr.replace(DECIMAL_SEP, '');
            }
            if ((i = numStr.search(/e/i)) > 0) {
                if (numberOfIntegerDigits < 0)
                    numberOfIntegerDigits = i;
                numberOfIntegerDigits += +numStr.slice(i + 1);
                numStr = numStr.substring(0, i);
            } else if (numberOfIntegerDigits < 0) {
                numberOfIntegerDigits = numStr.length;
            }
            for (i = 0; numStr.charAt(i) == ZERO_CHAR; i++) {
            }
            if (i == (zeros = numStr.length)) {
                digits = [0];
                numberOfIntegerDigits = 1;
            } else {
                zeros--;
                while (numStr.charAt(zeros) == ZERO_CHAR)
                    zeros--;
                numberOfIntegerDigits -= i;
                digits = [];
                for (j = 0; i <= zeros; i++, j++) {
                    digits[j] = +numStr.charAt(i);
                }
            }
            if (numberOfIntegerDigits > MAX_DIGITS) {
                digits = digits.splice(0, MAX_DIGITS - 1);
                exponent = numberOfIntegerDigits - 1;
                numberOfIntegerDigits = 1;
            }
            return {
                d: digits,
                e: exponent,
                i: numberOfIntegerDigits
            };
        }
        function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
            var digits = parsedNumber.d;
            var fractionLen = digits.length - parsedNumber.i;
            fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
            var roundAt = fractionSize + parsedNumber.i;
            var digit = digits[roundAt];
            if (roundAt > 0) {
                digits.splice(Math.max(parsedNumber.i, roundAt));
                for (var j = roundAt; j < digits.length; j++) {
                    digits[j] = 0;
                }
            } else {
                fractionLen = Math.max(0, fractionLen);
                parsedNumber.i = 1;
                digits.length = Math.max(1, roundAt = fractionSize + 1);
                digits[0] = 0;
                for (var i = 1; i < roundAt; i++)
                    digits[i] = 0;
            }
            if (digit >= 5) {
                if (roundAt - 1 < 0) {
                    for (var k = 0; k > roundAt; k--) {
                        digits.unshift(0);
                        parsedNumber.i++;
                    }
                    digits.unshift(1);
                    parsedNumber.i++;
                } else {
                    digits[roundAt - 1]++;
                }
            }
            for (; fractionLen < Math.max(0, fractionSize); fractionLen++)
                digits.push(0);
            var carry = digits.reduceRight(function (carry, d, i, digits) {
                d = d + carry;
                digits[i] = d % 10;
                return Math.floor(d / 10);
            }, 0);
            if (carry) {
                digits.unshift(carry);
                parsedNumber.i++;
            }
        }
        function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
            if (!(isString(number) || isNumber(number)) || isNaN(number))
                return '';
            var isInfinity = !isFinite(number);
            var isZero = false;
            var numStr = Math.abs(number) + '', formattedText = '', parsedNumber;
            if (isInfinity) {
                formattedText = '\u221E';
            } else {
                parsedNumber = parse(numStr);
                roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
                var digits = parsedNumber.d;
                var integerLen = parsedNumber.i;
                var exponent = parsedNumber.e;
                var decimals = [];
                isZero = digits.reduce(function (isZero, d) {
                    return isZero && !d;
                }, true);
                while (integerLen < 0) {
                    digits.unshift(0);
                    integerLen++;
                }
                if (integerLen > 0) {
                    decimals = digits.splice(integerLen);
                } else {
                    decimals = digits;
                    digits = [0];
                }
                var groups = [];
                if (digits.length >= pattern.lgSize) {
                    groups.unshift(digits.splice(-pattern.lgSize).join(''));
                }
                while (digits.length > pattern.gSize) {
                    groups.unshift(digits.splice(-pattern.gSize).join(''));
                }
                if (digits.length) {
                    groups.unshift(digits.join(''));
                }
                formattedText = groups.join(groupSep);
                if (decimals.length) {
                    formattedText += decimalSep + decimals.join('');
                }
                if (exponent) {
                    formattedText += 'e+' + exponent;
                }
            }
            if (number < 0 && !isZero) {
                return pattern.negPre + formattedText + pattern.negSuf;
            } else {
                return pattern.posPre + formattedText + pattern.posSuf;
            }
        }
        function padNumber(num, digits, trim, negWrap) {
            var neg = '';
            if (num < 0 || negWrap && num <= 0) {
                if (negWrap) {
                    num = -num + 1;
                } else {
                    num = -num;
                    neg = '-';
                }
            }
            num = '' + num;
            while (num.length < digits)
                num = ZERO_CHAR + num;
            if (trim) {
                num = num.substr(num.length - digits);
            }
            return neg + num;
        }
        function dateGetter(name, size, offset, trim, negWrap) {
            offset = offset || 0;
            return function (date) {
                var value = date['get' + name]();
                if (offset > 0 || value > -offset) {
                    value += offset;
                }
                if (value === 0 && offset == -12)
                    value = 12;
                return padNumber(value, size, trim, negWrap);
            };
        }
        function dateStrGetter(name, shortForm, standAlone) {
            return function (date, formats) {
                var value = date['get' + name]();
                var propPrefix = (standAlone ? 'STANDALONE' : '') + (shortForm ? 'SHORT' : '');
                var get = uppercase(propPrefix + name);
                return formats[get][value];
            };
        }
        function timeZoneGetter(date, formats, offset) {
            var zone = -1 * offset;
            var paddedZone = zone >= 0 ? '+' : '';
            paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2);
            return paddedZone;
        }
        function getFirstThursdayOfYear(year) {
            var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
            return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst);
        }
        function getThursdayThisWeek(datetime) {
            return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()));
        }
        function weekGetter(size) {
            return function (date) {
                var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date);
                var diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 604800000);
                return padNumber(result, size);
            };
        }
        function ampmGetter(date, formats) {
            return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];
        }
        function eraGetter(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1];
        }
        function longEraGetter(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1];
        }
        var DATE_FORMATS = {
            yyyy: dateGetter('FullYear', 4, 0, false, true),
            yy: dateGetter('FullYear', 2, 0, true, true),
            y: dateGetter('FullYear', 1, 0, false, true),
            MMMM: dateStrGetter('Month'),
            MMM: dateStrGetter('Month', true),
            MM: dateGetter('Month', 2, 1),
            M: dateGetter('Month', 1, 1),
            LLLL: dateStrGetter('Month', false, true),
            dd: dateGetter('Date', 2),
            d: dateGetter('Date', 1),
            HH: dateGetter('Hours', 2),
            H: dateGetter('Hours', 1),
            hh: dateGetter('Hours', 2, -12),
            h: dateGetter('Hours', 1, -12),
            mm: dateGetter('Minutes', 2),
            m: dateGetter('Minutes', 1),
            ss: dateGetter('Seconds', 2),
            s: dateGetter('Seconds', 1),
            sss: dateGetter('Milliseconds', 3),
            EEEE: dateStrGetter('Day'),
            EEE: dateStrGetter('Day', true),
            a: ampmGetter,
            Z: timeZoneGetter,
            ww: weekGetter(2),
            w: weekGetter(1),
            G: eraGetter,
            GG: eraGetter,
            GGG: eraGetter,
            GGGG: longEraGetter
        };
        var DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
        dateFilter.$inject = ['$locale'];
        function dateFilter($locale) {
            var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
            function jsonStringToDate(string) {
                var match;
                if (match = string.match(R_ISO8601_STR)) {
                    var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                    if (match[9]) {
                        tzHour = toInt(match[9] + match[10]);
                        tzMin = toInt(match[9] + match[11]);
                    }
                    dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                    var h = toInt(match[4] || 0) - tzHour;
                    var m = toInt(match[5] || 0) - tzMin;
                    var s = toInt(match[6] || 0);
                    var ms = Math.round(parseFloat('0.' + (match[7] || 0)) * 1000);
                    timeSetter.call(date, h, m, s, ms);
                    return date;
                }
                return string;
            }
            return function (date, format, timezone) {
                var text = '', parts = [], fn, match;
                format = format || 'mediumDate';
                format = $locale.DATETIME_FORMATS[format] || format;
                if (isString(date)) {
                    date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date);
                }
                if (isNumber(date)) {
                    date = new Date(date);
                }
                if (!isDate(date) || !isFinite(date.getTime())) {
                    return date;
                }
                while (format) {
                    match = DATE_FORMATS_SPLIT.exec(format);
                    if (match) {
                        parts = concat(parts, match, 1);
                        format = parts.pop();
                    } else {
                        parts.push(format);
                        format = null;
                    }
                }
                var dateTimezoneOffset = date.getTimezoneOffset();
                if (timezone) {
                    dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
                    date = convertTimezoneToLocal(date, timezone, true);
                }
                forEach(parts, function (value) {
                    fn = DATE_FORMATS[value];
                    text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : value === '\'\'' ? '\'' : value.replace(/(^'|'$)/g, '').replace(/''/g, '\'');
                });
                return text;
            };
        }
        function jsonFilter() {
            return function (object, spacing) {
                if (isUndefined(spacing)) {
                    spacing = 2;
                }
                return toJson(object, spacing);
            };
        }
        var lowercaseFilter = valueFn(lowercase);
        var uppercaseFilter = valueFn(uppercase);
        function limitToFilter() {
            return function (input, limit, begin) {
                if (Math.abs(Number(limit)) === Infinity) {
                    limit = Number(limit);
                } else {
                    limit = toInt(limit);
                }
                if (isNaN(limit))
                    return input;
                if (isNumber(input))
                    input = input.toString();
                if (!isArray(input) && !isString(input))
                    return input;
                begin = !begin || isNaN(begin) ? 0 : toInt(begin);
                begin = begin < 0 ? Math.max(0, input.length + begin) : begin;
                if (limit >= 0) {
                    return input.slice(begin, begin + limit);
                } else {
                    if (begin === 0) {
                        return input.slice(limit, input.length);
                    } else {
                        return input.slice(Math.max(0, begin + limit), begin);
                    }
                }
            };
        }
        orderByFilter.$inject = ['$parse'];
        function orderByFilter($parse) {
            return function (array, sortPredicate, reverseOrder) {
                if (array == null)
                    return array;
                if (!isArrayLike(array)) {
                    throw minErr('orderBy')('notarray', 'Expected array but received: {0}', array);
                }
                if (!isArray(sortPredicate)) {
                    sortPredicate = [sortPredicate];
                }
                if (sortPredicate.length === 0) {
                    sortPredicate = ['+'];
                }
                var predicates = processPredicates(sortPredicate, reverseOrder);
                predicates.push({
                    get: function () {
                        return {};
                    },
                    descending: reverseOrder ? -1 : 1
                });
                var compareValues = Array.prototype.map.call(array, getComparisonObject);
                compareValues.sort(doComparison);
                array = compareValues.map(function (item) {
                    return item.value;
                });
                return array;
                function getComparisonObject(value, index) {
                    return {
                        value: value,
                        predicateValues: predicates.map(function (predicate) {
                            return getPredicateValue(predicate.get(value), index);
                        })
                    };
                }
                function doComparison(v1, v2) {
                    var result = 0;
                    for (var index = 0, length = predicates.length; index < length; ++index) {
                        result = compare(v1.predicateValues[index], v2.predicateValues[index]) * predicates[index].descending;
                        if (result)
                            break;
                    }
                    return result;
                }
            };
            function processPredicates(sortPredicate, reverseOrder) {
                reverseOrder = reverseOrder ? -1 : 1;
                return sortPredicate.map(function (predicate) {
                    var descending = 1, get = identity;
                    if (isFunction(predicate)) {
                        get = predicate;
                    } else if (isString(predicate)) {
                        if (predicate.charAt(0) == '+' || predicate.charAt(0) == '-') {
                            descending = predicate.charAt(0) == '-' ? -1 : 1;
                            predicate = predicate.substring(1);
                        }
                        if (predicate !== '') {
                            get = $parse(predicate);
                            if (get.constant) {
                                var key = get();
                                get = function (value) {
                                    return value[key];
                                };
                            }
                        }
                    }
                    return {
                        get: get,
                        descending: descending * reverseOrder
                    };
                });
            }
            function isPrimitive(value) {
                switch (typeof value) {
                case 'number':
                case 'boolean':
                case 'string':
                    return true;
                default:
                    return false;
                }
            }
            function objectValue(value, index) {
                if (typeof value.valueOf === 'function') {
                    value = value.valueOf();
                    if (isPrimitive(value))
                        return value;
                }
                if (hasCustomToString(value)) {
                    value = value.toString();
                    if (isPrimitive(value))
                        return value;
                }
                return index;
            }
            function getPredicateValue(value, index) {
                var type = typeof value;
                if (value === null) {
                    type = 'string';
                    value = 'null';
                } else if (type === 'string') {
                    value = value.toLowerCase();
                } else if (type === 'object') {
                    value = objectValue(value, index);
                }
                return {
                    value: value,
                    type: type
                };
            }
            function compare(v1, v2) {
                var result = 0;
                if (v1.type === v2.type) {
                    if (v1.value !== v2.value) {
                        result = v1.value < v2.value ? -1 : 1;
                    }
                } else {
                    result = v1.type < v2.type ? -1 : 1;
                }
                return result;
            }
        }
        function ngDirective(directive) {
            if (isFunction(directive)) {
                directive = { link: directive };
            }
            directive.restrict = directive.restrict || 'AC';
            return valueFn(directive);
        }
        var htmlAnchorDirective = valueFn({
            restrict: 'E',
            compile: function (element, attr) {
                if (!attr.href && !attr.xlinkHref) {
                    return function (scope, element) {
                        if (element[0].nodeName.toLowerCase() !== 'a')
                            return;
                        var href = toString.call(element.prop('href')) === '[object SVGAnimatedString]' ? 'xlink:href' : 'href';
                        element.on('click', function (event) {
                            if (!element.attr(href)) {
                                event.preventDefault();
                            }
                        });
                    };
                }
            }
        });
        var ngAttributeAliasDirectives = {};
        forEach(BOOLEAN_ATTR, function (propName, attrName) {
            if (propName == 'multiple')
                return;
            function defaultLinkFn(scope, element, attr) {
                scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {
                    attr.$set(attrName, !!value);
                });
            }
            var normalized = directiveNormalize('ng-' + attrName);
            var linkFn = defaultLinkFn;
            if (propName === 'checked') {
                linkFn = function (scope, element, attr) {
                    if (attr.ngModel !== attr[normalized]) {
                        defaultLinkFn(scope, element, attr);
                    }
                };
            }
            ngAttributeAliasDirectives[normalized] = function () {
                return {
                    restrict: 'A',
                    priority: 100,
                    link: linkFn
                };
            };
        });
        forEach(ALIASED_ATTR, function (htmlAttr, ngAttr) {
            ngAttributeAliasDirectives[ngAttr] = function () {
                return {
                    priority: 100,
                    link: function (scope, element, attr) {
                        if (ngAttr === 'ngPattern' && attr.ngPattern.charAt(0) == '/') {
                            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                            if (match) {
                                attr.$set('ngPattern', new RegExp(match[1], match[2]));
                                return;
                            }
                        }
                        scope.$watch(attr[ngAttr], function ngAttrAliasWatchAction(value) {
                            attr.$set(ngAttr, value);
                        });
                    }
                };
            };
        });
        forEach([
            'src',
            'srcset',
            'href'
        ], function (attrName) {
            var normalized = directiveNormalize('ng-' + attrName);
            ngAttributeAliasDirectives[normalized] = function () {
                return {
                    priority: 99,
                    link: function (scope, element, attr) {
                        var propName = attrName, name = attrName;
                        if (attrName === 'href' && toString.call(element.prop('href')) === '[object SVGAnimatedString]') {
                            name = 'xlinkHref';
                            attr.$attr[name] = 'xlink:href';
                            propName = null;
                        }
                        attr.$observe(normalized, function (value) {
                            if (!value) {
                                if (attrName === 'href') {
                                    attr.$set(name, null);
                                }
                                return;
                            }
                            attr.$set(name, value);
                            if (msie && propName)
                                element.prop(propName, attr[name]);
                        });
                    }
                };
            };
        });
        var nullFormCtrl = {
                $addControl: noop,
                $$renameControl: nullFormRenameControl,
                $removeControl: noop,
                $setValidity: noop,
                $setDirty: noop,
                $setPristine: noop,
                $setSubmitted: noop
            }, SUBMITTED_CLASS = 'ng-submitted';
        function nullFormRenameControl(control, name) {
            control.$name = name;
        }
        FormController.$inject = [
            '$element',
            '$attrs',
            '$scope',
            '$animate',
            '$interpolate'
        ];
        function FormController(element, attrs, $scope, $animate, $interpolate) {
            var form = this, controls = [];
            form.$error = {};
            form.$$success = {};
            form.$pending = undefined;
            form.$name = $interpolate(attrs.name || attrs.ngForm || '')($scope);
            form.$dirty = false;
            form.$pristine = true;
            form.$valid = true;
            form.$invalid = false;
            form.$submitted = false;
            form.$$parentForm = nullFormCtrl;
            form.$rollbackViewValue = function () {
                forEach(controls, function (control) {
                    control.$rollbackViewValue();
                });
            };
            form.$commitViewValue = function () {
                forEach(controls, function (control) {
                    control.$commitViewValue();
                });
            };
            form.$addControl = function (control) {
                assertNotHasOwnProperty(control.$name, 'input');
                controls.push(control);
                if (control.$name) {
                    form[control.$name] = control;
                }
                control.$$parentForm = form;
            };
            form.$$renameControl = function (control, newName) {
                var oldName = control.$name;
                if (form[oldName] === control) {
                    delete form[oldName];
                }
                form[newName] = control;
                control.$name = newName;
            };
            form.$removeControl = function (control) {
                if (control.$name && form[control.$name] === control) {
                    delete form[control.$name];
                }
                forEach(form.$pending, function (value, name) {
                    form.$setValidity(name, null, control);
                });
                forEach(form.$error, function (value, name) {
                    form.$setValidity(name, null, control);
                });
                forEach(form.$$success, function (value, name) {
                    form.$setValidity(name, null, control);
                });
                arrayRemove(controls, control);
                control.$$parentForm = nullFormCtrl;
            };
            addSetValidityMethod({
                ctrl: this,
                $element: element,
                set: function (object, property, controller) {
                    var list = object[property];
                    if (!list) {
                        object[property] = [controller];
                    } else {
                        var index = list.indexOf(controller);
                        if (index === -1) {
                            list.push(controller);
                        }
                    }
                },
                unset: function (object, property, controller) {
                    var list = object[property];
                    if (!list) {
                        return;
                    }
                    arrayRemove(list, controller);
                    if (list.length === 0) {
                        delete object[property];
                    }
                },
                $animate: $animate
            });
            form.$setDirty = function () {
                $animate.removeClass(element, PRISTINE_CLASS);
                $animate.addClass(element, DIRTY_CLASS);
                form.$dirty = true;
                form.$pristine = false;
                form.$$parentForm.$setDirty();
            };
            form.$setPristine = function () {
                $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + ' ' + SUBMITTED_CLASS);
                form.$dirty = false;
                form.$pristine = true;
                form.$submitted = false;
                forEach(controls, function (control) {
                    control.$setPristine();
                });
            };
            form.$setUntouched = function () {
                forEach(controls, function (control) {
                    control.$setUntouched();
                });
            };
            form.$setSubmitted = function () {
                $animate.addClass(element, SUBMITTED_CLASS);
                form.$submitted = true;
                form.$$parentForm.$setSubmitted();
            };
        }
        var formDirectiveFactory = function (isNgForm) {
            return [
                '$timeout',
                '$parse',
                function ($timeout, $parse) {
                    var formDirective = {
                        name: 'form',
                        restrict: isNgForm ? 'EAC' : 'E',
                        require: [
                            'form',
                            '^^?form'
                        ],
                        controller: FormController,
                        compile: function ngFormCompile(formElement, attr) {
                            formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                            var nameAttr = attr.name ? 'name' : isNgForm && attr.ngForm ? 'ngForm' : false;
                            return {
                                pre: function ngFormPreLink(scope, formElement, attr, ctrls) {
                                    var controller = ctrls[0];
                                    if (!('action' in attr)) {
                                        var handleFormSubmission = function (event) {
                                            scope.$apply(function () {
                                                controller.$commitViewValue();
                                                controller.$setSubmitted();
                                            });
                                            event.preventDefault();
                                        };
                                        addEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                                        formElement.on('$destroy', function () {
                                            $timeout(function () {
                                                removeEventListenerFn(formElement[0], 'submit', handleFormSubmission);
                                            }, 0, false);
                                        });
                                    }
                                    var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                                    parentFormCtrl.$addControl(controller);
                                    var setter = nameAttr ? getSetter(controller.$name) : noop;
                                    if (nameAttr) {
                                        setter(scope, controller);
                                        attr.$observe(nameAttr, function (newValue) {
                                            if (controller.$name === newValue)
                                                return;
                                            setter(scope, undefined);
                                            controller.$$parentForm.$$renameControl(controller, newValue);
                                            setter = getSetter(controller.$name);
                                            setter(scope, controller);
                                        });
                                    }
                                    formElement.on('$destroy', function () {
                                        controller.$$parentForm.$removeControl(controller);
                                        setter(scope, undefined);
                                        extend(controller, nullFormCtrl);
                                    });
                                }
                            };
                        }
                    };
                    return formDirective;
                    function getSetter(expression) {
                        if (expression === '') {
                            return $parse('this[""]').assign;
                        }
                        return $parse(expression).assign || noop;
                    }
                }
            ];
        };
        var formDirective = formDirectiveFactory();
        var ngFormDirective = formDirectiveFactory(true);
        var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/;
        var URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i;
        var EMAIL_REGEXP = /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i;
        var NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/;
        var DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/;
        var DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
        var WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/;
        var MONTH_REGEXP = /^(\d{4,})-(\d\d)$/;
        var TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/;
        var PARTIAL_VALIDATION_EVENTS = 'keydown wheel mousedown';
        var PARTIAL_VALIDATION_TYPES = createMap();
        forEach('date,datetime-local,month,time,week'.split(','), function (type) {
            PARTIAL_VALIDATION_TYPES[type] = true;
        });
        var inputType = {
            'text': textInputType,
            'date': createDateInputType('date', DATE_REGEXP, createDateParser(DATE_REGEXP, [
                'yyyy',
                'MM',
                'dd'
            ]), 'yyyy-MM-dd'),
            'datetime-local': createDateInputType('datetimelocal', DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, [
                'yyyy',
                'MM',
                'dd',
                'HH',
                'mm',
                'ss',
                'sss'
            ]), 'yyyy-MM-ddTHH:mm:ss.sss'),
            'time': createDateInputType('time', TIME_REGEXP, createDateParser(TIME_REGEXP, [
                'HH',
                'mm',
                'ss',
                'sss'
            ]), 'HH:mm:ss.sss'),
            'week': createDateInputType('week', WEEK_REGEXP, weekParser, 'yyyy-Www'),
            'month': createDateInputType('month', MONTH_REGEXP, createDateParser(MONTH_REGEXP, [
                'yyyy',
                'MM'
            ]), 'yyyy-MM'),
            'number': numberInputType,
            'url': urlInputType,
            'email': emailInputType,
            'radio': radioInputType,
            'checkbox': checkboxInputType,
            'hidden': noop,
            'button': noop,
            'submit': noop,
            'reset': noop,
            'file': noop
        };
        function stringBasedInputType(ctrl) {
            ctrl.$formatters.push(function (value) {
                return ctrl.$isEmpty(value) ? value : value.toString();
            });
        }
        function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            stringBasedInputType(ctrl);
        }
        function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            var type = lowercase(element[0].type);
            if (!$sniffer.android) {
                var composing = false;
                element.on('compositionstart', function () {
                    composing = true;
                });
                element.on('compositionend', function () {
                    composing = false;
                    listener();
                });
            }
            var timeout;
            var listener = function (ev) {
                if (timeout) {
                    $browser.defer.cancel(timeout);
                    timeout = null;
                }
                if (composing)
                    return;
                var value = element.val(), event = ev && ev.type;
                if (type !== 'password' && (!attr.ngTrim || attr.ngTrim !== 'false')) {
                    value = trim(value);
                }
                if (ctrl.$viewValue !== value || value === '' && ctrl.$$hasNativeValidators) {
                    ctrl.$setViewValue(value, event);
                }
            };
            if ($sniffer.hasEvent('input')) {
                element.on('input', listener);
            } else {
                var deferListener = function (ev, input, origValue) {
                    if (!timeout) {
                        timeout = $browser.defer(function () {
                            timeout = null;
                            if (!input || input.value !== origValue) {
                                listener(ev);
                            }
                        });
                    }
                };
                element.on('keydown', function (event) {
                    var key = event.keyCode;
                    if (key === 91 || 15 < key && key < 19 || 37 <= key && key <= 40)
                        return;
                    deferListener(event, this, this.value);
                });
                if ($sniffer.hasEvent('paste')) {
                    element.on('paste cut', deferListener);
                }
            }
            element.on('change', listener);
            if (PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type) {
                element.on(PARTIAL_VALIDATION_EVENTS, function (ev) {
                    if (!timeout) {
                        var validity = this[VALIDITY_STATE_PROPERTY];
                        var origBadInput = validity.badInput;
                        var origTypeMismatch = validity.typeMismatch;
                        timeout = $browser.defer(function () {
                            timeout = null;
                            if (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) {
                                listener(ev);
                            }
                        });
                    }
                });
            }
            ctrl.$render = function () {
                var value = ctrl.$isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue;
                if (element.val() !== value) {
                    element.val(value);
                }
            };
        }
        function weekParser(isoWeek, existingDate) {
            if (isDate(isoWeek)) {
                return isoWeek;
            }
            if (isString(isoWeek)) {
                WEEK_REGEXP.lastIndex = 0;
                var parts = WEEK_REGEXP.exec(isoWeek);
                if (parts) {
                    var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = (week - 1) * 7;
                    if (existingDate) {
                        hours = existingDate.getHours();
                        minutes = existingDate.getMinutes();
                        seconds = existingDate.getSeconds();
                        milliseconds = existingDate.getMilliseconds();
                    }
                    return new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds);
                }
            }
            return NaN;
        }
        function createDateParser(regexp, mapping) {
            return function (iso, date) {
                var parts, map;
                if (isDate(iso)) {
                    return iso;
                }
                if (isString(iso)) {
                    if (iso.charAt(0) == '"' && iso.charAt(iso.length - 1) == '"') {
                        iso = iso.substring(1, iso.length - 1);
                    }
                    if (ISO_DATE_REGEXP.test(iso)) {
                        return new Date(iso);
                    }
                    regexp.lastIndex = 0;
                    parts = regexp.exec(iso);
                    if (parts) {
                        parts.shift();
                        if (date) {
                            map = {
                                yyyy: date.getFullYear(),
                                MM: date.getMonth() + 1,
                                dd: date.getDate(),
                                HH: date.getHours(),
                                mm: date.getMinutes(),
                                ss: date.getSeconds(),
                                sss: date.getMilliseconds() / 1000
                            };
                        } else {
                            map = {
                                yyyy: 1970,
                                MM: 1,
                                dd: 1,
                                HH: 0,
                                mm: 0,
                                ss: 0,
                                sss: 0
                            };
                        }
                        forEach(parts, function (part, index) {
                            if (index < mapping.length) {
                                map[mapping[index]] = +part;
                            }
                        });
                        return new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, map.sss * 1000 || 0);
                    }
                }
                return NaN;
            };
        }
        function createDateInputType(type, regexp, parseDate, format) {
            return function dynamicDateInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter) {
                badInputChecker(scope, element, attr, ctrl);
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                var timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
                var previousDate;
                ctrl.$$parserName = type;
                ctrl.$parsers.push(function (value) {
                    if (ctrl.$isEmpty(value))
                        return null;
                    if (regexp.test(value)) {
                        var parsedDate = parseDate(value, previousDate);
                        if (timezone) {
                            parsedDate = convertTimezoneToLocal(parsedDate, timezone);
                        }
                        return parsedDate;
                    }
                    return undefined;
                });
                ctrl.$formatters.push(function (value) {
                    if (value && !isDate(value)) {
                        throw ngModelMinErr('datefmt', 'Expected `{0}` to be a date', value);
                    }
                    if (isValidDate(value)) {
                        previousDate = value;
                        if (previousDate && timezone) {
                            previousDate = convertTimezoneToLocal(previousDate, timezone, true);
                        }
                        return $filter('date')(value, format, timezone);
                    } else {
                        previousDate = null;
                        return '';
                    }
                });
                if (isDefined(attr.min) || attr.ngMin) {
                    var minVal;
                    ctrl.$validators.min = function (value) {
                        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal;
                    };
                    attr.$observe('min', function (val) {
                        minVal = parseObservedDateValue(val);
                        ctrl.$validate();
                    });
                }
                if (isDefined(attr.max) || attr.ngMax) {
                    var maxVal;
                    ctrl.$validators.max = function (value) {
                        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal;
                    };
                    attr.$observe('max', function (val) {
                        maxVal = parseObservedDateValue(val);
                        ctrl.$validate();
                    });
                }
                function isValidDate(value) {
                    return value && !(value.getTime && value.getTime() !== value.getTime());
                }
                function parseObservedDateValue(val) {
                    return isDefined(val) && !isDate(val) ? parseDate(val) || undefined : val;
                }
            };
        }
        function badInputChecker(scope, element, attr, ctrl) {
            var node = element[0];
            var nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
            if (nativeValidation) {
                ctrl.$parsers.push(function (value) {
                    var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                    return validity.badInput || validity.typeMismatch ? undefined : value;
                });
            }
        }
        function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            badInputChecker(scope, element, attr, ctrl);
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            ctrl.$$parserName = 'number';
            ctrl.$parsers.push(function (value) {
                if (ctrl.$isEmpty(value))
                    return null;
                if (NUMBER_REGEXP.test(value))
                    return parseFloat(value);
                return undefined;
            });
            ctrl.$formatters.push(function (value) {
                if (!ctrl.$isEmpty(value)) {
                    if (!isNumber(value)) {
                        throw ngModelMinErr('numfmt', 'Expected `{0}` to be a number', value);
                    }
                    value = value.toString();
                }
                return value;
            });
            if (isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function (value) {
                    return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal;
                };
                attr.$observe('min', function (val) {
                    if (isDefined(val) && !isNumber(val)) {
                        val = parseFloat(val, 10);
                    }
                    minVal = isNumber(val) && !isNaN(val) ? val : undefined;
                    ctrl.$validate();
                });
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function (value) {
                    return ctrl.$isEmpty(value) || isUndefined(maxVal) || value <= maxVal;
                };
                attr.$observe('max', function (val) {
                    if (isDefined(val) && !isNumber(val)) {
                        val = parseFloat(val, 10);
                    }
                    maxVal = isNumber(val) && !isNaN(val) ? val : undefined;
                    ctrl.$validate();
                });
            }
        }
        function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            stringBasedInputType(ctrl);
            ctrl.$$parserName = 'url';
            ctrl.$validators.url = function (modelValue, viewValue) {
                var value = modelValue || viewValue;
                return ctrl.$isEmpty(value) || URL_REGEXP.test(value);
            };
        }
        function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            stringBasedInputType(ctrl);
            ctrl.$$parserName = 'email';
            ctrl.$validators.email = function (modelValue, viewValue) {
                var value = modelValue || viewValue;
                return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value);
            };
        }
        function radioInputType(scope, element, attr, ctrl) {
            if (isUndefined(attr.name)) {
                element.attr('name', nextUid());
            }
            var listener = function (ev) {
                if (element[0].checked) {
                    ctrl.$setViewValue(attr.value, ev && ev.type);
                }
            };
            element.on('click', listener);
            ctrl.$render = function () {
                var value = attr.value;
                element[0].checked = value == ctrl.$viewValue;
            };
            attr.$observe('value', ctrl.$render);
        }
        function parseConstantExpr($parse, context, name, expression, fallback) {
            var parseFn;
            if (isDefined(expression)) {
                parseFn = $parse(expression);
                if (!parseFn.constant) {
                    throw ngModelMinErr('constexpr', 'Expected constant expression for `{0}`, but saw ' + '`{1}`.', name, expression);
                }
                return parseFn(context);
            }
            return fallback;
        }
        function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            var trueValue = parseConstantExpr($parse, scope, 'ngTrueValue', attr.ngTrueValue, true);
            var falseValue = parseConstantExpr($parse, scope, 'ngFalseValue', attr.ngFalseValue, false);
            var listener = function (ev) {
                ctrl.$setViewValue(element[0].checked, ev && ev.type);
            };
            element.on('click', listener);
            ctrl.$render = function () {
                element[0].checked = ctrl.$viewValue;
            };
            ctrl.$isEmpty = function (value) {
                return value === false;
            };
            ctrl.$formatters.push(function (value) {
                return equals(value, trueValue);
            });
            ctrl.$parsers.push(function (value) {
                return value ? trueValue : falseValue;
            });
        }
        var inputDirective = [
            '$browser',
            '$sniffer',
            '$filter',
            '$parse',
            function ($browser, $sniffer, $filter, $parse) {
                return {
                    restrict: 'E',
                    require: ['?ngModel'],
                    link: {
                        pre: function (scope, element, attr, ctrls) {
                            if (ctrls[0]) {
                                (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse);
                            }
                        }
                    }
                };
            }
        ];
        var CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/;
        var ngValueDirective = function () {
            return {
                restrict: 'A',
                priority: 100,
                compile: function (tpl, tplAttr) {
                    if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {
                        return function ngValueConstantLink(scope, elm, attr) {
                            attr.$set('value', scope.$eval(attr.ngValue));
                        };
                    } else {
                        return function ngValueLink(scope, elm, attr) {
                            scope.$watch(attr.ngValue, function valueWatchAction(value) {
                                attr.$set('value', value);
                            });
                        };
                    }
                }
            };
        };
        var ngBindDirective = [
            '$compile',
            function ($compile) {
                return {
                    restrict: 'AC',
                    compile: function ngBindCompile(templateElement) {
                        $compile.$$addBindingClass(templateElement);
                        return function ngBindLink(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBind);
                            element = element[0];
                            scope.$watch(attr.ngBind, function ngBindWatchAction(value) {
                                element.textContent = isUndefined(value) ? '' : value;
                            });
                        };
                    }
                };
            }
        ];
        var ngBindTemplateDirective = [
            '$interpolate',
            '$compile',
            function ($interpolate, $compile) {
                return {
                    compile: function ngBindTemplateCompile(templateElement) {
                        $compile.$$addBindingClass(templateElement);
                        return function ngBindTemplateLink(scope, element, attr) {
                            var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                            $compile.$$addBindingInfo(element, interpolateFn.expressions);
                            element = element[0];
                            attr.$observe('ngBindTemplate', function (value) {
                                element.textContent = isUndefined(value) ? '' : value;
                            });
                        };
                    }
                };
            }
        ];
        var ngBindHtmlDirective = [
            '$sce',
            '$parse',
            '$compile',
            function ($sce, $parse, $compile) {
                return {
                    restrict: 'A',
                    compile: function ngBindHtmlCompile(tElement, tAttrs) {
                        var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml);
                        var ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function getStringValue(value) {
                            return (value || '').toString();
                        });
                        $compile.$$addBindingClass(tElement);
                        return function ngBindHtmlLink(scope, element, attr) {
                            $compile.$$addBindingInfo(element, attr.ngBindHtml);
                            scope.$watch(ngBindHtmlWatch, function ngBindHtmlWatchAction() {
                                element.html($sce.getTrustedHtml(ngBindHtmlGetter(scope)) || '');
                            });
                        };
                    }
                };
            }
        ];
        var ngChangeDirective = valueFn({
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, element, attr, ctrl) {
                ctrl.$viewChangeListeners.push(function () {
                    scope.$eval(attr.ngChange);
                });
            }
        });
        function classDirective(name, selector) {
            name = 'ngClass' + name;
            return [
                '$animate',
                function ($animate) {
                    return {
                        restrict: 'AC',
                        link: function (scope, element, attr) {
                            var oldVal;
                            scope.$watch(attr[name], ngClassWatchAction, true);
                            attr.$observe('class', function (value) {
                                ngClassWatchAction(scope.$eval(attr[name]));
                            });
                            if (name !== 'ngClass') {
                                scope.$watch('$index', function ($index, old$index) {
                                    var mod = $index & 1;
                                    if (mod !== (old$index & 1)) {
                                        var classes = arrayClasses(scope.$eval(attr[name]));
                                        mod === selector ? addClasses(classes) : removeClasses(classes);
                                    }
                                });
                            }
                            function addClasses(classes) {
                                var newClasses = digestClassCounts(classes, 1);
                                attr.$addClass(newClasses);
                            }
                            function removeClasses(classes) {
                                var newClasses = digestClassCounts(classes, -1);
                                attr.$removeClass(newClasses);
                            }
                            function digestClassCounts(classes, count) {
                                var classCounts = element.data('$classCounts') || createMap();
                                var classesToUpdate = [];
                                forEach(classes, function (className) {
                                    if (count > 0 || classCounts[className]) {
                                        classCounts[className] = (classCounts[className] || 0) + count;
                                        if (classCounts[className] === +(count > 0)) {
                                            classesToUpdate.push(className);
                                        }
                                    }
                                });
                                element.data('$classCounts', classCounts);
                                return classesToUpdate.join(' ');
                            }
                            function updateClasses(oldClasses, newClasses) {
                                var toAdd = arrayDifference(newClasses, oldClasses);
                                var toRemove = arrayDifference(oldClasses, newClasses);
                                toAdd = digestClassCounts(toAdd, 1);
                                toRemove = digestClassCounts(toRemove, -1);
                                if (toAdd && toAdd.length) {
                                    $animate.addClass(element, toAdd);
                                }
                                if (toRemove && toRemove.length) {
                                    $animate.removeClass(element, toRemove);
                                }
                            }
                            function ngClassWatchAction(newVal) {
                                if (selector === true || scope.$index % 2 === selector) {
                                    var newClasses = arrayClasses(newVal || []);
                                    if (!oldVal) {
                                        addClasses(newClasses);
                                    } else if (!equals(newVal, oldVal)) {
                                        var oldClasses = arrayClasses(oldVal);
                                        updateClasses(oldClasses, newClasses);
                                    }
                                }
                                if (isArray(newVal)) {
                                    oldVal = newVal.map(function (v) {
                                        return shallowCopy(v);
                                    });
                                } else {
                                    oldVal = shallowCopy(newVal);
                                }
                            }
                        }
                    };
                    function arrayDifference(tokens1, tokens2) {
                        var values = [];
                        outer:
                            for (var i = 0; i < tokens1.length; i++) {
                                var token = tokens1[i];
                                for (var j = 0; j < tokens2.length; j++) {
                                    if (token == tokens2[j])
                                        continue outer;
                                }
                                values.push(token);
                            }
                        return values;
                    }
                    function arrayClasses(classVal) {
                        var classes = [];
                        if (isArray(classVal)) {
                            forEach(classVal, function (v) {
                                classes = classes.concat(arrayClasses(v));
                            });
                            return classes;
                        } else if (isString(classVal)) {
                            return classVal.split(' ');
                        } else if (isObject(classVal)) {
                            forEach(classVal, function (v, k) {
                                if (v) {
                                    classes = classes.concat(k.split(' '));
                                }
                            });
                            return classes;
                        }
                        return classVal;
                    }
                }
            ];
        }
        var ngClassDirective = classDirective('', true);
        var ngClassOddDirective = classDirective('Odd', 0);
        var ngClassEvenDirective = classDirective('Even', 1);
        var ngCloakDirective = ngDirective({
            compile: function (element, attr) {
                attr.$set('ngCloak', undefined);
                element.removeClass('ng-cloak');
            }
        });
        var ngControllerDirective = [function () {
                return {
                    restrict: 'A',
                    scope: true,
                    controller: '@',
                    priority: 500
                };
            }];
        var ngEventDirectives = {};
        var forceAsyncEvents = {
            'blur': true,
            'focus': true
        };
        forEach('click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste'.split(' '), function (eventName) {
            var directiveName = directiveNormalize('ng-' + eventName);
            ngEventDirectives[directiveName] = [
                '$parse',
                '$rootScope',
                function ($parse, $rootScope) {
                    return {
                        restrict: 'A',
                        compile: function ($element, attr) {
                            var fn = $parse(attr[directiveName], null, true);
                            return function ngEventHandler(scope, element) {
                                element.on(eventName, function (event) {
                                    var callback = function () {
                                        fn(scope, { $event: event });
                                    };
                                    if (forceAsyncEvents[eventName] && $rootScope.$$phase) {
                                        scope.$evalAsync(callback);
                                    } else {
                                        scope.$apply(callback);
                                    }
                                });
                            };
                        }
                    };
                }
            ];
        });
        var ngIfDirective = [
            '$animate',
            '$compile',
            function ($animate, $compile) {
                return {
                    multiElement: true,
                    transclude: 'element',
                    priority: 600,
                    terminal: true,
                    restrict: 'A',
                    $$tlb: true,
                    link: function ($scope, $element, $attr, ctrl, $transclude) {
                        var block, childScope, previousElements;
                        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {
                            if (value) {
                                if (!childScope) {
                                    $transclude(function (clone, newScope) {
                                        childScope = newScope;
                                        clone[clone.length++] = $compile.$$createComment('end ngIf', $attr.ngIf);
                                        block = { clone: clone };
                                        $animate.enter(clone, $element.parent(), $element);
                                    });
                                }
                            } else {
                                if (previousElements) {
                                    previousElements.remove();
                                    previousElements = null;
                                }
                                if (childScope) {
                                    childScope.$destroy();
                                    childScope = null;
                                }
                                if (block) {
                                    previousElements = getBlockNodes(block.clone);
                                    $animate.leave(previousElements).then(function () {
                                        previousElements = null;
                                    });
                                    block = null;
                                }
                            }
                        });
                    }
                };
            }
        ];
        var ngIncludeDirective = [
            '$templateRequest',
            '$anchorScroll',
            '$animate',
            function ($templateRequest, $anchorScroll, $animate) {
                return {
                    restrict: 'ECA',
                    priority: 400,
                    terminal: true,
                    transclude: 'element',
                    controller: angular.noop,
                    compile: function (element, attr) {
                        var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || '', autoScrollExp = attr.autoscroll;
                        return function (scope, $element, $attr, ctrl, $transclude) {
                            var changeCounter = 0, currentScope, previousElement, currentElement;
                            var cleanupLastIncludeContent = function () {
                                if (previousElement) {
                                    previousElement.remove();
                                    previousElement = null;
                                }
                                if (currentScope) {
                                    currentScope.$destroy();
                                    currentScope = null;
                                }
                                if (currentElement) {
                                    $animate.leave(currentElement).then(function () {
                                        previousElement = null;
                                    });
                                    previousElement = currentElement;
                                    currentElement = null;
                                }
                            };
                            scope.$watch(srcExp, function ngIncludeWatchAction(src) {
                                var afterAnimation = function () {
                                    if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {
                                        $anchorScroll();
                                    }
                                };
                                var thisChangeId = ++changeCounter;
                                if (src) {
                                    $templateRequest(src, true).then(function (response) {
                                        if (scope.$$destroyed)
                                            return;
                                        if (thisChangeId !== changeCounter)
                                            return;
                                        var newScope = scope.$new();
                                        ctrl.template = response;
                                        var clone = $transclude(newScope, function (clone) {
                                            cleanupLastIncludeContent();
                                            $animate.enter(clone, null, $element).then(afterAnimation);
                                        });
                                        currentScope = newScope;
                                        currentElement = clone;
                                        currentScope.$emit('$includeContentLoaded', src);
                                        scope.$eval(onloadExp);
                                    }, function () {
                                        if (scope.$$destroyed)
                                            return;
                                        if (thisChangeId === changeCounter) {
                                            cleanupLastIncludeContent();
                                            scope.$emit('$includeContentError', src);
                                        }
                                    });
                                    scope.$emit('$includeContentRequested', src);
                                } else {
                                    cleanupLastIncludeContent();
                                    ctrl.template = null;
                                }
                            });
                        };
                    }
                };
            }
        ];
        var ngIncludeFillContentDirective = [
            '$compile',
            function ($compile) {
                return {
                    restrict: 'ECA',
                    priority: -400,
                    require: 'ngInclude',
                    link: function (scope, $element, $attr, ctrl) {
                        if (toString.call($element[0]).match(/SVG/)) {
                            $element.empty();
                            $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function namespaceAdaptedClone(clone) {
                                $element.append(clone);
                            }, { futureParentElement: $element });
                            return;
                        }
                        $element.html(ctrl.template);
                        $compile($element.contents())(scope);
                    }
                };
            }
        ];
        var ngInitDirective = ngDirective({
            priority: 450,
            compile: function () {
                return {
                    pre: function (scope, element, attrs) {
                        scope.$eval(attrs.ngInit);
                    }
                };
            }
        });
        var ngListDirective = function () {
            return {
                restrict: 'A',
                priority: 100,
                require: 'ngModel',
                link: function (scope, element, attr, ctrl) {
                    var ngList = element.attr(attr.$attr.ngList) || ', ';
                    var trimValues = attr.ngTrim !== 'false';
                    var separator = trimValues ? trim(ngList) : ngList;
                    var parse = function (viewValue) {
                        if (isUndefined(viewValue))
                            return;
                        var list = [];
                        if (viewValue) {
                            forEach(viewValue.split(separator), function (value) {
                                if (value)
                                    list.push(trimValues ? trim(value) : value);
                            });
                        }
                        return list;
                    };
                    ctrl.$parsers.push(parse);
                    ctrl.$formatters.push(function (value) {
                        if (isArray(value)) {
                            return value.join(ngList);
                        }
                        return undefined;
                    });
                    ctrl.$isEmpty = function (value) {
                        return !value || !value.length;
                    };
                }
            };
        };
        var VALID_CLASS = 'ng-valid', INVALID_CLASS = 'ng-invalid', PRISTINE_CLASS = 'ng-pristine', DIRTY_CLASS = 'ng-dirty', UNTOUCHED_CLASS = 'ng-untouched', TOUCHED_CLASS = 'ng-touched', PENDING_CLASS = 'ng-pending', EMPTY_CLASS = 'ng-empty', NOT_EMPTY_CLASS = 'ng-not-empty';
        var ngModelMinErr = minErr('ngModel');
        var NgModelController = [
            '$scope',
            '$exceptionHandler',
            '$attrs',
            '$element',
            '$parse',
            '$animate',
            '$timeout',
            '$rootScope',
            '$q',
            '$interpolate',
            function ($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
                this.$viewValue = Number.NaN;
                this.$modelValue = Number.NaN;
                this.$$rawModelValue = undefined;
                this.$validators = {};
                this.$asyncValidators = {};
                this.$parsers = [];
                this.$formatters = [];
                this.$viewChangeListeners = [];
                this.$untouched = true;
                this.$touched = false;
                this.$pristine = true;
                this.$dirty = false;
                this.$valid = true;
                this.$invalid = false;
                this.$error = {};
                this.$$success = {};
                this.$pending = undefined;
                this.$name = $interpolate($attr.name || '', false)($scope);
                this.$$parentForm = nullFormCtrl;
                var parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, parserValid, ctrl = this;
                this.$$setOptions = function (options) {
                    ctrl.$options = options;
                    if (options && options.getterSetter) {
                        var invokeModelGetter = $parse($attr.ngModel + '()'), invokeModelSetter = $parse($attr.ngModel + '($$$p)');
                        ngModelGet = function ($scope) {
                            var modelValue = parsedNgModel($scope);
                            if (isFunction(modelValue)) {
                                modelValue = invokeModelGetter($scope);
                            }
                            return modelValue;
                        };
                        ngModelSet = function ($scope, newValue) {
                            if (isFunction(parsedNgModel($scope))) {
                                invokeModelSetter($scope, { $$$p: newValue });
                            } else {
                                parsedNgModelAssign($scope, newValue);
                            }
                        };
                    } else if (!parsedNgModel.assign) {
                        throw ngModelMinErr('nonassign', 'Expression \'{0}\' is non-assignable. Element: {1}', $attr.ngModel, startingTag($element));
                    }
                };
                this.$render = noop;
                this.$isEmpty = function (value) {
                    return isUndefined(value) || value === '' || value === null || value !== value;
                };
                this.$$updateEmptyClasses = function (value) {
                    if (ctrl.$isEmpty(value)) {
                        $animate.removeClass($element, NOT_EMPTY_CLASS);
                        $animate.addClass($element, EMPTY_CLASS);
                    } else {
                        $animate.removeClass($element, EMPTY_CLASS);
                        $animate.addClass($element, NOT_EMPTY_CLASS);
                    }
                };
                var currentValidationRunId = 0;
                addSetValidityMethod({
                    ctrl: this,
                    $element: $element,
                    set: function (object, property) {
                        object[property] = true;
                    },
                    unset: function (object, property) {
                        delete object[property];
                    },
                    $animate: $animate
                });
                this.$setPristine = function () {
                    ctrl.$dirty = false;
                    ctrl.$pristine = true;
                    $animate.removeClass($element, DIRTY_CLASS);
                    $animate.addClass($element, PRISTINE_CLASS);
                };
                this.$setDirty = function () {
                    ctrl.$dirty = true;
                    ctrl.$pristine = false;
                    $animate.removeClass($element, PRISTINE_CLASS);
                    $animate.addClass($element, DIRTY_CLASS);
                    ctrl.$$parentForm.$setDirty();
                };
                this.$setUntouched = function () {
                    ctrl.$touched = false;
                    ctrl.$untouched = true;
                    $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS);
                };
                this.$setTouched = function () {
                    ctrl.$touched = true;
                    ctrl.$untouched = false;
                    $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS);
                };
                this.$rollbackViewValue = function () {
                    $timeout.cancel(pendingDebounce);
                    ctrl.$viewValue = ctrl.$$lastCommittedViewValue;
                    ctrl.$render();
                };
                this.$validate = function () {
                    if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                        return;
                    }
                    var viewValue = ctrl.$$lastCommittedViewValue;
                    var modelValue = ctrl.$$rawModelValue;
                    var prevValid = ctrl.$valid;
                    var prevModelValue = ctrl.$modelValue;
                    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                    ctrl.$$runValidators(modelValue, viewValue, function (allValid) {
                        if (!allowInvalid && prevValid !== allValid) {
                            ctrl.$modelValue = allValid ? modelValue : undefined;
                            if (ctrl.$modelValue !== prevModelValue) {
                                ctrl.$$writeModelToScope();
                            }
                        }
                    });
                };
                this.$$runValidators = function (modelValue, viewValue, doneCallback) {
                    currentValidationRunId++;
                    var localValidationRunId = currentValidationRunId;
                    if (!processParseErrors()) {
                        validationDone(false);
                        return;
                    }
                    if (!processSyncValidators()) {
                        validationDone(false);
                        return;
                    }
                    processAsyncValidators();
                    function processParseErrors() {
                        var errorKey = ctrl.$$parserName || 'parse';
                        if (isUndefined(parserValid)) {
                            setValidity(errorKey, null);
                        } else {
                            if (!parserValid) {
                                forEach(ctrl.$validators, function (v, name) {
                                    setValidity(name, null);
                                });
                                forEach(ctrl.$asyncValidators, function (v, name) {
                                    setValidity(name, null);
                                });
                            }
                            setValidity(errorKey, parserValid);
                            return parserValid;
                        }
                        return true;
                    }
                    function processSyncValidators() {
                        var syncValidatorsValid = true;
                        forEach(ctrl.$validators, function (validator, name) {
                            var result = validator(modelValue, viewValue);
                            syncValidatorsValid = syncValidatorsValid && result;
                            setValidity(name, result);
                        });
                        if (!syncValidatorsValid) {
                            forEach(ctrl.$asyncValidators, function (v, name) {
                                setValidity(name, null);
                            });
                            return false;
                        }
                        return true;
                    }
                    function processAsyncValidators() {
                        var validatorPromises = [];
                        var allValid = true;
                        forEach(ctrl.$asyncValidators, function (validator, name) {
                            var promise = validator(modelValue, viewValue);
                            if (!isPromiseLike(promise)) {
                                throw ngModelMinErr('nopromise', 'Expected asynchronous validator to return a promise but got \'{0}\' instead.', promise);
                            }
                            setValidity(name, undefined);
                            validatorPromises.push(promise.then(function () {
                                setValidity(name, true);
                            }, function () {
                                allValid = false;
                                setValidity(name, false);
                            }));
                        });
                        if (!validatorPromises.length) {
                            validationDone(true);
                        } else {
                            $q.all(validatorPromises).then(function () {
                                validationDone(allValid);
                            }, noop);
                        }
                    }
                    function setValidity(name, isValid) {
                        if (localValidationRunId === currentValidationRunId) {
                            ctrl.$setValidity(name, isValid);
                        }
                    }
                    function validationDone(allValid) {
                        if (localValidationRunId === currentValidationRunId) {
                            doneCallback(allValid);
                        }
                    }
                };
                this.$commitViewValue = function () {
                    var viewValue = ctrl.$viewValue;
                    $timeout.cancel(pendingDebounce);
                    if (ctrl.$$lastCommittedViewValue === viewValue && (viewValue !== '' || !ctrl.$$hasNativeValidators)) {
                        return;
                    }
                    ctrl.$$updateEmptyClasses(viewValue);
                    ctrl.$$lastCommittedViewValue = viewValue;
                    if (ctrl.$pristine) {
                        this.$setDirty();
                    }
                    this.$$parseAndValidate();
                };
                this.$$parseAndValidate = function () {
                    var viewValue = ctrl.$$lastCommittedViewValue;
                    var modelValue = viewValue;
                    parserValid = isUndefined(modelValue) ? undefined : true;
                    if (parserValid) {
                        for (var i = 0; i < ctrl.$parsers.length; i++) {
                            modelValue = ctrl.$parsers[i](modelValue);
                            if (isUndefined(modelValue)) {
                                parserValid = false;
                                break;
                            }
                        }
                    }
                    if (isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue)) {
                        ctrl.$modelValue = ngModelGet($scope);
                    }
                    var prevModelValue = ctrl.$modelValue;
                    var allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                    ctrl.$$rawModelValue = modelValue;
                    if (allowInvalid) {
                        ctrl.$modelValue = modelValue;
                        writeToModelIfNeeded();
                    }
                    ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function (allValid) {
                        if (!allowInvalid) {
                            ctrl.$modelValue = allValid ? modelValue : undefined;
                            writeToModelIfNeeded();
                        }
                    });
                    function writeToModelIfNeeded() {
                        if (ctrl.$modelValue !== prevModelValue) {
                            ctrl.$$writeModelToScope();
                        }
                    }
                };
                this.$$writeModelToScope = function () {
                    ngModelSet($scope, ctrl.$modelValue);
                    forEach(ctrl.$viewChangeListeners, function (listener) {
                        try {
                            listener();
                        } catch (e) {
                            $exceptionHandler(e);
                        }
                    });
                };
                this.$setViewValue = function (value, trigger) {
                    ctrl.$viewValue = value;
                    if (!ctrl.$options || ctrl.$options.updateOnDefault) {
                        ctrl.$$debounceViewValueCommit(trigger);
                    }
                };
                this.$$debounceViewValueCommit = function (trigger) {
                    var debounceDelay = 0, options = ctrl.$options, debounce;
                    if (options && isDefined(options.debounce)) {
                        debounce = options.debounce;
                        if (isNumber(debounce)) {
                            debounceDelay = debounce;
                        } else if (isNumber(debounce[trigger])) {
                            debounceDelay = debounce[trigger];
                        } else if (isNumber(debounce['default'])) {
                            debounceDelay = debounce['default'];
                        }
                    }
                    $timeout.cancel(pendingDebounce);
                    if (debounceDelay) {
                        pendingDebounce = $timeout(function () {
                            ctrl.$commitViewValue();
                        }, debounceDelay);
                    } else if ($rootScope.$$phase) {
                        ctrl.$commitViewValue();
                    } else {
                        $scope.$apply(function () {
                            ctrl.$commitViewValue();
                        });
                    }
                };
                $scope.$watch(function ngModelWatch() {
                    var modelValue = ngModelGet($scope);
                    if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                        ctrl.$modelValue = ctrl.$$rawModelValue = modelValue;
                        parserValid = undefined;
                        var formatters = ctrl.$formatters, idx = formatters.length;
                        var viewValue = modelValue;
                        while (idx--) {
                            viewValue = formatters[idx](viewValue);
                        }
                        if (ctrl.$viewValue !== viewValue) {
                            ctrl.$$updateEmptyClasses(viewValue);
                            ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue;
                            ctrl.$render();
                            ctrl.$$runValidators(modelValue, viewValue, noop);
                        }
                    }
                    return modelValue;
                });
            }
        ];
        var ngModelDirective = [
            '$rootScope',
            function ($rootScope) {
                return {
                    restrict: 'A',
                    require: [
                        'ngModel',
                        '^?form',
                        '^?ngModelOptions'
                    ],
                    controller: NgModelController,
                    priority: 1,
                    compile: function ngModelCompile(element) {
                        element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS);
                        return {
                            pre: function ngModelPreLink(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                                modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options);
                                formCtrl.$addControl(modelCtrl);
                                attr.$observe('name', function (newValue) {
                                    if (modelCtrl.$name !== newValue) {
                                        modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue);
                                    }
                                });
                                scope.$on('$destroy', function () {
                                    modelCtrl.$$parentForm.$removeControl(modelCtrl);
                                });
                            },
                            post: function ngModelPostLink(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0];
                                if (modelCtrl.$options && modelCtrl.$options.updateOn) {
                                    element.on(modelCtrl.$options.updateOn, function (ev) {
                                        modelCtrl.$$debounceViewValueCommit(ev && ev.type);
                                    });
                                }
                                element.on('blur', function () {
                                    if (modelCtrl.$touched)
                                        return;
                                    if ($rootScope.$$phase) {
                                        scope.$evalAsync(modelCtrl.$setTouched);
                                    } else {
                                        scope.$apply(modelCtrl.$setTouched);
                                    }
                                });
                            }
                        };
                    }
                };
            }
        ];
        var DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
        var ngModelOptionsDirective = function () {
            return {
                restrict: 'A',
                controller: [
                    '$scope',
                    '$attrs',
                    function ($scope, $attrs) {
                        var that = this;
                        this.$options = copy($scope.$eval($attrs.ngModelOptions));
                        if (isDefined(this.$options.updateOn)) {
                            this.$options.updateOnDefault = false;
                            this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function () {
                                that.$options.updateOnDefault = true;
                                return ' ';
                            }));
                        } else {
                            this.$options.updateOnDefault = true;
                        }
                    }
                ]
            };
        };
        function addSetValidityMethod(context) {
            var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, $animate = context.$animate;
            classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS));
            ctrl.$setValidity = setValidity;
            function setValidity(validationErrorKey, state, controller) {
                if (isUndefined(state)) {
                    createAndSet('$pending', validationErrorKey, controller);
                } else {
                    unsetAndCleanup('$pending', validationErrorKey, controller);
                }
                if (!isBoolean(state)) {
                    unset(ctrl.$error, validationErrorKey, controller);
                    unset(ctrl.$$success, validationErrorKey, controller);
                } else {
                    if (state) {
                        unset(ctrl.$error, validationErrorKey, controller);
                        set(ctrl.$$success, validationErrorKey, controller);
                    } else {
                        set(ctrl.$error, validationErrorKey, controller);
                        unset(ctrl.$$success, validationErrorKey, controller);
                    }
                }
                if (ctrl.$pending) {
                    cachedToggleClass(PENDING_CLASS, true);
                    ctrl.$valid = ctrl.$invalid = undefined;
                    toggleValidationCss('', null);
                } else {
                    cachedToggleClass(PENDING_CLASS, false);
                    ctrl.$valid = isObjectEmpty(ctrl.$error);
                    ctrl.$invalid = !ctrl.$valid;
                    toggleValidationCss('', ctrl.$valid);
                }
                var combinedState;
                if (ctrl.$pending && ctrl.$pending[validationErrorKey]) {
                    combinedState = undefined;
                } else if (ctrl.$error[validationErrorKey]) {
                    combinedState = false;
                } else if (ctrl.$$success[validationErrorKey]) {
                    combinedState = true;
                } else {
                    combinedState = null;
                }
                toggleValidationCss(validationErrorKey, combinedState);
                ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl);
            }
            function createAndSet(name, value, controller) {
                if (!ctrl[name]) {
                    ctrl[name] = {};
                }
                set(ctrl[name], value, controller);
            }
            function unsetAndCleanup(name, value, controller) {
                if (ctrl[name]) {
                    unset(ctrl[name], value, controller);
                }
                if (isObjectEmpty(ctrl[name])) {
                    ctrl[name] = undefined;
                }
            }
            function cachedToggleClass(className, switchValue) {
                if (switchValue && !classCache[className]) {
                    $animate.addClass($element, className);
                    classCache[className] = true;
                } else if (!switchValue && classCache[className]) {
                    $animate.removeClass($element, className);
                    classCache[className] = false;
                }
            }
            function toggleValidationCss(validationErrorKey, isValid) {
                validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';
                cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === true);
                cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === false);
            }
        }
        function isObjectEmpty(obj) {
            if (obj) {
                for (var prop in obj) {
                    if (obj.hasOwnProperty(prop)) {
                        return false;
                    }
                }
            }
            return true;
        }
        var ngNonBindableDirective = ngDirective({
            terminal: true,
            priority: 1000
        });
        var ngOptionsMinErr = minErr('ngOptions');
        var NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/;
        var ngOptionsDirective = [
            '$compile',
            '$document',
            '$parse',
            function ($compile, $document, $parse) {
                function parseOptionsExpression(optionsExp, selectElement, scope) {
                    var match = optionsExp.match(NG_OPTIONS_REGEXP);
                    if (!match) {
                        throw ngOptionsMinErr('iexp', 'Expected expression in form of ' + '\'_select_ (as _label_)? for (_key_,)?_value_ in _collection_\'' + ' but got \'{0}\'. Element: {1}', optionsExp, startingTag(selectElement));
                    }
                    var valueName = match[5] || match[7];
                    var keyName = match[6];
                    var selectAs = / as /.test(match[0]) && match[1];
                    var trackBy = match[9];
                    var valueFn = $parse(match[2] ? match[1] : valueName);
                    var selectAsFn = selectAs && $parse(selectAs);
                    var viewValueFn = selectAsFn || valueFn;
                    var trackByFn = trackBy && $parse(trackBy);
                    var getTrackByValueFn = trackBy ? function (value, locals) {
                        return trackByFn(scope, locals);
                    } : function getHashOfValue(value) {
                        return hashKey(value);
                    };
                    var getTrackByValue = function (value, key) {
                        return getTrackByValueFn(value, getLocals(value, key));
                    };
                    var displayFn = $parse(match[2] || match[1]);
                    var groupByFn = $parse(match[3] || '');
                    var disableWhenFn = $parse(match[4] || '');
                    var valuesFn = $parse(match[8]);
                    var locals = {};
                    var getLocals = keyName ? function (value, key) {
                        locals[keyName] = key;
                        locals[valueName] = value;
                        return locals;
                    } : function (value) {
                        locals[valueName] = value;
                        return locals;
                    };
                    function Option(selectValue, viewValue, label, group, disabled) {
                        this.selectValue = selectValue;
                        this.viewValue = viewValue;
                        this.label = label;
                        this.group = group;
                        this.disabled = disabled;
                    }
                    function getOptionValuesKeys(optionValues) {
                        var optionValuesKeys;
                        if (!keyName && isArrayLike(optionValues)) {
                            optionValuesKeys = optionValues;
                        } else {
                            optionValuesKeys = [];
                            for (var itemKey in optionValues) {
                                if (optionValues.hasOwnProperty(itemKey) && itemKey.charAt(0) !== '$') {
                                    optionValuesKeys.push(itemKey);
                                }
                            }
                        }
                        return optionValuesKeys;
                    }
                    return {
                        trackBy: trackBy,
                        getTrackByValue: getTrackByValue,
                        getWatchables: $parse(valuesFn, function (optionValues) {
                            var watchedArray = [];
                            optionValues = optionValues || [];
                            var optionValuesKeys = getOptionValuesKeys(optionValues);
                            var optionValuesLength = optionValuesKeys.length;
                            for (var index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                                var value = optionValues[key];
                                var locals = getLocals(value, key);
                                var selectValue = getTrackByValueFn(value, locals);
                                watchedArray.push(selectValue);
                                if (match[2] || match[1]) {
                                    var label = displayFn(scope, locals);
                                    watchedArray.push(label);
                                }
                                if (match[4]) {
                                    var disableWhen = disableWhenFn(scope, locals);
                                    watchedArray.push(disableWhen);
                                }
                            }
                            return watchedArray;
                        }),
                        getOptions: function () {
                            var optionItems = [];
                            var selectValueMap = {};
                            var optionValues = valuesFn(scope) || [];
                            var optionValuesKeys = getOptionValuesKeys(optionValues);
                            var optionValuesLength = optionValuesKeys.length;
                            for (var index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index];
                                var value = optionValues[key];
                                var locals = getLocals(value, key);
                                var viewValue = viewValueFn(scope, locals);
                                var selectValue = getTrackByValueFn(viewValue, locals);
                                var label = displayFn(scope, locals);
                                var group = groupByFn(scope, locals);
                                var disabled = disableWhenFn(scope, locals);
                                var optionItem = new Option(selectValue, viewValue, label, group, disabled);
                                optionItems.push(optionItem);
                                selectValueMap[selectValue] = optionItem;
                            }
                            return {
                                items: optionItems,
                                selectValueMap: selectValueMap,
                                getOptionFromViewValue: function (value) {
                                    return selectValueMap[getTrackByValue(value)];
                                },
                                getViewValueFromOption: function (option) {
                                    return trackBy ? angular.copy(option.viewValue) : option.viewValue;
                                }
                            };
                        }
                    };
                }
                var optionTemplate = window.document.createElement('option'), optGroupTemplate = window.document.createElement('optgroup');
                function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
                    var selectCtrl = ctrls[0];
                    var ngModelCtrl = ctrls[1];
                    var multiple = attr.multiple;
                    var emptyOption;
                    for (var i = 0, children = selectElement.children(), ii = children.length; i < ii; i++) {
                        if (children[i].value === '') {
                            emptyOption = children.eq(i);
                            break;
                        }
                    }
                    var providedEmptyOption = !!emptyOption;
                    var unknownOption = jqLite(optionTemplate.cloneNode(false));
                    unknownOption.val('?');
                    var options;
                    var ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope);
                    var listFragment = $document[0].createDocumentFragment();
                    var renderEmptyOption = function () {
                        if (!providedEmptyOption) {
                            selectElement.prepend(emptyOption);
                        }
                        selectElement.val('');
                        emptyOption.prop('selected', true);
                        emptyOption.attr('selected', true);
                    };
                    var removeEmptyOption = function () {
                        if (!providedEmptyOption) {
                            emptyOption.remove();
                        }
                    };
                    var renderUnknownOption = function () {
                        selectElement.prepend(unknownOption);
                        selectElement.val('?');
                        unknownOption.prop('selected', true);
                        unknownOption.attr('selected', true);
                    };
                    var removeUnknownOption = function () {
                        unknownOption.remove();
                    };
                    if (!multiple) {
                        selectCtrl.writeValue = function writeNgOptionsValue(value) {
                            var option = options.getOptionFromViewValue(value);
                            if (option) {
                                if (selectElement[0].value !== option.selectValue) {
                                    removeUnknownOption();
                                    removeEmptyOption();
                                    selectElement[0].value = option.selectValue;
                                    option.element.selected = true;
                                }
                                option.element.setAttribute('selected', 'selected');
                            } else {
                                if (value === null || providedEmptyOption) {
                                    removeUnknownOption();
                                    renderEmptyOption();
                                } else {
                                    removeEmptyOption();
                                    renderUnknownOption();
                                }
                            }
                        };
                        selectCtrl.readValue = function readNgOptionsValue() {
                            var selectedOption = options.selectValueMap[selectElement.val()];
                            if (selectedOption && !selectedOption.disabled) {
                                removeEmptyOption();
                                removeUnknownOption();
                                return options.getViewValueFromOption(selectedOption);
                            }
                            return null;
                        };
                        if (ngOptions.trackBy) {
                            scope.$watch(function () {
                                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue);
                            }, function () {
                                ngModelCtrl.$render();
                            });
                        }
                    } else {
                        ngModelCtrl.$isEmpty = function (value) {
                            return !value || value.length === 0;
                        };
                        selectCtrl.writeValue = function writeNgOptionsMultiple(value) {
                            options.items.forEach(function (option) {
                                option.element.selected = false;
                            });
                            if (value) {
                                value.forEach(function (item) {
                                    var option = options.getOptionFromViewValue(item);
                                    if (option)
                                        option.element.selected = true;
                                });
                            }
                        };
                        selectCtrl.readValue = function readNgOptionsMultiple() {
                            var selectedValues = selectElement.val() || [], selections = [];
                            forEach(selectedValues, function (value) {
                                var option = options.selectValueMap[value];
                                if (option && !option.disabled)
                                    selections.push(options.getViewValueFromOption(option));
                            });
                            return selections;
                        };
                        if (ngOptions.trackBy) {
                            scope.$watchCollection(function () {
                                if (isArray(ngModelCtrl.$viewValue)) {
                                    return ngModelCtrl.$viewValue.map(function (value) {
                                        return ngOptions.getTrackByValue(value);
                                    });
                                }
                            }, function () {
                                ngModelCtrl.$render();
                            });
                        }
                    }
                    if (providedEmptyOption) {
                        emptyOption.remove();
                        $compile(emptyOption)(scope);
                        emptyOption.removeClass('ng-scope');
                    } else {
                        emptyOption = jqLite(optionTemplate.cloneNode(false));
                    }
                    selectElement.empty();
                    updateOptions();
                    scope.$watchCollection(ngOptions.getWatchables, updateOptions);
                    function addOptionElement(option, parent) {
                        var optionElement = optionTemplate.cloneNode(false);
                        parent.appendChild(optionElement);
                        updateOptionElement(option, optionElement);
                    }
                    function updateOptionElement(option, element) {
                        option.element = element;
                        element.disabled = option.disabled;
                        if (option.label !== element.label) {
                            element.label = option.label;
                            element.textContent = option.label;
                        }
                        if (option.value !== element.value)
                            element.value = option.selectValue;
                    }
                    function updateOptions() {
                        var previousValue = options && selectCtrl.readValue();
                        if (options) {
                            for (var i = options.items.length - 1; i >= 0; i--) {
                                var option = options.items[i];
                                if (option.group) {
                                    jqLiteRemove(option.element.parentNode);
                                } else {
                                    jqLiteRemove(option.element);
                                }
                            }
                        }
                        options = ngOptions.getOptions();
                        var groupElementMap = {};
                        if (providedEmptyOption) {
                            selectElement.prepend(emptyOption);
                        }
                        options.items.forEach(function addOption(option) {
                            var groupElement;
                            if (isDefined(option.group)) {
                                groupElement = groupElementMap[option.group];
                                if (!groupElement) {
                                    groupElement = optGroupTemplate.cloneNode(false);
                                    listFragment.appendChild(groupElement);
                                    groupElement.label = option.group;
                                    groupElementMap[option.group] = groupElement;
                                }
                                addOptionElement(option, groupElement);
                            } else {
                                addOptionElement(option, listFragment);
                            }
                        });
                        selectElement[0].appendChild(listFragment);
                        ngModelCtrl.$render();
                        if (!ngModelCtrl.$isEmpty(previousValue)) {
                            var nextValue = selectCtrl.readValue();
                            var isNotPrimitive = ngOptions.trackBy || multiple;
                            if (isNotPrimitive ? !equals(previousValue, nextValue) : previousValue !== nextValue) {
                                ngModelCtrl.$setViewValue(nextValue);
                                ngModelCtrl.$render();
                            }
                        }
                    }
                }
                return {
                    restrict: 'A',
                    terminal: true,
                    require: [
                        'select',
                        'ngModel'
                    ],
                    link: {
                        pre: function ngOptionsPreLink(scope, selectElement, attr, ctrls) {
                            ctrls[0].registerOption = noop;
                        },
                        post: ngOptionsPostLink
                    }
                };
            }
        ];
        var ngPluralizeDirective = [
            '$locale',
            '$interpolate',
            '$log',
            function ($locale, $interpolate, $log) {
                var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
                return {
                    link: function (scope, element, attr) {
                        var numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + '-' + offset + endSymbol, watchRemover = angular.noop, lastCount;
                        forEach(attr, function (expression, attributeName) {
                            var tmpMatch = IS_WHEN.exec(attributeName);
                            if (tmpMatch) {
                                var whenKey = (tmpMatch[1] ? '-' : '') + lowercase(tmpMatch[2]);
                                whens[whenKey] = element.attr(attr.$attr[attributeName]);
                            }
                        });
                        forEach(whens, function (expression, key) {
                            whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement));
                        });
                        scope.$watch(numberExp, function ngPluralizeWatchAction(newVal) {
                            var count = parseFloat(newVal);
                            var countIsNaN = isNaN(count);
                            if (!countIsNaN && !(count in whens)) {
                                count = $locale.pluralCat(count - offset);
                            }
                            if (count !== lastCount && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                                watchRemover();
                                var whenExpFn = whensExpFns[count];
                                if (isUndefined(whenExpFn)) {
                                    if (newVal != null) {
                                        $log.debug('ngPluralize: no rule defined for \'' + count + '\' in ' + whenExp);
                                    }
                                    watchRemover = noop;
                                    updateElementText();
                                } else {
                                    watchRemover = scope.$watch(whenExpFn, updateElementText);
                                }
                                lastCount = count;
                            }
                        });
                        function updateElementText(newText) {
                            element.text(newText || '');
                        }
                    }
                };
            }
        ];
        var ngRepeatDirective = [
            '$parse',
            '$animate',
            '$compile',
            function ($parse, $animate, $compile) {
                var NG_REMOVED = '$$NG_REMOVED';
                var ngRepeatMinErr = minErr('ngRepeat');
                var updateScope = function (scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
                    scope[valueIdentifier] = value;
                    if (keyIdentifier)
                        scope[keyIdentifier] = key;
                    scope.$index = index;
                    scope.$first = index === 0;
                    scope.$last = index === arrayLength - 1;
                    scope.$middle = !(scope.$first || scope.$last);
                    scope.$odd = !(scope.$even = (index & 1) === 0);
                };
                var getBlockStart = function (block) {
                    return block.clone[0];
                };
                var getBlockEnd = function (block) {
                    return block.clone[block.clone.length - 1];
                };
                return {
                    restrict: 'A',
                    multiElement: true,
                    transclude: 'element',
                    priority: 1000,
                    terminal: true,
                    $$tlb: true,
                    compile: function ngRepeatCompile($element, $attr) {
                        var expression = $attr.ngRepeat;
                        var ngRepeatEndComment = $compile.$$createComment('end ngRepeat', expression);
                        var match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                        if (!match) {
                            throw ngRepeatMinErr('iexp', 'Expected expression in form of \'_item_ in _collection_[ track by _id_]\' but got \'{0}\'.', expression);
                        }
                        var lhs = match[1];
                        var rhs = match[2];
                        var aliasAs = match[3];
                        var trackByExp = match[4];
                        match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/);
                        if (!match) {
                            throw ngRepeatMinErr('iidexp', '\'_item_\' in \'_item_ in _collection_\' should be an identifier or \'(_key_, _value_)\' expression, but got \'{0}\'.', lhs);
                        }
                        var valueIdentifier = match[3] || match[1];
                        var keyIdentifier = match[2];
                        if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) {
                            throw ngRepeatMinErr('badident', 'alias \'{0}\' is invalid --- must be a valid JS identifier which is not a reserved name.', aliasAs);
                        }
                        var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn;
                        var hashFnLocals = { $id: hashKey };
                        if (trackByExp) {
                            trackByExpGetter = $parse(trackByExp);
                        } else {
                            trackByIdArrayFn = function (key, value) {
                                return hashKey(value);
                            };
                            trackByIdObjFn = function (key) {
                                return key;
                            };
                        }
                        return function ngRepeatLink($scope, $element, $attr, ctrl, $transclude) {
                            if (trackByExpGetter) {
                                trackByIdExpFn = function (key, value, index) {
                                    if (keyIdentifier)
                                        hashFnLocals[keyIdentifier] = key;
                                    hashFnLocals[valueIdentifier] = value;
                                    hashFnLocals.$index = index;
                                    return trackByExpGetter($scope, hashFnLocals);
                                };
                            }
                            var lastBlockMap = createMap();
                            $scope.$watchCollection(rhs, function ngRepeatAction(collection) {
                                var index, length, previousNode = $element[0], nextNode, nextBlockMap = createMap(), collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove;
                                if (aliasAs) {
                                    $scope[aliasAs] = collection;
                                }
                                if (isArrayLike(collection)) {
                                    collectionKeys = collection;
                                    trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                                } else {
                                    trackByIdFn = trackByIdExpFn || trackByIdObjFn;
                                    collectionKeys = [];
                                    for (var itemKey in collection) {
                                        if (hasOwnProperty.call(collection, itemKey) && itemKey.charAt(0) !== '$') {
                                            collectionKeys.push(itemKey);
                                        }
                                    }
                                }
                                collectionLength = collectionKeys.length;
                                nextBlockOrder = new Array(collectionLength);
                                for (index = 0; index < collectionLength; index++) {
                                    key = collection === collectionKeys ? index : collectionKeys[index];
                                    value = collection[key];
                                    trackById = trackByIdFn(key, value, index);
                                    if (lastBlockMap[trackById]) {
                                        block = lastBlockMap[trackById];
                                        delete lastBlockMap[trackById];
                                        nextBlockMap[trackById] = block;
                                        nextBlockOrder[index] = block;
                                    } else if (nextBlockMap[trackById]) {
                                        forEach(nextBlockOrder, function (block) {
                                            if (block && block.scope)
                                                lastBlockMap[block.id] = block;
                                        });
                                        throw ngRepeatMinErr('dupes', 'Duplicates in a repeater are not allowed. Use \'track by\' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}', expression, trackById, value);
                                    } else {
                                        nextBlockOrder[index] = {
                                            id: trackById,
                                            scope: undefined,
                                            clone: undefined
                                        };
                                        nextBlockMap[trackById] = true;
                                    }
                                }
                                for (var blockKey in lastBlockMap) {
                                    block = lastBlockMap[blockKey];
                                    elementsToRemove = getBlockNodes(block.clone);
                                    $animate.leave(elementsToRemove);
                                    if (elementsToRemove[0].parentNode) {
                                        for (index = 0, length = elementsToRemove.length; index < length; index++) {
                                            elementsToRemove[index][NG_REMOVED] = true;
                                        }
                                    }
                                    block.scope.$destroy();
                                }
                                for (index = 0; index < collectionLength; index++) {
                                    key = collection === collectionKeys ? index : collectionKeys[index];
                                    value = collection[key];
                                    block = nextBlockOrder[index];
                                    if (block.scope) {
                                        nextNode = previousNode;
                                        do {
                                            nextNode = nextNode.nextSibling;
                                        } while (nextNode && nextNode[NG_REMOVED]);
                                        if (getBlockStart(block) != nextNode) {
                                            $animate.move(getBlockNodes(block.clone), null, previousNode);
                                        }
                                        previousNode = getBlockEnd(block);
                                        updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                    } else {
                                        $transclude(function ngRepeatTransclude(clone, scope) {
                                            block.scope = scope;
                                            var endNode = ngRepeatEndComment.cloneNode(false);
                                            clone[clone.length++] = endNode;
                                            $animate.enter(clone, null, previousNode);
                                            previousNode = endNode;
                                            block.clone = clone;
                                            nextBlockMap[block.id] = block;
                                            updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength);
                                        });
                                    }
                                }
                                lastBlockMap = nextBlockMap;
                            });
                        };
                    }
                };
            }
        ];
        var NG_HIDE_CLASS = 'ng-hide';
        var NG_HIDE_IN_PROGRESS_CLASS = 'ng-hide-animate';
        var ngShowDirective = [
            '$animate',
            function ($animate) {
                return {
                    restrict: 'A',
                    multiElement: true,
                    link: function (scope, element, attr) {
                        scope.$watch(attr.ngShow, function ngShowWatchAction(value) {
                            $animate[value ? 'removeClass' : 'addClass'](element, NG_HIDE_CLASS, { tempClasses: NG_HIDE_IN_PROGRESS_CLASS });
                        });
                    }
                };
            }
        ];
        var ngHideDirective = [
            '$animate',
            function ($animate) {
                return {
                    restrict: 'A',
                    multiElement: true,
                    link: function (scope, element, attr) {
                        scope.$watch(attr.ngHide, function ngHideWatchAction(value) {
                            $animate[value ? 'addClass' : 'removeClass'](element, NG_HIDE_CLASS, { tempClasses: NG_HIDE_IN_PROGRESS_CLASS });
                        });
                    }
                };
            }
        ];
        var ngStyleDirective = ngDirective(function (scope, element, attr) {
            scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {
                if (oldStyles && newStyles !== oldStyles) {
                    forEach(oldStyles, function (val, style) {
                        element.css(style, '');
                    });
                }
                if (newStyles)
                    element.css(newStyles);
            }, true);
        });
        var ngSwitchDirective = [
            '$animate',
            '$compile',
            function ($animate, $compile) {
                return {
                    require: 'ngSwitch',
                    controller: [
                        '$scope',
                        function ngSwitchController() {
                            this.cases = {};
                        }
                    ],
                    link: function (scope, element, attr, ngSwitchController) {
                        var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [];
                        var spliceFactory = function (array, index) {
                            return function () {
                                array.splice(index, 1);
                            };
                        };
                        scope.$watch(watchExpr, function ngSwitchWatchAction(value) {
                            var i, ii;
                            for (i = 0, ii = previousLeaveAnimations.length; i < ii; ++i) {
                                $animate.cancel(previousLeaveAnimations[i]);
                            }
                            previousLeaveAnimations.length = 0;
                            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                                var selected = getBlockNodes(selectedElements[i].clone);
                                selectedScopes[i].$destroy();
                                var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                                promise.then(spliceFactory(previousLeaveAnimations, i));
                            }
                            selectedElements.length = 0;
                            selectedScopes.length = 0;
                            if (selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?']) {
                                forEach(selectedTranscludes, function (selectedTransclude) {
                                    selectedTransclude.transclude(function (caseElement, selectedScope) {
                                        selectedScopes.push(selectedScope);
                                        var anchor = selectedTransclude.element;
                                        caseElement[caseElement.length++] = $compile.$$createComment('end ngSwitchWhen');
                                        var block = { clone: caseElement };
                                        selectedElements.push(block);
                                        $animate.enter(caseElement, anchor.parent(), anchor);
                                    });
                                });
                            }
                        });
                    }
                };
            }
        ];
        var ngSwitchWhenDirective = ngDirective({
            transclude: 'element',
            priority: 1200,
            require: '^ngSwitch',
            multiElement: true,
            link: function (scope, element, attrs, ctrl, $transclude) {
                ctrl.cases['!' + attrs.ngSwitchWhen] = ctrl.cases['!' + attrs.ngSwitchWhen] || [];
                ctrl.cases['!' + attrs.ngSwitchWhen].push({
                    transclude: $transclude,
                    element: element
                });
            }
        });
        var ngSwitchDefaultDirective = ngDirective({
            transclude: 'element',
            priority: 1200,
            require: '^ngSwitch',
            multiElement: true,
            link: function (scope, element, attr, ctrl, $transclude) {
                ctrl.cases['?'] = ctrl.cases['?'] || [];
                ctrl.cases['?'].push({
                    transclude: $transclude,
                    element: element
                });
            }
        });
        var ngTranscludeMinErr = minErr('ngTransclude');
        var ngTranscludeDirective = ngDirective({
            restrict: 'EAC',
            link: function ($scope, $element, $attrs, controller, $transclude) {
                if ($attrs.ngTransclude === $attrs.$attr.ngTransclude) {
                    $attrs.ngTransclude = '';
                }
                function ngTranscludeCloneAttachFn(clone) {
                    if (clone.length) {
                        $element.empty();
                        $element.append(clone);
                    }
                }
                if (!$transclude) {
                    throw ngTranscludeMinErr('orphan', 'Illegal use of ngTransclude directive in the template! ' + 'No parent directive that requires a transclusion found. ' + 'Element: {0}', startingTag($element));
                }
                var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                $transclude(ngTranscludeCloneAttachFn, null, slotName);
            }
        });
        var scriptDirective = [
            '$templateCache',
            function ($templateCache) {
                return {
                    restrict: 'E',
                    terminal: true,
                    compile: function (element, attr) {
                        if (attr.type == 'text/ng-template') {
                            var templateUrl = attr.id, text = element[0].text;
                            $templateCache.put(templateUrl, text);
                        }
                    }
                };
            }
        ];
        var noopNgModelController = {
            $setViewValue: noop,
            $render: noop
        };
        function chromeHack(optionElement) {
            if (optionElement[0].hasAttribute('selected')) {
                optionElement[0].selected = true;
            }
        }
        var SelectController = [
            '$element',
            '$scope',
            function ($element, $scope) {
                var self = this, optionsMap = new HashMap();
                self.ngModelCtrl = noopNgModelController;
                self.unknownOption = jqLite(window.document.createElement('option'));
                self.renderUnknownOption = function (val) {
                    var unknownVal = '? ' + hashKey(val) + ' ?';
                    self.unknownOption.val(unknownVal);
                    $element.prepend(self.unknownOption);
                    $element.val(unknownVal);
                };
                $scope.$on('$destroy', function () {
                    self.renderUnknownOption = noop;
                });
                self.removeUnknownOption = function () {
                    if (self.unknownOption.parent())
                        self.unknownOption.remove();
                };
                self.readValue = function readSingleValue() {
                    self.removeUnknownOption();
                    return $element.val();
                };
                self.writeValue = function writeSingleValue(value) {
                    if (self.hasOption(value)) {
                        self.removeUnknownOption();
                        $element.val(value);
                        if (value === '')
                            self.emptyOption.prop('selected', true);
                    } else {
                        if (value == null && self.emptyOption) {
                            self.removeUnknownOption();
                            $element.val('');
                        } else {
                            self.renderUnknownOption(value);
                        }
                    }
                };
                self.addOption = function (value, element) {
                    if (element[0].nodeType === NODE_TYPE_COMMENT)
                        return;
                    assertNotHasOwnProperty(value, '"option value"');
                    if (value === '') {
                        self.emptyOption = element;
                    }
                    var count = optionsMap.get(value) || 0;
                    optionsMap.put(value, count + 1);
                    self.ngModelCtrl.$render();
                    chromeHack(element);
                };
                self.removeOption = function (value) {
                    var count = optionsMap.get(value);
                    if (count) {
                        if (count === 1) {
                            optionsMap.remove(value);
                            if (value === '') {
                                self.emptyOption = undefined;
                            }
                        } else {
                            optionsMap.put(value, count - 1);
                        }
                    }
                };
                self.hasOption = function (value) {
                    return !!optionsMap.get(value);
                };
                self.registerOption = function (optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
                    if (interpolateValueFn) {
                        var oldVal;
                        optionAttrs.$observe('value', function valueAttributeObserveAction(newVal) {
                            if (isDefined(oldVal)) {
                                self.removeOption(oldVal);
                            }
                            oldVal = newVal;
                            self.addOption(newVal, optionElement);
                        });
                    } else if (interpolateTextFn) {
                        optionScope.$watch(interpolateTextFn, function interpolateWatchAction(newVal, oldVal) {
                            optionAttrs.$set('value', newVal);
                            if (oldVal !== newVal) {
                                self.removeOption(oldVal);
                            }
                            self.addOption(newVal, optionElement);
                        });
                    } else {
                        self.addOption(optionAttrs.value, optionElement);
                    }
                    optionElement.on('$destroy', function () {
                        self.removeOption(optionAttrs.value);
                        self.ngModelCtrl.$render();
                    });
                };
            }
        ];
        var selectDirective = function () {
            return {
                restrict: 'E',
                require: [
                    'select',
                    '?ngModel'
                ],
                controller: SelectController,
                priority: 1,
                link: {
                    pre: selectPreLink,
                    post: selectPostLink
                }
            };
            function selectPreLink(scope, element, attr, ctrls) {
                var ngModelCtrl = ctrls[1];
                if (!ngModelCtrl)
                    return;
                var selectCtrl = ctrls[0];
                selectCtrl.ngModelCtrl = ngModelCtrl;
                element.on('change', function () {
                    scope.$apply(function () {
                        ngModelCtrl.$setViewValue(selectCtrl.readValue());
                    });
                });
                if (attr.multiple) {
                    selectCtrl.readValue = function readMultipleValue() {
                        var array = [];
                        forEach(element.find('option'), function (option) {
                            if (option.selected) {
                                array.push(option.value);
                            }
                        });
                        return array;
                    };
                    selectCtrl.writeValue = function writeMultipleValue(value) {
                        var items = new HashMap(value);
                        forEach(element.find('option'), function (option) {
                            option.selected = isDefined(items.get(option.value));
                        });
                    };
                    var lastView, lastViewRef = NaN;
                    scope.$watch(function selectMultipleWatch() {
                        if (lastViewRef === ngModelCtrl.$viewValue && !equals(lastView, ngModelCtrl.$viewValue)) {
                            lastView = shallowCopy(ngModelCtrl.$viewValue);
                            ngModelCtrl.$render();
                        }
                        lastViewRef = ngModelCtrl.$viewValue;
                    });
                    ngModelCtrl.$isEmpty = function (value) {
                        return !value || value.length === 0;
                    };
                }
            }
            function selectPostLink(scope, element, attrs, ctrls) {
                var ngModelCtrl = ctrls[1];
                if (!ngModelCtrl)
                    return;
                var selectCtrl = ctrls[0];
                ngModelCtrl.$render = function () {
                    selectCtrl.writeValue(ngModelCtrl.$viewValue);
                };
            }
        };
        var optionDirective = [
            '$interpolate',
            function ($interpolate) {
                return {
                    restrict: 'E',
                    priority: 100,
                    compile: function (element, attr) {
                        if (isDefined(attr.value)) {
                            var interpolateValueFn = $interpolate(attr.value, true);
                        } else {
                            var interpolateTextFn = $interpolate(element.text(), true);
                            if (!interpolateTextFn) {
                                attr.$set('value', element.text());
                            }
                        }
                        return function (scope, element, attr) {
                            var selectCtrlName = '$selectController', parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                            if (selectCtrl) {
                                selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn);
                            }
                        };
                    }
                };
            }
        ];
        var styleDirective = valueFn({
            restrict: 'E',
            terminal: false
        });
        var requiredDirective = function () {
            return {
                restrict: 'A',
                require: '?ngModel',
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl)
                        return;
                    attr.required = true;
                    ctrl.$validators.required = function (modelValue, viewValue) {
                        return !attr.required || !ctrl.$isEmpty(viewValue);
                    };
                    attr.$observe('required', function () {
                        ctrl.$validate();
                    });
                }
            };
        };
        var patternDirective = function () {
            return {
                restrict: 'A',
                require: '?ngModel',
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl)
                        return;
                    var regexp, patternExp = attr.ngPattern || attr.pattern;
                    attr.$observe('pattern', function (regex) {
                        if (isString(regex) && regex.length > 0) {
                            regex = new RegExp('^' + regex + '$');
                        }
                        if (regex && !regex.test) {
                            throw minErr('ngPattern')('noregexp', 'Expected {0} to be a RegExp but was {1}. Element: {2}', patternExp, regex, startingTag(elm));
                        }
                        regexp = regex || undefined;
                        ctrl.$validate();
                    });
                    ctrl.$validators.pattern = function (modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue);
                    };
                }
            };
        };
        var maxlengthDirective = function () {
            return {
                restrict: 'A',
                require: '?ngModel',
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl)
                        return;
                    var maxlength = -1;
                    attr.$observe('maxlength', function (value) {
                        var intVal = toInt(value);
                        maxlength = isNaN(intVal) ? -1 : intVal;
                        ctrl.$validate();
                    });
                    ctrl.$validators.maxlength = function (modelValue, viewValue) {
                        return maxlength < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength;
                    };
                }
            };
        };
        var minlengthDirective = function () {
            return {
                restrict: 'A',
                require: '?ngModel',
                link: function (scope, elm, attr, ctrl) {
                    if (!ctrl)
                        return;
                    var minlength = 0;
                    attr.$observe('minlength', function (value) {
                        minlength = toInt(value) || 0;
                        ctrl.$validate();
                    });
                    ctrl.$validators.minlength = function (modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength;
                    };
                }
            };
        };
        if (window.angular.bootstrap) {
            if (window.console) {
                console.log('WARNING: Tried to load angular more than once.');
            }
            return;
        }
        bindJQuery();
        publishExternalAPI(angular);
        angular.module('ngLocale', [], [
            '$provide',
            function ($provide) {
                var PLURAL_CATEGORY = {
                    ZERO: 'zero',
                    ONE: 'one',
                    TWO: 'two',
                    FEW: 'few',
                    MANY: 'many',
                    OTHER: 'other'
                };
                function getDecimals(n) {
                    n = n + '';
                    var i = n.indexOf('.');
                    return i == -1 ? 0 : n.length - i - 1;
                }
                function getVF(n, opt_precision) {
                    var v = opt_precision;
                    if (undefined === v) {
                        v = Math.min(getDecimals(n), 3);
                    }
                    var base = Math.pow(10, v);
                    var f = (n * base | 0) % base;
                    return {
                        v: v,
                        f: f
                    };
                }
                $provide.value('$locale', {
                    'DATETIME_FORMATS': {
                        'AMPMS': [
                            'AM',
                            'PM'
                        ],
                        'DAY': [
                            'Sunday',
                            'Monday',
                            'Tuesday',
                            'Wednesday',
                            'Thursday',
                            'Friday',
                            'Saturday'
                        ],
                        'ERANAMES': [
                            'Before Christ',
                            'Anno Domini'
                        ],
                        'ERAS': [
                            'BC',
                            'AD'
                        ],
                        'FIRSTDAYOFWEEK': 6,
                        'MONTH': [
                            'January',
                            'February',
                            'March',
                            'April',
                            'May',
                            'June',
                            'July',
                            'August',
                            'September',
                            'October',
                            'November',
                            'December'
                        ],
                        'SHORTDAY': [
                            'Sun',
                            'Mon',
                            'Tue',
                            'Wed',
                            'Thu',
                            'Fri',
                            'Sat'
                        ],
                        'SHORTMONTH': [
                            'Jan',
                            'Feb',
                            'Mar',
                            'Apr',
                            'May',
                            'Jun',
                            'Jul',
                            'Aug',
                            'Sep',
                            'Oct',
                            'Nov',
                            'Dec'
                        ],
                        'STANDALONEMONTH': [
                            'January',
                            'February',
                            'March',
                            'April',
                            'May',
                            'June',
                            'July',
                            'August',
                            'September',
                            'October',
                            'November',
                            'December'
                        ],
                        'WEEKENDRANGE': [
                            5,
                            6
                        ],
                        'fullDate': 'EEEE, MMMM d, y',
                        'longDate': 'MMMM d, y',
                        'medium': 'MMM d, y h:mm:ss a',
                        'mediumDate': 'MMM d, y',
                        'mediumTime': 'h:mm:ss a',
                        'short': 'M/d/yy h:mm a',
                        'shortDate': 'M/d/yy',
                        'shortTime': 'h:mm a'
                    },
                    'NUMBER_FORMATS': {
                        'CURRENCY_SYM': '$',
                        'DECIMAL_SEP': '.',
                        'GROUP_SEP': ',',
                        'PATTERNS': [
                            {
                                'gSize': 3,
                                'lgSize': 3,
                                'maxFrac': 3,
                                'minFrac': 0,
                                'minInt': 1,
                                'negPre': '-',
                                'negSuf': '',
                                'posPre': '',
                                'posSuf': ''
                            },
                            {
                                'gSize': 3,
                                'lgSize': 3,
                                'maxFrac': 2,
                                'minFrac': 2,
                                'minInt': 1,
                                'negPre': '-\xA4',
                                'negSuf': '',
                                'posPre': '\xA4',
                                'posSuf': ''
                            }
                        ]
                    },
                    'id': 'en-us',
                    'localeID': 'en_US',
                    'pluralCat': function (n, opt_precision) {
                        var i = n | 0;
                        var vf = getVF(n, opt_precision);
                        if (i == 1 && vf.v == 0) {
                            return PLURAL_CATEGORY.ONE;
                        }
                        return PLURAL_CATEGORY.OTHER;
                    }
                });
            }
        ]);
        jqLite(window.document).ready(function () {
            angularInit(window.document, bootstrap);
        });
    }(window));
    !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>');
    return angular;
});
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('metro', ['jquery'], factory);
    } else {
        factory(jQuery);
    }
}(function (jQuery) {
    'use strict';
    var $ = jQuery;
    if (typeof jQuery === 'undefined') {
        throw new Error('Metro\'s JavaScript requires jQuery');
    }
    window.METRO_VERSION = '3.0.13';
    if (window.METRO_AUTO_REINIT === undefined)
        window.METRO_AUTO_REINIT = true;
    if (window.METRO_LANGUAGE === undefined)
        window.METRO_LANGUAGE = 'en';
    if (window.METRO_LOCALE === undefined)
        window.METRO_LOCALE = 'EN_en';
    if (window.METRO_CURRENT_LOCALE === undefined)
        window.METRO_CURRENT_LOCALE = 'en';
    if (window.METRO_SHOW_TYPE === undefined)
        window.METRO_SHOW_TYPE = 'slide';
    if (window.METRO_DEBUG === undefined)
        window.METRO_DEBUG = true;
    if (window.METRO_CALENDAR_WEEK_START === undefined)
        window.METRO_CALENDAR_WEEK_START = 0;
    window.canObserveMutation = 'MutationObserver' in window;
    String.prototype.isUrl = function () {
        var regexp = /^(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
        return regexp.test(this);
    };
    String.prototype.isColor = function () {
        return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(this);
    };
    window.secondsToFormattedString = function (time) {
        var hours, minutes, seconds;
        hours = parseInt(time / 3600) % 24;
        minutes = parseInt(time / 60) % 60;
        seconds = time % 60;
        return (hours ? hours + ':' : '') + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
    };
    Array.prototype.shuffle = function () {
        var currentIndex = this.length, temporaryValue, randomIndex;
        while (0 !== currentIndex) {
            randomIndex = Math.floor(Math.random() * currentIndex);
            currentIndex -= 1;
            temporaryValue = this[currentIndex];
            this[currentIndex] = this[randomIndex];
            this[randomIndex] = temporaryValue;
        }
        return this;
    };
    Array.prototype.clone = function () {
        return this.slice(0);
    };
    Array.prototype.unique = function () {
        var a = this.concat();
        for (var i = 0; i < a.length; ++i) {
            for (var j = i + 1; j < a.length; ++j) {
                if (a[i] === a[j])
                    a.splice(j--, 1);
            }
        }
        return a;
    };
    window.uniqueId = function (prefix) {
        var d = new Date().getTime();
        var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            var r = (d + Math.random() * 16) % 16 | 0;
            d = Math.floor(d / 16);
            return (c == 'x' ? r : r & 3 | 8).toString(16);
        });
        return uuid;
    };
    window.isTouchDevice = function () {
        return 'ontouchstart' in window || navigator.MaxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    };
    window.METRO_LOCALES = {
        'en': {
            months: [
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December',
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec'
            ],
            days: [
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday',
                'Su',
                'Mo',
                'Tu',
                'We',
                'Th',
                'Fr',
                'Sa'
            ],
            buttons: [
                'Today',
                'Clear',
                'Cancel',
                'Help',
                'Prior',
                'Next',
                'Finish'
            ]
        },
        'fr': {
            months: [
                'Janvier',
                'Février',
                'Mars',
                'Avril',
                'Mai',
                'Juin',
                'Juillet',
                'Août',
                'Septembre',
                'Octobre',
                'Novembre',
                'Décembre',
                'Jan',
                'Fév',
                'Mars',
                'Avr',
                'Mai',
                'Juin',
                'Juil',
                'Août',
                'Sept',
                'Oct',
                'Nov',
                'Déc'
            ],
            days: [
                'Dimanche',
                'Lundi',
                'Mardi',
                'Mercredi',
                'Jeudi',
                'Vendredi',
                'Samedi',
                'Di',
                'Lu',
                'Ma',
                'Me',
                'Je',
                'Ve',
                'Sa'
            ],
            buttons: [
                'Aujourd\'hui',
                'Effacer',
                'Annuler',
                'Aide',
                'Précedent',
                'Suivant',
                'Fin'
            ]
        },
        'nl': {
            months: [
                'Januari',
                'Februari',
                'Maart',
                'April',
                'Mei',
                'Juni',
                'Juli',
                'Augustus',
                'September',
                'Oktober',
                'November',
                'December',
                'Jan',
                'Feb',
                'Mrt',
                'Apr',
                'Mei',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Okt',
                'Nov',
                'Dec'
            ],
            days: [
                'Zondag',
                'Maandag',
                'Dinsdag',
                'Woensdag',
                'Donderdag',
                'Vrijdag',
                'Zaterdag',
                'Zo',
                'Ma',
                'Di',
                'Wo',
                'Do',
                'Vr',
                'Za'
            ],
            buttons: [
                'Vandaag',
                'Verwijderen',
                'Annuleren',
                'Hulp',
                'Vorige',
                'Volgende',
                'Einde'
            ]
        },
        'ua': {
            months: [
                'Січень',
                'Лютий',
                'Березень',
                'Квітень',
                'Травень',
                'Червень',
                'Липень',
                'Серпень',
                'Вересень',
                'Жовтень',
                'Листопад',
                'Грудень',
                'Січ',
                'Лют',
                'Бер',
                'Кві',
                'Тра',
                'Чер',
                'Лип',
                'Сер',
                'Вер',
                'Жов',
                'Лис',
                'Гру'
            ],
            days: [
                'Неділя',
                'Понеділок',
                'Вівторок',
                'Середа',
                'Четвер',
                'П\u2019ятниця',
                'Субота',
                'Нд',
                'Пн',
                'Вт',
                'Ср',
                'Чт',
                'Пт',
                'Сб'
            ],
            buttons: [
                'Сьогодні',
                'Очистити',
                'Скасувати',
                'Допомога',
                'Назад',
                'Вперед',
                'Готово'
            ]
        },
        'ru': {
            months: [
                'Январь',
                'Февраль',
                'Март',
                'Апрель',
                'Май',
                'Июнь',
                'Июль',
                'Август',
                'Сентябрь',
                'Октябрь',
                'Ноябрь',
                'Декабрь',
                'Янв',
                'Фев',
                'Мар',
                'Апр',
                'Май',
                'Июн',
                'Июл',
                'Авг',
                'Сен',
                'Окт',
                'Ноя',
                'Дек'
            ],
            days: [
                'Воскресенье',
                'Понедельник',
                'Вторник',
                'Среда',
                'Четверг',
                'Пятница',
                'Суббота',
                'Вс',
                'Пн',
                'Вт',
                'Ср',
                'Чт',
                'Пт',
                'Сб'
            ],
            buttons: [
                'Сегодня',
                'Очистить',
                'Отменить',
                'Помощь',
                'Назад',
                'Вперед',
                'Готово'
            ]
        },
        'zhCN': {
            months: [
                '一月',
                '二月',
                '三月',
                '四月',
                '五月',
                '六月',
                '七月',
                '八月',
                '九月',
                '十月',
                '十一月',
                '十二月',
                '一月',
                '二月',
                '三月',
                '四月',
                '五月',
                '六月',
                '七月',
                '八月',
                '九月',
                '十月',
                '十一月',
                '十二月'
            ],
            days: [
                '星期日',
                '星期一',
                '星期二',
                '星期三',
                '星期四',
                '星期五',
                '星期六',
                '日',
                '一',
                '二',
                '三',
                '四',
                '五',
                '六'
            ],
            buttons: [
                '今日',
                '清除',
                'Cancel',
                'Help',
                'Prior',
                'Next',
                'Finish'
            ]
        },
        'it': {
            months: [
                'Gennaio',
                'Febbraio',
                'Marzo',
                'Aprile',
                'Maggio',
                'Giugno',
                'Luglio',
                'Agosto',
                'Settembre',
                'Ottobre',
                'Novembre',
                'Dicembre',
                'Gen',
                ' Feb',
                'Mar',
                'Apr',
                'Mag',
                'Giu',
                'Lug',
                'Ago',
                'Set',
                'Ott',
                'Nov',
                'Dic'
            ],
            days: [
                'Domenica',
                'Lunedì',
                'Martedì',
                'Mercoledì',
                'Giovedì',
                'Venerdì',
                'Sabato',
                'Dom',
                'Lun',
                'Mar',
                'Mer',
                'Gio',
                'Ven',
                'Sab'
            ],
            buttons: [
                'Oggi',
                'Cancella',
                'Cancel',
                'Help',
                'Prior',
                'Next',
                'Finish'
            ]
        },
        'de': {
            months: [
                'Januar',
                'Februar',
                'März',
                'April',
                'Mai',
                'Juni',
                'Juli',
                'August',
                'September',
                'Oktober',
                'November',
                'Dezember',
                'Jan',
                'Feb',
                'Mrz',
                'Apr',
                'Mai',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Okt',
                'Nov',
                'Dez'
            ],
            days: [
                'Sonntag',
                'Montag',
                'Dienstag',
                'Mittwoch',
                'Donnerstag',
                'Freitag',
                'Samstag',
                'So',
                'Mo',
                'Di',
                'Mi',
                'Do',
                'Fr',
                'Sa'
            ],
            buttons: [
                'Heute',
                'Zurücksetzen',
                'Abbrechen',
                'Hilfe',
                'Früher',
                'Später',
                'Fertig'
            ]
        },
        'es': {
            months: [
                'Enero',
                'Febrero',
                'Marzo',
                'Abril',
                'Mayo',
                'Junio',
                'Julio',
                'Agosto',
                'Septiembre',
                'Octubre',
                'Noviembre',
                'Diciembre',
                'Ene',
                'Feb',
                'Mar',
                'Abr',
                'May',
                'Jun',
                'Jul',
                'Ago',
                'Sept',
                'Oct',
                'Nov',
                'Dic'
            ],
            days: [
                'Domingo',
                'Lunes',
                'Martes',
                'Miércoles',
                'Jueves',
                'Viernes',
                'Sábado',
                'Do',
                'Lu',
                'Mar',
                'Mié',
                'Jue',
                'Vi',
                'Sáb'
            ],
            buttons: [
                'Hoy',
                'Limpiar',
                'Cancel',
                'Help',
                'Prior',
                'Next',
                'Finish'
            ]
        },
        'pt': {
            months: [
                'Janeiro',
                'Fevereiro',
                'Março',
                'Abril',
                'Maio',
                'Junho',
                'Julho',
                'Agosto',
                'Setembro',
                'Outubro',
                'Novembro',
                'Dezembro',
                'Jan',
                'Fev',
                'Mar',
                'Abr',
                'Mai',
                'Jun',
                'Jul',
                'Ago',
                'Set',
                'Out',
                'Nov',
                'Dez'
            ],
            days: [
                'Domingo',
                'Segunda-feira',
                'Terça-feira',
                'Quarta-feira',
                'Quinta-feira',
                'Sexta-feira',
                'Sabado',
                'Dom',
                'Seg',
                'Ter',
                'Qua',
                'Qui',
                'Sex',
                'Sab'
            ],
            buttons: [
                'Hoje',
                'Limpar',
                'Cancelar',
                'Ajuda',
                'Anterior',
                'Seguinte',
                'Terminar'
            ]
        },
        'pl': {
            months: [
                'Styczeń',
                'Luty',
                'Marzec',
                'Kwiecień',
                'Maj',
                'Czerwiec',
                'Lipiec',
                'Sierpień',
                'Wrzesień',
                'Październik',
                'Listopad',
                'Grudzień',
                'Sty',
                'Lut',
                'Mar',
                'Kwi',
                'Maj',
                'Cze',
                'Lip',
                'Sie',
                'Wrz',
                'Paź',
                'Lis',
                'Gru'
            ],
            days: [
                'Niedziela',
                'Poniedziałek',
                'Wtorek',
                'Środa',
                'Czwartek',
                'Piątek',
                'Sobota',
                'Nd',
                'Pon',
                'Wt',
                'Śr',
                'Czw',
                'Pt',
                'Sob'
            ],
            buttons: [
                'Dzisiaj',
                'Wyczyść',
                'Anuluj',
                'Pomoc',
                'Poprzedni',
                'Następny',
                'Koniec'
            ]
        },
        'cs': {
            months: [
                'Leden',
                'Únor',
                'Březen',
                'Duben',
                'Květen',
                'Červen',
                'Červenec',
                'Srpen',
                'Září',
                'Říjen',
                'Listopad',
                'Prosinec',
                'Led',
                'Ún',
                'Bř',
                'Dub',
                'Kvě',
                'Če',
                'Čer',
                'Srp',
                'Zá',
                'Ří',
                'Li',
                'Pro'
            ],
            days: [
                'Neděle',
                'Pondělí',
                'Úterý',
                'Středa',
                'Čtvrtek',
                'Pátek',
                'Sobota',
                'Ne',
                'Po',
                'Út',
                'St',
                'Čt',
                'Pá',
                'So'
            ],
            buttons: [
                'Dnes',
                'Vyčistit',
                'Zrušit',
                'Pomoc',
                'Předešlý',
                'Další',
                'Dokončit'
            ]
        },
        'th': {
            months: [
                'มกราคม',
                'กุมภาพันธ์',
                'มีนาคม',
                'เมษายน',
                'พฤษภาคม',
                'มิถุนายน',
                'กรกฎาคม',
                'สิงหาคม',
                'กันยายน',
                'ตุลาคม',
                'พฤศจิกายน',
                'ธันวาคม',
                'ม.ค.',
                'ก.พ.',
                'มี.ค.',
                'เม.ย.',
                'พ.ค.',
                'มิ.ย.',
                'ก.ค.',
                'ส.ค.',
                'ก.ย.',
                'ต.ค.',
                'พ.ย.',
                'ธ.ค.'
            ],
            days: [
                'อาทิตย์',
                'จันทร์',
                'อังคาร',
                'พุธ',
                'พฤหัสบดี',
                'ศุกร์',
                'เสาร์',
                'อา.',
                'จ.',
                'อ.',
                'พ.',
                'พฤ.',
                'ศ.',
                'ส.'
            ],
            buttons: [
                'วันนี้',
                'ล้าง',
                'ยกเลิก',
                'ช่วยเหลือ',
                'กลับ',
                'ต่อไป',
                'เสร็จ'
            ]
        }
    };
    var dateFormat = function () {
        var token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g, timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g, timezoneClip = /[^-+\dA-Z]/g, pad = function (val, len) {
                val = String(val);
                len = len || 2;
                while (val.length < len) {
                    val = '0' + val;
                }
                return val;
            };
        return function (date, mask, utc) {
            var dF = dateFormat;
            if (arguments.length === 1 && Object.prototype.toString.call(date) === '[object String]' && !/\d/.test(date)) {
                mask = date;
                date = undefined;
            }
            date = date ? new Date(date) : new Date();
            mask = String(dF.masks[mask] || mask || dF.masks['default']);
            if (mask.slice(0, 4) === 'UTC:') {
                mask = mask.slice(4);
                utc = true;
            }
            var locale = window.METRO_CURRENT_LOCALE || 'en';
            var _ = utc ? 'getUTC' : 'get', d = date[_ + 'Date'](), D = date[_ + 'Day'](), m = date[_ + 'Month'](), y = date[_ + 'FullYear'](), H = date[_ + 'Hours'](), M = date[_ + 'Minutes'](), s = date[_ + 'Seconds'](), L = date[_ + 'Milliseconds'](), o = utc ? 0 : date.getTimezoneOffset(), flags = {
                    d: d,
                    dd: pad(d),
                    ddd: window.METRO_LOCALES[locale].days[D],
                    dddd: window.METRO_LOCALES[locale].days[D + 7],
                    m: m + 1,
                    mm: pad(m + 1),
                    mmm: window.METRO_LOCALES[locale].months[m],
                    mmmm: window.METRO_LOCALES[locale].months[m + 12],
                    yy: String(y).slice(2),
                    yyyy: y,
                    h: H % 12 || 12,
                    hh: pad(H % 12 || 12),
                    H: H,
                    HH: pad(H),
                    M: M,
                    MM: pad(M),
                    s: s,
                    ss: pad(s),
                    l: pad(L, 3),
                    L: pad(L > 99 ? Math.round(L / 10) : L),
                    t: H < 12 ? 'a' : 'p',
                    tt: H < 12 ? 'am' : 'pm',
                    T: H < 12 ? 'A' : 'P',
                    TT: H < 12 ? 'AM' : 'PM',
                    Z: utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
                    o: (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                    S: [
                        'th',
                        'st',
                        'nd',
                        'rd'
                    ][d % 10 > 3 ? 0 : (d % 100 - d % 10 !== 10) * d % 10]
                };
            return mask.replace(token, function ($0) {
                return $0 in flags ? flags[$0] : $0.slice(1, $0.length - 1);
            });
        };
    }();
    dateFormat.masks = {
        'default': 'ddd mmm dd yyyy HH:MM:ss',
        shortDate: 'm/d/yy',
        mediumDate: 'mmm d, yyyy',
        longDate: 'mmmm d, yyyy',
        fullDate: 'dddd, mmmm d, yyyy',
        shortTime: 'h:MM TT',
        mediumTime: 'h:MM:ss TT',
        longTime: 'h:MM:ss TT Z',
        isoDate: 'yyyy-mm-dd',
        isoTime: 'HH:MM:ss',
        isoDateTime: 'yyyy-mm-dd\'T\'HH:MM:ss',
        isoUtcDateTime: 'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\''
    };
    Date.prototype.format = function (mask, utc) {
        return dateFormat(this, mask, utc);
    };
    var widget_uuid = 0, widget_slice = Array.prototype.slice;
    $.cleanData = function (orig) {
        return function (elems) {
            var events, elem, i;
            for (i = 0; (elem = elems[i]) != null; i++) {
                try {
                    events = $._data(elem, 'events');
                    if (events && events.remove) {
                        $(elem).triggerHandler('remove');
                    }
                } catch (e) {
                }
            }
            orig(elems);
        };
    }($.cleanData);
    $.widget = function (name, base, prototype) {
        var fullName, existingConstructor, constructor, basePrototype, proxiedPrototype = {}, namespace = name.split('.')[0];
        name = name.split('.')[1];
        fullName = namespace + '-' + name;
        if (!prototype) {
            prototype = base;
            base = $.Widget;
        }
        $.expr[':'][fullName.toLowerCase()] = function (elem) {
            return !!$.data(elem, fullName);
        };
        $[namespace] = $[namespace] || {};
        existingConstructor = $[namespace][name];
        constructor = $[namespace][name] = function (options, element) {
            if (!this._createWidget) {
                return new constructor(options, element);
            }
            if (arguments.length) {
                this._createWidget(options, element);
            }
        };
        $.extend(constructor, existingConstructor, {
            version: prototype.version,
            _proto: $.extend({}, prototype),
            _childConstructors: []
        });
        basePrototype = new base();
        basePrototype.options = $.widget.extend({}, basePrototype.options);
        $.each(prototype, function (prop, value) {
            if (!$.isFunction(value)) {
                proxiedPrototype[prop] = value;
                return;
            }
            proxiedPrototype[prop] = function () {
                var _super = function () {
                        return base.prototype[prop].apply(this, arguments);
                    }, _superApply = function (args) {
                        return base.prototype[prop].apply(this, args);
                    };
                return function () {
                    var __super = this._super, __superApply = this._superApply, returnValue;
                    this._super = _super;
                    this._superApply = _superApply;
                    returnValue = value.apply(this, arguments);
                    this._super = __super;
                    this._superApply = __superApply;
                    return returnValue;
                };
            }();
        });
        constructor.prototype = $.widget.extend(basePrototype, { widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name }, proxiedPrototype, {
            constructor: constructor,
            namespace: namespace,
            widgetName: name,
            widgetFullName: fullName
        });
        if (existingConstructor) {
            $.each(existingConstructor._childConstructors, function (i, child) {
                var childPrototype = child.prototype;
                $.widget(childPrototype.namespace + '.' + childPrototype.widgetName, constructor, child._proto);
            });
            delete existingConstructor._childConstructors;
        } else {
            base._childConstructors.push(constructor);
        }
        $.widget.bridge(name, constructor);
        return constructor;
    };
    $.widget.extend = function (target) {
        var input = widget_slice.call(arguments, 1), inputIndex = 0, inputLength = input.length, key, value;
        for (; inputIndex < inputLength; inputIndex++) {
            for (key in input[inputIndex]) {
                value = input[inputIndex][key];
                if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
                    if ($.isPlainObject(value)) {
                        target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);
                    } else {
                        target[key] = value;
                    }
                }
            }
        }
        return target;
    };
    $.widget.bridge = function (name, object) {
        var fullName = object.prototype.widgetFullName || name;
        $.fn[name] = function (options) {
            var isMethodCall = typeof options === 'string', args = widget_slice.call(arguments, 1), returnValue = this;
            if (isMethodCall) {
                this.each(function () {
                    var methodValue, instance = $.data(this, fullName);
                    if (options === 'instance') {
                        returnValue = instance;
                        return false;
                    }
                    if (!instance) {
                        return $.error('cannot call methods on ' + name + ' prior to initialization; ' + 'attempted to call method \'' + options + '\'');
                    }
                    if (!$.isFunction(instance[options]) || options.charAt(0) === '_') {
                        return $.error('no such method \'' + options + '\' for ' + name + ' widget instance');
                    }
                    methodValue = instance[options].apply(instance, args);
                    if (methodValue !== instance && methodValue !== undefined) {
                        returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
                        return false;
                    }
                });
            } else {
                if (args.length) {
                    options = $.widget.extend.apply(null, [options].concat(args));
                }
                this.each(function () {
                    var instance = $.data(this, fullName);
                    if (instance) {
                        instance.option(options || {});
                        if (instance._init) {
                            instance._init();
                        }
                    } else {
                        $.data(this, fullName, new object(options, this));
                    }
                });
            }
            return returnValue;
        };
    };
    $.Widget = function () {
    };
    $.Widget._childConstructors = [];
    $.Widget.prototype = {
        widgetName: 'widget',
        widgetEventPrefix: '',
        defaultElement: '<div>',
        options: {
            disabled: false,
            create: null
        },
        _createWidget: function (options, element) {
            element = $(element || this.defaultElement || this)[0];
            this.element = $(element);
            this.uuid = widget_uuid++;
            this.eventNamespace = '.' + this.widgetName + this.uuid;
            this.bindings = $();
            this.hoverable = $();
            this.focusable = $();
            if (element !== this) {
                $.data(element, this.widgetFullName, this);
                this._on(true, this.element, {
                    remove: function (event) {
                        if (event.target === element) {
                            this.destroy();
                        }
                    }
                });
                this.document = $(element.style ? element.ownerDocument : element.document || element);
                this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
            }
            this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
            this._create();
            this._trigger('create', null, this._getCreateEventData());
            this._init();
        },
        _getCreateOptions: $.noop,
        _getCreateEventData: $.noop,
        _create: $.noop,
        _init: $.noop,
        destroy: function () {
            this._destroy();
            this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName));
            this.widget().unbind(this.eventNamespace).removeAttr('aria-disabled').removeClass(this.widgetFullName + '-disabled ' + 'ui-state-disabled');
            this.bindings.unbind(this.eventNamespace);
            this.hoverable.removeClass('ui-state-hover');
            this.focusable.removeClass('ui-state-focus');
        },
        _destroy: $.noop,
        widget: function () {
            return this.element;
        },
        option: function (key, value) {
            var options = key, parts, curOption, i;
            if (arguments.length === 0) {
                return $.widget.extend({}, this.options);
            }
            if (typeof key === 'string') {
                options = {};
                parts = key.split('.');
                key = parts.shift();
                if (parts.length) {
                    curOption = options[key] = $.widget.extend({}, this.options[key]);
                    for (i = 0; i < parts.length - 1; i++) {
                        curOption[parts[i]] = curOption[parts[i]] || {};
                        curOption = curOption[parts[i]];
                    }
                    key = parts.pop();
                    if (arguments.length === 1) {
                        return curOption[key] === undefined ? null : curOption[key];
                    }
                    curOption[key] = value;
                } else {
                    if (arguments.length === 1) {
                        return this.options[key] === undefined ? null : this.options[key];
                    }
                    options[key] = value;
                }
            }
            this._setOptions(options);
            return this;
        },
        _setOptions: function (options) {
            var key;
            for (key in options) {
                this._setOption(key, options[key]);
            }
            return this;
        },
        _setOption: function (key, value) {
            this.options[key] = value;
            if (key === 'disabled') {
                this.widget().toggleClass(this.widgetFullName + '-disabled', !!value);
                if (value) {
                    this.hoverable.removeClass('ui-state-hover');
                    this.focusable.removeClass('ui-state-focus');
                }
            }
            return this;
        },
        enable: function () {
            return this._setOptions({ disabled: false });
        },
        disable: function () {
            return this._setOptions({ disabled: true });
        },
        _on: function (suppressDisabledCheck, element, handlers) {
            var delegateElement, instance = this;
            if (typeof suppressDisabledCheck !== 'boolean') {
                handlers = element;
                element = suppressDisabledCheck;
                suppressDisabledCheck = false;
            }
            if (!handlers) {
                handlers = element;
                element = this.element;
                delegateElement = this.widget();
            } else {
                element = delegateElement = $(element);
                this.bindings = this.bindings.add(element);
            }
            $.each(handlers, function (event, handler) {
                function handlerProxy() {
                    if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass('ui-state-disabled'))) {
                        return;
                    }
                    return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
                }
                if (typeof handler !== 'string') {
                    handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
                }
                var match = event.match(/^([\w:-]*)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
                if (selector) {
                    delegateElement.delegate(selector, eventName, handlerProxy);
                } else {
                    element.bind(eventName, handlerProxy);
                }
            });
        },
        _off: function (element, eventName) {
            eventName = (eventName || '').split(' ').join(this.eventNamespace + ' ') + this.eventNamespace;
            element.unbind(eventName).undelegate(eventName);
            this.bindings = $(this.bindings.not(element).get());
            this.focusable = $(this.focusable.not(element).get());
            this.hoverable = $(this.hoverable.not(element).get());
        },
        _delay: function (handler, delay) {
            function handlerProxy() {
                return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
            }
            var instance = this;
            return setTimeout(handlerProxy, delay || 0);
        },
        _hoverable: function (element) {
            this.hoverable = this.hoverable.add(element);
            this._on(element, {
                mouseenter: function (event) {
                    $(event.currentTarget).addClass('ui-state-hover');
                },
                mouseleave: function (event) {
                    $(event.currentTarget).removeClass('ui-state-hover');
                }
            });
        },
        _focusable: function (element) {
            this.focusable = this.focusable.add(element);
            this._on(element, {
                focusin: function (event) {
                    $(event.currentTarget).addClass('ui-state-focus');
                },
                focusout: function (event) {
                    $(event.currentTarget).removeClass('ui-state-focus');
                }
            });
        },
        _trigger: function (type, event, data) {
            var prop, orig, callback = this.options[type];
            data = data || {};
            event = $.Event(event);
            event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
            event.target = this.element[0];
            orig = event.originalEvent;
            if (orig) {
                for (prop in orig) {
                    if (!(prop in event)) {
                        event[prop] = orig[prop];
                    }
                }
            }
            this.element.trigger(event, data);
            return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
        }
    };
    $.each({
        show: 'fadeIn',
        hide: 'fadeOut'
    }, function (method, defaultEffect) {
        $.Widget.prototype['_' + method] = function (element, options, callback) {
            if (typeof options === 'string') {
                options = { effect: options };
            }
            var hasOptions, effectName = !options ? method : options === true || typeof options === 'number' ? defaultEffect : options.effect || defaultEffect;
            options = options || {};
            if (typeof options === 'number') {
                options = { duration: options };
            }
            hasOptions = !$.isEmptyObject(options);
            options.complete = callback;
            if (options.delay) {
                element.delay(options.delay);
            }
            if (hasOptions && $.effects && $.effects.effect[effectName]) {
                element[method](options);
            } else if (effectName !== method && element[effectName]) {
                element[effectName](options.duration, options.easing, callback);
            } else {
                element.queue(function (next) {
                    $(this)[method]();
                    if (callback) {
                        callback.call(element[0]);
                    }
                    next();
                });
            }
        };
    });
    var widget = $.widget;
    $.fn.reverse = Array.prototype.reverse;
    $.Metro = function (params) {
        params = $.extend({}, params);
    };
    $.Metro.hotkeys = [];
    $.Metro.initWidgets = function () {
        var widgets = $('[data-role]');
        var hotkeys = $('[data-hotkey]');
        $.each(hotkeys, function () {
            var element = $(this);
            var hotkey = element.data('hotkey').toLowerCase();
            if (element.data('hotKeyBonded') === true) {
                return;
            }
            $.Metro.hotkeys.push(hotkey);
            $(document).on('keyup', null, hotkey, function (e) {
                if (element === undefined)
                    return;
                if (element[0].tagName === 'A' && element.attr('href') !== undefined && element.attr('href').trim() !== '' && element.attr('href').trim() !== '#') {
                    document.location.href = element.attr('href');
                } else {
                    element.click();
                }
                return false;
            });
            element.data('hotKeyBonded', true);
        });
        $.each(widgets, function () {
            var $this = $(this), w = this;
            var roles = $this.data('role').split(/\s*,\s*/);
            roles.map(function (func) {
                try {
                    if ($.fn[func] !== undefined && $this.data(func + '-initiated') !== true) {
                        $.fn[func].call($this);
                        $this.data(func + '-initiated', true);
                    }
                } catch (e) {
                    if (window.METRO_DEBUG) {
                        console.log(e.message, e.stack);
                    }
                }
            });
        });
    };
    $.Metro.init = function () {
        $.Metro.initWidgets();
        if (window.METRO_AUTO_REINIT) {
            if (!window.canObserveMutation) {
                var originalDOM = $('body').html(), actualDOM;
                setInterval(function () {
                    actualDOM = $('body').html();
                    if (originalDOM !== actualDOM) {
                        originalDOM = actualDOM;
                        $.Metro.initWidgets();
                    }
                }, 100);
            } else {
                var observer, observerOptions, observerCallback;
                observerOptions = {
                    'childList': true,
                    'subtree': true
                };
                observerCallback = function (mutations) {
                    mutations.map(function (record) {
                        if (record.addedNodes) {
                            var obj, widgets, plugins, hotkeys;
                            for (var i = 0, l = record.addedNodes.length; i < l; i++) {
                                obj = $(record.addedNodes[i]);
                                plugins = obj.find('[data-role]');
                                hotkeys = obj.find('[data-hotkey]');
                                $.each(hotkeys, function () {
                                    var element = $(this);
                                    var hotkey = element.data('hotkey').toLowerCase();
                                    if (element.data('hotKeyBonded') === true) {
                                        return;
                                    }
                                    $.Metro.hotkeys.push(hotkey);
                                    $(document).on('keyup', null, hotkey, function () {
                                        if (element === undefined)
                                            return;
                                        if (element[0].tagName === 'A' && element.attr('href') !== undefined && element.attr('href').trim() !== '' && element.attr('href').trim() !== '#') {
                                            document.location.href = element.attr('href');
                                        } else {
                                            element.click();
                                        }
                                        return false;
                                    });
                                    element.data('hotKeyBonded', true);
                                });
                                if (obj.data('role') !== undefined) {
                                    widgets = $.merge(plugins, obj);
                                } else {
                                    widgets = plugins;
                                }
                                if (widgets.length) {
                                    $.each(widgets, function () {
                                        var _this = $(this);
                                        var roles = _this.data('role').split(/\s*,\s*/);
                                        roles.map(function (func) {
                                            try {
                                                if ($.fn[func] !== undefined && _this.data(func + '-initiated') !== true) {
                                                    $.fn[func].call(_this);
                                                    _this.data(func + '-initiated', true);
                                                }
                                            } catch (e) {
                                                if (window.METRO_DEBUG) {
                                                    console.log(e.message, e.stack);
                                                }
                                            }
                                        });
                                    });
                                }
                            }
                        }
                    });
                };
                observer = new MutationObserver(observerCallback);
                observer.observe(document, observerOptions);
            }
        }
    };
    $.easing['jswing'] = $.easing['swing'];
    $.extend($.easing, {
        def: 'easeOutQuad',
        swing: function (x, t, b, c, d) {
            return $.easing[$.easing.def](x, t, b, c, d);
        },
        easeInQuad: function (x, t, b, c, d) {
            return c * (t /= d) * t + b;
        },
        easeOutQuad: function (x, t, b, c, d) {
            return -c * (t /= d) * (t - 2) + b;
        },
        easeInOutQuad: function (x, t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t + b;
            return -c / 2 * (--t * (t - 2) - 1) + b;
        },
        easeInCubic: function (x, t, b, c, d) {
            return c * (t /= d) * t * t + b;
        },
        easeOutCubic: function (x, t, b, c, d) {
            return c * ((t = t / d - 1) * t * t + 1) + b;
        },
        easeInOutCubic: function (x, t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t + 2) + b;
        },
        easeInQuart: function (x, t, b, c, d) {
            return c * (t /= d) * t * t * t + b;
        },
        easeOutQuart: function (x, t, b, c, d) {
            return -c * ((t = t / d - 1) * t * t * t - 1) + b;
        },
        easeInOutQuart: function (x, t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t * t + b;
            return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
        },
        easeInQuint: function (x, t, b, c, d) {
            return c * (t /= d) * t * t * t * t + b;
        },
        easeOutQuint: function (x, t, b, c, d) {
            return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
        },
        easeInOutQuint: function (x, t, b, c, d) {
            if ((t /= d / 2) < 1)
                return c / 2 * t * t * t * t * t + b;
            return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
        },
        easeInSine: function (x, t, b, c, d) {
            return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
        },
        easeOutSine: function (x, t, b, c, d) {
            return c * Math.sin(t / d * (Math.PI / 2)) + b;
        },
        easeInOutSine: function (x, t, b, c, d) {
            return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
        },
        easeInExpo: function (x, t, b, c, d) {
            return t == 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
        },
        easeOutExpo: function (x, t, b, c, d) {
            return t == d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
        },
        easeInOutExpo: function (x, t, b, c, d) {
            if (t == 0)
                return b;
            if (t == d)
                return b + c;
            if ((t /= d / 2) < 1)
                return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
            return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
        },
        easeInCirc: function (x, t, b, c, d) {
            return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
        },
        easeOutCirc: function (x, t, b, c, d) {
            return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
        },
        easeInOutCirc: function (x, t, b, c, d) {
            if ((t /= d / 2) < 1)
                return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
            return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
        },
        easeInElastic: function (x, t, b, c, d) {
            var s = 1.70158;
            var p = 0;
            var a = c;
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * 0.3;
            if (a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else
                s = p / (2 * Math.PI) * Math.asin(c / a);
            return -(a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
        },
        easeOutElastic: function (x, t, b, c, d) {
            var s = 1.70158;
            var p = 0;
            var a = c;
            if (t == 0)
                return b;
            if ((t /= d) == 1)
                return b + c;
            if (!p)
                p = d * 0.3;
            if (a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else
                s = p / (2 * Math.PI) * Math.asin(c / a);
            return a * Math.pow(2, -10 * t) * Math.sin((t * d - s) * (2 * Math.PI) / p) + c + b;
        },
        easeInOutElastic: function (x, t, b, c, d) {
            var s = 1.70158;
            var p = 0;
            var a = c;
            if (t == 0)
                return b;
            if ((t /= d / 2) == 2)
                return b + c;
            if (!p)
                p = d * (0.3 * 1.5);
            if (a < Math.abs(c)) {
                a = c;
                s = p / 4;
            } else
                s = p / (2 * Math.PI) * Math.asin(c / a);
            if (t < 1)
                return -0.5 * (a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p)) + b;
            return a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - s) * (2 * Math.PI) / p) * 0.5 + c + b;
        },
        easeInBack: function (x, t, b, c, d, s) {
            if (s == undefined)
                s = 1.70158;
            return c * (t /= d) * t * ((s + 1) * t - s) + b;
        },
        easeOutBack: function (x, t, b, c, d, s) {
            if (s == undefined)
                s = 1.70158;
            return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
        },
        easeInOutBack: function (x, t, b, c, d, s) {
            if (s == undefined)
                s = 1.70158;
            if ((t /= d / 2) < 1)
                return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
            return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
        },
        easeInBounce: function (x, t, b, c, d) {
            return c - $.easing.easeOutBounce(x, d - t, 0, c, d) + b;
        },
        easeOutBounce: function (x, t, b, c, d) {
            if ((t /= d) < 1 / 2.75) {
                return c * (7.5625 * t * t) + b;
            } else if (t < 2 / 2.75) {
                return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
            } else if (t < 2.5 / 2.75) {
                return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
            } else {
                return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
            }
        },
        easeInOutBounce: function (x, t, b, c, d) {
            if (t < d / 2)
                return $.easing.easeInBounce(x, t * 2, 0, c, d) * 0.5 + b;
            return $.easing.easeOutBounce(x, t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
        }
    });
    $.hotkeys = {
        version: '0.8',
        specialKeys: {
            8: 'backspace',
            9: 'tab',
            10: 'return',
            13: 'return',
            16: 'shift',
            17: 'ctrl',
            18: 'alt',
            19: 'pause',
            20: 'capslock',
            27: 'esc',
            32: 'space',
            33: 'pageup',
            34: 'pagedown',
            35: 'end',
            36: 'home',
            37: 'left',
            38: 'up',
            39: 'right',
            40: 'down',
            45: 'insert',
            46: 'del',
            59: ';',
            61: '=',
            96: '0',
            97: '1',
            98: '2',
            99: '3',
            100: '4',
            101: '5',
            102: '6',
            103: '7',
            104: '8',
            105: '9',
            106: '*',
            107: '+',
            109: '-',
            110: '.',
            111: '/',
            112: 'f1',
            113: 'f2',
            114: 'f3',
            115: 'f4',
            116: 'f5',
            117: 'f6',
            118: 'f7',
            119: 'f8',
            120: 'f9',
            121: 'f10',
            122: 'f11',
            123: 'f12',
            144: 'numlock',
            145: 'scroll',
            173: '-',
            186: ';',
            187: '=',
            188: ',',
            189: '-',
            190: '.',
            191: '/',
            192: '`',
            219: '[',
            220: '\\',
            221: ']',
            222: '\''
        },
        shiftNums: {
            '`': '~',
            '1': '!',
            '2': '@',
            '3': '#',
            '4': '$',
            '5': '%',
            '6': '^',
            '7': '&',
            '8': '*',
            '9': '(',
            '0': ')',
            '-': '_',
            '=': '+',
            ';': ': ',
            '\'': '"',
            ',': '<',
            '.': '>',
            '/': '?',
            '\\': '|'
        },
        textAcceptingInputTypes: [
            'text',
            'password',
            'number',
            'email',
            'url',
            'range',
            'date',
            'month',
            'week',
            'time',
            'datetime',
            'datetime-local',
            'search',
            'color',
            'tel'
        ],
        textInputTypes: /textarea|input|select/i,
        options: {
            filterInputAcceptingElements: true,
            filterTextInputs: true,
            filterContentEditable: true
        }
    };
    function keyHandler(handleObj) {
        if (typeof handleObj.data === 'string') {
            handleObj.data = { keys: handleObj.data };
        }
        if (!handleObj.data || !handleObj.data.keys || typeof handleObj.data.keys !== 'string') {
            return;
        }
        var origHandler = handleObj.handler, keys = handleObj.data.keys.toLowerCase().split(' ');
        handleObj.handler = function (event) {
            if (this !== event.target && ($.hotkeys.options.filterInputAcceptingElements && $.hotkeys.textInputTypes.test(event.target.nodeName) || $.hotkeys.options.filterContentEditable && $(event.target).attr('contenteditable') || $.hotkeys.options.filterTextInputs && $.inArray(event.target.type, $.hotkeys.textAcceptingInputTypes) > -1)) {
                return;
            }
            var special = event.type !== 'keypress' && $.hotkeys.specialKeys[event.which], character = String.fromCharCode(event.which).toLowerCase(), modif = '', possible = {};
            $.each([
                'alt',
                'ctrl',
                'shift'
            ], function (index, specialKey) {
                if (event[specialKey + 'Key'] && special !== specialKey) {
                    modif += specialKey + '+';
                }
            });
            if (event.metaKey && !event.ctrlKey && special !== 'meta') {
                modif += 'meta+';
            }
            if (event.metaKey && special !== 'meta' && modif.indexOf('alt+ctrl+shift+') > -1) {
                modif = modif.replace('alt+ctrl+shift+', 'hyper+');
            }
            if (special) {
                possible[modif + special] = true;
            } else {
                possible[modif + character] = true;
                possible[modif + $.hotkeys.shiftNums[character]] = true;
                if (modif === 'shift+') {
                    possible[$.hotkeys.shiftNums[character]] = true;
                }
            }
            for (var i = 0, l = keys.length; i < l; i++) {
                if (possible[keys[i]]) {
                    return origHandler.apply(this, arguments);
                }
            }
        };
    }
    $.each([
        'keydown',
        'keyup',
        'keypress'
    ], function () {
        $.event.special[this] = { add: keyHandler };
    });
    var toFix = [
        'wheel',
        'mousewheel',
        'DOMMouseScroll',
        'MozMousePixelScroll'
    ];
    var toBind = 'onwheel' in document || document.documentMode >= 9 ? ['wheel'] : [
        'mousewheel',
        'DomMouseScroll',
        'MozMousePixelScroll'
    ];
    var lowestDelta, lowestDeltaXY;
    if ($.event.fixHooks) {
        for (var i = toFix.length; i;) {
            $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
        }
    }
    $.event.special.mousewheel = {
        setup: function () {
            if (this.addEventListener) {
                for (var i = toBind.length; i;) {
                    this.addEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = handler;
            }
        },
        teardown: function () {
            if (this.removeEventListener) {
                for (var i = toBind.length; i;) {
                    this.removeEventListener(toBind[--i], handler, false);
                }
            } else {
                this.onmousewheel = null;
            }
        }
    };
    $.fn.extend({
        mousewheel: function (fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },
        unmousewheel: function (fn) {
            return this.unbind('mousewheel', fn);
        }
    });
    function handler(event) {
        var orgEvent = event || window.event, args = [].slice.call(arguments, 1), delta = 0, deltaX = 0, deltaY = 0, absDelta = 0, absDeltaXY = 0, fn;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';
        if (orgEvent.wheelDelta) {
            delta = orgEvent.wheelDelta;
        }
        if (orgEvent.detail) {
            delta = orgEvent.detail * -1;
        }
        if (orgEvent.deltaY) {
            deltaY = orgEvent.deltaY * -1;
            delta = deltaY;
        }
        if (orgEvent.deltaX) {
            deltaX = orgEvent.deltaX;
            delta = deltaX * -1;
        }
        if (orgEvent.wheelDeltaY !== undefined) {
            deltaY = orgEvent.wheelDeltaY;
        }
        if (orgEvent.wheelDeltaX !== undefined) {
            deltaX = orgEvent.wheelDeltaX * -1;
        }
        absDelta = Math.abs(delta);
        if (!lowestDelta || absDelta < lowestDelta) {
            lowestDelta = absDelta;
        }
        absDeltaXY = Math.max(Math.abs(deltaY), Math.abs(deltaX));
        if (!lowestDeltaXY || absDeltaXY < lowestDeltaXY) {
            lowestDeltaXY = absDeltaXY;
        }
        fn = delta > 0 ? 'floor' : 'ceil';
        delta = Math[fn](delta / lowestDelta);
        deltaX = Math[fn](deltaX / lowestDeltaXY);
        deltaY = Math[fn](deltaY / lowestDeltaXY);
        args.unshift(event, delta, deltaX, deltaY);
        return ($.event.dispatch || $.event.handle).apply(this, args);
    }
    function preCode(selector) {
        var els = Array.prototype.slice.call(document.querySelectorAll(selector), 0);
        els.forEach(function (el, idx, arr) {
            var txt = el.textContent.replace(/^[\r\n]+/, '').replace(/\s+$/g, '');
            if (/^\S/gm.test(txt)) {
                el.textContent = txt;
                return;
            }
            var mat, str, re = /^[\t ]+/gm, len, min = 1000;
            while (mat = re.exec(txt)) {
                len = mat[0].length;
                if (len < min) {
                    min = len;
                    str = mat[0];
                }
            }
            if (min == 1000)
                return;
            el.textContent = txt.replace(new RegExp('^' + str, 'gm'), '');
        });
    }
    document.addEventListener('DOMContentLoaded', function () {
        preCode('pre code, textarea');
    }, false);
    var hasTouch = 'ontouchend' in window, eventTimer;
    var moveDirection = 'undefined', startX, startY, deltaX, deltaY, mouseDown = false;
    var addTouchEvents = function (element) {
        if (hasTouch) {
            element.addEventListener('touchstart', touch2Mouse, true);
            element.addEventListener('touchmove', touch2Mouse, true);
            element.addEventListener('touchend', touch2Mouse, true);
        }
    };
    function touch2Mouse(e) {
        var theTouch = e.changedTouches[0];
        var mouseEv;
        switch (e.type) {
        case 'touchstart':
            mouseEv = 'mousedown';
            break;
        case 'touchend':
            mouseEv = 'mouseup';
            break;
        case 'touchmove':
            mouseEv = 'mousemove';
            break;
        default:
            return;
        }
        if (mouseEv == 'mousedown') {
            eventTimer = new Date().getTime();
            startX = theTouch.clientX;
            startY = theTouch.clientY;
            mouseDown = true;
        }
        if (mouseEv == 'mouseup') {
            if (new Date().getTime() - eventTimer <= 500) {
                mouseEv = 'click';
            } else if (new Date().getTime() - eventTimer > 1000) {
                mouseEv = 'longclick';
            }
            eventTimer = 0;
            mouseDown = false;
        }
        if (mouseEv == 'mousemove') {
            if (mouseDown) {
                deltaX = theTouch.clientX - startX;
                deltaY = theTouch.clientY - startY;
                moveDirection = deltaX > deltaY ? 'horizontal' : 'vertical';
            }
        }
        var mouseEvent = document.createEvent('MouseEvent');
        mouseEvent.initMouseEvent(mouseEv, true, true, window, 1, theTouch.screenX, theTouch.screenY, theTouch.clientX, theTouch.clientY, false, false, false, false, 0, null);
        theTouch.target.dispatchEvent(mouseEvent);
        e.preventDefault();
    }
    $.widget('metro.accordion', {
        version: '3.0.0',
        options: {
            closeAny: false,
            speed: 'fast',
            onFrameOpen: function (frame) {
                return true;
            },
            onFrameOpened: function (frame) {
            },
            onFrameClose: function (frame) {
                return true;
            },
            onFrameClosed: function (frame) {
            }
        },
        init: function () {
            var that = this, element = this.element;
            element.on('click', '.heading', function (e) {
                var frame = $(this).parent();
                if (frame.hasClass('disabled')) {
                    return false;
                }
                if (!frame.hasClass('active')) {
                    that._openFrame(frame);
                } else {
                    that._closeFrame(frame);
                }
                e.preventDefault();
                e.stopPropagation();
            });
        },
        _closeAllFrames: function () {
            var that = this;
            var frames = this.element.children('.frame.active');
            $.each(frames, function () {
                that._closeFrame($(this));
            });
        },
        _openFrame: function (frame) {
            var o = this.options;
            var content = frame.children('.content');
            var result;
            if (typeof o.onFrameOpen === 'function') {
                if (!o.onFrameOpen(frame)) {
                    return false;
                }
            } else {
                if (typeof window[o.onFrameOpen] === 'function') {
                    if (!window[o.onFrameOpen](frame)) {
                        return false;
                    }
                } else {
                    result = eval('(function(){' + o.onFrameOpen + '})');
                    if (!result.call(frame)) {
                        return false;
                    }
                }
            }
            if (o.closeAny) {
                this._closeAllFrames();
            }
            content.slideDown(o.speed);
            frame.addClass('active');
            if (typeof o.onFrameOpened === 'function') {
                o.onFrameOpened(frame);
            } else {
                if (typeof window[o.onFrameOpened] === 'function') {
                    window[o.onFrameOpened](frame);
                } else {
                    result = eval('(function(){' + o.onFrameOpened + '})');
                    result.call(frame);
                }
            }
        },
        _closeFrame: function (frame) {
            var o = this.options;
            var content = frame.children('.content');
            var result;
            if (typeof o.onFrameClose === 'function') {
                if (!o.onFrameClose(frame)) {
                    return false;
                }
            } else {
                if (typeof window[o.onFrameClose] === 'function') {
                    if (!window[o.onFrameClose](frame)) {
                        return false;
                    }
                } else {
                    result = eval('(function(){' + o.onFrameClose + '})');
                    if (!result.call(frame)) {
                        return false;
                    }
                }
            }
            content.slideUp(o.speed, function () {
                frame.removeClass('active');
            });
            if (typeof o.onFrameClosed === 'function') {
                o.onFrameClosed(frame);
            } else {
                if (typeof window[o.onFrameClosed] === 'function') {
                    window[o.onFrameClosed](frame);
                } else {
                    result = eval('(function(){' + o.onFrameClosed + '})');
                    result.call(frame);
                }
            }
        },
        _create: function () {
            var that = this, o = this.options, element = this.element;
            $.each(this.element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            that.init();
            element.data('accordion', this);
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.appbar', {
        version: '3.0.0',
        options: {
            flexstyle: 'app-bar-menu',
            flexclean: false,
            flextolerance: 3
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._initBar();
            element.data('appbar', this);
        },
        _calculateFreeSpace: function () {
            var that = this, element = this.element, o = this.options;
            var menusParentWidth = 0, childrenWidth = 0, children;
            var freeSpace;
            menusParentWidth = $(that.menusParent).width();
            children = $(that.menusParent).children(':visible').not('.app-bar-pullmenu');
            var childrenLeftFloated = [];
            var childrenRightFloated = [];
            var childrenAsUsual = [];
            var floatState;
            for (var i = 0, len = children.length; i < len; i++) {
                floatState = $(children[i]).css('float');
                switch (floatState) {
                case 'left':
                    childrenLeftFloated.push(children[i]);
                    break;
                case 'right':
                    childrenRightFloated.push(children[i]);
                    break;
                default:
                    childrenAsUsual.push(children[i]);
                }
            }
            childrenRightFloated.reverse();
            children = new Array();
            children = childrenLeftFloated.concat(childrenAsUsual, childrenRightFloated);
            children = $(children);
            childrenWidth += parseInt($(children).first().css('margin-left'));
            for (var i = 0, len = children.length - 1; i <= len; i++) {
                childrenWidth += $(children[i]).outerWidth();
                if (i !== len) {
                    childrenWidth += Math.max(parseInt($(children[i]).css('margin-right')), parseInt($(children[i + 1]).css('margin-left')));
                }
            }
            childrenWidth += parseInt($(children[len]).css('margin-right'));
            freeSpace = menusParentWidth - childrenWidth;
            that.freeSpace = freeSpace;
            that.childrenWidth = childrenWidth;
            that.menusParentWidth = menusParentWidth;
            return freeSpace;
        },
        _originIndexMove: function (menu, child) {
            var flexChildren = $(menu).children().filter(function () {
                return parseInt($(this).attr('data-flexorderorigin')) < parseInt($(child).attr('data-flexorderorigin'));
            });
            if (flexChildren.length > 0) {
                $(flexChildren).last().after(child);
            } else {
                flexChildren = $(menu).children().filter(function () {
                    return parseInt($(this).attr('data-flexorderorigin')) > parseInt($(child).attr('data-flexorderorigin'));
                });
                if (flexChildren.length > 0) {
                    $(flexChildren).first().before(child);
                } else {
                    $(menu).append(child);
                }
            }
        },
        _moveMenuEntry: function (direction) {
            var that = this, element = this.element, o = this.options;
            direction = direction || 'toPullMenu';
            if (direction === 'toPullMenu') {
                var nextToHide = $(that.allMenuEntries).not('.app-bar-pullmenu-entry').last();
                if (nextToHide.length === 0) {
                    return false;
                }
                var topMenu = $(nextToHide).parent();
                var topMenuIndex = $(that.flexVisibles).index($(nextToHide).parent());
                var pullMenuBar = $(that.pullMenu).find('.app-bar-pullmenubar').eq(topMenuIndex);
                that._originIndexMove(pullMenuBar, nextToHide);
                $(nextToHide).addClass('app-bar-pullmenu-entry');
                $(pullMenuBar).removeClass('hidden').show();
                if ($(topMenu).children().length === 0) {
                    $(topMenu).addClass('hidden');
                }
                $(that.pullButton).show();
                return nextToHide;
            } else if (direction === 'fromPullMenu') {
                var nextToShow = $(that.allMenuEntries).filter('.app-bar-pullmenu-entry').first();
                var pullMenuBar = $(nextToShow).parent();
                var topMenuIndex = $(pullMenuBar).index();
                var topMenu = $(that.flexVisibles).eq(topMenuIndex);
                $(topMenu).removeClass('hidden');
                $(nextToShow).removeClass('app-bar-pullmenu-entry');
                that._originIndexMove(topMenu, nextToShow);
                if ($(pullMenuBar).children().length === 0) {
                    $(pullMenuBar).addClass('hidden').hide();
                }
                if ($(that.pullMenu).children('.app-bar-pullmenubar').not('.hidden').length === 0) {
                    $(that.pullMenu).hide().addClass('hidden');
                    $(that.pullButton).hide();
                }
                if (nextToShow.length === 0) {
                    return false;
                }
                return nextToShow;
            }
        },
        _checkMenuEntries: function () {
            var that = this, element = this.element, o = this.options;
            var forceEndLoop = false;
            for (var maxLoop = 0, maxLoopLen = that.allMenuEntries.length; maxLoop < maxLoopLen; maxLoop++) {
                that._calculateFreeSpace();
                var freeSpace = that.freeSpace;
                if (freeSpace < o.flextolerance || o.flexclean) {
                    if (!that._moveMenuEntry('toPullMenu')) {
                        break;
                    } else {
                        if (!forceEndLoop) {
                            continue;
                        }
                    }
                } else {
                    if (!that._moveMenuEntry('fromPullMenu')) {
                        break;
                    } else {
                        forceEndLoop = true;
                        continue;
                    }
                }
                break;
            }
        },
        resize: function () {
            var that = this, element = this.element, o = this.options;
            if (that.initiatedAsFlex) {
                this._checkMenuEntries();
            }
        },
        _initBar: function () {
            var that = this, element = this.element, o = this.options;
            that.lastFlexAction = undefined;
            that.pullButton = $(element).find('.app-bar-pullbutton');
            var menus = $(element).find('.app-bar-menu');
            that.initiatedAsFlex = false;
            o.flexclean = $(element).is('[data-flexclean=\'true\']') || o.flexclean;
            o.flexstyle = $(element).attr('data-flexstyle') || o.flexstyle;
            var flexVisible, menuEntries;
            that.flexVisibles = $();
            that.allMenuEntries = $();
            that.menusParent = $();
            that.pullMenu = $();
            if (menus.length > 0 && $(element).is(':not(\'.no-flexible\')')) {
                that.flexVisibles = $(menus).not('.no-flexible');
                if (that.flexVisibles.length > 0) {
                    that.initiatedAsFlex = true;
                    that.flexVisibles.sort(function (a, b) {
                        var aValue = parseInt($(a).data('flexorder')) || $(a).index() + 1;
                        var bValue = parseInt($(b).data('flexorder')) || $(b).index() + 1;
                        return aValue - bValue;
                    });
                    $(that.flexVisibles).each(function () {
                        flexVisible = this;
                        menuEntries = $(flexVisible).children();
                        $(menuEntries).each(function () {
                            $(this).attr('data-flexorderorigin', $(this).index());
                            if (!$(this).is('[data-flexorder]')) {
                                $(this).attr('data-flexorder', $(this).index() + 1);
                            }
                        });
                        menuEntries.sort(function (a, b) {
                            var aValue = parseInt($(a).data('flexorder'));
                            var bValue = parseInt($(b).data('flexorder'));
                            return aValue - bValue;
                        });
                        if ($(flexVisible).is('[data-flexdirection=\'reverse\']')) {
                            menuEntries.reverse();
                        }
                        $.merge(that.allMenuEntries, $(menuEntries).not('.no-flexible'));
                    });
                    that.menusParent = $(element).find('.app-bar-menu').first().parent();
                    if (!(that.pullButton.length > 0)) {
                        that.pullButton = $('<div class="app-bar-pullbutton automatic"></div>');
                        $(that.menusParent).append(that.pullButton);
                    }
                    that.pullMenu = $('<nav class="app-bar-pullmenu hidden" />');
                    that.flexVisibles.each(function () {
                        $(that.pullMenu).append($('<ul class="app-bar-pullmenubar hidden ' + o.flexstyle + '" />'));
                    });
                    $(that.menusParent).append($('<div class="clearfix" style="width: 0;">'));
                    $(that.pullMenu).addClass('flexstyle-' + o.flexstyle);
                    $(that.menusParent).append(that.pullMenu);
                    that._checkMenuEntries();
                    $(that.pullButton).on('click', function () {
                        that = $(this).closest('[data-role=appbar]').data('appbar');
                        if ($(that.pullMenu).is(':hidden')) {
                            $(that.pullMenu).show();
                            $(that.pullMenu).find('.app-bar-pullmenubar').hide().not('.hidden').slideDown('fast');
                        } else {
                            $(that.pullMenu).find('.app-bar-pullmenubar').not('.hidden').show().slideUp('fast', function () {
                                $(that.pullMenu).hide();
                            });
                        }
                    });
                    $(window).resize(function () {
                        $('[data-role=appbar]:not(.no-flexible)').each(function () {
                            $(this).data('appbar').resize();
                        });
                    });
                    $(window).load(function () {
                        $('[data-role=appbar]:not(.no-flexible)').each(function () {
                            $(this).data('appbar').resize();
                        });
                    });
                    $('[data-role=appbar]:not(.no-flexible) [src]').on('load', function () {
                        var appbar = $(this).closest('[data-role=appbar]').data('appbar');
                        appbar.resize();
                    });
                }
            }
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.audio', {
        version: '3.0.14',
        options: {
            src: false,
            volume: 0.5,
            muted: false,
            loop: false,
            preload: false,
            autoplay: false,
            playList: false,
            mode: 'full',
            loopButton: '<span class=\'mif-loop\'></span>',
            stopButton: '<span class=\'mif-stop\'></span>',
            playButton: '<span class=\'mif-play\'></span>',
            pauseButton: '<span class=\'mif-pause\'></span>',
            muteButton: '<span class=\'mif-volume-mute2\'></span>',
            shuffleButton: '<span class=\'mif-shuffle\'></span>',
            nextButton: '<span class=\'mif-forward\'></span>',
            prevButton: '<span class=\'mif-backward\'></span>',
            randomButton: '<span class=\'mif-dice\'></span>',
            playListButton: '<span class=\'mif-list2\'></span>',
            volumeLowButton: '<span class=\'mif-volume-low\'></span>',
            volumeMediumButton: '<span class=\'mif-volume-medium\'></span>',
            volumeHighButton: '<span class=\'mif-volume-high\'></span>'
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            this._setOptionsFromDOM();
            this._createPlayer();
            this._addControls();
            this._addEvents();
            this._addPlayList();
            this._setControlsVisibility();
            element.data('audio', this);
        },
        _setControlsVisibility: function () {
            var that = this, element = this.element, o = this.options;
            if (element.find('.play-list').length == 0) {
                element.find('.controls .plist').hide();
                element.find('.controls .next').hide();
                element.find('.controls .prev').hide();
                element.find('.controls .random').hide();
            }
        },
        _addPlayList: function () {
            var that = this, element = this.element, o = this.options;
            var audio = element.find('audio');
            var pl, pli, plw, poster, title;
            var play_list;
            if (o.playList) {
                if (window[o.playList] != undefined && typeof window[o.playList] == 'function') {
                    pl = window[o.playList]();
                    pli = pl.items;
                    plw = $('<div>').addClass('play-list-wrapper').insertBefore(element.find('audio'));
                    if (pl.title != undefined) {
                        title = $('<h1>').addClass('album-title').html(pl.title).appendTo(plw);
                    }
                    if (pl.poster != undefined) {
                        poster = $('<div>').addClass('poster').html($('<img>').attr('src', pl.poster)).appendTo(plw);
                    }
                    if (pl.desc != undefined) {
                        $('<div>').addClass('album-desc').html(pl.desc).appendTo(poster);
                    }
                    play_list = $('<ul>').addClass('play-list').appendTo(plw);
                    if (pli != undefined) {
                        $.each(pl.items, function () {
                            var item = this, li;
                            li = $('<li>').appendTo(play_list);
                            li.data('src', item.file);
                            if (item.type != undefined) {
                                li.data('type', item.type);
                            }
                            if (item.title != undefined) {
                                li.html(item.title);
                            } else {
                                li.html(item.file.replace(/^.*[\\\/]/, ''));
                            }
                        });
                    }
                }
            }
            play_list = element.find('ul');
            if (play_list.length == 0) {
                return this;
            }
            play_list.addClass('play-list');
            var items = play_list.find('li');
            if (items.length == 0) {
                return this;
            }
            $.each(items, function () {
                var item = $(this);
                var pb = $('<div>').addClass('progress-bar small no-margin-top').data('role', 'progress').appendTo(item).hide();
                item.on('click', function () {
                    items.removeClass('current');
                    items.find('.progress-bar').hide();
                    var src = item.data('src'), type = item.data('type');
                    item.addClass('current');
                    item.find('.progress-bar').show();
                    element.data('current', item);
                    that.play(src, type);
                });
            });
            $(items[0]).click();
            this._stop();
            element.data('current', $(items[0]));
        },
        _createPlayer: function () {
            var that = this, element = this.element, o = this.options;
            var audio = element.find('audio');
            element.addClass('audio-player');
            element.addClass(o.mode);
            if (audio.length == 0) {
                audio = $('<audio>').appendTo(element);
            }
            $.each([
                'autoplay',
                'controls',
                'muted',
                'loop',
                'preload'
            ], function () {
                audio.removeAttr(this);
            });
            if (o.src) {
                audio.attr(src, o.src);
            }
            if (o.loop) {
                audio.attr('loop', 'loop');
            }
            if (o.preload) {
                audio.attr('preload', 'auto');
            }
            if (o.autoplay) {
                audio.attr('autoplay', 'autoplay');
            }
            audio[0].volume = o.volume;
            audio[0].muted = o.muted;
            element.data('muted', false);
            element.data('duration', 0);
            element.data('played', false);
            element.data('volume', audio[0].volume);
            element.data('current', false);
        },
        _addControls: function () {
            var that = this, element = this.element, o = this.options;
            var controls, play_button, loop_button, stop_button, volume_button, volume_slider, stream_slider, info_box, stream_wrapper, volume_wrapper, shufle_button, next_button, prev_button, random_button, play_list_button;
            var audio = element.find('audio'), audio_obj = audio[0];
            controls = $('<div>').addClass('controls').appendTo(element);
            if (o.playListButton !== false) {
                play_list_button = $('<button/>').addClass('square-button control-element plist').html(o.playListButton).appendTo(controls);
                play_list_button.on('click', function () {
                    var play_list = element.find('.play-list-wrapper');
                    if (play_list.length == 0) {
                        return that;
                    }
                    play_list.toggleClass('not-visible');
                });
            }
            if (o.loopButton !== false) {
                loop_button = $('<button/>').addClass('square-button control-element loop').html(o.loopButton).appendTo(controls);
                loop_button.on('click', function () {
                    loop_button.toggleClass('active');
                    if (loop_button.hasClass('active')) {
                        audio.attr('loop', 'loop');
                    } else {
                        audio.removeAttr('loop');
                    }
                });
            }
            if (o.playButton !== false) {
                play_button = $('<button/>').addClass('square-button control-element play').html(o.playButton).appendTo(controls);
                play_button.on('click', function () {
                    that._play();
                });
            }
            if (o.prevButton !== false) {
                prev_button = $('<button/>').addClass('square-button control-element prev').html(o.prevButton).appendTo(controls);
                prev_button.on('click', function () {
                    that._playPrev();
                });
            }
            if (o.nextButton !== false) {
                next_button = $('<button/>').addClass('square-button control-element next').html(o.nextButton).appendTo(controls);
                next_button.on('click', function () {
                    that._playNext();
                });
            }
            if (o.randomButton !== false) {
                random_button = $('<button/>').addClass('square-button control-element random').html(o.randomButton).appendTo(controls);
                random_button.on('click', function () {
                    that._playRandom();
                });
            }
            if (o.stopButton !== false) {
                stop_button = $('<button/>').addClass('square-button control-element stop').html(o.stopButton).appendTo(controls);
                stop_button.attr('disabled', true);
                stop_button.on('click', function () {
                    that._stop();
                });
            }
            stream_wrapper = $('<div/>').addClass('control-element stream-wrapper').appendTo(controls);
            stream_slider = $('<div/>').addClass('slider stream-slider').appendTo(stream_wrapper);
            stream_slider.slider({
                showHint: true,
                animate: false,
                markerColor: 'bg-red',
                completeColor: 'bg-cyan',
                onStartChange: function () {
                    audio_obj.pause();
                },
                onChanged: function (value, slider) {
                    if (audio_obj.seekable.length > 0)
                        audio_obj.currentTime = (element.data('duration') * value / 100).toFixed(0);
                    if (element.data('played') && audio_obj.currentTime >= 0) {
                        audio_obj.play();
                    }
                }
            });
            stream_slider.data('slider').value(0);
            info_box = $('<div/>').addClass('control-element info-box').appendTo(controls);
            info_box.html('00:00 / 00:00');
            var volume_container = $('<div/>').addClass('place-right').appendTo(controls);
            volume_button = $('<button/>').addClass('square-button control-element volume').html(o.volumeLowButton).appendTo(volume_container);
            volume_button.on('click', function () {
                var volume_slider = element.find('.volume-slider').data('slider');
                element.data('muted', !element.data('muted'));
                if (element.data('muted')) {
                    element.data('volume', audio_obj.volume);
                    volume_button.html(o.muteButton);
                    volume_slider.value(0);
                } else {
                    audio_obj.volume = element.data('volume');
                    volume_slider.value(element.data('volume') * 100);
                    that._setupVolumeButton();
                }
                audio_obj.muted = element.data('muted');
            });
            this._setupVolumeButton();
            volume_wrapper = $('<div/>').addClass('control-element volume-wrapper').appendTo(volume_container);
            volume_slider = $('<div/>').addClass('slider volume-slider').appendTo(volume_wrapper);
            volume_slider.slider({
                showHint: true,
                animate: false,
                markerColor: 'bg-red',
                completeColor: 'bg-green',
                onChange: function (value, slider) {
                    audio_obj.volume = value / 100;
                    that._setupVolumeButton();
                }
            });
            volume_slider.data('slider').value(audio_obj.volume * 100);
        },
        _setupVolumeButton: function () {
            var that = this, element = this.element, o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0];
            var controls = element.find('.controls'), volume_button = controls.find('.volume');
            var current_volume = audio_obj.volume;
            if (current_volume > 0 && current_volume < 0.3) {
                volume_button.html(o.volumeLowButton);
            } else if (current_volume >= 0.3 && current_volume < 0.6) {
                volume_button.html(o.volumeMediumButton);
            } else if (current_volume >= 0.6 && current_volume <= 1) {
                volume_button.html(o.volumeHighButton);
            } else {
                volume_button.html(o.muteButton);
            }
        },
        _addEvents: function () {
            var that = this, element = this.element, o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0];
            var controls = element.find('.controls');
            var info_box = element.find('.info-box');
            audio.on('loadedmetadata', function () {
                element.data('duration', audio_obj.duration.toFixed(0));
                info_box.html('00:00' + ' / ' + secondsToFormattedString(element.data('duration')));
            });
            audio.on('canplay', function () {
                var buffered = audio_obj.buffered.length ? Math.round(Math.floor(audio_obj.buffered.end(0)) / Math.floor(audio_obj.duration) * 100) : 0;
                that._setBufferSize(buffered);
            });
            audio.on('progress', function () {
                var buffered = audio_obj.buffered.length ? Math.round(Math.floor(audio_obj.buffered.end(0)) / Math.floor(audio_obj.duration) * 100) : 0;
                that._setBufferSize(buffered);
            });
            audio.on('timeupdate', function () {
                that._setInfoData();
                that._setStreamSliderPosition();
                if (element.data('current')) {
                    var pb = element.data('current').find('.progress-bar').data('progress');
                    var value = Math.round(audio_obj.currentTime * 100 / element.data('duration'));
                    pb.value(value);
                }
            });
            audio.on('waiting', function () {
            });
            audio.on('loadeddata', function () {
            });
            audio.on('ended', function () {
                that._stop();
                if (element.find('.play-list li').length > 0) {
                    that._playNext();
                }
            });
        },
        _setInfoData: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0];
            var info_box = element.find('.controls .info-box');
            var currentTime = Math.round(audio_obj.currentTime);
            info_box.html(secondsToFormattedString(currentTime) + ' / ' + secondsToFormattedString(element.data('duration')));
        },
        _setStreamSliderPosition: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0];
            var slider = element.find('.stream-slider').data('slider');
            var value = Math.round(audio_obj.currentTime * 100 / element.data('duration'));
            slider.value(value);
        },
        _setBufferSize: function (value) {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0];
            var slider = element.find('.stream-slider').data('slider');
            slider.buffer(Math.round(value));
        },
        _play: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0];
            var play_button = element.find('.controls .play');
            var stop_button = element.find('.controls .stop');
            if (audio_obj.paused) {
                play_button.html(o.pauseButton);
                audio_obj.play();
                stop_button.removeAttr('disabled');
                element.data('played', true);
                element.trigger('play');
            } else {
                play_button.html(o.playButton);
                audio_obj.pause();
                element.data('played', false);
                element.trigger('pause');
            }
        },
        _playRandom: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0];
            var play_list = element.find('.play-list');
            var items = element.find('.play-list li');
            if (items.length == 0) {
                return this;
            }
            var index = Math.floor(Math.random() * items.length) + 1;
            var next = play_list.find('li:nth-child(' + index + ')');
            next.click();
        },
        _playNext: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0];
            var play_list = element.find('.play-list');
            var items = element.find('.play-list li');
            if (items.length == 0) {
                return this;
            }
            var next = play_list.find('.current').next();
            if (next.length == 0) {
                next = play_list.find('li:nth-child(1)');
            }
            next.click();
        },
        _playPrev: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0];
            var play_list = element.find('.play-list');
            var items = element.find('.play-list li');
            if (items.length == 0) {
                return this;
            }
            var prev = play_list.find('.current').prev();
            if (prev.length == 0) {
                prev = play_list.find('li:last-child');
            }
            prev.click();
        },
        _stop: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0];
            var stop_button = element.find('.controls .stop');
            var play_button = element.find('.controls .play');
            audio_obj.pause();
            audio_obj.currentTime = 0;
            play_button.html(o.playButton);
            stop_button.attr('disabled', 'disabled');
            element.data('played', false);
            element.find('.stream-slider').data('slider').value(0);
            element.trigger('stop');
        },
        play: function (file, type) {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0], source;
            this._stop();
            audio.find('source').remove();
            audio.removeAttr('src');
            source = $('<source>').attr('src', file);
            if (type != undefined) {
                source.attr('type', type);
            }
            audio_obj.load();
            source.appendTo(audio);
            this._play();
        },
        pause: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0], play_button = element.find('.play');
            play_button.html(o.playButton);
            audio_obj.pause();
            element.data('played', false);
            element.trigger('pause');
        },
        resume: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var audio = element.find('audio'), audio_obj = audio[0], play_button = element.find('.play'), stop_button = element.find('.stop');
            play_button.html(o.pauseButton);
            audio_obj.play();
            stop_button.removeAttr('disabled');
            element.data('played', true);
            element.trigger('play');
        },
        stop: function () {
            this._stop();
        },
        _setOptionsFromDOM: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.group', {
        version: '3.0.0',
        options: {
            groupType: 'one-state',
            buttonStyle: false,
            onChange: function (index, btn) {
                return true;
            },
            onChanged: function (index, btn) {
            }
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            var result;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (!element.hasClass('group-of-buttons')) {
                element.addClass('group-of-buttons');
            }
            var buttons = element.find('.button, .toolbar-button');
            for (var i = 0; i < buttons.length; i++) {
                $(buttons[i]).data('index', i);
            }
            if (o.buttonStyle !== false) {
                buttons.addClass(o.buttonStyle);
            }
            element.on('click', '.button, .toolbar-button', function () {
                var button = $(this), index = button.data('index');
                if (typeof o.onChange === 'function') {
                    if (!o.onChange(index, button)) {
                        return false;
                    }
                } else {
                    if (typeof window[o.onChange] === 'function') {
                        if (!window[o.onChange](index, button)) {
                            return false;
                        }
                    } else {
                        result = eval('(function(){' + o.onChange + '})');
                        if (!result.call(index, button)) {
                            return false;
                        }
                    }
                }
                if (o.groupType === 'one-state') {
                    buttons.removeClass('active');
                    $(this).addClass('active');
                } else {
                    $(this).toggleClass('active');
                }
                if (typeof o.onChanged === 'function') {
                    o.onChanged(index, button);
                } else {
                    if (typeof window[o.onChanged] === 'function') {
                        window[o.onChanged](index, button);
                    } else {
                        result = eval('(function(){' + o.onChanged + '})');
                        result.call(index, button);
                    }
                }
            });
            element.data('group', this);
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.calendar', {
        version: '3.0.0',
        options: {
            format: 'yyyy-mm-dd',
            multiSelect: false,
            startMode: 'day',
            weekStart: window.METRO_CALENDAR_WEEK_START,
            otherDays: true,
            date: new Date(),
            minDate: false,
            maxDate: false,
            preset: false,
            exclude: false,
            stored: false,
            buttons: true,
            buttonToday: true,
            buttonClear: true,
            syncCalenderToDateField: true,
            locale: window.METRO_CURRENT_LOCALE,
            actions: true,
            condensedGrid: false,
            scheme: 'default',
            getDates: function (d) {
            },
            dayClick: function (d, d0) {
            }
        },
        _year: 0,
        _month: 0,
        _day: 0,
        _today: new Date(),
        _event: '',
        _mode: 'day',
        _distance: 0,
        _events: [],
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (typeof o.date === 'string') {
                o.date = new Date(o.date);
            }
            if (o.minDate !== false && typeof o.minDate === 'string') {
                o.minDate = new Date(o.minDate + 'T00:00:00Z') - 24 * 60 * 60 * 1000;
            }
            if (o.maxDate !== false && typeof o.maxDate === 'string') {
                o.maxDate = new Date(o.maxDate + 'T00:00:00Z');
            }
            this.locales = window.METRO_LOCALES;
            this._year = o.date.getFullYear();
            this._distance = o.date.getFullYear() - 4;
            this._month = o.date.getMonth();
            this._day = o.date.getDate();
            this._mode = o.startMode;
            element.data('_storage', []);
            element.data('_exclude', []);
            element.data('_stored', []);
            if (!element.hasClass('calendar')) {
                element.addClass('calendar');
            }
            var re, dates;
            if (o.preset) {
                re = /\s*,\s*/;
                dates = o.preset.split(re);
                $.each(dates, function () {
                    if (new Date(this) !== undefined) {
                        that.setDate(this);
                    }
                });
            }
            if (o.exclude) {
                re = /\s*,\s*/;
                dates = o.exclude.split(re);
                $.each(dates, function () {
                    if (new Date(this) !== undefined) {
                        that.setDateExclude(this);
                    }
                });
            }
            if (o.stored) {
                re = /\s*,\s*/;
                dates = o.stored.split(re);
                $.each(dates, function () {
                    if (new Date(this) !== undefined) {
                        that.setDateStored(this);
                    }
                });
            }
            if (o.scheme !== 'default') {
                element.addClass(o.scheme);
            }
            this._renderCalendar();
            element.data('calendar', this);
        },
        _renderButtons: function (table) {
            var tr, td, o = this.options;
            if (this.options.buttons) {
                var buttonToday = o.buttonToday ? '<button class=\'button calendar-btn-today small-button success\'>' + this.locales[o.locale].buttons[0] + '</button>' : '';
                var buttonClear = o.buttonClear ? '<button class=\'button calendar-btn-clear small-button warning\'>' + this.locales[o.locale].buttons[1] + '</button>' : '';
                tr = $('<div/>').addClass('calendar-row calendar-actions');
                td = $('<div/>').addClass('align-center').html(buttonToday + buttonClear);
                td.appendTo(tr);
                tr.appendTo(table);
            }
        },
        _renderMonth: function () {
            var that = this, o = this.options, year = this._year, month = this._month, day = this._day, event = this._event, feb = 28;
            if (month === 1) {
                if (year % 100 !== 0 && year % 4 === 0 || year % 400 === 0) {
                    feb = 29;
                }
            }
            var totalDays = [
                '31',
                '' + feb + '',
                '31',
                '30',
                '31',
                '30',
                '31',
                '31',
                '30',
                '31',
                '30',
                '31'
            ];
            var daysInMonth = totalDays[month];
            var first_week_day = this._dateFromNumbers(year, month + 1, 1).getDay();
            var table, tr, td, i, div;
            this.element.html('');
            table = $('<div/>').addClass('calendar-grid');
            if (o.condensedGrid) {
                table.addClass('condensed no-border');
            }
            tr = $('<div/>').addClass('calendar-row no-margin');
            $('<div/>').addClass('calendar-cell align-center').html('<a class=\'btn-previous-year\' href=\'#\'>-</a>').appendTo(tr);
            $('<div/>').addClass('calendar-cell align-center').html('<a class=\'btn-previous-month\' href=\'#\'>&#12296;</a>').appendTo(tr);
            $('<div/>').addClass('calendar-cell sel-month align-center').html('<a class=\'btn-select-month\' href=\'#\'>' + this.locales[o.locale].months[month] + ' ' + year + '</a>').appendTo(tr);
            $('<div/>').addClass('calendar-cell align-center').html('<a class=\'btn-next-month\' href=\'#\'>&#12297;</a>').appendTo(tr);
            $('<div/>').addClass('calendar-cell align-center').html('<a class=\'btn-next-year\' href=\'#\'>+</a>').appendTo(tr);
            tr.addClass('calendar-header').appendTo(table);
            var j;
            tr = $('<div/>').addClass('calendar-row week-days');
            for (i = 0; i < 7; i++) {
                if (!o.weekStart) {
                    td = $('<div/>').addClass('calendar-cell align-center day-of-week').appendTo(tr);
                    div = $('<div/>').html(this.locales[o.locale].days[i + 7]).appendTo(td);
                } else {
                    j = i + 1;
                    if (j === 7) {
                        j = 0;
                    }
                    td = $('<div/>').addClass('calendar-cell align-center day-of-week').appendTo(tr);
                    div = $('<div/>').html(this.locales[o.locale].days[j + 7]).appendTo(td);
                }
            }
            tr.addClass('calendar-subheader').appendTo(table);
            var prevMonth = this._month - 1;
            if (prevMonth < 0) {
                prevMonth = 11;
            }
            var daysInPrevMonth = totalDays[prevMonth];
            var _first_week_day = (o.weekStart ? first_week_day + 6 : first_week_day) % 7;
            var htmlPrevDay = '';
            tr = $('<div/>').addClass('calendar-row');
            for (i = 0; i < _first_week_day; i++) {
                if (o.otherDays) {
                    htmlPrevDay = daysInPrevMonth - (_first_week_day - i - 1);
                }
                td = $('<div/>').addClass('calendar-cell empty').appendTo(tr);
                div = $('<div/>').addClass('other-day').html(htmlPrevDay).appendTo(td);
                if (!o.otherDays) {
                    div.css('visibility', 'hidden');
                }
            }
            var week_day = (o.weekStart ? first_week_day + 6 : first_week_day) % 7;
            var d, a, d_html;
            for (i = 1; i <= daysInMonth; i++) {
                week_day %= 7;
                if (week_day === 0) {
                    tr.appendTo(table);
                    tr = $('<div/>').addClass('calendar-row');
                }
                td = $('<div/>').addClass('calendar-cell align-center day');
                div = $('<div/>').appendTo(td);
                if (o.minDate !== false && this._dateFromNumbers(year, month + 1, i) < o.minDate || o.maxDate !== false && this._dateFromNumbers(year, month + 1, i) > o.maxDate) {
                    td.removeClass('day');
                    div.addClass('other-day');
                    d_html = i;
                } else {
                    d_html = '<a href=\'#\'>' + i + '</a>';
                }
                div.html(d_html);
                if (year === this._today.getFullYear() && month === this._today.getMonth() && this._today.getDate() === i) {
                    td.addClass('today');
                }
                d = this._dateNumberStringyFy(this._year, this._month + 1, i);
                if (this.element.data('_storage').indexOf(d) >= 0) {
                    a = td.find('a');
                    a.parent().parent().addClass('selected');
                }
                if (this.element.data('_exclude').indexOf(d) >= 0) {
                    a = td.find('a');
                    a.parent().parent().addClass('exclude');
                }
                if (this.element.data('_stored').indexOf(d) >= 0) {
                    a = td.find('a');
                    a.parent().parent().addClass('stored');
                }
                td.appendTo(tr);
                week_day++;
            }
            var htmlOtherDays = '';
            for (i = week_day + 1; i <= 7; i++) {
                if (o.otherDays) {
                    htmlOtherDays = i - week_day;
                }
                td = $('<div/>').addClass('calendar-cell empty').appendTo(tr);
                div = $('<div/>').addClass('other-day').html(htmlOtherDays).appendTo(td);
                if (!o.otherDays) {
                    div.css('visibility', 'hidden');
                }
            }
            tr.appendTo(table);
            this._renderButtons(table);
            table.appendTo(this.element);
        },
        _renderMonths: function () {
            var table, tr, td, i, j;
            this.element.html('');
            table = $('<div/>').addClass('calendar-grid');
            if (this.options.condensedGrid) {
                table.addClass('condensed no-border');
            }
            tr = $('<div/>').addClass('calendar-row');
            $('<div/>').addClass('calendar-cell sel-minus align-center').html('<a class=\'btn-previous-year\' href=\'#\'>-</a>').appendTo(tr);
            $('<div/>').addClass('calendar-cell sel-year align-center').html('<a class=\'btn-select-year\' href=\'#\'>' + this._year + '</a>').appendTo(tr);
            $('<div/>').addClass('calendar-cell sel-plus align-center').html('<a class=\'btn-next-year\' href=\'#\'>+</a>').appendTo(tr);
            tr.addClass('calendar-header').appendTo(table);
            tr = $('<div/>').addClass('calendar-row');
            j = 0;
            for (i = 0; i < 12; i++) {
                td = $('<div/>').addClass('calendar-cell month-cell align-center month').html('<a href=\'#\' data-month=\'' + i + '\'>' + this.locales[this.options.locale].months[i + 12] + '</a>');
                if (this._month === i && new Date().getFullYear() === this._year) {
                    td.addClass('today');
                }
                td.appendTo(tr);
                if ((j + 1) % 4 === 0) {
                    tr.appendTo(table);
                    tr = $('<div/>').addClass('calendar-row');
                }
                j += 1;
            }
            this._renderButtons(table);
            table.appendTo(this.element);
        },
        _renderYears: function () {
            var table, tr, td, i, j;
            this.element.html('');
            table = $('<div/>').addClass('calendar-grid');
            if (this.options.condensedGrid) {
                table.addClass('condensed no-border');
            }
            tr = $('<div/>').addClass('calendar-row cells4');
            $('<div/>').addClass('calendar-cell sel-minus align-center').html('<a class=\'btn-previous-year\' href=\'#\'>-</a>').appendTo(tr);
            $('<div/>').addClass('calendar-cell sel-year align-center').html('<a class=\'btn-none-btn\'>' + this._distance + '-' + (this._distance + 11) + '</a>').appendTo(tr);
            $('<div/>').addClass('calendar-cell sel-plus align-center').html('<a class=\'btn-next-year\' href=\'#\'>+</a>').appendTo(tr);
            tr.addClass('calendar-header').appendTo(table);
            tr = $('<div/>').addClass('calendar-row');
            j = 0;
            for (i = this._distance; i < this._distance + 12; i++) {
                td = $('<div/>').addClass('calendar-cell year-cell align-center year').html('<a href=\'#\' data-year=\'' + i + '\'>' + i + '</a>');
                if (new Date().getFullYear() === i) {
                    td.addClass('today');
                }
                td.appendTo(tr);
                if ((j + 1) % 4 === 0) {
                    tr.appendTo(table);
                    tr = $('<div/>').addClass('calendar-row');
                }
                j += 1;
            }
            this._renderButtons(table);
            table.appendTo(this.element);
        },
        _renderCalendar: function () {
            switch (this._mode) {
            case 'year':
                this._renderYears();
                break;
            case 'month':
                this._renderMonths();
                break;
            default:
                this._renderMonth();
            }
            this._initButtons();
        },
        _initButtons: function () {
            var that = this, o = this.options, table = this.element.find('.calendar-grid');
            if (this._mode === 'day') {
                table.find('.btn-select-month').on('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    that._mode = 'month';
                    that._renderCalendar();
                });
                table.find('.btn-previous-month').on('click', function (e) {
                    that._event = 'eventPrevious';
                    e.preventDefault();
                    e.stopPropagation();
                    that._month -= 1;
                    if (that._month < 0) {
                        that._year -= 1;
                        that._month = 11;
                    }
                    that._renderCalendar();
                });
                table.find('.btn-next-month').on('click', function (e) {
                    that._event = 'eventNext';
                    e.preventDefault();
                    e.stopPropagation();
                    that._month += 1;
                    if (that._month === 12) {
                        that._year += 1;
                        that._month = 0;
                    }
                    that._renderCalendar();
                });
                table.find('.btn-previous-year').on('click', function (e) {
                    that._event = 'eventPrevious';
                    e.preventDefault();
                    e.stopPropagation();
                    that._year -= 1;
                    that._renderCalendar();
                });
                table.find('.btn-next-year').on('click', function (e) {
                    that._event = 'eventNext';
                    e.preventDefault();
                    e.stopPropagation();
                    that._year += 1;
                    that._renderCalendar();
                });
                table.find('.day a').on('click', function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    if ($(this).parent().parent().hasClass('exclude')) {
                        return false;
                    }
                    var d = new Date(that._paddy(that._year, 4), that._paddy(that._month, 2), that._paddy(parseInt($(this).html()), 2)).format(that.options.format, null);
                    var d0 = new Date(that._paddy(that._year, 4), that._paddy(that._month, 2), that._paddy(parseInt($(this).html()), 2));
                    if (that.options.multiSelect) {
                        $(this).parent().parent().toggleClass('selected');
                        if ($(this).parent().parent().hasClass('selected')) {
                            that._addDate(that._dateStringyFy(d0));
                        } else {
                            that._removeDate(that._dateStringyFy(d0));
                        }
                    } else {
                        table.find('.day a').parent().parent().removeClass('selected');
                        $(this).parent().parent().addClass('selected');
                        that.element.data('_storage', []);
                        that._addDate(that._dateStringyFy(d0));
                    }
                    if (typeof o.dayClick === 'function') {
                        o.dayClick(d, d0);
                    } else {
                        if (typeof window[o.dayClick] === 'function') {
                            window[o.dayClick](d, d0);
                        } else {
                            var result = eval('(function(){' + o.dayClick + '})');
                            result.call(d, d0);
                        }
                    }
                });
            } else if (this._mode === 'month') {
                table.find('.month a').on('click', function (e) {
                    that._event = 'eventNext';
                    e.preventDefault();
                    e.stopPropagation();
                    that._month = parseInt($(this).data('month'));
                    that._mode = 'day';
                    that._renderCalendar();
                });
                table.find('.btn-previous-year').on('click', function (e) {
                    that._event = 'eventPrevious';
                    e.preventDefault();
                    e.stopPropagation();
                    that._year -= 1;
                    that._renderCalendar();
                });
                table.find('.btn-next-year').on('click', function (e) {
                    that._event = 'eventNext';
                    e.preventDefault();
                    e.stopPropagation();
                    that._year += 1;
                    that._renderCalendar();
                });
                table.find('.btn-select-year').on('click', function (e) {
                    that._event = 'eventNext';
                    e.preventDefault();
                    e.stopPropagation();
                    that._mode = 'year';
                    that._renderCalendar();
                });
            } else {
                table.find('.year a').on('click', function (e) {
                    that._event = 'eventNext';
                    e.preventDefault();
                    e.stopPropagation();
                    that._year = parseInt($(this).data('year'));
                    that._mode = 'month';
                    that._renderCalendar();
                });
                table.find('.btn-previous-year').on('click', function (e) {
                    that._event = 'eventPrevious';
                    e.preventDefault();
                    e.stopPropagation();
                    that._distance -= 10;
                    that._renderCalendar();
                });
                table.find('.btn-next-year').on('click', function (e) {
                    that._event = 'eventNext';
                    e.preventDefault();
                    e.stopPropagation();
                    that._distance += 10;
                    that._renderCalendar();
                });
            }
            table.find('.calendar-btn-today').on('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                that._mode = that.options.startMode;
                that.options.date = new Date();
                that._year = that.options.date.getFullYear();
                that._month = that.options.date.getMonth();
                that._day = that.options.date.getDate();
                that._renderCalendar();
            });
            table.find('.calendar-btn-clear').on('click', function (e) {
                e.preventDefault();
                e.stopPropagation();
                that.options.date = new Date();
                that._year = that.options.date.getFullYear();
                that._month = that.options.date.getMonth();
                that._day = that.options.date.getDate();
                that.element.data('_storage', []);
                that._renderCalendar();
            });
        },
        _addDate: function (d) {
            var index = this.element.data('_storage').indexOf(d);
            if (index < 0) {
                this.element.data('_storage').push(d);
            }
        },
        _removeDate: function (d) {
            var index = this.element.data('_storage').indexOf(d);
            this.element.data('_storage').splice(index, 1);
        },
        _addDateExclude: function (d) {
            var index = this.element.data('_exclude').indexOf(d);
            if (index < 0) {
                this.element.data('_exclude').push(d);
            }
        },
        _addDateStored: function (d) {
            var index = this.element.data('_stored').indexOf(d);
            if (index < 0) {
                this.element.data('_stored').push(d);
            }
        },
        _removeDateExclude: function (d) {
            var index = this.element.data('_exclude').indexOf(d);
            this.element.data('_exclude').splice(index, 1);
        },
        _removeDateStored: function (d) {
            var index = this.element.data('_stored').indexOf(d);
            this.element.data('_stored').splice(index, 1);
        },
        _paddy: function paddy(n, p, c) {
            var pad_char = typeof c !== 'undefined' ? c : '0';
            var pad = new Array(1 + p).join(pad_char);
            return (pad + n).slice(-pad.length);
        },
        _dateFromNumbers: function dateFromNumbers(year, month, day) {
            return new Date(this._paddy(year, 4) + '/' + this._paddy(month, 2) + '/' + this._paddy(day, 2));
        },
        _dateNumberStringyFy: function dateNumberStringyFy(year, month, day) {
            return this._dateFromNumbers(year, month, day).format('yyyy-mm-dd');
        },
        _dateStringyFy: function dateStringyFy(d) {
            return this._dateNumberStringyFy(d.getFullYear(), d.getMonth() + 1, d.getDate());
        },
        setDate: function (d) {
            var r;
            d = new Date(d);
            r = this._dateNumberStringyFy(d.getFullYear(), d.getMonth() + 1, d.getDate());
            this._addDate(r);
            if (this.options.syncCalenderToDateField) {
                this._year = d.getFullYear();
                this._month = d.getMonth();
                this._day = d.getDate();
            }
            this._renderCalendar();
        },
        setDateExclude: function (d) {
            var r;
            d = new Date(d);
            r = this._dateNumberStringyFy(d.getFullYear(), d.getMonth() + 1, d.getDate());
            this._addDateExclude(r);
            this._renderCalendar();
        },
        setDateStored: function (d) {
            var r;
            d = new Date(d);
            r = this._dateNumberStringyFy(d.getFullYear(), d.getMonth() + 1, d.getDate());
            this._addDateStored(r);
            this._renderCalendar();
        },
        getDate: function (index) {
            return new Date(index !== undefined ? this.element.data('_storage')[index] : this.element.data('_storage')[0]).format(this.options.format);
        },
        getDates: function () {
            var res;
            res = $.merge($.merge([], this.element.data('_storage')), this.element.data('_stored'));
            return res.unique();
        },
        unsetDate: function (d) {
            var r;
            d = new Date(d);
            r = this._dateNumberStringyFy(d.getFullYear(), d.getMonth() + 1, d.getDate());
            this._removeDate(r);
            this._renderCalendar();
        },
        unsetDateExclude: function (d) {
            var r;
            d = new Date(d);
            r = this._dateNumberStringyFy(d.getFullYear(), d.getMonth() + 1, d.getDate());
            this._removeDateExclude(r);
            this._renderCalendar();
        },
        unsetDateStored: function (d) {
            var r;
            d = new Date(d);
            r = this._dateNumberStringyFy(d.getFullYear(), d.getMonth() + 1, d.getDate());
            this._removeDateStored(r);
            this._renderCalendar();
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.carousel', {
        version: '3.0.0',
        options: {
            auto: true,
            period: 5000,
            duration: 1000,
            effect: 'slide',
            effectFunc: 'linear',
            direction: 'left',
            controls: true,
            controlNext: false,
            controlPrev: false,
            markers: true,
            stop: true,
            width: '100%',
            height: false,
            _slides: {},
            _currentIndex: 0,
            _interval: 0,
            _outPosition: 0,
            _animating: false
        },
        _create: function () {
            var that = this, o = this.options, element = this.element;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            o._slides = element.find('.slide');
            var max_height = 0;
            $.each(o._slides, function () {
                var oh, slide = $(this);
                oh = slide.outerHeight();
                if (oh > max_height) {
                    max_height = oh;
                }
            });
            element.css({
                'width': o.width,
                'height': o.height ? o.height : max_height
            });
            if (o._slides.length <= 1) {
                return;
            }
            if (o.markers) {
                this._markers();
            }
            if (o.controls) {
                this._controls();
            }
            if (o.stop) {
                element.on('mouseenter', function () {
                    clearInterval(o._interval);
                }).on('mouseleave', function () {
                    if (that.options.auto) {
                        that._autoStart();
                    }
                });
            }
            element.find('.slide').hide();
            element.find('.slide:nth-child(1)').show();
            if (o.auto) {
                this._autoStart();
            }
            element.data('carousel', this);
        },
        _autoStart: function () {
            var that = this, o = this.options;
            o._interval = setInterval(function () {
                if (o.direction === 'left') {
                    that._slideTo('next');
                } else {
                    that._slideTo('prior');
                }
            }, o.period);
        },
        _slideTo: function (direction) {
            var carousel = this.element, that = this, o = this.options;
            var currentSlide = o._slides[o._currentIndex], nextSlide;
            if (direction === undefined) {
                direction = 'next';
            }
            if (direction === 'prior') {
                o._currentIndex -= 1;
                if (o._currentIndex < 0) {
                    o._currentIndex = o._slides.length - 1;
                }
                o._outPosition = this.element.width();
            } else if (direction === 'next') {
                o._currentIndex += 1;
                if (o._currentIndex >= o._slides.length) {
                    o._currentIndex = 0;
                }
                o._outPosition = -this.element.width();
            }
            nextSlide = o._slides[o._currentIndex];
            switch (this.options.effect) {
            case 'switch':
                this._effectSwitch(currentSlide, nextSlide);
                break;
            case 'slowdown':
                this._effectSlowdown(currentSlide, nextSlide, this.options.duration);
                break;
            case 'fade':
                this._effectFade(currentSlide, nextSlide, this.options.duration);
                break;
            default:
                this._effectSlide(currentSlide, nextSlide, this.options.duration);
            }
            carousel.find('.carousel-bullets a').each(function () {
                var index = $(this).data('num');
                if (index === o._currentIndex) {
                    $(this).addClass('bullet-on');
                } else {
                    $(this).removeClass('bullet-on');
                }
            });
        },
        _slideToSlide: function (slideIndex) {
            var o = this.options, currentSlide = o._slides[o._currentIndex], nextSlide = o._slides[slideIndex];
            if (o._currentIndex === slideIndex) {
                return false;
            }
            if (slideIndex > o._currentIndex) {
                o._outPosition = -this.element.width();
            } else {
                o._outPosition = this.element.width();
            }
            switch (this.options.effect) {
            case 'switch':
                this._effectSwitch(currentSlide, nextSlide);
                break;
            case 'slowdown':
                this._effectSlowdown(currentSlide, nextSlide);
                break;
            case 'fade':
                this._effectFade(currentSlide, nextSlide);
                break;
            default:
                this._effectSlide(currentSlide, nextSlide);
            }
            o._currentIndex = slideIndex;
        },
        _controls: function () {
            var next, prev, that = this, element = this.element, o = this.options;
            next = $('<span/>').addClass('carousel-switch-next').html('&gt;');
            prev = $('<span/>').addClass('carousel-switch-prev').html('&lt;');
            if (o.controlNext) {
                next.html(o.controlNext);
            }
            if (o.controlPrev) {
                prev.html(o.controlPrev);
            }
            next.appendTo(element);
            prev.appendTo(element);
            if (o._slides.length > 1) {
                prev.on('click', function () {
                    if (o._animating === false) {
                        that._slideTo('prior');
                        o._animating = true;
                        setTimeout(function () {
                            o._animating = false;
                        }, o.duration);
                    }
                });
                next.on('click', function () {
                    if (o._animating === false) {
                        that._slideTo('next');
                        o._animating = true;
                        setTimeout(function () {
                            o._animating = false;
                        }, o.duration);
                    }
                });
            } else {
                next.hide();
                prev.hide();
            }
        },
        _markers: function () {
            var div, a, i, that = this, o = this.options;
            div = $('<div class="carousel-bullets" />');
            for (i = 0; i < o._slides.length; i++) {
                a = $('<a class="carousel-bullet" href="javascript:void(0)" data-num="' + i + '"></a>');
                if (i === 0) {
                    a.addClass('bullet-on');
                }
                a.appendTo(div);
            }
            div.find('a').on('click', function (e) {
                var _this = $(this), index = _this.data('num');
                div.find('a').removeClass('bullet-on');
                _this.addClass('bullet-on');
                if (index === o._currentIndex) {
                    return false;
                }
                that._slideToSlide(index);
                e.preventDefault();
                e.stopPropagation();
            });
            div.appendTo(this.element);
        },
        _effectSwitch: function (currentSlide, nextSlide) {
            $(currentSlide).hide();
            $(nextSlide).css({ left: 0 }).show();
            this.element.css({ height: $(nextSlide).outerHeight() });
        },
        _effectSlide: function (currentSlide, nextSlide) {
            var o = this.options;
            $(currentSlide).animate({ left: o._outPosition }, o.duration, o.effectFunc);
            $(nextSlide).css('left', o._outPosition * -1).show();
            this.element.css({ height: $(nextSlide).outerHeight() });
            $(nextSlide).animate({ left: 0 }, o.duration, o.effectFunc);
        },
        _effectSlowdown: function (currentSlide, nextSlide) {
            var o = this.options;
            var options = {
                'duration': o.duration,
                'easing': 'doubleSqrt'
            };
            $.easing.doubleSqrt = function (t) {
                return Math.sqrt(Math.sqrt(t));
            };
            $(currentSlide).animate({ left: o._outPosition }, options);
            $(nextSlide).css('left', o._outPosition * -1).show();
            this.element.css({ height: $(nextSlide).outerHeight() });
            $(nextSlide).animate({ left: 0 }, options);
        },
        _effectFade: function (currentSlide, nextSlide) {
            var o = this.options;
            $(currentSlide).fadeOut(o.duration);
            $(nextSlide).css({ left: 0 }).fadeIn(o.duration);
            this.element.css({ height: $(nextSlide).outerHeight() });
        },
        slideTo: function (index) {
            this._slideToSlide(index);
        },
        nextSlide: function () {
            this._slideTo('next');
        },
        priorSlide: function () {
            this._slideTo('prior');
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.charm', {
        version: '3.0.0',
        options: {
            position: 'right',
            opacity: 1,
            outside: false,
            timeout: 0,
            duration: 400
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._createCharm();
            element.data('charm', this);
        },
        _createCharm: function () {
            var that = this, element = this.element, o = this.options;
            element.addClass('charm').addClass(o.position + '-side').css({ opacity: o.opacity }).hide();
            var closer = $('<span/>').addClass('charm-closer').appendTo(element);
            closer.on('click', function () {
                that.close();
            });
            if (o.outside === true) {
                element.on('mouseleave', function (e) {
                    that.close();
                });
            }
        },
        _showCharm: function () {
            var that = this, element = this.element, o = this.options;
            var size;
            if (o.position === 'left' || o.position === 'right') {
                size = element.outerWidth();
                if (o.position === 'left') {
                    element.css({ left: -size }).show().animate({ left: 0 }, o.duration);
                } else {
                    element.css({ right: -size }).show().animate({ right: 0 }, o.duration);
                }
            } else {
                size = element.outerHeight();
                if (o.position === 'top') {
                    element.css({ top: -size }).show().animate({ top: 0 }, o.duration);
                } else {
                    element.css({ bottom: -size }).show().animate({ bottom: 0 }, o.duration);
                }
            }
            if (o.timeout > 0) {
                this._timeout_interval = setInterval(function () {
                    if (!element.is(':hover')) {
                        that.close();
                        clearInterval(that._timeout_interval);
                    }
                }, o.timeout);
            }
        },
        _hideCharm: function () {
            var that = this, element = this.element, o = this.options;
            var size;
            if (o.position === 'left' || o.position === 'right') {
                size = element.outerWidth();
                if (o.position === 'left') {
                    element.animate({ left: -size }, o.duration, function () {
                        element.hide();
                    });
                } else {
                    element.animate({ right: -size }, o.duration, function () {
                        element.hide();
                    });
                }
            } else {
                size = element.outerHeight();
                if (o.position === 'top') {
                    element.animate({ top: -size }, o.duration, function () {
                        element.hide();
                    });
                } else {
                    element.animate({ bottom: -size }, o.duration, function () {
                        element.hide();
                    });
                }
            }
            clearInterval(this._timeout_interval);
        },
        open: function () {
            var that = this, element = this.element, o = this.options;
            if (element.data('opened') === true) {
                return;
            }
            element.data('opened', true);
            this._showCharm();
        },
        close: function () {
            var that = this, element = this.element, o = this.options;
            if (element.data('opened') === false) {
                return;
            }
            element.data('opened', false);
            this._hideCharm();
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.clock', {
        version: '1.0.0',
        options: {
            showTime: true,
            showDate: true,
            timeFormat: '24',
            dateFormat: 'american',
            divider: '&nbsp;&nbsp;'
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            this._setOptionsFromDOM();
            this._tick();
            this._clockInterval = setInterval(function () {
                that._tick();
            }, 500);
            element.data('clock', this);
        },
        _addLeadingZero: function (i) {
            if (i < 10) {
                i = '0' + i;
            }
            return i;
        },
        _tick: function () {
            var that = this, element = this.element, o = this.options;
            var timestamp = new Date();
            var time = timestamp.getTime();
            var result = '';
            var h = timestamp.getHours(), i = timestamp.getMinutes(), s = timestamp.getSeconds(), d = timestamp.getDate(), m = timestamp.getMonth() + 1, y = timestamp.getFullYear(), a = '';
            if (o.timeFormat == '12') {
                a = ' AM';
                if (h > 11) {
                    a = ' PM';
                }
                if (h > 12) {
                    h = h - 12;
                }
                if (h == 0) {
                    h = 12;
                }
            }
            h = this._addLeadingZero(h);
            i = this._addLeadingZero(i);
            s = this._addLeadingZero(s);
            m = this._addLeadingZero(m);
            d = this._addLeadingZero(d);
            if (o.showDate) {
                if (o.dateFormat == 'american') {
                    result += '<span class=\'date-month\'>' + m + '</span>';
                    result += '<span class=\'date-divider\'>-</span>';
                    result += '<span class=\'date-day\'>' + d + '</span>';
                    result += '<span class=\'date-divider\'>-</span>';
                    result += '<span class=\'date-year\'>' + y + '</span>';
                } else {
                    result += '<span class=\'date-day\'>' + d + '</span>';
                    result += '<span class=\'date-divider\'>-</span>';
                    result += '<span class=\'date-month\'>' + m + '</span>';
                    result += '<span class=\'date-divider\'>-</span>';
                    result += '<span class=\'date-year\'>' + y + '</span>';
                }
                result += o.divider;
            }
            if (o.showTime) {
                result += '<span class=\'clock-hour\'>' + h + '</span>';
                result += '<span class=\'clock-divider\'>:</span>';
                result += '<span class=\'clock-minute\'>' + i + '</span>';
                result += '<span class=\'clock-divider\'>:</span>';
                result += '<span class=\'clock-second\'>' + s + '</span>';
            }
            element.html(result);
        },
        _setOptionsFromDOM: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
        },
        _destroy: function () {
            clearInterval(this._clockInterval);
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.countdown', {
        version: '3.0.0',
        options: {
            stop: false,
            days: false,
            hours: false,
            minutes: false,
            seconds: false,
            backgroundColor: 'bg-cyan',
            digitColor: 'fg-white',
            dividerColor: 'fg-dark',
            labelColor: 'fg-grayLight',
            labels: {
                'days': 'days',
                'hours': 'hours',
                'minutes': 'mins',
                'seconds': 'secs'
            },
            onTick: function (d, h, m, s) {
            },
            onStop: function () {
            }
        },
        _interval: 0,
        _interval2: 0,
        _alarmOn: undefined,
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._alarmOn = new Date();
            if (o.stop !== false) {
                this._alarmOn = new Date(o.stop);
            }
            var dm = 24 * 60 * 60 * 1000, hm = 60 * 60 * 1000, mm = 60 * 1000, sm = 1000;
            if (o.days !== false) {
                if (typeof this._alarmOn === 'object') {
                    this._alarmOn = this._alarmOn.getTime();
                }
                this._alarmOn = this._alarmOn + o.days * dm;
            }
            if (o.hours !== false) {
                if (typeof this._alarmOn === 'object') {
                    this._alarmOn = this._alarmOn.getTime();
                }
                this._alarmOn = this._alarmOn + o.hours * hm;
            }
            if (o.minutes !== false) {
                if (typeof this._alarmOn === 'object') {
                    this._alarmOn = this._alarmOn.getTime();
                }
                this._alarmOn = this._alarmOn + o.minutes * mm;
            }
            if (o.seconds !== false) {
                if (typeof this._alarmOn === 'object') {
                    this._alarmOn = this._alarmOn.getTime();
                }
                this._alarmOn = this._alarmOn + o.seconds * sm;
            }
            this._createDigits();
            element.find('.digit').text('0');
            that._tick();
            element.data('countdown', this);
        },
        _createDigits: function () {
            var element = this.element, o = this.options;
            var parts = [
                'days',
                'hours',
                'minutes',
                'seconds'
            ];
            var p, d;
            parts.map(function (v) {
                p = $('<div/>').addClass('part ' + v).attr('data-day-text', o.labels[v]).appendTo(element);
                $('<div/>').addClass('digit').appendTo(p);
                $('<div/>').addClass('digit').appendTo(p);
                if (o.labelColor.isColor()) {
                    p.css({ color: o.labelColor });
                } else {
                    p.addClass(o.labelColor);
                }
                if (o.backgroundColor.isColor()) {
                    p.find('.digit').css({ background: o.backgroundColor });
                } else {
                    p.find('.digit').addClass(o.backgroundColor);
                }
                if (o.digitColor.isColor()) {
                    p.find('.digit').css({ color: o.digitColor });
                } else {
                    p.find('.digit').addClass(o.digitColor);
                }
                if (v !== 'seconds') {
                    d = $('<div/>').addClass('divider').text(':').appendTo(element);
                    if (o.dividerColor.isColor()) {
                        d.css({ 'color': o.dividerColor });
                    } else {
                        d.addClass(o.dividerColor);
                    }
                }
            });
        },
        _blink: function () {
            this.element.toggleClass('tick');
        },
        _tick: function () {
            var that = this, o = this.options, element = this.element;
            var days = 24 * 60 * 60, hours = 60 * 60, minutes = 60;
            var left, d, h, m, s;
            this._interval2 = setInterval(function () {
                that._blink();
            }, 500);
            this._interval = setInterval(function () {
                var result;
                left = Math.floor((that._alarmOn - new Date()) / 1000);
                if (left < 0) {
                    left = 0;
                }
                d = Math.floor(left / days);
                left -= d * days;
                that._update('days', d);
                if (d === 0) {
                    element.find('.part.days').addClass('disabled');
                }
                h = Math.floor(left / hours);
                left -= h * hours;
                that._update('hours', h);
                if (d === 0 && h === 0) {
                    element.find('.part.hours').addClass('disabled');
                }
                m = Math.floor(left / minutes);
                left -= m * minutes;
                that._update('minutes', m);
                if (d === 0 && h === 0 && m === 0) {
                    element.find('.part.minutes').addClass('disabled');
                }
                s = left;
                that._update('seconds', s);
                if (typeof o.onTick === 'function') {
                    o.onTick(d, h, m, s);
                } else {
                    if (typeof window[o.onTick] === 'function') {
                        window[o.onTick](d, h, m, s);
                    } else {
                        result = eval('(function(){' + o.onTick + '})');
                        result.call(d, h, m, s);
                    }
                }
                if (d === 0 && h === 0 && m === 0 && s === 0) {
                    element.find('.part').addClass('disabled');
                    if (typeof o.onStop === 'function') {
                        o.onStop();
                    } else {
                        if (typeof window[o.onStop] === 'function') {
                            window[o.onStop]();
                        } else {
                            result = eval('(function(){' + o.onStop + '})');
                            result.call();
                        }
                    }
                    that._stop('all');
                    that._trigger('alarm');
                    clearInterval(that._interval);
                }
            }, 1000);
        },
        _update: function (part, value) {
            var element = this.element;
            var major_value = Math.floor(value / 10) % 10;
            var minor_value = value % 10;
            var major_digit, minor_digit;
            major_digit = element.find('.' + part + ' .digit:eq(0)');
            minor_digit = element.find('.' + part + ' .digit:eq(1)');
            if (minor_value !== parseInt(minor_digit.text())) {
                minor_digit.toggleClass('scaleIn');
                setTimeout(function () {
                    minor_digit.text(minor_value).toggleClass('scaleIn');
                }, 500);
            }
            if (major_value !== parseInt(major_digit.text())) {
                major_digit.toggleClass('scaleIn');
                setTimeout(function () {
                    major_digit.text(major_value).toggleClass('scaleIn');
                }, 500);
            }
        },
        _stop: function () {
            clearInterval(this._interval);
            clearInterval(this._interval2);
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.datatable', {
        version: '3.0.0',
        options: {},
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                try {
                    o[key] = $.parseJSON(value);
                } catch (e) {
                    o[key] = value;
                }
            });
            if ($().dataTable) {
                try {
                    element.dataTable(o);
                } catch (e) {
                }
            } else {
                alert('dataTable plugin required');
            }
            element.data('datatable', this);
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.datepicker', {
        version: '3.0.14',
        options: {
            format: 'yyyy.mm.dd',
            preset: false,
            minDate: false,
            maxDate: false,
            effect: 'fade',
            position: 'bottom',
            locale: window.METRO_CURRENT_LOCALE,
            weekStart: window.METRO_CALENDAR_WEEK_START,
            otherDays: false,
            exclude: false,
            stored: false,
            buttons: false,
            buttonToday: true,
            buttonClear: true,
            condensedGrid: false,
            scheme: 'default',
            onSelect: function (d, d0) {
            }
        },
        _calendar: undefined,
        _create: function () {
            var that = this, element = this.element, o = this.options, input = element.children('input'), button = element.children('button');
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._createCalendar();
            input.attr('readonly', true);
            button.attr('type', 'button');
            button.on('click', function (e) {
                e.stopPropagation();
                if (that._calendar.css('display') === 'none') {
                    that._show();
                } else {
                    that._hide();
                }
            });
            element.on('click', function (e) {
                e.stopPropagation();
                if (that._calendar.css('display') === 'none') {
                    that._show();
                } else {
                    that._hide();
                }
            });
            $('html').on('click', function () {
                $('.calendar-dropdown').hide();
            });
            element.data('datepicker', this);
        },
        _createCalendar: function () {
            var _calendar, that = this, element = this.element, o = this.options;
            _calendar = $('<div/>').css({
                position: 'absolute',
                display: 'none',
                'max-width': 220,
                'z-index': 1000
            }).addClass('calendar calendar-dropdown').appendTo(element);
            _calendar.calendar({
                multiSelect: false,
                format: o.format,
                buttons: false,
                buttonToday: false,
                buttonClear: false,
                locale: o.locale,
                otherDays: o.otherDays,
                weekStart: o.weekStart,
                condensedGrid: o.condensedGrid,
                exclude: o.exclude,
                stored: o.stored,
                date: o.preset ? o.preset : new Date(),
                minDate: o.minDate,
                maxDate: o.maxDate,
                scheme: o.scheme,
                dayClick: function (d, d0) {
                    _calendar.calendar('setDate', d0);
                    that.element.children('input[type=text]').val(d);
                    that.element.children('input[type=text]').trigger('change', d0);
                    that.element.children('input[type=text]').blur();
                    that._hide();
                    if (typeof o.onSelect === 'function') {
                        o.onSelect(d, d0);
                    } else {
                        if (typeof window[o.onSelect] === 'function') {
                            window[o.onSelect](d, d0);
                        } else {
                            var result = eval('(function(){' + o.onSelect + '})');
                            result.call(d, d0);
                        }
                    }
                }
            });
            if (o.preset !== false) {
                _calendar.calendar('setDate', o.preset);
                element.find('input, .datepicker-output').val(_calendar.calendar('getDate'));
            }
            switch (this.options.position) {
            case 'top':
                _calendar.css({
                    top: 0 - _calendar.height(),
                    left: 0
                });
                break;
            default:
                _calendar.css({
                    top: '100%',
                    left: 0
                });
            }
            this._calendar = _calendar;
        },
        _show: function () {
            if (this.options.effect === 'slide') {
                $('.calendar-dropdown').slideUp('fast');
                this._calendar.slideDown('fast');
            } else if (this.options.effect === 'fade') {
                $('.calendar-dropdown').fadeOut('fast');
                this._calendar.fadeIn('fast');
            } else {
                $('.calendar-dropdown').hide();
                this._calendar.show();
            }
        },
        _hide: function () {
            if (this.options.effect === 'slide') {
                this._calendar.slideUp('fast');
            } else if (this.options.effect === 'fade') {
                this._calendar.fadeOut('fast');
            } else {
                this._calendar.hide();
            }
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        },
        setDate: function (date) {
            if ($.isArray(date)) {
            }
            var input = this.element.find('input');
            var calInst = this._calendar.data('metro-calendar');
            var calEl = calInst.element;
            calEl.data('_storage', []);
            this._calendar.calendar('setDate', date);
            date = this._calendar.calendar('getDate');
            input.val(date);
        }
    });
    $.widget('metro.dialog', {
        version: '3.0.14',
        options: {
            modal: false,
            overlay: false,
            overlayColor: 'default',
            overlayClickClose: false,
            type: 'default',
            place: 'center',
            position: 'default',
            content: false,
            hide: false,
            width: 'auto',
            height: 'auto',
            background: 'default',
            color: 'default',
            closeButton: false,
            windowsStyle: false,
            show: false,
            href: false,
            contentType: 'default',
            _interval: undefined,
            _overlay: undefined,
            onDialogOpen: function (dialog) {
            },
            onDialogClose: function (dialog) {
            }
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (o.overlay) {
                this._createOverlay();
            }
            this._createDialog();
            element.data('dialog', this);
            if (o.show) {
                this.open();
            }
        },
        _createOverlay: function () {
            var that = this, element = this.element, o = this.options;
            var overlay = $('body').find('.dialog-overlay');
            if (overlay.length === 0) {
                overlay = $('<div/>').addClass('dialog-overlay');
            }
            if (o.overlayColor) {
                if (o.overlayColor.isColor()) {
                    overlay.css({ background: o.overlayColor });
                } else {
                    overlay.addClass(o.overlayColor);
                }
            }
            o._overlay = overlay;
        },
        _createDialog: function () {
            var that = this, element = this.element, o = this.options;
            element.addClass('dialog');
            if (o.type !== 'default') {
                element.addClass(o.type);
            }
            if (o.windowsStyle) {
                o.width = 'auto';
                element.css({
                    left: 0,
                    right: 0
                });
            }
            if (o.background !== 'default') {
                if (o.background.isColor()) {
                    element.css({ background: o.background });
                } else {
                    element.addClass(o.background);
                }
            }
            if (o.color !== 'default') {
                if (o.color.isColor()) {
                    element.css({ color: o.color });
                } else {
                    element.addClass(o.color);
                }
            }
            element.css({
                width: o.width,
                height: o.height
            });
            if (o.closeButton) {
                $('<span/>').addClass('dialog-close-button').appendTo(element).on('click', function () {
                    that.close();
                });
            }
            this._hide();
        },
        _hide: function () {
            var element = this.element;
            element.css({ visibility: 'hidden' });
        },
        _show: function () {
            var that = this, element = this.element, o = this.options;
            this._setContent();
            element.css({ visibility: 'visible' });
        },
        _setPosition: function () {
            var that = this, element = this.element, o = this.options;
            var width = element.width(), height = element.height();
            switch (o.place) {
            case 'top-left': {
                    element.css({
                        left: 0,
                        top: 0
                    });
                    break;
                }
            case 'top-right': {
                    element.css({
                        right: 0,
                        top: 0
                    });
                    break;
                }
            case 'top-center': {
                    element.css({
                        left: ($(window).width() - width) / 2,
                        top: 0
                    });
                    break;
                }
            case 'bottom-left': {
                    element.css({
                        left: 0,
                        bottom: 0
                    });
                    break;
                }
            case 'bottom-right': {
                    element.css({
                        right: 0,
                        bottom: 0
                    });
                    break;
                }
            case 'center-left': {
                    element.css({
                        left: 0,
                        top: ($(window).height() - height) / 2
                    });
                    break;
                }
            case 'center-right': {
                    element.css({
                        right: 0,
                        top: ($(window).height() - height) / 2
                    });
                    break;
                }
            case 'bottom-center': {
                    element.css({
                        left: ($(window).width() - width) / 2,
                        bottom: 0
                    });
                    break;
                }
            default: {
                    element.css({
                        left: o.windowsStyle === false ? ($(window).width() - width) / 2 : 0,
                        top: ($(window).height() - height) / 2
                    });
                }
            }
        },
        _setContent: function () {
            var that = this, element = this.element, o = this.options;
            var content = $('<div>').addClass('set-dialog-content');
            if (o.contentType === 'video') {
                content.addClass('video-container');
            }
            if (o.content === false && o.href === false) {
                return false;
            }
            element.find('.set-dialog-content').remove();
            content.appendTo(element);
            if (o.content) {
                content.html(o.content);
                this._setPosition();
            }
            if (o.href) {
                $.get(o.href, function (response) {
                    content.html(response);
                    that._setPosition();
                });
            }
        },
        toggle: function () {
            var element = this.element;
            if (element.data('opened')) {
                this.close();
            } else {
                this.open();
            }
        },
        open: function () {
            var that = this, element = this.element, o = this.options;
            var overlay;
            this._setPosition();
            element.data('opened', true);
            if (o.overlay) {
                overlay = o._overlay;
                overlay.appendTo('body').show();
                if (o.overlayClickClose) {
                    overlay.on('click', function () {
                        that.close();
                    });
                }
            }
            this._show();
            if (typeof o.onDialogOpen === 'function') {
                o.onDialogOpen(element);
            } else {
                if (typeof window[o.onDialogOpen] === 'function') {
                    window[o.onDialogOpen](element);
                } else {
                    var result = eval('(function(){' + o.onDialogOpen + '})');
                    result.call(element);
                }
            }
            if (o.hide && parseInt(o.hide) > 0) {
                o._interval = setTimeout(function () {
                    that.close();
                }, parseInt(o.hide));
            }
        },
        close: function () {
            var that = this, element = this.element, o = this.options;
            clearInterval(o._interval);
            if (o.overlay) {
                $('body').find('.dialog-overlay').remove();
            }
            element.data('opened', false);
            this._hide();
            if (typeof o.onDialogClose === 'function') {
                o.onDialogClose(element);
            } else {
                if (typeof window[o.onDialogClose] === 'function') {
                    window[o.onDialogClose](element);
                } else {
                    var result = eval('(function(){' + o.onDialogClose + '})');
                    result.call(element);
                }
            }
        },
        reset: function (place) {
            if (place !== undefined) {
                this.options.place = place;
            }
            this._setPosition();
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    window.showMetroDialog = function (el, place) {
        var dialog = $(el), dialog_obj;
        if (dialog.length == 0) {
            console.log('Dialog ' + el + ' not found!');
            return false;
        }
        dialog_obj = dialog.data('dialog');
        if (dialog_obj == undefined) {
            console.log('Element not contain role dialog! Please add attribute data-role="dialog" to element ' + el);
            return false;
        }
        if (place !== undefined) {
            dialog_obj.options.place = place;
        }
        dialog_obj.open();
    };
    window.hideMetroDialog = function (el) {
        var dialog = $(el), dialog_obj;
        if (dialog.length == 0) {
            console.log('Dialog ' + el + ' not found!');
            return false;
        }
        dialog_obj = dialog.data('dialog');
        if (dialog_obj == undefined) {
            console.log('Element not contain role dialog! Please add attribute data-role="dialog" to element ' + el);
            return false;
        }
        dialog_obj.close();
    };
    window.toggleMetroDialog = function (el, place) {
        var dialog = $(el), dialog_obj;
        if (dialog.length == 0) {
            console.log('Dialog ' + el + ' not found!');
            return false;
        }
        dialog_obj = dialog.data('dialog');
        if (dialog_obj == undefined) {
            console.log('Element not contain role dialog! Please add attribute data-role="dialog" to element ' + el);
            return false;
        }
        if (dialog_obj.element.data('opened') === true) {
            dialog_obj.close();
        } else {
            if (place !== undefined) {
                dialog_obj.options.place = place;
            }
            dialog_obj.open();
        }
    };
    $.widget('metro.draggable', {
        version: '3.0.0',
        options: {
            dragElement: null,
            dragArea: null,
            zIndex: 2000,
            onDragStart: function (el) {
            },
            onDragStop: function (el) {
            },
            onDragMove: function (el, offset) {
            }
        },
        drag: false,
        oldCursor: null,
        oldZindex: null,
        oldPosition: null,
        _create: function () {
            var that = this, element = this.element, o = this.options;
            this._setOptionsFromDOM();
            this._createDraggable();
            element.data('draggable', this);
        },
        _createDraggable: function () {
            var that = this, element = this.element, o = this.options;
            var dragElement = o.dragElement ? element.find(o.dragElement) : element;
            addTouchEvents(element[0]);
            dragElement.on('mousedown', function (e) {
                var result, el = $(this);
                that.drag = true;
                if (typeof o.onDragStart === 'function') {
                    o.onDragStart(element);
                } else {
                    if (typeof window[o.onDragStart] === 'function') {
                        window[o.onDragStart](element);
                    } else {
                        result = eval('(function(){' + o.onDragStart + '})');
                        result.call(element);
                    }
                }
                that.oldCursor = el.css('cursor') ? el.css('cursor') : 'default';
                that.oldZindex = element.css('z-index');
                dragElement.css({ cursor: 'move' });
                element.css({ 'z-index': o.zIndex });
                var dragArea = o.dragArea ? $(o.dragArea) : $(window);
                var os = {
                    left: o.dragArea ? dragArea.offset().left : 0,
                    top: o.dragArea ? dragArea.offset().top : 0
                };
                var drg_h = element.outerHeight(), drg_w = element.outerWidth(), pos_y = element.offset().top + drg_h - e.pageY, pos_x = element.offset().left + drg_w - e.pageX;
                dragArea.on('mousemove', function (e) {
                    var offset, pageX, pageY;
                    if (!that.drag)
                        return false;
                    pageX = e.pageX - os.left;
                    pageY = e.pageY - os.top;
                    var t = pageY > 0 ? pageY + pos_y - drg_h : 0;
                    var l = pageX > 0 ? pageX + pos_x - drg_w : 0;
                    var t_delta = dragArea.innerHeight() + dragArea.scrollTop() - element.outerHeight();
                    var l_delta = dragArea.innerWidth() + dragArea.scrollLeft() - element.outerWidth();
                    if (t >= 0 && t <= t_delta) {
                        element.offset({ top: t + os.top });
                    }
                    if (l >= 0 && l <= l_delta) {
                        element.offset({ left: l + os.left });
                    }
                    offset = {
                        left: l,
                        top: t
                    };
                    if (typeof o.onDragMove === 'function') {
                        o.onDragMove(element, offset);
                    } else {
                        if (typeof window[o.onDragMove] === 'function') {
                            window[o.onDragMove](element, offset);
                        } else {
                            result = eval('(function(){' + o.onDragMove + '})');
                            result.call(element, offset);
                        }
                    }
                });
            });
            dragElement.on('mouseup', function (e) {
                var result, el = $(this);
                that.drag = false;
                dragElement.css({ cursor: that.oldCursor });
                element.css({
                    'z-index': that.oldZindex,
                    'position': that.oldPosition
                });
                if (typeof o.onDragStop === 'function') {
                    o.onDragStop(element);
                } else {
                    if (typeof window[o.onDragStop] === 'function') {
                        window[o.onDragStop](element);
                    } else {
                        result = eval('(function(){' + o.onDragStop + '})');
                        result.call(element);
                    }
                }
            });
        },
        _setOptionsFromDOM: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.dropdown', {
        version: '3.0.0',
        options: {
            effect: window.METRO_SHOW_TYPE,
            toggleElement: false,
            noClose: false,
            onDrop: function (object) {
            },
            onUp: function (object) {
            }
        },
        _create: function () {
            var that = this, element = this.element, o = this.options, menu = this.element, name = this.name, parent = this.element.parent();
            var toggle;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            toggle = o.toggleElement ? $(o.toggleElement) : parent.children('.dropdown-toggle').length > 0 ? parent.children('.dropdown-toggle') : parent.children('a:nth-child(1)');
            if (METRO_SHOW_TYPE !== undefined) {
                this.options.effect = METRO_SHOW_TYPE;
            }
            toggle.on('click.' + name, function (e) {
                parent.siblings(parent[0].tagName).removeClass('active-container');
                $('.active-container').removeClass('active-container');
                if (menu.css('display') === 'block' && !menu.hasClass('keep-open')) {
                    that._close(menu);
                } else {
                    $('[data-role=dropdown]').each(function (i, el) {
                        if (!menu.parents('[data-role=dropdown]').is(el) && !$(el).hasClass('keep-open') && $(el).css('display') === 'block') {
                            that._close(el);
                        }
                    });
                    if (menu.hasClass('horizontal')) {
                        menu.css({
                            'visibility': 'hidden',
                            'display': 'block'
                        });
                        var item_length = $(menu.children('li')[0]).outerWidth();
                        menu.css({
                            'visibility': 'visible',
                            'display': 'none'
                        });
                        var menu_width = menu.children('li').length * item_length + (menu.children('li').length - 1);
                        menu.css('width', menu_width);
                    }
                    that._open(menu);
                    parent.addClass('active-container');
                }
                e.preventDefault();
                e.stopPropagation();
            });
            if (o.noClose === true) {
                element.on('click', function (e) {
                    e.stopPropagation();
                });
            }
            $(menu).find('li.disabled a').on('click', function (e) {
                e.preventDefault();
            });
            $(document).on('click', function (e) {
                $('[data-role=dropdown]').each(function (i, el) {
                    if (!$(el).hasClass('keep-open') && $(el).css('display') === 'block') {
                        that._close(el);
                    }
                });
            });
            element.data('dropdown', this);
        },
        _open: function (el) {
            var parent = this.element.parent(), o = this.options;
            var toggle = o.toggleElement ? $(o.toggleElement) : parent.children('.dropdown-toggle').length > 0 ? parent.children('.dropdown-toggle') : parent.children('a:nth-child(1)');
            switch (this.options.effect) {
            case 'fade':
                $(el).fadeIn('fast');
                break;
            case 'slide':
                $(el).slideDown('fast');
                break;
            default:
                $(el).show();
            }
            this._trigger('onOpen', null, el);
            toggle.addClass('active-toggle');
            if (typeof o.onDrop === 'function') {
                o.onDrop(el);
            } else {
                if (typeof window[o.onDrop] === 'function') {
                    window[o.onDrop](el);
                } else {
                    var result = eval('(function(){' + o.onDrop + '})');
                    result.call(el);
                }
            }
        },
        _close: function (el) {
            var parent = $(el).parent(), o = this.options;
            var toggle = o.toggleElement ? $(o.toggleElement) : parent.children('.dropdown-toggle').length > 0 ? parent.children('.dropdown-toggle') : parent.children('a:nth-child(1)');
            switch (this.options.effect) {
            case 'fade':
                $(el).fadeOut('fast');
                break;
            case 'slide':
                $(el).slideUp('fast');
                break;
            default:
                $(el).hide();
            }
            this._trigger('onClose', null, el);
            toggle.removeClass('active-toggle');
            if (typeof o.onUp === 'function') {
                o.onUp(el);
            } else {
                if (typeof window[o.onUp] === 'function') {
                    window[o.onUp](el);
                } else {
                    var result = eval('(function(){' + o.onUp + '})');
                    result.call(el);
                }
            }
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.fitImage', {
        version: '3.0.0',
        options: {
            shadow: false,
            overlay: false,
            type: 'default',
            frameColor: 'default',
            format: 'hd'
        },
        _create: function () {
            var element = this.element, o = this.options;
            var parent = element.parent();
            var i_w, i_h, p_w, p_h;
            var div, src = element.attr('src');
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            $('<img/>').attr('src', src).load(function () {
                i_w = this.width;
                i_h = this.height;
            }).remove();
            var image_container = $('<div/>').addClass('image-container').css('width', '100%').appendTo(parent);
            var image_frame = $('<div/>').addClass('frame').appendTo(image_container);
            p_w = image_frame.innerWidth();
            p_h = image_frame.innerHeight();
            switch (o.format) {
            case 'sd':
                p_h = 3 * p_w / 4;
                break;
            case 'square':
                p_h = p_w;
                break;
            case 'cycle':
                p_h = p_w;
                break;
            case 'fill-h':
                p_h = '100%';
                image_container.css('height', '100%');
                break;
            case 'fill':
                p_h = '100%';
                image_container.css('height', '100%');
                break;
            default:
                p_h = 9 * p_w / 16;
            }
            div = $('<div/>').css({
                'width': '100%',
                'height': p_h,
                'background-image': 'url(' + src + ')',
                'background-size': 'cover',
                'background-repeat': 'no-repeat',
                'border-radius': o.format === 'cycle' ? '50%' : '0'
            });
            $(window).on('resize', function () {
                var p_w = image_frame.innerWidth();
                var p_h = image_frame.innerHeight();
                switch (o.format) {
                case 'sd':
                    p_h = 3 * p_w / 4;
                    break;
                case 'square':
                    p_h = p_w;
                    break;
                case 'cycle':
                    p_h = p_w;
                    break;
                case 'fill-h':
                    p_h = '100%';
                    image_container.css('height', '100%');
                    break;
                case 'fill':
                    p_h = '100%';
                    image_container.css('height', '100%');
                    break;
                default:
                    p_h = 9 * p_w / 16;
                }
                div.css({ 'height': p_h });
            });
            if (o.frameColor !== 'default') {
                if (o.frameColor.isUrl()) {
                    image_frame.css('background-color', o.frameColor);
                } else {
                    image_frame.addClass(o.frameColor);
                }
            }
            if (o.overlay !== false) {
                var overlay = $('<div/>').addClass('image-overlay').html(o.overlay).appendTo(image_container);
            }
            if (o.shadow !== false) {
                image_container.addClass('block-shadow');
            }
            div.appendTo(image_frame);
            switch (o.type) {
            case 'diamond': {
                    image_container.addClass('diamond');
                    div.addClass('image-replacer');
                    break;
                }
            case 'bordered': {
                    image_container.addClass('bordered');
                    break;
                }
            case 'polaroid': {
                    image_container.addClass('polaroid');
                    break;
                }
            case 'handing': {
                    image_container.addClass('handing');
                    break;
                }
            case 'handing-ani': {
                    image_container.addClass('handing ani');
                    break;
                }
            case 'handing-ani-hover': {
                    image_container.addClass('handing ani-hover');
                    break;
                }
            }
            image_container.addClass('image-format-' + o.format);
            element.remove();
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.fluentmenu', {
        version: '3.0.0',
        options: {
            onSpecialClick: function (a, li) {
            },
            onTabClick: function (a, li) {
            },
            onTabChange: function (a, li) {
            }
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._createMenu();
            element.data('fluentmenu', this);
        },
        _createMenu: function () {
            var that = this, element = this.element, o = this.options;
            var active_tab = $(element.find('.tabs-holder > li.active')[0]);
            this.openTab(active_tab);
            element.on('click', '.tabs-holder > li > a', function (e) {
                var a = $(this);
                var li = a.parent('li');
                var result;
                if (li.hasClass('special')) {
                    if (typeof o.onSpecialClick === 'function') {
                        o.onSpecialClick(a, li);
                    } else {
                        if (typeof window[o.onSpecialClick] === 'function') {
                            window[o.onSpecialClick](a, li);
                        } else {
                            result = eval('(function(){' + o.onSpecialClick + '})');
                            result.call(a, li);
                        }
                    }
                } else {
                    var panel = $(a.attr('href'));
                    that._hidePanels();
                    that._showPanel(panel);
                    element.find('.tabs-holder > li').removeClass('active');
                    a.parent('li').addClass('active');
                    if (typeof o.onTabClick === 'function') {
                        o.onTabClick(a, li);
                    } else {
                        if (typeof window[o.onTabClick] === 'function') {
                            window[o.onTabClick](a, li);
                        } else {
                            result = eval('(function(){' + o.onTabClick + '})');
                            result.call(a, li);
                        }
                    }
                    if (typeof o.onTabChange === 'function') {
                        o.onTabChange(a, li);
                    } else {
                        if (typeof window[o.onTabChange] === 'function') {
                            window[o.onTabChange](a, li);
                        } else {
                            result = eval('(function(){' + o.onTabChange + '})');
                            result.call(a, li);
                        }
                    }
                }
                e.preventDefault();
            });
        },
        _hidePanels: function () {
            this.element.find('.tab-panel').hide();
        },
        _showPanel: function (panel) {
            if (panel == undefined) {
                panel = this.element.find('.tabs-holder li.active a').attr('href');
            }
            $(panel).show();
        },
        openTab: function (tab) {
            var that = this, element = this.element, o = this.options;
            var target_panel = $(tab.children('a').attr('href'));
            if (target_panel.length === 0) {
                return false;
            }
            this._hidePanels();
            this._showPanel(target_panel);
            element.find('.tabs-holder > li').removeClass('active');
            tab.addClass('active');
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.grid', {
        version: '3.0.0',
        options: { equalHeight: true },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (o.equalHeight) {
                setTimeout(function () {
                    that._setEqualHeight();
                }, 50);
                $(window).on('resize', function () {
                    that._setEqualHeight();
                });
            }
            element.data('grid', this);
        },
        _setEqualHeight: function () {
            var that = this, element = this.element, o = this.options;
            var rows = element.find('.row');
            $.each(rows, function () {
                var row = $(this);
                var cells = row.children('.cell');
                var maxHeight = 0;
                cells.css('min-height', '0');
                $.each(cells, function () {
                    if ($(this).outerHeight() > maxHeight) {
                        maxHeight = $(this).outerHeight();
                    }
                });
                cells.css('min-height', maxHeight);
            });
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.hint', {
        version: '3.0.0',
        options: {
            hintPosition: 'auto',
            hintBackground: '#FFFCC0',
            hintColor: '#000000',
            hintMaxSize: 200,
            hintMode: 'default',
            hintShadow: false,
            hintBorder: true,
            hintTimeout: 0,
            hintTimeDelay: 0,
            _hint: undefined
        },
        _create: function () {
            var that = this, element = this.element;
            var o = this.options;
            this.element.on('mouseenter', function (e) {
                $('.hint, .hint2').remove();
                if (o.hintTimeDelay > 0) {
                    setTimeout(function () {
                        that.createHint();
                        o._hint.show();
                    }, o.hintTimeDelay);
                } else {
                    that.createHint();
                    o._hint.show();
                }
                e.preventDefault();
            });
            this.element.on('mouseleave', function (e) {
                if (o._hint.length) {
                    o._hint.hide().remove();
                }
                e.preventDefault();
            });
        },
        createHint: function () {
            var that = this, element = this.element, hint = element.data('hint').split('|'), o = this.options;
            var _hint;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (element[0].tagName === 'TD' || element[0].tagName === 'TH') {
                var wrp = $('<div/>').css('display', 'inline-block').html(element.html());
                element.html(wrp);
                element = wrp;
            }
            var hint_title = hint.length > 1 ? hint[0] : false;
            var hint_text = hint.length > 1 ? hint[1] : hint[0];
            _hint = $('<div/>').appendTo('body');
            if (o.hintMode === 2) {
                _hint.addClass('hint2');
            } else {
                _hint.addClass('hint');
            }
            if (!o.hintBorder) {
                _hint.addClass('no-border');
            }
            if (hint_title) {
                $('<div/>').addClass('hint-title').html(hint_title).appendTo(_hint);
            }
            $('<div/>').addClass('hint-text').html(hint_text).appendTo(_hint);
            _hint.addClass(o.position);
            if (o.hintShadow) {
                _hint.addClass('shadow');
            }
            if (o.hintBackground) {
                if (o.hintBackground.isColor()) {
                    _hint.css('background-color', o.hintBackground);
                } else {
                    _hint.addClass(o.hintBackground);
                }
            }
            if (o.hintColor) {
                if (o.hintColor.isColor()) {
                    _hint.css('color', o.hintColor);
                } else {
                    _hint.addClass(o.hintColor);
                }
            }
            if (o.hintMaxSize > 0) {
                _hint.css({ 'max-width': o.hintMaxSize });
            }
            if (o.hintPosition === 'top') {
                _hint.addClass('top');
                _hint.css({
                    top: element.offset().top - $(window).scrollTop() - _hint.outerHeight() - 20,
                    left: o.hintMode === 2 ? element.offset().left + element.outerWidth() / 2 - _hint.outerWidth() / 2 - $(window).scrollLeft() : element.offset().left - $(window).scrollLeft()
                });
            } else if (o.hintPosition === 'right') {
                _hint.addClass('right');
                _hint.css({
                    top: o.hintMode === 2 ? element.offset().top + element.outerHeight() / 2 - _hint.outerHeight() / 2 - $(window).scrollTop() - 10 : element.offset().top - 10 - $(window).scrollTop(),
                    left: element.offset().left + element.outerWidth() + 15 - $(window).scrollLeft()
                });
            } else if (o.hintPosition === 'left') {
                _hint.addClass('left');
                _hint.css({
                    top: o.hintMode === 2 ? element.offset().top + element.outerHeight() / 2 - _hint.outerHeight() / 2 - $(window).scrollTop() - 10 : element.offset().top - 10 - $(window).scrollTop(),
                    left: element.offset().left - _hint.outerWidth() - 10 - $(window).scrollLeft()
                });
            } else {
                _hint.addClass('bottom');
                _hint.css({
                    top: element.offset().top - $(window).scrollTop() + element.outerHeight(),
                    left: o.hintMode === 2 ? element.offset().left + element.outerWidth() / 2 - _hint.outerWidth() / 2 - $(window).scrollLeft() : element.offset().left - $(window).scrollLeft()
                });
            }
            o._hint = _hint;
            if (o.hintTimeout > 0) {
                setTimeout(function () {
                    if (o._hint.length) {
                        o._hint.hide().remove();
                    }
                }, o.hintTimeout);
            }
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.input', {
        version: '3.0.0',
        options: {
            showLabelOnValue: false,
            textAutoResize: false,
            textMaxHeight: 0
        },
        _create: function () {
            var element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (element.hasClass('file')) {
                this._createInputFile();
            }
            if (element.hasClass('text')) {
                this._createInputText();
            }
            if (element.hasClass('password')) {
                this._createInputText();
            }
            if (element.hasClass('select')) {
                this._createInputSelect();
            }
            if (element.hasClass('textarea')) {
                this._createInputTextarea();
            }
            if (element.hasClass('modern')) {
                this._createInputModern();
            }
            element.data('input', this);
        },
        _createInputModern: function () {
            var element = this.element;
            var input = element.find('input');
            var placeholder = element.find('.placeholder');
            if (input.val() !== '') {
                placeholder.css({ display: 'none' });
            }
            input.on('blur', function () {
                if (input.val() !== '') {
                    placeholder.css({ display: 'none' });
                } else {
                    placeholder.css({ display: 'block' });
                }
            });
            input.on('focus', function () {
                if (input.val() !== '') {
                    placeholder.css({ display: 'none' });
                } else {
                    placeholder.css({ display: 'block' });
                }
            });
        },
        _createInputFile: function () {
            var element = this.element;
            var wrapper, button, input;
            wrapper = $('<input type=\'text\' class=\'input-file-wrapper\' readonly style=\'z-index: 1; cursor: default;\'>');
            button = element.children('.button');
            input = element.children('input[type="file"]');
            input.css('z-index', 0);
            wrapper.insertAfter(input);
            input.attr('tabindex', '-1');
            button.attr('type', 'button');
            wrapper.attr('placeholder', input.attr('placeholder'));
            input.on('change', function () {
                var val = $(this).val();
                if (val !== '') {
                    wrapper.val(val.replace(/.+[\\\/]/, ''));
                    wrapper.attr('title', val.replace(/.+[\\\/]/, ''));
                }
            });
            element.on('click', '.button, .input-file-wrapper', function () {
                input.trigger('click');
            });
        },
        _createInputText: function () {
            var element = this.element;
            var helper_clear = element.find('.helper-button.clear');
            var helper_reveal = element.find('.helper-button.reveal');
            var input = element.find('input');
            var helpers = element.find('.helper-button');
            var buttons = element.find('.button');
            var states = element.find('.input-state-error, .input-state-warning, .input-state-info, .input-state-success, .input-state-required');
            var padding = 0;
            var rtl = element.attr('dir') === 'rtl' || element.parents('[dir=\'rtl\']').length > 0;
            $.each(buttons, function () {
                var b = $(this);
                padding += b.outerWidth();
            });
            if (rtl) {
                input.css({ 'padding-left': padding + 5 });
                states.css({ 'left': padding + 8 });
            } else {
                input.css({ 'padding-right': padding + 5 });
                states.css({ 'right': padding + 8 });
            }
            helpers.attr('tabindex', -1).attr('type', 'button');
            if (helper_clear) {
                helper_clear.on('click', function () {
                    input.val('').trigger('change').focus();
                });
            }
            if (helper_reveal && element.hasClass('password')) {
                helper_reveal.on('mousedown', function () {
                    input.attr('type', 'text');
                }).on('mouseup', function () {
                    input.attr('type', 'password').focus();
                });
            }
        },
        _createInputSelect: function () {
        },
        _createInputTextarea: function () {
            var element = this.element, that = this, o = this.options;
            var textarea = element.find('textarea');
            console.log(textarea);
            var fitTextarea = function () {
                textarea.css({
                    'resize': 'none',
                    'overflow-y': 'hidden'
                });
                textarea[0].style.height = 0;
                var adjust = textarea[0].scrollHeight;
                if (o.textMaxHeight > 0) {
                    if (o.textMaxHeight > adjust) {
                        textarea[0].style.height = adjust + 'px';
                    } else {
                        textarea[0].style.height = o.textMaxHeight + 'px';
                    }
                } else {
                    textarea[0].style.height = adjust + 'px';
                }
            };
            if (o.textAutoResize) {
                textarea.on('keyup', fitTextarea);
                textarea.on('keydown', fitTextarea);
                textarea.on('change', fitTextarea);
                textarea.on('focus', fitTextarea);
                textarea.on('cut', fitTextarea);
                textarea.on('paste', fitTextarea);
                textarea.on('drop', fitTextarea);
            }
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.keypad', {
        version: '3.0.0',
        options: {
            target: false,
            shuffle: false,
            length: false,
            keys: [
                '1',
                '2',
                '3',
                '4',
                '5',
                '6',
                '7',
                '8',
                '9',
                '0'
            ],
            size: 32,
            onKey: function (key) {
            },
            onChange: function (value) {
            }
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (typeof o.keys === 'string') {
                o.keys = o.keys.split(',');
            }
            if (o.target !== false) {
                o.target = $(o.target);
            }
            this._createKeypad();
            element.data('keypad', this);
        },
        _shuffleKeys: function () {
            var that = this, element = this.element, o = this.options;
            var keys = o.keys.slice(0);
            var keypad = this._keypad;
            var keys_length = keys.length + 2;
            if (o.shuffle) {
                keys = keys.shuffle();
            }
            keypad.html('').css({ width: keys_length / 4 * o.size + (keys_length / 4 + 1) * 2 + 2 });
            keys.map(function (i) {
                $('<div/>').addClass('key').html(i).data('key', i).appendTo(keypad);
            });
            $('<div/>').addClass('key').html('&larr;').data('key', '&larr;').appendTo(keypad);
            $('<div/>').addClass('key').html('&times;').data('key', '&times;').appendTo(keypad);
        },
        _createKeypad: function () {
            var that = this, element = this.element, o = this.options;
            var keypad;
            if (element.hasClass('input-control')) {
                keypad = $('<div/>').addClass('keypad keypad-dropdown').css({
                    position: 'absolute',
                    'z-index': 1000,
                    display: 'none'
                }).appendTo(element);
                o.target = element.find('input');
                element.on('click', function (e) {
                    if (keypad.css('display') === 'none') {
                        keypad.show();
                    } else {
                        keypad.hide();
                    }
                    var opened_pads = $('.keypad.keypad-dropdown');
                    $.each(opened_pads, function () {
                        if (!$(this).is(keypad)) {
                            $(this).hide();
                        }
                    });
                    e.stopPropagation();
                });
                $('html').on('click', function () {
                    $('.keypad.keypad-dropdown').hide();
                });
            } else {
                keypad = element;
                keypad.addClass('keypad');
            }
            if (o.target !== false) {
                $(o.target).attr('readonly', true);
            }
            if (keypad.parent().data('role') === 'dropdown') {
                keypad.parent().css({ top: '100%' });
            }
            this._keypad = keypad;
            this._shuffleKeys();
            keypad.on('click', '.key', function (e) {
                var key = $(this);
                var result;
                if (o.target) {
                    if (key.data('key') !== '&larr;' && key.data('key') !== '&times;') {
                        if (o.length && $(o.target).val().length === o.length) {
                            return false;
                        }
                        $(o.target).val($(o.target).val() + '' + key.data('key'));
                    } else {
                        if (key.data('key') === '&times;') {
                            $(o.target).val('');
                        }
                        if (key.data('key') === '&larr;') {
                            var val = $(o.target).val();
                            $(o.target).val(val.substring(0, val.length - 1));
                        }
                    }
                    o.target.trigger('change');
                }
                if (typeof o.onKey === 'function') {
                    o.onKey(key);
                } else {
                    if (typeof window[o.onKey] === 'function') {
                        window[o.onKey](key);
                    } else {
                        result = eval('(function(){' + o.onKey + '})');
                        result.call(key);
                    }
                }
                if (typeof o.onChange === 'function') {
                    o.onChange(o.target.val());
                } else {
                    if (typeof window[o.onChange] === 'function') {
                        window[o.onChange](o.target.val());
                    } else {
                        result = eval('(function(){' + o.onChange + '})');
                        result.call({ value: o.target.val() });
                    }
                }
                if (o.shuffle) {
                    that._shuffleKeys();
                }
                e.preventDefault();
                e.stopPropagation();
            });
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.listview', {
        version: '3.0.0',
        options: {
            onExpand: function (group) {
            },
            onCollapse: function (group) {
            },
            onActivate: function (list) {
            },
            onListClick: function (list) {
            }
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._initList();
            this._createEvents();
            element.data('listview', this);
        },
        _initList: function () {
            var that = this, element = this.element, o = this.options;
            var groups = element.find('.list-group');
            $.each(groups, function () {
                var group = $(this);
                if (group.hasClass('collapsed')) {
                    group.find('.list-group-content').hide();
                }
            });
        },
        _createEvents: function () {
            var that = this, element = this.element, o = this.options;
            element.on('click', '.list-group-toggle', function (e) {
                var toggle = $(this), parent = toggle.parent();
                var result;
                if (toggle.parent().hasClass('keep-open')) {
                    return;
                }
                parent.toggleClass('collapsed');
                if (!parent.hasClass('collapsed')) {
                    toggle.siblings('.list-group-content').slideDown('fast');
                    if (typeof o.onExpand === 'function') {
                        o.onExpand(parent);
                    } else {
                        if (typeof window[o.onExpand] === 'function') {
                            window[o.onExpand](parent);
                        } else {
                            result = eval('(function(){' + o.onExpand + '})');
                            result.call(parent);
                        }
                    }
                } else {
                    toggle.siblings('.list-group-content').slideUp('fast');
                    if (typeof o.onCollapse === 'function') {
                        o.onCollapse(parent);
                    } else {
                        if (typeof window[o.onCollapse] === 'function') {
                            window[o.onCollapse](parent);
                        } else {
                            result = eval('(function(){' + o.onCollapse + '})');
                            result.call(parent);
                        }
                    }
                }
                e.preventDefault();
                e.stopPropagation();
            });
            element.on('click', '.list', function (e) {
                var list = $(this);
                var result;
                element.find('.list').removeClass('active');
                list.addClass('active');
                if (typeof o.onActivate === 'function') {
                    o.onActivate(list);
                } else {
                    if (typeof window[o.onActivate] === 'function') {
                        window[o.onActivate](list);
                    } else {
                        result = eval('(function(){' + o.onActivate + '})');
                        result.call(list);
                    }
                }
                if (typeof o.onListClick === 'function') {
                    o.onListClick(list);
                } else {
                    if (typeof window[o.onListClick] === 'function') {
                        window[o.onListClick](list);
                    } else {
                        result = eval('(function(){' + o.onListClick + '})');
                        result.call(list);
                    }
                }
                e.preventDefault();
                e.stopPropagation();
            });
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    var _notify_container = false;
    var _notifies = [];
    var Notify = {
        _container: null,
        _notify: null,
        _timer: null,
        version: '3.0.0',
        options: {
            icon: '',
            caption: '',
            content: '',
            shadow: true,
            width: 'auto',
            height: 'auto',
            style: false,
            position: 'right',
            timeout: 3000,
            keepOpen: false,
            type: 'default'
        },
        init: function (options) {
            this.options = $.extend({}, this.options, options);
            this._build();
            return this;
        },
        _build: function () {
            var that = this, o = this.options;
            this._container = _notify_container || $('<div/>').addClass('notify-container').appendTo('body');
            _notify_container = this._container;
            if (o.content === '' || o.content === undefined) {
                return false;
            }
            this._notify = $('<div/>').addClass('notify');
            if (o.type !== 'default') {
                this._notify.addClass(o.type);
            }
            if (o.shadow) {
                this._notify.addClass('shadow');
            }
            if (o.style && o.style.background !== undefined) {
                this._notify.css('background-color', o.style.background);
            }
            if (o.style && o.style.color !== undefined) {
                this._notify.css('color', o.style.color);
            }
            if (o.icon !== '') {
                var icon = $(o.icon).addClass('notify-icon').appendTo(this._notify);
            }
            if (o.caption !== '' && o.caption !== undefined) {
                $('<div/>').addClass('notify-title').html(o.caption).appendTo(this._notify);
            }
            if (o.content !== '' && o.content !== undefined) {
                $('<div/>').addClass('notify-text').html(o.content).appendTo(this._notify);
            }
            var closer = $('<span/>').addClass('notify-closer').appendTo(this._notify);
            closer.on('click', function () {
                that.close(0);
            });
            if (o.width !== 'auto') {
                this._notify.css('min-width', o.width);
            }
            if (o.height !== 'auto') {
                this._notify.css('min-height', o.height);
            }
            this._notify.hide().appendTo(this._container).fadeIn('slow');
            _notifies.push(this._notify);
            if (!o.keepOpen) {
                this.close(o.timeout);
            }
        },
        close: function (timeout) {
            var self = this;
            if (timeout === undefined) {
                return this._hide();
            }
            setTimeout(function () {
                self._hide();
            }, timeout);
            return this;
        },
        _hide: function () {
            var that = this;
            if (this._notify !== undefined) {
                this._notify.fadeOut('slow', function () {
                    $(this).remove();
                    _notifies.splice(_notifies.indexOf(that._notify), 1);
                });
                return this;
            } else {
                return false;
            }
        },
        closeAll: function () {
            _notifies.forEach(function (notEntry) {
                notEntry.hide('slow', function () {
                    notEntry.remove();
                    _notifies.splice(_notifies.indexOf(notEntry), 1);
                });
            });
            return this;
        }
    };
    $.Notify = function (options) {
        return Object.create(Notify).init(options);
    };
    $.Notify.show = function (message, title, icon) {
        return $.Notify({
            content: message,
            caption: title,
            icon: icon
        });
    };
    $.widget('metro.panel', {
        version: '3.0.0',
        options: {
            onExpand: function (panel) {
            },
            onCollapse: function (panel) {
            }
        },
        _create: function () {
            var element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (!element.hasClass('collapsible')) {
                element.addClass('collapsible');
            }
            if (element.hasClass('collapsible')) {
                var toggle = element.children('.heading');
                var content = element.children('.content');
                toggle.on('click', function () {
                    var result;
                    if (element.hasClass('collapsed')) {
                        content.slideDown('fast', function () {
                            element.removeClass('collapsed');
                            if (typeof o.onExpand === 'function') {
                                o.onExpand(element);
                            } else {
                                if (typeof window[o.onExpand] === 'function') {
                                    window[o.onExpand](element);
                                } else {
                                    result = eval('(function(){' + o.onExpand + '})');
                                    result.call(element);
                                }
                            }
                        });
                    } else {
                        content.slideUp('fast', function () {
                            element.addClass('collapsed');
                            if (typeof o.onCollapse === 'function') {
                                o.onCollapse(element);
                            } else {
                                if (typeof window[o.onCollapse] === 'function') {
                                    window[o.onCollapse](element);
                                } else {
                                    result = eval('(function(){' + o.onCollapse + '})');
                                    result.call(element);
                                }
                            }
                        });
                    }
                });
            }
            element.data('panel', this);
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.widget', {
        version: '1.0.0',
        options: { someValue: null },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            this._setOptionsFromDOM();
            element.data('widget', this);
        },
        _setOptionsFromDOM: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.popover', {
        version: '3.0.0',
        options: {
            popoverText: '',
            popoverTimeout: 3000,
            popoverPosition: 'top',
            popoverBackground: 'bg-cyan',
            popoverColor: 'fg-white',
            popoverMode: 'none',
            popoverShadow: true,
            onPopup: function (popover) {
            }
        },
        popover: {},
        _create: function () {
            var element = this.element;
            this.createPopover();
            element.data('popover', this);
        },
        createPopover: function () {
            var that = this, element, o = this.options;
            element = this.element;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            var popover, content_container, marker_class;
            popover = $('<div/>').addClass('popover').appendTo('body').hide();
            $('<div/>').appendTo(popover);
            if (o.popoverShadow) {
                popover.addClass('popover-shadow');
            }
            if (o.popoverBackground) {
                if (o.popoverBackground[0] === '#') {
                    popover.css('background-color', o.popoverBackground);
                } else {
                    popover.addClass(o.popoverBackground);
                }
            }
            if (o.popoverColor) {
                if (o.popoverColor[0] === '#') {
                    popover.css('color', o.popoverColor);
                } else {
                    popover.addClass(o.popoverColor);
                }
            }
            switch (o.popoverPosition) {
            case 'left':
                marker_class = 'marker-on-right';
                break;
            case 'right':
                marker_class = 'marker-on-left';
                break;
            case 'bottom':
                marker_class = 'marker-on-top';
                break;
            default:
                marker_class = 'marker-on-bottom';
            }
            popover.css({ position: 'fixed' });
            popover.addClass(marker_class);
            this.popover = popover;
            this.setText(o.popoverText);
            element.on(o.popoverMode, function (e) {
                if (!popover.data('visible')) {
                    that.show();
                }
            });
            $(window).scroll(function () {
                if (that.popover.data('visible')) {
                    that.setPosition();
                }
            });
        },
        setPosition: function () {
            var o = this.options, popover = this.popover, element = this.element;
            if (o.popoverPosition === 'top') {
                popover.css({
                    top: element.offset().top - $(window).scrollTop() - popover.outerHeight() - 10,
                    left: element.offset().left + element.outerWidth() / 2 - popover.outerWidth() / 2 - $(window).scrollLeft()
                });
            } else if (o.popoverPosition === 'bottom') {
                popover.css({
                    top: element.offset().top - $(window).scrollTop() + element.outerHeight() + 10,
                    left: element.offset().left + element.outerWidth() / 2 - popover.outerWidth() / 2 - $(window).scrollLeft()
                });
            } else if (o.popoverPosition === 'right') {
                popover.css({
                    top: element.offset().top + element.outerHeight() / 2 - popover.outerHeight() / 2 - $(window).scrollTop(),
                    left: element.offset().left + element.outerWidth() - $(window).scrollLeft() + 10
                });
            } else if (o.popoverPosition === 'left') {
                popover.css({
                    top: element.offset().top + element.outerHeight() / 2 - popover.outerHeight() / 2 - $(window).scrollTop(),
                    left: element.offset().left - popover.outerWidth() - $(window).scrollLeft() - 10
                });
            }
            return this;
        },
        setText: function (text) {
            this.popover.children('div').html(text);
        },
        show: function () {
            var o = this.options, popover = this.popover;
            this.setPosition();
            popover.fadeIn(function () {
                popover.data('visible', true);
                if (typeof o.onPopup === 'function') {
                    o.onPopup(popover);
                } else {
                    if (typeof window[o.onPopup] === 'function') {
                        window[o.onPopup](popover);
                    } else {
                        var result = eval('(function(){' + o.onPopup + '})');
                        result.call(popover);
                    }
                }
                setTimeout(function () {
                    popover.fadeOut(function () {
                        popover.data('visible', false);
                    });
                }, o.popoverTimeout);
            });
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.preloader', {
        version: '3.0.0',
        options: {
            type: 'ring',
            style: 'light'
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._createStructure();
            element.data('preloader', this);
        },
        _createRing: function () {
            var that = this, element = this.element, o = this.options;
            var i, wrap, circle;
            for (i = 0; i < 5; i++) {
                wrap = $('<div/>').addClass('wrap').appendTo(element);
                circle = $('<div/>').addClass('circle').appendTo(wrap);
            }
        },
        _createMetro: function () {
            var that = this, element = this.element, o = this.options;
            var i, circle;
            for (i = 0; i < 5; i++) {
                circle = $('<div/>').addClass('circle').appendTo(element);
            }
        },
        _createSquare: function () {
            var that = this, element = this.element, o = this.options;
            var i, square;
            for (i = 0; i < 4; i++) {
                square = $('<div/>').addClass('square').appendTo(element);
            }
        },
        _createCycle: function () {
            var that = this, element = this.element, o = this.options;
            var i, cycle;
            cycle = $('<div/>').addClass('cycle').appendTo(element);
        },
        _createStructure: function () {
            var that = this, element = this.element, o = this.options;
            element.addClass('preloader-' + o.type);
            if (o.style !== 'light') {
                element.addClass(o.style + '-style');
            }
            element.html('');
            switch (o.type) {
            case 'ring':
                this._createRing();
                break;
            case 'metro':
                this._createMetro();
                break;
            case 'square':
                this._createSquare();
                break;
            case 'cycle':
                this._createCycle();
                break;
            }
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.presenter', {
        version: '3.0.0',
        options: {
            height: '200',
            width: '100%',
            effect: 'random',
            duration: 1000,
            timeout: 2000,
            sceneTimeout: 2000,
            easing: 'swing'
        },
        _acts: undefined,
        _currentAct: 0,
        _actDone: true,
        _interval: undefined,
        _effects: [
            'top',
            'bottom',
            'left',
            'right'
        ],
        _actor_positions: [],
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._createPresenter();
            this._showScene();
            element.data('presenter', this);
        },
        _createPresenter: function () {
            var that = this, element = this.element, o = this.options;
            var acts = element.find('.act');
            acts.hide();
            this._acts = acts;
            element.css({
                height: o.height,
                width: o.width
            });
        },
        _showScene: function () {
            var that = this, element = this.element, o = this.options;
            this._interval = setInterval(function () {
                if (that._actDone) {
                    that._currentAct++;
                    if (that._currentAct == that._acts.length) {
                        that._currentAct = 0;
                    }
                    that._showAct();
                }
            }, 500);
        },
        _closeAct: function () {
            var that = this, element = this.element, o = this.options;
            var index = this._currentAct;
            setTimeout(function () {
                if (that._acts[index] !== undefined)
                    $(that._acts[index]).fadeOut(1000, function () {
                        that._actDone = true;
                    });
            }, o.sceneTimeout);
        },
        _showAct: function () {
            var that = this, element = this.element, o = this.options;
            var act = $(this._acts[this._currentAct]);
            var actors = act.find('.actor');
            var i;
            this._actDone = false;
            act.fadeIn(1000);
            actors.css({
                opacity: 0,
                position: 'absolute',
                display: 'none'
            });
            i = 0;
            $.each(actors, function () {
                var actor = $(this), pos = {
                        top: actor.data('position').split(',')[0],
                        left: actor.data('position').split(',')[1]
                    };
                var actor_effect, actor_duration, actor_timeout, actor_easing;
                actor_effect = actor.data('effect') !== undefined ? actor.data('effect') : o.effect;
                if (actor_effect === 'random') {
                    actor_effect = that._effects[Math.floor(Math.random() * that._effects.length)];
                }
                actor_duration = actor.data('duration') !== undefined ? actor.data('duration') : o.duration;
                actor_timeout = actor.data('timeout') !== undefined ? actor.data('timeout') : o.timeout;
                actor_easing = actor.data('easing') !== undefined ? actor.data('easing') : o.easing;
                if (actor_effect === 'top') {
                    setTimeout(function () {
                        actor.css({
                            top: -element.height(),
                            left: pos.left,
                            display: 'block'
                        }).animate({
                            top: pos.top,
                            left: pos.left,
                            opacity: 1
                        }, actor_duration, actor_easing, function () {
                            if (actor[0] == actors[actors.length - 1])
                                that._closeAct();
                        });
                    }, i * actor_timeout);
                } else if (actor_effect === 'bottom') {
                    setTimeout(function () {
                        actor.css({
                            top: element.height(),
                            left: pos.left,
                            display: 'block'
                        }).animate({
                            top: pos.top,
                            left: pos.left,
                            opacity: 1
                        }, actor_duration, actor_easing, function () {
                            if (actor[0] == actors[actors.length - 1])
                                that._closeAct();
                        });
                    }, i * actor_timeout);
                } else if (actor_effect === 'left') {
                    setTimeout(function () {
                        actor.css({
                            left: -element.width(),
                            top: pos.top,
                            display: 'block'
                        }).animate({
                            top: pos.top,
                            left: pos.left,
                            opacity: 1
                        }, actor_duration, actor_easing, function () {
                            if (actor[0] == actors[actors.length - 1])
                                that._closeAct();
                        });
                    }, i * actor_timeout);
                } else if (actor_effect === 'right') {
                    setTimeout(function () {
                        actor.css({
                            left: element.width(),
                            top: pos.top,
                            display: 'block'
                        }).animate({
                            top: pos.top,
                            left: pos.left,
                            opacity: 1
                        }, actor_duration, actor_easing, function () {
                            if (actor[0] == actors[actors.length - 1])
                                that._closeAct();
                        });
                    }, i * actor_timeout);
                } else {
                    setTimeout(function () {
                        actor.css({
                            top: pos.top,
                            left: pos.left,
                            display: 'block'
                        }).animate({
                            top: pos.top,
                            left: pos.left,
                            opacity: 1
                        }, actor_duration, 'swing', function () {
                            if (actor[0] == actors[actors.length - 1])
                                that._closeAct();
                        });
                    }, i * actor_timeout);
                }
                i++;
            });
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.progress', {
        version: '3.0.0',
        options: {
            color: 'default',
            colors: false,
            value: 0,
            animate: false,
            onProgress: function (value) {
            }
        },
        colorsDim: {},
        _create: function () {
            var that = this, element = this.element, o = this.options;
            var bar = element.children('.bar:last-child');
            if (!element.hasClass('progress')) {
                element.addClass('progress');
            }
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (bar.length === 0) {
                bar = $('<div/>').addClass('bar').appendTo(element);
            }
            if (o.colors) {
                var p = 0;
                $.each(o.colors, function (c, v) {
                    that.colorsDim[c] = [
                        p,
                        v
                    ];
                    p = v + 1;
                });
            }
            this.set(o.value);
            this.color(o.color);
            element.data('progress', this);
        },
        color: function (value) {
            var element = this.element, o = this.options;
            var bar = element.children('.bar:last-child');
            var isOk = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(value);
            if (isOk) {
                bar.css({ 'background-color': value });
            } else {
                bar.removeClass(function (index, css) {
                    return (css.match(/(^|\s)bg-\S+/g) || []).join(' ');
                }).addClass(value);
            }
            o.color = value;
        },
        set: function (value) {
            if (value !== undefined) {
                var element = this.element, o = this.options, colors = this.colorsDim;
                var bar = element.children('.bar:last-child');
                var that = this, gradient = [];
                if (parseInt(value) < 0) {
                    return;
                }
                if (o.colors) {
                    $.each(colors, function (c, v) {
                        if (value >= v[0] && value <= v[1]) {
                            that.color(c);
                            return true;
                        }
                    });
                }
                o.value = value;
                if (o.animate !== false) {
                    var ani_speed = isNaN(o.animate) ? 500 : o.animate;
                    bar.animate({ width: o.value + '%' }, ani_speed, function () {
                        if (typeof o.onProgress === 'function') {
                            o.onProgress(value);
                        } else {
                            if (typeof window[o.onProgress] === 'function') {
                                window[o.onProgress](value);
                            } else {
                                var result = eval('(function(){' + o.onProgress + '})');
                                result.call(value);
                            }
                        }
                    });
                } else {
                    bar.css({ width: o.value + '%' });
                    if (typeof o.onProgress === 'function') {
                        o.onProgress(value);
                    } else {
                        if (typeof window[o.onProgress] === 'function') {
                            window[o.onProgress](value);
                        } else {
                            var result = eval('(function(){' + o.onProgress + '})');
                            result.call(value);
                        }
                    }
                }
            } else {
                return this.options.value;
            }
        },
        value: function (value) {
            return this.set(value);
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.rating', {
        version: '3.0.0',
        options: {
            stars: 5,
            value: 0,
            half: true,
            static: false,
            showScore: true,
            scoreTitle: 'Current: ',
            size: 'default',
            colorRate: false,
            onRate: function (v, s, w) {
                return true;
            },
            onRated: function (v, s, w) {
            }
        },
        _value: 0,
        _values: [],
        _create: function () {
            var element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._value = parseFloat(o.value);
            this._values[0] = Math.ceil(o.stars * 1 / 3);
            this._values[1] = Math.ceil(o.stars * 2 / 3);
            this._values[2] = o.stars;
            this._createRating();
            this._createEvents();
            this._setValue(this._value);
            this._setScore(this._value);
            element.data('rating', this);
        },
        _createRating: function () {
            var element = this.element, o = this.options;
            var i, star, stars, score;
            if (!element.hasClass('rating')) {
                element.addClass('rating');
            }
            switch (o.size) {
            case 'small':
                element.addClass('small');
                break;
            case 'large':
                element.addClass('large');
                break;
            default:
                break;
            }
            if (o.static) {
                element.addClass('static');
            }
            for (i = 0; i < o.stars; i++) {
                star = $('<span/>').addClass('star').appendTo(element).data('star-value', i + 1);
            }
            if (o.showScore) {
                score = $('<span/>').addClass('score').appendTo(element);
            }
        },
        _createEvents: function () {
            var that = this, element = this.element, o = this.options;
            var stars;
            stars = element.find('.star');
            stars.on('click', function (e) {
                if (o.static || element.hasClass('static') || element.data('static')) {
                    return false;
                }
                var result, value = $(this).data('star-value'), star = this, rating = that;
                if (typeof o.onRate === 'function') {
                    if (!o.onRate(value, star, rating)) {
                        return false;
                    }
                } else {
                    if (typeof window[o.onRate] === 'function') {
                        if (!window[o.onRate](value, star, rating)) {
                            return false;
                        }
                    } else {
                        result = eval('(function(){' + o.onRate + '})');
                        if (!result.call(value, star, rating)) {
                            return false;
                        }
                    }
                }
                if (typeof o.onRated === 'function') {
                    o.onRated(value, star, rating);
                } else {
                    if (typeof window[o.onRated] === 'function') {
                        window[o.onRated](value, star, rating);
                    } else {
                        result = eval('(function(){' + o.onRated + '})');
                        result.call(value, star, rating);
                    }
                }
                that._value = $(this).data('star-value');
                that._setValue();
                that._setScore();
                e.preventDefault();
                e.stopPropagation();
            });
        },
        _setValue: function () {
            var stars, o = this.options, element = this.element;
            if (o.stars) {
                stars = element.find('.star').removeClass('on half');
                var index = Math.floor(this._value) - 1;
                var half = (this._value - Math.floor(this._value)) * 10 > 0;
                $(stars[index]).addClass('on');
                $(stars[index]).prevAll().addClass('on');
                if (half) {
                    $(stars[index]).next().addClass('on half');
                }
            }
            if (o.colorRate) {
                element.removeClass('poor regular good');
                if (this._value <= this._values[0]) {
                    element.addClass('poor');
                } else if (this._value > this._values[0] && this._value <= this._values[1]) {
                    element.addClass('regular');
                } else if (this._value > this._values[1]) {
                    element.addClass('good');
                }
            }
        },
        _setScore: function () {
            var value = this._value, element = this.element, o = this.options;
            if (value !== undefined) {
                element.find('.score').html(o.scoreTitle + value);
            }
        },
        value: function (value) {
            if (value !== undefined) {
                this._value = value;
                this._setValue();
                this._setScore();
            } else {
                return this._value;
            }
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.select', {
        version: '3.0.0',
        options: {},
        _create: function () {
            var that = this, element = this.element, o = this.options;
            var func_options = [
                'templateResult',
                'templateSelection',
                'matcher',
                'initSelection',
                'query'
            ];
            $.each(element.data(), function (key, value) {
                try {
                    o[key] = $.parseJSON(value);
                } catch (e) {
                    o[key] = value;
                }
            });
            func_options.map(function (func, index) {
                if (o[func] !== undefined) {
                    o[func] = window[o[func]];
                }
            });
            if (o.dropdownParent !== undefined) {
                o.dropdownParent = $(o.dropdownParent);
            }
            if ($().select2) {
                try {
                    element.find('select').select2(o);
                } catch (e) {
                }
            } else {
                console.log('You are trying to use support for Select2, but the plugin is not found!');
            }
            element.data('select', this);
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.slider', {
        version: '3.0.14',
        options: {
            position: 0,
            buffer: 0,
            accuracy: 0,
            color: 'default',
            completeColor: 'default',
            bufferColor: 'default',
            markerColor: 'default',
            colors: false,
            showHint: false,
            permanentHint: false,
            hintPosition: 'top',
            vertical: false,
            min: 0,
            max: 100,
            animate: false,
            minValue: 0,
            maxValue: 100,
            currValue: 0,
            returnType: 'value',
            target: false,
            onStartChange: function () {
            },
            onChange: function (value, slider) {
            },
            onChanged: function (value, slider) {
            },
            onBufferChange: function (value, slider) {
            },
            _slider: {
                vertical: false,
                offset: 0,
                length: 0,
                marker: 0,
                ppp: 0,
                start: 0,
                stop: 0
            }
        },
        _create: function () {
            var that = this, element = this.element;
            var o = this.options, s = o._slider;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            element.data('internal_id', uniqueId());
            o.accuracy = o.accuracy < 0 ? 0 : o.accuracy;
            o.min = o.min < 0 ? 0 : o.min;
            o.min = o.min > o.max ? o.max : o.min;
            o.max = o.max > 100 ? 100 : o.max;
            o.max = o.max < o.min ? o.min : o.max;
            o.position = this._correctValue(element.data('position') > o.min ? element.data('position') > o.max ? o.max : element.data('position') : o.min);
            o.buffer = this._correctValue(element.data('buffer') > o.min ? element.data('buffer') > o.max ? o.max : element.data('buffer') : o.min);
            o.colors = o.colors ? o.colors.split(',') : false;
            s.vertical = o.vertical;
            if (o.vertical && !element.hasClass('vertical')) {
                element.addClass('vertical');
            }
            if (o.permanentHint && !element.hasClass('permanent-hint')) {
                element.addClass('permanent-hint');
            }
            if (!o.vertical && o.hintPosition === 'bottom') {
                element.addClass('hint-bottom');
            }
            if (o.vertical && o.hintPosition === 'left') {
                element.addClass('hint-left');
            }
            this._createSlider();
            this._initPoints();
            this._placeMarker(o.position);
            this._showBuffer(o.buffer);
            var event_down = isTouchDevice() ? 'touchstart' : 'mousedown';
            if (o.target && $(o.target)[0].tagName == 'INPUT') {
                $(o.target).on('keyup', function () {
                    var input_value = this.value !== undefined ? this.value : 0;
                    var new_value = Math.min(input_value, o.maxValue);
                    that._placeMarker(that._realValueToValue(new_value));
                });
            }
            element.children('.marker').on(event_down, function (e) {
                that._startMoveMarker(e);
                if (typeof o.onStartChange === 'function') {
                    o.onStartChange();
                } else {
                    if (typeof window[o.onStartChange] === 'function') {
                        window[o.onStartChange]();
                    } else {
                        var result = eval('(function(){' + o.onStartChange + '})');
                        result.call();
                    }
                }
                e.preventDefault();
                e.stopPropagation();
            });
            element.on(event_down, function (e) {
                e.preventDefault();
                that._startMoveMarker(e);
            });
            element.data('slider', this);
        },
        _startMoveMarker: function (e) {
            var element = this.element, o = this.options, that = this, hint = element.children('.slider-hint');
            var returnedValue;
            var event_move = isTouchDevice() ? 'touchmove' : 'mousemove';
            var event_up = isTouchDevice() ? 'touchend' : 'mouseup mouseleave';
            $(document).on(event_move, function (event) {
                that._movingMarker(event);
                if (!element.hasClass('permanent-hint')) {
                    hint.css('display', 'block');
                }
            });
            $(document).on(event_up, function () {
                $(document).off(event_move);
                $(document).off(event_up);
                element.data('value', o.position);
                element.trigger('changed', o.position);
                element.trigger('change', o.position);
                returnedValue = o.returnType === 'value' ? that._valueToRealValue(o.position) : o.position;
                if (!element.hasClass('permanent-hint')) {
                    hint.css('display', 'none');
                }
                if (typeof o.onChanged === 'function') {
                    o.onChanged(returnedValue, element);
                } else {
                    if (typeof window[o.onChanged] === 'function') {
                        window[o.onChanged](returnedValue, element);
                    } else {
                        var result = eval('(function(){' + o.onChanged + '})');
                        result.call(returnedValue, element);
                    }
                }
            });
            this._initPoints();
            this._movingMarker(e);
        },
        _movingMarker: function (ev) {
            var element = this.element, o = this.options;
            var cursorPos, percents, valuePix, vertical = o._slider.vertical, sliderOffset = o._slider.offset, sliderStart = o._slider.start, sliderEnd = o._slider.stop, sliderLength = o._slider.length, markerSize = o._slider.marker;
            var event = !isTouchDevice() ? ev.originalEvent : ev.originalEvent.touches[0];
            if (vertical) {
                cursorPos = event.pageY - sliderOffset;
            } else {
                cursorPos = event.pageX - sliderOffset;
            }
            if (cursorPos < sliderStart) {
                cursorPos = sliderStart;
            } else if (cursorPos > sliderEnd) {
                cursorPos = sliderEnd;
            }
            if (vertical) {
                valuePix = sliderLength - cursorPos - markerSize / 2;
            } else {
                valuePix = cursorPos - markerSize / 2;
            }
            percents = this._pixToPerc(valuePix);
            this._placeMarker(percents);
            o.currValue = this._valueToRealValue(percents);
            o.position = percents;
            var returnedValue = o.returnType === 'value' ? this._valueToRealValue(o.position) : o.position;
            if (o.target) {
                if ($(o.target)[0].tagName == 'INPUT') {
                    $(o.target).val(returnedValue);
                } else {
                    $(o.target).html(returnedValue);
                }
                $(o.target).trigger('change', returnedValue);
            }
            if (typeof o.onChange === 'function') {
                o.onChange(returnedValue, element);
            } else {
                if (typeof window[o.onChange] === 'function') {
                    window[o.onChange](returnedValue, element);
                } else {
                    var result = eval('(function(){' + o.onChange + '})');
                    result.call(returnedValue, element);
                }
            }
        },
        _placeMarker: function (value) {
            var size, size2, o = this.options, colorParts, colorIndex = 0, colorDelta, element = this.element, marker = this.element.children('.marker'), complete = this.element.children('.complete'), hint = this.element.children('.slider-hint'), hintValue, oldPos = this._percToPix(o.position);
            colorParts = o.colors.length;
            colorDelta = o._slider.length / colorParts;
            if (o._slider.vertical) {
                var oldSize = this._percToPix(o.position) + o._slider.marker, oldSize2 = o._slider.length - oldSize;
                size = this._percToPix(value) + o._slider.marker / 2;
                size2 = o._slider.length - size;
                this._animate(marker.css('top', oldSize2), { top: size2 });
                this._animate(complete.css('height', oldSize), { height: size });
                if (colorParts) {
                    colorIndex = Math.round(size / colorDelta) - 1;
                    complete.css('background-color', o.colors[colorIndex < 0 ? 0 : colorIndex]);
                }
                if (o.showHint) {
                    hintValue = this._valueToRealValue(value);
                    hint.html(hintValue).css('top', size2 - marker.height() / 2 - hint.height() / 4);
                }
            } else {
                size = this._percToPix(value);
                this._animate(marker.css('left', oldPos), { left: size });
                this._animate(complete.css('width', oldPos), { width: size });
                if (colorParts) {
                    colorIndex = Math.round(size / colorDelta) - 1;
                    complete.css('background-color', o.colors[colorIndex < 0 ? 0 : colorIndex]);
                }
                if (o.showHint) {
                    hintValue = this._valueToRealValue(value);
                    hint.html(hintValue).css('left', size - marker.width() / 2);
                }
            }
        },
        _valueToRealValue: function (value) {
            var o = this.options;
            var real_value;
            var percent_value = (o.maxValue - o.minValue) / 100;
            real_value = value * percent_value + o.minValue;
            return Math.round(real_value);
        },
        _realValueToValue: function (value) {
            var o = this.options, val_val;
            var percent_value = (o.maxValue - o.minValue) / 100;
            val_val = value / percent_value + o.minValue;
            return Math.round(val_val);
        },
        _animate: function (obj, val) {
            var o = this.options;
            if (o.animate) {
                obj.stop(true).animate(val);
            } else {
                obj.css(val);
            }
        },
        _pixToPerc: function (valuePix) {
            var valuePerc;
            valuePerc = (valuePix < 0 ? 0 : valuePix) * this.options._slider.ppp;
            return Math.round(this._correctValue(valuePerc));
        },
        _percToPix: function (value) {
            if (this.options._slider.ppp === 0) {
                return 0;
            }
            return Math.round(value / this.options._slider.ppp);
        },
        _correctValue: function (value) {
            var o = this.options;
            var accuracy = o.accuracy;
            var max = o.max;
            var min = o.min;
            if (accuracy === 0) {
                return value;
            }
            if (value === max) {
                return max;
            }
            if (value === min) {
                return min;
            }
            value = Math.floor(value / accuracy) * accuracy + Math.round(value % accuracy / accuracy) * accuracy;
            if (value > max) {
                return max;
            }
            if (value < min) {
                return min;
            }
            return value;
        },
        _initPoints: function () {
            var o = this.options, s = o._slider, element = this.element;
            if (s.vertical) {
                s.offset = element.offset().top;
                s.length = element.height();
                s.marker = element.children('.marker').height();
            } else {
                s.offset = element.offset().left;
                s.length = element.width();
                s.marker = element.children('.marker').width();
            }
            s.ppp = o.max / (s.length - s.marker);
            s.start = s.marker / 2;
            s.stop = s.length - s.marker / 2;
        },
        _createSlider: function () {
            var element = this.element, o = this.options, complete, marker, hint, buffer, back;
            element.html('');
            back = $('<div/>').addClass('slider-backside').appendTo(element);
            complete = $('<div/>').addClass('complete').appendTo(element);
            buffer = $('<div/>').addClass('buffer').appendTo(element);
            marker = $('<a/>').addClass('marker').appendTo(element);
            if (o.showHint) {
                hint = $('<span/>').addClass('slider-hint').appendTo(element);
            }
            if (o.color !== 'default') {
                if (o.color.isColor()) {
                    back.css('background-color', o.color);
                } else {
                    back.addClass(o.color);
                }
            }
            if (o.completeColor !== 'default') {
                if (o.completeColor.isColor()) {
                    complete.css('background-color', o.completeColor);
                } else {
                    complete.addClass(o.completeColor);
                }
            }
            if (o.bufferColor !== 'default') {
                if (o.bufferColor.isColor()) {
                    buffer.css('background-color', o.bufferColor);
                } else {
                    buffer.addClass(o.bufferColor);
                }
            }
            if (o.markerColor !== 'default') {
                if (o.markerColor.isColor()) {
                    marker.css('background-color', o.markerColor);
                } else {
                    marker.addClass(o.markerColor);
                }
            }
        },
        value: function (value) {
            var element = this.element, o = this.options, returnedValue;
            if (typeof value !== 'undefined') {
                value = value > o.max ? o.max : value;
                value = value < o.min ? o.min : value;
                this._placeMarker(parseInt(value));
                o.position = parseInt(value);
                returnedValue = o.returnType === 'value' ? this._valueToRealValue(o.position) : o.position;
                if (o.target) {
                    if ($(o.target)[0].tagName == 'INPUT') {
                        $(o.target).val(returnedValue);
                    } else {
                        $(o.target).html(returnedValue);
                    }
                    $(o.target).trigger('change', returnedValue);
                }
                if (typeof o.onChange === 'function') {
                    o.onChange(returnedValue, element);
                } else {
                    if (typeof window[o.onChange] === 'function') {
                        window[o.onChange](returnedValue, element);
                    } else {
                        var result = eval('(function(){' + o.onChange + '})');
                        result.call(returnedValue, element);
                    }
                }
                return this;
            } else {
                returnedValue = o.returnType === 'value' ? this._valueToRealValue(o.position) : o.position;
                return returnedValue;
            }
        },
        _showBuffer: function (value) {
            var size, oldSize, o = this.options, element = this.element, buffer = this.element.children('.buffer');
            oldSize = o.buffer;
            size = value == 100 ? 99.9 : value;
            if (o._slider.vertical) {
                this._animate(buffer.css('height', oldSize + '%'), { height: size + '%' });
            } else {
                this._animate(buffer.css('width', oldSize + '%'), { width: size + '%' });
            }
        },
        buffer: function (value) {
            var element = this.element, o = this.options, returnedValue;
            if (typeof value !== 'undefined') {
                value = value > 100 ? 100 : value;
                value = value < 0 ? 0 : value;
                this._showBuffer(parseInt(value));
                o.buffer = parseInt(value);
                returnedValue = o.buffer;
                if (typeof o.onBufferChange === 'function') {
                    o.onBufferChange(returnedValue, element);
                } else {
                    if (typeof window[o.onBufferChange] === 'function') {
                        window[o.onBufferChange](returnedValue, element);
                    } else {
                        var result = eval('(function(){' + o.onBufferChange + '})');
                        result.call(returnedValue, element);
                    }
                }
                return this;
            } else {
                returnedValue = o.buffer;
                return returnedValue;
            }
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.stepper', {
        version: '3.0.0',
        options: {
            steps: 3,
            start: 1,
            type: 'default',
            clickable: true,
            onStep: function (index, step) {
            },
            onStepClick: function (index, step) {
            }
        },
        _create: function () {
            var element = this.element, o = this.options, element_id = element.attr('id');
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (!element.hasClass('stepper')) {
                element.addClass('stepper');
            }
            if (element_id === undefined) {
                element_id = window.uniqueId(this.widgetName + '_');
                element.attr('id', element_id);
            }
            this._createStepper();
            if (o.clickable) {
                this._createEvents();
            }
            this._positioningSteps();
            this._stepTo(o.start);
            element.data('stepper', this);
        },
        _createEvents: function () {
            var that = this, element = this.element, o = this.options;
            element.on('click', 'li', function (e) {
                var step = $(this).data('step');
                if (typeof o.onStepClick === 'function') {
                    o.onStepClick(step - 1, step);
                } else {
                    if (typeof window[o.onStepClick] === 'function') {
                        window[o.onStepClick](step - 1, step);
                    } else {
                        var result = eval('(function(){' + o.onStepClick + '})');
                        result.call(step - 1, step);
                    }
                }
                element.trigger('stepclick', step);
            });
        },
        _createStepper: function () {
            var element = this.element, o = this.options;
            var i, ul, li;
            ul = $('<ul/>');
            switch (o.type) {
            case 'diamond':
                element.addClass('diamond');
                break;
            case 'cycle':
                element.addClass('cycle');
                break;
            }
            for (i = 0; i < o.steps; i++) {
                li = $('<li/>').data('step', i + 1).appendTo(ul);
            }
            ul.appendTo(element);
        },
        _positioningSteps: function () {
            var that = this, element = this.element, o = this.options, steps = element.find('li'), element_width = element.width(), steps_length = steps.length - 1, step_width = $(steps[0]).width();
            $.each(steps, function (i, step) {
                var left = i === 0 ? 0 : (element_width - step_width) / steps_length * i;
                console.log(element_width);
                $(step).animate({ left: left });
            });
        },
        _stepTo: function (step) {
            var element = this.element, o = this.options;
            var steps = element.find('li');
            steps.removeClass('current').removeClass('complete');
            $.each(steps, function (i, s) {
                if (i < step - 1) {
                    $(s).addClass('complete');
                }
                if (i === step - 1) {
                    $(s).addClass('current');
                    if (typeof o.onStep === 'function') {
                        o.onStep(i + 1, s);
                    } else {
                        if (typeof window[o.onStep] === 'function') {
                            window[o.onStep](i + 1, s);
                        } else {
                            var result = eval('(function(){' + o.onStep + '})');
                            result.call(i + 1, s);
                        }
                    }
                }
            });
        },
        stepTo: function (step) {
            this._stepTo(step);
        },
        first: function () {
            var o = this.options;
            o.start = 1;
            this._stepTo(o.start);
        },
        last: function () {
            var element = this.element, o = this.options;
            var steps = element.find('li');
            o.start = steps.length;
            this._stepTo(o.start);
        },
        next: function () {
            var element = this.element, o = this.options;
            var steps = element.find('li');
            if (o.start + 1 > steps.length) {
                return;
            }
            o.start++;
            this._stepTo(o.start);
        },
        prior: function () {
            var o = this.options;
            if (o.start - 1 === 0) {
                return;
            }
            o.start--;
            this._stepTo(o.start);
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.streamer', {
        version: '3.0.0',
        options: {
            scrollBar: false,
            meterStart: 9,
            meterStop: 19,
            meterInterval: 20,
            slideToTime: 'default',
            slideSleep: 1000,
            slideSpeed: 1000,
            onClick: function (event) {
            }
        },
        _create: function () {
            var that = this, element = this.element, o = this.options, streams = element.find('.stream'), events = element.find('.event'), events_container = element.find('.events'), events_area = element.find('.events-area'), groups = element.find('.event-group'), event_streams = element.find('.event-stream');
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            element.data('streamSelect', -1);
            var meter = $('<ul/>').addClass('meter');
            var i, j, m, start = o.meterStart, stop = o.meterStop, interval = o.meterInterval;
            var _intervals = [];
            for (i = start; i < stop; i++) {
                for (j = 0; j < 60; j += interval) {
                    m = (i < 10 ? '0' + i : i) + ':' + (j < 10 ? '0' + j : j);
                    $('<li/>').addClass('js-interval-' + m.replace(':', '-')).html('<em>' + m + '</em>').appendTo(meter);
                    _intervals.push(m);
                }
            }
            element.data('intervals', _intervals);
            meter.insertBefore(element.find('.events-grid'));
            element.find('.event-stream').each(function (i, s) {
                var event_stream_width = 0;
                var events = $(s).find('.event');
                events.each(function (i, el) {
                    event_stream_width += $(el).outerWidth() + parseInt($(el).css('margin-left'));
                });
                $(s).css({ width: event_stream_width + (events.length - 1) * 2 + 1 });
                $(s).find('.time').css('background-color', $(streams[i]).css('background-color'));
            });
            events_container.css({ 'overflow-x': o.scrollBar ? 'scroll' : 'hidden' });
            element.css({ height: element.find('.streams').outerHeight() + (o.scrollBar ? 20 : 0) });
            var events_area_width = 0;
            groups.each(function (i, el) {
                events_area_width += $(el).outerWidth();
            });
            events_area_width += (groups.length - 1) * 2 + 10;
            events_area.css('width', events_area_width);
            events.each(function (i, el) {
                addTouchEvents(el);
            });
            element.mousewheel(function (event, delta) {
                var scroll_value = delta * 50;
                events_container.scrollLeft(events_container.scrollLeft() - scroll_value);
                return false;
            });
            streams.each(function (i, s) {
                $(s).mousedown(function (e) {
                    if (element.data('streamSelect') == i) {
                        events.removeClass('event-disable');
                        element.data('streamSelect', -1);
                    } else {
                        element.data('streamSelect', i);
                        events.addClass('event-disable');
                        $(event_streams[i]).find('.event').removeClass('event-disable');
                    }
                });
            });
            this._createEvents();
            this.slideToTime(o.slideToTime, o.slideSleep, o.slideSpeed);
            element.data('streamer', this);
        },
        _createEvents: function () {
            var that = this, element = this.element, o = this.options;
            var events = element.find('.event');
            events.on('click', function (e) {
                var event = $(this);
                if (e.ctrlKey) {
                    $(this).toggleClass('selected');
                }
                if (typeof o.onClick === 'function') {
                    o.onClick(event);
                } else {
                    if (typeof window[o.onClick] === 'function') {
                        window[o.onClick](event);
                    } else {
                        var result = eval('(function(){' + o.onClick + '})');
                        result.call(event);
                    }
                }
                e.preventDefault();
            });
            element.find('.js-go-previous-time').on('click', function (e) {
                var next_index = element.data('intervals').indexOf(element.data('current-time'));
                if (next_index == 0) {
                    return;
                }
                next_index--;
                var new_time = element.data('intervals')[next_index];
                that.slideToTime(new_time, 0, o.slideSpeed);
            });
            element.find('.js-go-next-time').on('click', function (e) {
                var next_index = element.data('intervals').indexOf(element.data('current-time'));
                if (next_index == element.data('intervals').length - 1) {
                    return;
                }
                next_index++;
                var new_time = element.data('intervals')[next_index];
                that.slideToTime(new_time, 0, o.slideSpeed);
            });
            element.find('.js-show-all-streams').on('click', function (e) {
                element.find('.event').removeClass('event-disable');
                element.data('streamSelect', -1);
                e.preventDefault();
            });
            element.find('.js-schedule-mode').on('click', function (e) {
                $(this).toggleClass('active');
                element.data('schedule-mode', $(this).hasClass('inverse'));
                e.preventDefault();
            });
        },
        slideToTime: function (time, sleep, speed) {
            var that = this, element = this.element, interval, _time;
            if (time === 'default') {
                interval = element.find('.meter li')[0];
                time = interval.className.replace('js-interval-', '').replace('-', ':');
            } else {
                _time = time.split(':');
                if (_time[0].length === 1) {
                    time = '0' + time;
                }
            }
            interval = element.find('.meter li.js-interval-' + time.replace(':', '-'))[0];
            setTimeout(function () {
                element.find('.events').animate({ scrollLeft: interval.offsetLeft - $('.streams').width() }, speed, function () {
                    that._afterSlide();
                });
            }, sleep);
            element.data('current-time', time);
        },
        _afterSlide: function () {
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.tabcontrol', {
        version: '3.0.0',
        options: {
            openTarget: false,
            saveState: false,
            onTabClick: function (tab) {
                return true;
            },
            onTabChange: function (tab) {
            },
            _current: {
                tab: false,
                frame: false
            }
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            var tabs = element.children('.tabs').find('li').children('a');
            var frames = element.children('.frames').children('div');
            var tab, target, frame;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (o.saveState && element.attr('id') !== undefined && element.attr('id').trim() !== '') {
                var stored_target = window.localStorage.getItem(element.attr('id') + '-stored-tab');
                if (stored_target && stored_target !== 'undefined') {
                    tab = element.find('a[href=\'' + stored_target + '\']');
                    if (tab) {
                        target = tab.attr('href');
                        frame = target && target.isUrl() ? false : $(target);
                        o._current.tab = tab;
                        o._current.frame = frame;
                    }
                }
            }
            if (!o._current.tab && o.openTarget !== false) {
                tab = element.find('a[href=\'' + o.openTarget + '\']');
                if (tab) {
                    target = tab.attr('href');
                    frame = target && target.isUrl() ? false : $(target);
                    o._current.tab = tab;
                    o._current.frame = frame;
                }
            }
            if (!o._current.tab) {
                $.each(tabs, function (i, v) {
                    var tab = $(v), target = tab.attr('href'), frame = target.isUrl() ? false : $(target);
                    if (tab.parent().hasClass('active') && !tab.parent().hasClass('disabled') && frame !== false) {
                        o._current.tab = tab;
                        o._current.frame = frame;
                    }
                });
            }
            if (!o._current.tab) {
                for (var i = 0; i < tabs.length; i++) {
                    if (!$(tabs[i]).attr('href').isUrl() && !$(tabs[i]).parent().hasClass('disabled')) {
                        o._current.tab = $(tabs[i]);
                        o._current.frame = $($(tabs[i]).attr('href'));
                        break;
                    }
                }
            }
            this._createEvents();
            this._openTab();
            element.data('tabcontrol', this);
        },
        _hideTabs: function () {
            var element = this.element;
            var w = element.outerWidth();
            var _tabs = element.children('.tabs').find('li:not(.non-visible-tabs)');
            var _nvt = element.children('.tabs').find('.non-visible-tabs').children('.d-menu');
            $.each(_tabs, function () {
                var $tab = $(this), tab = this;
                if (tab.offsetLeft + tab.offsetWidth + 30 > w) {
                    var new_tab = $tab.clone(true);
                    new_tab.appendTo(_nvt);
                    $tab.remove();
                }
            });
        },
        _openTab: function () {
            var element = this.element, o = this.options;
            var tabs = element.children('.tabs').find('li').children('a');
            var frames = element.children('.frames').children('div');
            tabs.parent().removeClass('active');
            frames.hide();
            o._current.tab.parent().addClass('active');
            o._current.frame.show();
            if (o.saveState && element.attr('id') !== undefined && element.attr('id').trim() !== '') {
                window.localStorage.setItem(element.attr('id') + '-stored-tab', o._current.tab.attr('href'));
            }
        },
        _createEvents: function () {
            var that = this, element = this.element, o = this.options;
            var tabs = element.children('.tabs').find('li').children('a');
            var frames = element.children('.frames').children('div');
            element.on('click', '.tabs > li > a', function (e) {
                var result;
                var tab = $(this), target = tab.attr('href'), frame = $(target);
                if (tab.parent().hasClass('disabled')) {
                    return false;
                }
                if (typeof o.onTabClick === 'function') {
                    if (!o.onTabClick(tab)) {
                        return false;
                    }
                } else {
                    if (typeof window[o.onTabClick] === 'function') {
                        if (!window[o.onTabClick](tab)) {
                            return false;
                        }
                    } else {
                        result = eval('(function(){' + o.onTabClick + '})');
                        if (!result.call(tab)) {
                            return false;
                        }
                    }
                }
                if (target.isUrl()) {
                    window.location.href = target;
                    return true;
                }
                o._current.tab = tab;
                o._current.frame = frame;
                that._openTab();
                if (typeof o.onTabChange === 'function') {
                    o.onTabChange(tab);
                } else {
                    if (typeof window[o.onTabChange] === 'function') {
                        window[o.onTabChange](tab);
                    } else {
                        result = eval('(function(){' + o.onTabChange + '})');
                        result.call(tab);
                    }
                }
                e.preventDefault();
                e.stopPropagation();
            });
        },
        hideTab: function (tab) {
        },
        showTab: function (tab) {
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.tile', {
        version: '3.0.0',
        options: {
            effect: 'slideLeft',
            period: 4000,
            duration: 700,
            easing: 'doubleSqrt',
            onClick: function (tile) {
            }
        },
        _frames: {},
        _currentIndex: 0,
        _interval: 0,
        _outPosition: 0,
        _size: {},
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._createTransformTile();
            this._createLiveTile();
            this._createEvents();
            element.data('tile', this);
        },
        _createEvents: function () {
            var that = this, element = this.element, o = this.options;
            var event = isTouchDevice() ? 'touchstart' : 'click';
            element.on(event, function (e) {
                if (element[0].tagName === 'A') {
                } else {
                    if (typeof o.onClick === 'function') {
                        o.onClick(element);
                    } else {
                        if (typeof window[o.onClick] === 'function') {
                            window[o.onClick](element);
                        } else {
                            var result = eval('(function(){' + o.onClick + '})');
                            result.call(element);
                        }
                    }
                }
            });
        },
        _createLiveTile: function () {
            var that = this, element = this.element, o = this.options;
            var event_down = isTouchDevice() ? 'touchstart' : 'mouseenter';
            var event_up = isTouchDevice() ? 'touchend' : 'mouseleave';
            this._frames = element.find('.live-slide');
            if (this._frames.length <= 1) {
                return false;
            }
            $.easing.doubleSqrt = function (t) {
                return Math.sqrt(Math.sqrt(t));
            };
            this._size = {
                'width': element.width(),
                'height': element.height()
            };
            element.on(event_down, function () {
                that.stop();
            });
            element.on(event_up, function () {
                that.start();
            });
            this.start();
        },
        start: function () {
            var that = this;
            this._interval = setInterval(function () {
                that._animate();
            }, this.options.period);
        },
        stop: function () {
            clearInterval(this._interval);
        },
        _animate: function () {
            var currentFrame = this._frames[this._currentIndex], nextFrame;
            this._currentIndex += 1;
            if (this._currentIndex >= this._frames.length) {
                this._currentIndex = 0;
            }
            nextFrame = this._frames[this._currentIndex];
            switch (this.options.effect) {
            case 'slideLeft':
                this._effectSlideLeft(currentFrame, nextFrame);
                break;
            case 'slideRight':
                this._effectSlideRight(currentFrame, nextFrame);
                break;
            case 'slideDown':
                this._effectSlideDown(currentFrame, nextFrame);
                break;
            case 'slideUpDown':
                this._effectSlideUpDown(currentFrame, nextFrame);
                break;
            case 'slideLeftRight':
                this._effectSlideLeftRight(currentFrame, nextFrame);
                break;
            default:
                this._effectSlideUp(currentFrame, nextFrame);
            }
        },
        _effectSlideLeftRight: function (currentFrame, nextFrame) {
            if (this._currentIndex % 2 === 0) {
                this._effectSlideLeft(currentFrame, nextFrame);
            } else {
                this._effectSlideRight(currentFrame, nextFrame);
            }
        },
        _effectSlideUpDown: function (currentFrame, nextFrame) {
            if (this._currentIndex % 2 === 0) {
                this._effectSlideUp(currentFrame, nextFrame);
            } else {
                this._effectSlideDown(currentFrame, nextFrame);
            }
        },
        _effectSlideUp: function (currentFrame, nextFrame) {
            var _out = this._size.height;
            var options = {
                'duration': this.options.duration,
                'easing': this.options.easing
            };
            $(currentFrame).animate({ top: -_out }, options);
            $(nextFrame).css({ top: _out }).show().animate({ top: 0 }, options);
        },
        _effectSlideDown: function (currentFrame, nextFrame) {
            var _out = this._size.height;
            var options = {
                'duration': this.options.duration,
                'easing': this.options.easing
            };
            $(currentFrame).animate({ top: _out }, options);
            $(nextFrame).css({ top: -_out }).show().animate({ top: 0 }, options);
        },
        _effectSlideLeft: function (currentFrame, nextFrame) {
            var _out = this._size.width;
            var options = {
                'duration': this.options.duration,
                'easing': this.options.easing
            };
            $(currentFrame).animate({ left: _out * -1 }, options);
            $(nextFrame).css({ left: _out }).show().animate({ left: 0 }, options);
        },
        _effectSlideRight: function (currentFrame, nextFrame) {
            var _out = this._size.width;
            var options = {
                'duration': this.options.duration,
                'easing': this.options.easing
            };
            $(currentFrame).animate({ left: _out }, options);
            $(nextFrame).css({ left: -_out }).show().animate({ left: 0 }, options);
        },
        _createTransformTile: function () {
            var that = this, element = this.element, o = this.options;
            var dim = {
                w: element.width(),
                h: element.height()
            };
            var event_down = isTouchDevice() ? 'touchstart' : 'mousedown';
            var event_up = isTouchDevice() ? 'touchend' : 'mouseup';
            var event_leave = isTouchDevice() ? 'touchend' : 'mouseleave';
            element.on(event_down, function (e) {
                var X = e.pageX - $(this).offset().left, Y = e.pageY - $(this).offset().top;
                var transform = 'top';
                if (X < dim.w * 1 / 3 && (Y < dim.h * 1 / 2 || Y > dim.h * 1 / 2)) {
                    transform = 'left';
                } else if (X > dim.w * 2 / 3 && (Y < dim.h * 1 / 2 || Y > dim.h * 1 / 2)) {
                    transform = 'right';
                } else if (X > dim.w * 1 / 3 && X < dim.w * 2 / 3 && Y > dim.h / 2) {
                    transform = 'bottom';
                }
                $(this).addClass('tile-transform-' + transform);
                if (element[0].tagName === 'A' && element.attr('href')) {
                    setTimeout(function () {
                        document.location.href = element.attr('href');
                    }, 500);
                }
            });
            element.on(event_up, function () {
                $(this).removeClass('tile-transform-left').removeClass('tile-transform-right').removeClass('tile-transform-top').removeClass('tile-transform-bottom');
            });
            element.on(event_leave, function () {
                $(this).removeClass('tile-transform-left').removeClass('tile-transform-right').removeClass('tile-transform-top').removeClass('tile-transform-bottom');
            });
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.treeview', {
        version: '3.0.0',
        options: {
            doubleClick: true,
            onClick: function (leaf, node, pnode, tree) {
            },
            onInputClick: function (leaf, node, pnode, tree) {
            },
            onExpand: function (leaf, node, pnode, tree) {
            },
            onCollapse: function (leaf, node, pnode, tree) {
            }
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._initTree();
            this._createEvents();
            element.data('treeview', this);
        },
        _createCheckbox: function (leaf, parent) {
            var input, checkbox, check;
            input = $('<label/>').addClass('input-control checkbox small-check').insertBefore(leaf);
            checkbox = $('<input/>').attr('type', 'checkbox').appendTo(input);
            check = $('<span/>').addClass('check').appendTo(input);
            if (parent.data('name') !== undefined) {
                checkbox.attr('name', parent.data('name'));
            }
            if (parent.data('id') !== undefined) {
                checkbox.attr('id', parent.data('id'));
            }
            if (parent.data('checked') !== undefined) {
                checkbox.prop('checked', parent.data('checked'));
            }
            if (parent.data('readonly') !== undefined) {
                checkbox.prop('disabled', parent.data('readonly'));
            }
            if (parent.data('disabled') !== undefined) {
                checkbox.prop('disabled', parent.data('disabled'));
                if (parent.data('disabled') === true) {
                    parent.addClass('disabled');
                }
            }
            if (parent.data('value') !== undefined) {
                checkbox.val(parent.data('value'));
            }
        },
        _createRadio: function (leaf, parent) {
            var input, checkbox, check;
            input = $('<label/>').addClass('input-control radio small-check').insertBefore(leaf);
            checkbox = $('<input/>').attr('type', 'radio').appendTo(input);
            check = $('<span/>').addClass('check').appendTo(input);
            if (parent.data('name') !== undefined) {
                checkbox.attr('name', parent.data('name'));
            }
            if (parent.data('id') !== undefined) {
                checkbox.attr('id', parent.data('id'));
            }
            if (parent.data('checked') !== undefined) {
                checkbox.prop('checked', parent.data('checked'));
            }
            if (parent.data('readonly') !== undefined) {
                checkbox.prop('disabled', parent.data('readonly'));
            }
            if (parent.data('disabled') !== undefined) {
                checkbox.prop('disabled', parent.data('disabled'));
                if (parent.data('disabled') === true) {
                    parent.addClass('disabled');
                }
            }
            if (parent.data('value') !== undefined) {
                checkbox.val(parent.data('value'));
            }
        },
        _initTree: function () {
            var that = this, element = this.element, o = this.options;
            var leafs = element.find('.leaf');
            $.each(leafs, function () {
                var leaf = $(this), parent = leaf.parent('li'), ul = leaf.siblings('ul'), node = $(leaf.parents('.node')[0]);
                if (parent.data('mode') === 'checkbox') {
                    that._createCheckbox(leaf, parent);
                }
                if (parent.data('mode') === 'radio') {
                    that._createRadio(leaf, parent);
                }
                if (ul.length > 0) {
                    if (!parent.hasClass('node')) {
                        parent.addClass('node');
                    }
                }
                if (parent.hasClass('collapsed')) {
                    ul.hide();
                }
            });
        },
        _renderChecks: function (check) {
            var element = this.element, that = this, o = this.options;
            var state = check.is(':checked');
            var parent = $(check.parent().parent());
            var children_checks = parent.children('ul').find('[type="checkbox"]');
            children_checks.prop('checked', state).removeClass('indeterminate');
            $.each(element.find('.node[data-mode=checkbox]').reverse(), function () {
                var node = $(this), ch = node.children('.input-control').find('[type="checkbox"]'), children_all = node.children('ul').find('[type="checkbox"]'), children_checked = node.children('ul').find('[type="checkbox"]:checked');
                ch.removeClass('indeterminate');
                if (children_checked.length === 0) {
                    ch.prop('checked', false);
                    ch.removeClass('indeterminate');
                } else if (children_checked.length > 0 && children_all.length > children_checked.length) {
                    ch.prop('checked', true);
                    ch.addClass('indeterminate');
                }
            });
        },
        _createEvents: function () {
            var that = this, element = this.element, o = this.options;
            element.on('change', 'input:checkbox', function () {
                that._renderChecks($(this));
            });
            element.on('click', 'input', function () {
                var leaf = $(this), node = $(leaf.parents('.node')[0]), parent = leaf.parent('li'), check = leaf.siblings('.input-control').find('input:checkbox'), radio = leaf.siblings('.input-control').find('input:radio'), new_check_state, check_disabled;
                if (check.length > 0) {
                    new_check_state = !check.is(':checked');
                    check_disabled = check.is(':disabled');
                    if (!check_disabled) {
                        check.prop('checked', new_check_state);
                    }
                    that._renderChecks(check);
                }
                if (radio.length > 0) {
                    check_disabled = radio.is(':disabled');
                    if (!check_disabled) {
                        radio.prop('checked', true);
                    }
                }
                if (typeof o.onInputClick === 'function') {
                    o.onInputClick(leaf, parent, node, that);
                } else {
                    if (typeof window[o.onInputClick] === 'function') {
                        window[o.onInputClick](leaf, parent, node, that);
                    } else {
                        var result = eval('(function(){' + o.onInputClick + '})');
                        result.call(leaf, parent, node, that);
                    }
                }
            });
            element.on('click', '.leaf', function () {
                var leaf = $(this), node = $(leaf.parents('.node')[0]), parent = leaf.parent('li');
                element.find('.leaf').parent('li').removeClass('active');
                parent.addClass('active');
                if (typeof o.onClick === 'function') {
                    o.onClick(leaf, parent, node, that);
                } else {
                    if (typeof window[o.onClick] === 'function') {
                        window[o.onClick](leaf, parent, node, that);
                    } else {
                        var result = eval('(function(){' + o.onClick + '})');
                        result.call(leaf, parent, node, that);
                    }
                }
            });
            if (o.doubleClick) {
                element.on('dblclick', '.leaf', function (e) {
                    var leaf = $(this), parent = leaf.parent('li'), node = $(leaf.parents('.node')[0]);
                    var result;
                    if (parent.hasClass('keep-open')) {
                        return false;
                    }
                    parent.toggleClass('collapsed');
                    if (!parent.hasClass('collapsed')) {
                        parent.children('ul').fadeIn('fast');
                        if (typeof o.onExpand === 'function') {
                            o.onExpand(parent, leaf, node, that);
                        } else {
                            if (typeof window[o.onExpand] === 'function') {
                                window[o.onExpand](parent, leaf, node, that);
                            } else {
                                result = eval('(function(){' + o.onExpand + '})');
                                result.call(parent, leaf, node, that);
                            }
                        }
                    } else {
                        parent.children('ul').fadeOut('fast');
                        if (typeof o.onCollapse === 'function') {
                            o.onCollapse(parent, leaf, node, that);
                        } else {
                            if (typeof window[o.onCollapse] === 'function') {
                                window[o.onCollapse](parent, leaf, node, that);
                            } else {
                                result = eval('(function(){' + o.onCollapse + '})');
                                result.call(parent, leaf, node, that);
                            }
                        }
                    }
                    e.stopPropagation();
                    e.preventDefault();
                });
            }
            element.on('click', '.node-toggle', function (e) {
                var leaf = $(this).siblings('.leaf'), parent = $(this).parent('li'), node = $(leaf.parents('.node')[0]);
                var result;
                if (parent.hasClass('keep-open')) {
                    return false;
                }
                parent.toggleClass('collapsed');
                if (!parent.hasClass('collapsed')) {
                    parent.children('ul').fadeIn('fast');
                    if (typeof o.onExpand === 'function') {
                        o.onExpand(parent, leaf, node, that);
                    } else {
                        if (typeof window[o.onExpand] === 'function') {
                            window[o.onExpand](parent, leaf, node, that);
                        } else {
                            result = eval('(function(){' + o.onExpand + '})');
                            result.call(parent, leaf, node, that);
                        }
                    }
                } else {
                    parent.children('ul').fadeOut('fast');
                    if (typeof o.onCollapse === 'function') {
                        o.onCollapse(parent, leaf, node, that);
                    } else {
                        if (typeof window[o.onCollapse] === 'function') {
                            window[o.onCollapse](parent, leaf, node, that);
                        } else {
                            result = eval('(function(){' + o.onCollapse + '})');
                            result.call(parent, leaf, node, that);
                        }
                    }
                }
                e.stopPropagation();
                e.preventDefault();
            });
        },
        addLeaf: function (parent, name, data) {
            var element = this.element;
            var leaf, li, ul;
            if (parent) {
                if (parent[0].tagName === 'LI') {
                    parent.addClass('node');
                }
                if (parent.children('.node-toggle').length === 0) {
                    $('<span/>').addClass('node-toggle').appendTo(parent);
                }
            }
            ul = parent ? $(parent).children('ul') : element.children('ul');
            if (ul.length === 0) {
                ul = $('<ul/>').appendTo(parent ? parent : element);
            }
            li = $('<li/>').appendTo(ul);
            if (data !== undefined) {
                if (data.tagName !== undefined) {
                    leaf = $('<' + data.tagName + '/>').addClass('leaf').appendTo(li);
                } else {
                    leaf = $('<span/>').addClass('leaf').appendTo(li);
                }
            } else {
                leaf = $('<span/>').addClass('leaf').appendTo(li);
            }
            leaf.html(name);
            if (data !== undefined) {
                $.each(data, function (key, value) {
                    li.attr('data-' + key, value);
                });
                if (data.mode !== undefined) {
                    switch (data.mode) {
                    case 'checkbox':
                        this._createCheckbox(leaf, li);
                        break;
                    case 'radio':
                        this._createRadio(leaf, li);
                        break;
                    }
                }
            }
            return li;
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.validator', {
        version: '1.0.0',
        options: {
            showErrorState: true,
            showErrorHint: true,
            showRequiredState: true,
            showSuccessState: true,
            hintSize: 0,
            hintBackground: '#FFFCC0',
            hintColor: '#000000',
            hideError: 2000,
            hideHint: 5000,
            hintEasing: 'easeInQuad',
            hintEasingTime: 400,
            hintMode: 'hint',
            hintPosition: 'right',
            focusInput: true,
            onBeforeSubmit: function (form, result) {
                return true;
            },
            onErrorInput: function (input) {
            },
            onSubmit: function (form) {
                return true;
            }
        },
        _scroll: 0,
        funcs: {
            required: function (val) {
                return val.trim() !== '';
            },
            minlength: function (val, len) {
                if (len == undefined || isNaN(len) || len <= 0) {
                    return false;
                }
                return val.trim().length >= len;
            },
            maxlength: function (val, len) {
                if (len == undefined || isNaN(len) || len <= 0) {
                    return false;
                }
                return val.trim().length <= len;
            },
            min: function (val, min_value) {
                if (min_value == undefined || isNaN(min_value)) {
                    return false;
                }
                if (val.trim() === '') {
                    return false;
                }
                if (isNaN(val)) {
                    return false;
                }
                return val >= min_value;
            },
            max: function (val, max_value) {
                if (max_value == undefined || isNaN(max_value)) {
                    return false;
                }
                if (val.trim() === '') {
                    return false;
                }
                if (isNaN(val)) {
                    return false;
                }
                return val <= max_value;
            },
            email: function (val) {
                return /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i.test(val);
            },
            url: function (val) {
                return /^(?:[a-z]+:)?\/\//i.test(val);
            },
            date: function (val) {
                return !!(new Date(val) !== 'Invalid Date' && !isNaN(new Date(val)));
            },
            number: function (val) {
                return val - 0 == val && ('' + val).trim().length > 0;
            },
            digits: function (val) {
                return /^\d+$/.test(val);
            },
            hexcolor: function (val) {
                return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(val);
            },
            pattern: function (val, pat) {
                if (pat == undefined) {
                    return false;
                }
                var reg = new RegExp(pat);
                return reg.test(val);
            }
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            if (o.hintMode !== 'line') {
                o.hintMode = 'hint2';
            }
            this._scroll = $(window).scrollTop();
            this._createValidator();
            element.data('validator', this);
        },
        _createValidator: function () {
            var that = this, element = this.element, o = this.options;
            var inputs = element.find('[data-validate-func]');
            element.attr('novalidate', 'novalidate');
            if (o.showRequiredState) {
                $.each(inputs, function () {
                    var input = $(this);
                    if (input.parent().hasClass('input-control')) {
                        input.parent().addClass('required');
                    } else {
                        input.addClass('required');
                    }
                });
            }
            inputs.on('focus', function () {
            });
            $(window).scroll(function (e) {
                var st = $(this).scrollTop();
                var delta = isNaN(st - this._scroll) ? 0 : st - this._scroll;
                $('.validator-hint.hint2').css({ top: '-=' + delta });
                this._scroll = st;
            });
            if (element[0].onsubmit) {
                this._onsubmit = element[0].onsubmit;
                element[0].onsubmit = null;
            } else {
                this._onsubmit = null;
            }
            element[0].onsubmit = function () {
                return that._submit();
            };
        },
        _submit: function () {
            var that = this, element = this.element, o = this.options;
            var inputs = element.find('[data-validate-func]');
            var submit = element.find(':submit').attr('disabled', 'disabled').addClass('disabled');
            var result = 0;
            $('.validator-hint').hide();
            inputs.removeClass('error success');
            $.each(inputs, function (i, v) {
                var input = $(v);
                if (input.parent().hasClass('input-control')) {
                    input.parent().removeClass('error success');
                }
            });
            $.each(inputs, function (i, v) {
                var input = $(v);
                var func = input.data('validateFunc'), arg = input.data('validateArg');
                var this_result = that.funcs[func](input.val(), arg);
                if (!this_result) {
                    if (typeof o.onErrorInput === 'function') {
                        o.onErrorInput(input);
                    } else {
                        if (typeof window[o.onErrorInput] === 'function') {
                            window[o.onErrorInput](input);
                        } else {
                            result = eval('(function(){' + o.onErrorInput + '})');
                            result.call(input);
                        }
                    }
                }
                if (!this_result && o.showErrorState) {
                    that._showError(input);
                }
                if (!this_result && o.showErrorHint) {
                    setTimeout(function () {
                        that._showErrorHint(input);
                    }, i * 100);
                }
                if (this_result && o.showSuccessState) {
                    that._showSuccess(input);
                }
                if (!this_result && i == 0 && o.focusInput) {
                    input.focus();
                }
                result += !this_result ? 1 : 0;
            });
            if (typeof o.onBeforeSubmit === 'function') {
                result += !o.onBeforeSubmit(element, result) ? 1 : 0;
            } else {
                if (typeof window[o.onBeforeSubmit] === 'function') {
                    result += window[o.onBeforeSubmit](element, result) ? 1 : 0;
                } else {
                    var f0 = eval('(function(){' + o.onBeforeSubmit + '})');
                    result += f0.call(element, result) ? 1 : 0;
                }
            }
            if (result !== 0) {
                submit.removeAttr('disabled').removeClass('disabled');
                return false;
            }
            if (typeof o.onSubmit === 'function') {
                result = o.onSubmit(element[0]);
            } else {
                if (typeof window[o.onSubmit] === 'function') {
                    result = window[o.onSubmit](element[0]);
                } else {
                    var f = eval('(function(){' + o.onSubmit + '})');
                    result = f.call(element[0]);
                }
            }
            submit.removeAttr('disabled').removeClass('disabled');
            return result;
        },
        _showSuccess: function (input) {
            if (input.parent().hasClass('input-control')) {
                input.parent().addClass('success');
            } else {
                input.addClass('success');
            }
        },
        _showError: function (input) {
            var o = this.options;
            if (input.parent().hasClass('input-control')) {
                input.parent().addClass('error');
            } else {
                input.addClass('error');
            }
            if (o.hideError && o.hideError > 0) {
                setTimeout(function () {
                    input.parent().removeClass('error');
                }, o.hideError);
            }
        },
        _showErrorHint: function (input) {
            var o = this.options, msg = input.data('validateHint'), pos = input.data('validateHintPosition') || o.hintPosition, mode = input.data('validateHintMode') || o.hintMode, background = input.data('validateHintBackground') || o.hintBackground, color = input.data('validateHintColor') || o.hintColor;
            var hint, top, left;
            if (msg === undefined) {
                return false;
            }
            hint = $('<div/>').addClass(mode + ' validator-hint');
            hint.html(msg !== undefined ? this._format(msg, input.val()) : '');
            hint.css({ 'min-width': o.hintSize });
            if (background.isColor()) {
                hint.css('background-color', background);
            } else {
                hint.addClass(background);
            }
            if (color.isColor()) {
                hint.css('color', color);
            } else {
                hint.addClass(color);
            }
            if (mode === 'line') {
                hint.addClass('hint2').addClass('line');
                hint.css({
                    'position': 'relative',
                    'width': input.parent().hasClass('input-control') ? input.parent().width() : input.width(),
                    'z-index': 100
                });
                hint.appendTo(input.parent());
                hint.fadeIn(o.hintEasingTime, function () {
                    setTimeout(function () {
                        hint.hide().remove();
                    }, o.hideHint);
                });
            } else {
                hint.appendTo('body');
                if (pos === 'right') {
                    left = input.offset().left + input.outerWidth() + 15 - $(window).scrollLeft();
                    top = input.offset().top + input.outerHeight() / 2 - hint.outerHeight() / 2 - $(window).scrollTop() - 10;
                    hint.addClass(pos);
                    hint.css({
                        top: top,
                        left: $(window).width() + 100
                    });
                    hint.show().animate({ left: left }, o.hintEasingTime, o.hintEasing, function () {
                        setTimeout(function () {
                            hint.hide().remove();
                        }, o.hideHint);
                    });
                } else if (pos === 'left') {
                    left = input.offset().left - hint.outerWidth() - 10 - $(window).scrollLeft();
                    top = input.offset().top + input.outerHeight() / 2 - hint.outerHeight() / 2 - $(window).scrollTop() - 10;
                    hint.addClass(pos);
                    hint.css({
                        top: top,
                        left: -input.offset().left - hint.outerWidth() - 10
                    });
                    hint.show().animate({ left: left }, o.hintEasingTime, o.hintEasing, function () {
                        setTimeout(function () {
                            hint.hide().remove();
                        }, o.hideHint);
                    });
                } else if (pos === 'top') {
                    left = input.offset().left + input.outerWidth() / 2 - hint.outerWidth() / 2 - $(window).scrollLeft();
                    top = input.offset().top - $(window).scrollTop() - hint.outerHeight() - 20;
                    hint.addClass(pos);
                    hint.css({
                        top: -hint.outerHeight(),
                        left: left
                    }).show().animate({ top: top }, o.hintEasingTime, o.hintEasing, function () {
                        setTimeout(function () {
                            hint.hide().remove();
                        }, o.hideHint);
                    });
                } else {
                    left = input.offset().left + input.outerWidth() / 2 - hint.outerWidth() / 2 - $(window).scrollLeft();
                    top = input.offset().top - $(window).scrollTop() + input.outerHeight();
                    hint.addClass(pos);
                    hint.css({
                        top: $(window).height(),
                        left: left
                    }).show().animate({ top: top }, o.hintEasingTime, o.hintEasing, function () {
                        setTimeout(function () {
                            hint.hide().remove();
                        }, o.hideHint);
                    });
                }
            }
        },
        _format: function (source, params) {
            if (arguments.length === 1) {
                return function () {
                    var args = $.makeArray(arguments);
                    args.unshift(source);
                    return $.validator.format.apply(this, args);
                };
            }
            if (arguments.length > 2 && params.constructor !== Array) {
                params = $.makeArray(arguments).slice(1);
            }
            if (params.constructor !== Array) {
                params = [params];
            }
            $.each(params, function (i, n) {
                source = source.replace(new RegExp('\\{' + i + '\\}', 'g'), function () {
                    return n;
                });
            });
            return source;
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.video', {
        version: '3.0.14',
        options: {
            width: '100%',
            videoSize: 'hd',
            controls: true,
            controlsPosition: 'bottom',
            controlsModel: 'full',
            loopButton: '<span class=\'mif-loop\'></span>',
            stopButton: '<span class=\'mif-stop\'></span>',
            playButton: '<span class=\'mif-play\'></span>',
            pauseButton: '<span class=\'mif-pause\'></span>',
            muteButton: '<span class=\'mif-volume-mute2\'></span>',
            volumeLowButton: '<span class=\'mif-volume-low\'></span>',
            volumeMediumButton: '<span class=\'mif-volume-medium\'></span>',
            volumeHighButton: '<span class=\'mif-volume-high\'></span>',
            screenMoreButton: '<span class=\'mif-enlarge\'></span>',
            screenLessButton: '<span class=\'mif-shrink\'></span>',
            fullScreenMode: 'window',
            poster: false,
            src: false,
            loop: false,
            preload: false,
            autoplay: false,
            muted: false,
            volume: 0.5,
            logo: false,
            controlsHide: 1000
        },
        _create: function () {
            var that = this, element = this.element, o = this.options;
            this._setOptionsFromDOM();
            this._createPlayer();
            this._addControls();
            this._addEvents();
            element.data('video', this);
        },
        _createPlayer: function () {
            var that = this, element = this.element, o = this.options;
            var player_width = element.width(), player_height;
            var controls, video = element.find('video');
            if (o.videoSize == 'HD' && o.videoSize == 'hd') {
                player_height = 9 * player_width / 16;
            } else if (o.videoSize == 'SD' && o.videoSize == 'sd') {
                player_height = 3 * player_width / 4;
            } else {
            }
            element.addClass('video-player');
            element.css({ height: player_height });
            if (video.length == 0) {
                video = $('<video/>').appendTo(element);
            }
            $.each([
                'muted',
                'autoplay',
                'controls',
                'height',
                'width',
                'loop',
                'poster',
                'preload'
            ], function () {
                video.removeAttr(this);
            });
            if (o.poster) {
                video.attr('poster', o.poster);
            }
            if (o.src) {
                if (o.src.indexOf('youtube') >= 0) {
                    var youtube_reg = /v=[(\w)]+/gi;
                    var youtube_id = youtube_reg.exec(o.src)[0].substring(2);
                } else {
                    video.attr('src', o.src);
                }
            }
            if (o.loop) {
                video.attr('loop', 'loop');
            }
            if (o.preload) {
                video.attr('preload', 'auto');
            }
            if (o.autoplay) {
                video.attr('autoplay', 'autoplay');
            }
            video[0].volume = o.volume;
            element.data('fullScreen', false);
            element.data('muted', false);
            element.data('duration', 0);
            element.data('timeInterval', undefined);
            element.data('played', false);
            element.data('volume', video[0].volume);
        },
        _addEvents: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var controls = element.find('.controls'), preloader = element.find('.video-preloader'), play_button = controls.find('.play'), stop_button = controls.find('.stop'), volume_button = controls.find('.volume'), screen_button = controls.find('.full'), volume_slider = controls.find('.volume-slider'), stream_slider = controls.find('.stream-slider'), info_box = controls.find('.info-box');
            var video = element.find('video'), video_obj = video[0];
            video.on('loadedmetadata', function () {
                element.data('duration', video_obj.duration.toFixed(0));
                info_box.html('00:00' + ' / ' + secondsToFormattedString(element.data('duration')));
            });
            video.on('canplay', function () {
                controls.fadeIn();
                preloader.hide();
                var buffered = video_obj.buffered.length ? Math.round(Math.floor(video_obj.buffered.end(0)) / Math.floor(video_obj.duration) * 100) : 0;
                that._setBufferSize(buffered);
            });
            video.on('progress', function () {
                var buffered = video_obj.buffered.length ? Math.round(Math.floor(video_obj.buffered.end(0)) / Math.floor(video_obj.duration) * 100) : 0;
                that._setBufferSize(buffered);
            });
            video.on('timeupdate', function () {
                that._setInfoData();
                that._setStreamSliderPosition();
            });
            video.on('waiting', function () {
                preloader.show();
            });
            video.on('loadeddata', function () {
                preloader.hide();
            });
            video.on('ended', function () {
                that._stopVideo();
            });
            element.on('play', function () {
                if (isTouchDevice()) {
                    setTimeout(function () {
                        controls.fadeOut();
                    }, o.controlsHide);
                }
            });
            element.on('pause', function () {
            });
            element.on('stop', function () {
                controls.show();
            });
            element.on('mouseenter', function () {
                setTimeout(function () {
                    controls.fadeIn();
                }, o.controlsHide);
            });
            element.on('mouseleave', function () {
                if (video_obj.currentTime > 0) {
                    setTimeout(function () {
                        controls.fadeOut();
                    }, o.controlsHide);
                }
            });
            if (isTouchDevice()) {
                element.on('touchstart', function () {
                    if (video_obj.currentTime > 0) {
                        setTimeout(function () {
                            if (controls.css('display') == 'none') {
                                controls.fadeIn();
                            } else {
                                controls.fadeOut();
                            }
                        }, o.controlsHide);
                    }
                });
            }
        },
        _setInfoData: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var video = element.find('video'), video_obj = video[0];
            var info_box = element.find('.controls .info-box');
            var currentTime = Math.round(video_obj.currentTime);
            info_box.html(secondsToFormattedString(currentTime) + ' / ' + secondsToFormattedString(element.data('duration')));
        },
        _setStreamSliderPosition: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var video = element.find('video'), video_obj = video[0];
            var slider = element.find('.stream-slider').data('slider');
            slider.value(Math.round(video_obj.currentTime * 100 / element.data('duration')));
        },
        _setBufferSize: function (value) {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var video = element.find('video'), video_obj = video[0];
            var slider = element.find('.stream-slider').data('slider');
            slider.buffer(Math.round(value));
        },
        _stop: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var video = element.find('video'), video_obj = video[0];
            var stop_button = element.find('.controls .stop');
            var play_button = element.find('.controls .play');
            video_obj.pause();
            video_obj.currentTime = 0;
            play_button.html(o.playButton);
            stop_button.attr('disabled', 'disabled');
            element.data('played', false);
            element.find('.stream-slider').data('slider').value(0);
            element.trigger('stop');
        },
        _play: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var video = element.find('video'), video_obj = video[0];
            var play_button = element.find('.controls .play');
            var stop_button = element.find('.controls .stop');
            if (video_obj.paused) {
                play_button.html(o.pauseButton);
                video_obj.play();
                stop_button.removeAttr('disabled');
                element.data('played', true);
                element.trigger('play');
            } else {
                play_button.html(o.playButton);
                video_obj.pause();
                element.data('played', false);
                element.trigger('pause');
            }
        },
        _addControls: function () {
            var that = this, element = this.element, element_obj = element[0], o = this.options;
            var preloader, logo, controls, loop_button, play_button, stop_button, volume_button, screen_button, volume_slider, stream_slider, info_box, volume_slider_wrapper, stream_slider_wrapper;
            var video = element.find('video'), video_obj = video[0];
            if (o.logo) {
                logo = $('<img/>').addClass('video-logo').appendTo(element);
                logo.attr('src', o.logo);
            }
            preloader = $('<div/>').addClass('video-preloader').attr('data-role', 'preloader').attr('data-type', 'cycle').attr('data-style', 'color').appendTo(element);
            controls = $('<div/>').addClass('controls').appendTo(element);
            controls.addClass('position-' + o.controlsPosition);
            stream_slider_wrapper = $('<div/>').addClass('stream-slider-wrapper').appendTo(controls);
            stream_slider = $('<div/>').addClass('slider stream-slider').appendTo(stream_slider_wrapper);
            stream_slider.slider({
                showHint: true,
                animate: false,
                markerColor: 'bg-red',
                completeColor: 'bg-cyan',
                onStartChange: function () {
                    video_obj.pause();
                },
                onChanged: function (value, slider) {
                    if (video_obj.seekable.length > 0)
                        video_obj.currentTime = (element.data('duration') * value / 100).toFixed(0);
                    if (element.data('played') && video_obj.currentTime >= 0) {
                        video_obj.play();
                    }
                }
            });
            stream_slider.data('slider').value(0);
            if (o.loopButton !== false) {
                loop_button = $('<button/>').addClass('square-button small-button1 control-button loop no-phone').html(o.loopButton).appendTo(controls);
                loop_button.on('click', function () {
                    loop_button.toggleClass('active');
                    if (loop_button.hasClass('active')) {
                        video.attr('loop', 'loop');
                    } else {
                        video.removeAttr('loop');
                    }
                });
            }
            if (o.playButton !== false) {
                play_button = $('<button/>').addClass('square-button small-button1 control-button play').html(o.playButton).appendTo(controls);
                play_button.on('click', function () {
                    that._play();
                });
            }
            if (o.stopButton !== false) {
                stop_button = $('<button/>').addClass('square-button small-button1 control-button stop no-phone').html(o.stopButton).appendTo(controls).attr('disabled', 'disabled');
                stop_button.on('click', function () {
                    that._stop();
                });
            }
            info_box = $('<div/>').addClass('info-box no-small-phone').appendTo(controls);
            info_box.html('00:00 / 00:00');
            if (o.screenMoreButton !== false) {
                screen_button = $('<button/>').addClass('square-button small-button1 control-button full').html(o.screenMoreButton).appendTo(controls);
                screen_button.on('click', function () {
                    element.data('fullScreen', !element.data('fullScreen'));
                    if (element.data('fullScreen')) {
                        screen_button.html(o.screenLessButton);
                    } else {
                        screen_button.html(o.screenMoreButton);
                    }
                    if (o.fullScreenMode === 'window') {
                        element.toggleClass('full-screen');
                    } else {
                        if (element.data('fullScreen')) {
                            if (element_obj.requestFullscreen) {
                                element_obj.requestFullscreen();
                            } else if (element_obj.msRequestFullscreen) {
                                element_obj.msRequestFullscreen();
                            } else if (element_obj.mozRequestFullScreen) {
                                element_obj.mozRequestFullScreen();
                            } else if (element_obj.webkitRequestFullscreen) {
                                element_obj.webkitRequestFullscreen();
                            }
                        } else {
                            if (document.exitFullscreen) {
                                document.exitFullscreen();
                            } else if (document.mozCancelFullScreen) {
                                document.mozCancelFullScreen();
                            } else if (document.webkitExitFullscreen) {
                                document.webkitExitFullscreen();
                            }
                        }
                    }
                    if (element.data('fullScreen')) {
                        $(document).on('keyup.metro_video_player', function (e) {
                            if (e.keyCode == 27) {
                                screen_button.html(o.screenMoreButton);
                                element.data('fullScreen', false);
                                if (element.hasClass('full-screen')) {
                                    element.removeClass('full-screen');
                                }
                            }
                        });
                    } else {
                        $(document).off('keyup.metro_video_player');
                    }
                });
            }
            volume_slider_wrapper = $('<div/>').addClass('control-slider volume-slider-wrapper place-right').appendTo(controls);
            volume_slider = $('<div/>').addClass('slider volume-slider').appendTo(volume_slider_wrapper);
            volume_slider.slider({
                showHint: true,
                animate: false,
                markerColor: 'bg-red',
                completeColor: 'bg-green',
                onChange: function (value, slider) {
                    video_obj.volume = value / 100;
                    that._setupVolumeButton();
                }
            });
            volume_slider.data('slider').value(video_obj.volume * 100);
            volume_button = $('<button/>').addClass('square-button small-button1 control-button volume place-right').html(o.volumeLowButton).appendTo(controls);
            volume_button.on('click', function () {
                var volume_slider = element.find('.volume-slider').data('slider');
                element.data('muted', !element.data('muted'));
                if (element.data('muted')) {
                    element.data('volume', video_obj.volume);
                    volume_button.html(o.muteButton);
                    volume_slider.value(0);
                } else {
                    video_obj.volume = element.data('volume');
                    volume_slider.value(element.data('volume') * 100);
                    that._setupVolumeButton();
                }
                video_obj.muted = element.data('muted');
            });
            this._setupVolumeButton();
            controls.hide();
        },
        _setupVolumeButton: function () {
            var that = this, element = this.element, o = this.options;
            var video = element.find('video'), video_obj = video[0];
            var controls = element.find('.controls'), volume_button = controls.find('.volume');
            var current_volume = video_obj.volume;
            if (current_volume > 0 && current_volume < 0.3) {
                volume_button.html(o.volumeLowButton);
            } else if (current_volume >= 0.3 && current_volume < 0.6) {
                volume_button.html(o.volumeMediumButton);
            } else if (current_volume >= 0.6 && current_volume <= 1) {
                volume_button.html(o.volumeHighButton);
            } else {
                volume_button.html(o.muteButton);
            }
        },
        _setOptionsFromDOM: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        },
        play: function (file, type) {
            var that = this, element = this.element, o = this.options;
            var video = element.find('video'), video_obj = video[0];
            var source;
            this._stop();
            video.find('source').remove();
            video.removeAttr('src');
            source = $('<source>').attr('src', file);
            if (type != undefined) {
                source.attr('type', type);
            }
            video_obj.load();
            source.appendTo(video);
            this._play();
        },
        stop: function () {
            this._stop();
        },
        pause: function () {
            var that = this, element = this.element, o = this.options;
            var video = element.find('video'), video_obj = video[0];
            var play_button = element.find('.play');
            play_button.html(o.playButton);
            video_obj.pause();
            element.data('played', false);
            element.trigger('pause');
        },
        resume: function () {
            var that = this, element = this.element, o = this.options;
            var video = element.find('video'), video_obj = video[0];
            var play_button = element.find('.play');
            var stop_button = element.find('.stop');
            play_button.html(o.pauseButton);
            video_obj.play();
            stop_button.removeAttr('disabled');
            element.data('played', true);
            element.trigger('play');
        }
    });
    $.widget('metro.window', {
        version: '3.0.0',
        options: {
            parent: 'default',
            captionStyle: false,
            contentStyle: false,
            buttons: {
                btnMin: false,
                btnMax: false,
                btnClose: false
            },
            title: false,
            content: false,
            icon: false,
            type: 'default',
            size: false,
            onBtnMinClick: function (e) {
                e.preventDefault();
            },
            onBtnMaxClick: function (e) {
                e.preventDefault();
            },
            onBtnCloseClick: function (e) {
                e.preventDefault();
            },
            onShow: function (e) {
                e.preventDefault();
            },
            onHide: function (e) {
                e.preventDefault();
            }
        },
        _create: function () {
            var element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._createWindow();
            element.data('window', this);
        },
        _createWindow: function () {
            var that = this, element = this.element, o = this.options;
            var wind = element, capt, cont;
            wind.addClass('window');
            capt = $('<div/>').addClass('window-caption');
            cont = $('<div/>').addClass('window-content');
            if (o.icon || o.title) {
                capt.appendTo(wind);
            }
            cont.appendTo(wind);
            if (typeof o.size === 'object') {
                $.each(o.size, function (key, value) {
                    cont.css(key, value);
                });
            }
            if (o.captionStyle && typeof o.captionStyle === 'object') {
                $.each(o.captionStyle, function (key, value) {
                    if (value.isColor()) {
                        capt.css(key, value + ' !important');
                    } else {
                        capt.addClass(value);
                    }
                });
            }
            if (o.contentStyle && typeof o.contentStyle === 'object') {
                $.each(o.contentStyle, function (key, value) {
                    if (value.isColor()) {
                        cont.css(key, value + ' !important');
                    } else {
                        cont.addClass(value);
                    }
                });
            }
            wind.appendTo(o.parent !== 'default' ? o.parent : element.parent());
            this.icon();
            this.title();
            this.buttons();
            this.content();
        },
        icon: function () {
            var o = this.options;
            var capt = this.element.children('.window-caption');
            var icon = capt.find('.window-caption-icon');
            if (o.icon) {
                if (icon.length === 0) {
                    $('<span/>').addClass('window-caption-icon').html(o.icon).appendTo(capt);
                } else {
                    icon.html(o.icon);
                }
            }
        },
        title: function () {
            var o = this.options;
            var capt = this.element.children('.window-caption');
            var title = capt.find('.window-caption-title');
            if (o.title) {
                if (title.length === 0) {
                    $('<span/>').addClass('window-caption-title').html(o.title).appendTo(capt);
                } else {
                    title.html(o.title);
                }
            }
        },
        buttons: function () {
            var o = this.options;
            var bMin, bMax, bClose;
            var capt = this.element.children('.window-caption');
            if (capt.length === 0) {
                return;
            }
            if (o.buttons) {
                var btnMin = o.buttons.btnMin;
                var btnMax = o.buttons.btnMax;
                var btnClose = o.buttons.btnClose;
                if (btnMin && btnMin !== false) {
                    bMin = $('<span/>').addClass('btn-min').appendTo(capt);
                    if (typeof btnMin === 'object') {
                        bMin.css(btnMin);
                    }
                    if (typeof o.onBtnMinClick === 'string') {
                        var bMinFn = window[o.onBtnMinClick];
                        bMin.on('click', bMinFn);
                    } else {
                        bMin.on('click', o.onBtnMinClick(e));
                    }
                }
                if (btnMax && btnMax !== false) {
                    bMax = $('<span/>').addClass('btn-max').appendTo(capt);
                    if (typeof btnMax === 'object') {
                        bMax.css(btnMax);
                    }
                    if (typeof o.onBtnMaxClick === 'string') {
                        var bMaxFn = window[o.onBtnMaxClick];
                        bMax.on('click', bMaxFn);
                    } else {
                        bMax.on('click', o.onBtnMaxClick(e));
                    }
                }
                if (btnClose && btnClose !== false) {
                    bClose = $('<span/>').addClass('btn-close').appendTo(capt);
                    if (typeof btnClose === 'object') {
                        bClose.css(btnClose);
                    }
                    if (typeof o.onBtnCloseClick === 'string') {
                        var bCloseFn = window[o.onBtnCloseClick];
                        bClose.on('click', bCloseFn);
                    } else {
                        bClose.on('click', o.onBtnCloseClick(e));
                    }
                }
            }
        },
        content: function () {
            var o = this.options;
            var c = o.content;
            var content = this.element.children('.window-content');
            if (!c) {
                return;
            }
            if (c.isUrl()) {
                if (c.indexOf('youtube') > -1) {
                    var iframe = $('<iframe>');
                    var video_container = $('<div/>').addClass('video-container').appendTo(content);
                    iframe.attr('src', c).attr('frameborder', '0');
                    iframe.appendTo(video_container);
                }
            } else {
                content.html(c);
            }
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.wizard', {
        version: '3.0.0',
        options: {
            stepper: true,
            stepperType: 'default',
            stepperClickable: false,
            startPage: 'default',
            finishStep: 'default',
            locale: window.METRO_CURRENT_LOCALE,
            buttons: {
                cancel: true,
                help: true,
                prior: true,
                next: true,
                finish: true
            },
            onCancel: function (page, wiz) {
            },
            onHelp: function (page, wiz) {
            },
            onPrior: function (page, wiz) {
                return true;
            },
            onNext: function (page, wiz) {
                return true;
            },
            onFinish: function (page, wiz) {
            },
            onPage: function (page, wiz) {
            },
            onStepClick: function (step) {
            }
        },
        _stepper: undefined,
        _currentStep: 0,
        _steps: undefined,
        _create: function () {
            var that = this, element = this.element, o = this.options, steps = element.find('.step');
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._steps = steps;
            if (o.stepper) {
                this._stepper = this._createStepper(steps.length).insertBefore(element.find('.steps')).stepper({ clickable: o.stepperClickable }).on('stepclick', function (e, s) {
                    that.stepTo(s);
                    if (typeof o.onStepClick === 'function') {
                        o.onStepClick(s);
                    } else {
                        if (typeof window[o.onStepClick] === 'function') {
                            window[o.onStepClick](s);
                        } else {
                            var result = eval('(function(){' + o.onStepClick + '})');
                            result.call(s);
                        }
                    }
                });
            }
            if (element.data('locale') !== undefined) {
                o.locale = element.data('locale');
            }
            this._createEvents();
            var sp = o.startPage !== 'default' && parseInt(o.startPage) > 1 ? o.startPage : 1;
            this.stepTo(sp);
            if (typeof o.onPage === 'string') {
                window[o.onPage](this._currentStep + 1, element);
            } else {
                o.onPage(this._currentStep + 1, element);
            }
            element.data('wizard', this);
        },
        _createStepper: function (steps) {
            var stepper, o = this.options;
            stepper = $('<div/>').addClass('stepper').attr('data-role', 'stepper').attr('data-steps', steps);
            if (o.stepperType !== 'default') {
                stepper.addClass(o.stepperType);
            }
            return stepper;
        },
        _createEvents: function () {
            var that = this, element = this.element, o = this.options;
            if (o.buttons) {
                var actions = $('<div/>').addClass('actions').appendTo(element);
                var group_left = $('<div/>').addClass('group-left').appendTo(actions);
                var group_right = $('<div/>').addClass('group-right').appendTo(actions);
                var cancel_button, help_button, prior_button, next_button, finish_button;
                if (o.buttons.cancel) {
                    cancel_button = $('<button type=\'button\'/>').addClass('btn-cancel').html(window.METRO_LOCALES[o.locale].buttons[2]);
                    if (typeof o.buttons.cancel === 'boolean') {
                        cancel_button.appendTo(group_left);
                    } else {
                        if (o.buttons.cancel.title) {
                            cancel_button.html(o.buttons.cancel.title);
                        }
                        if (o.buttons.cancel.cls) {
                            cancel_button.addClass(o.buttons.cancel.cls);
                        }
                        if (o.buttons.cancel.group && o.buttons.cancel.group !== 'left') {
                            cancel_button.appendTo(group_right);
                        } else {
                            cancel_button.appendTo(group_left);
                        }
                    }
                    cancel_button.on('click', function () {
                        if (typeof o.onCancel === 'function') {
                            o.onCancel(that._currentStep + 1, element);
                        } else {
                            if (typeof window[o.onCancel] === 'function') {
                                window[o.onCancel](that._currentStep + 1, element);
                            } else {
                                var result = eval('(function(){' + o.onCancel + '})');
                                result.call(that._currentStep + 1, element);
                            }
                        }
                    });
                }
                if (o.buttons.help) {
                    help_button = $('<button type=\'button\'/>').addClass('btn-help').html(window.METRO_LOCALES[o.locale].buttons[3]);
                    if (typeof o.buttons.help === 'boolean') {
                        help_button.appendTo(group_right);
                    } else {
                        if (o.buttons.help.title) {
                            help_button.html(o.buttons.help.title);
                        }
                        if (o.buttons.help.cls) {
                            help_button.addClass(o.buttons.help.cls);
                        }
                        if (o.buttons.help.group && o.buttons.help.group !== 'left') {
                            help_button.appendTo(group_right);
                        } else {
                            help_button.appendTo(group_left);
                        }
                    }
                    help_button.on('click', function () {
                        if (typeof o.onHelp === 'function') {
                            o.onHelp(that._currentStep + 1, element);
                        } else {
                            if (typeof window[o.onHelp] === 'function') {
                                window[o.onHelp](that._currentStep + 1, element);
                            } else {
                                var result = eval('(function(){' + o.onHelp + '})');
                                result.call(that._currentStep + 1, element);
                            }
                        }
                    });
                }
                if (o.buttons.prior) {
                    prior_button = $('<button type=\'button\'/>').addClass('btn-prior').html(window.METRO_LOCALES[o.locale].buttons[4]);
                    if (typeof o.buttons.prior === 'boolean') {
                        prior_button.appendTo(group_right);
                    } else {
                        if (o.buttons.prior.title) {
                            prior_button.html(o.buttons.prior.title);
                        }
                        if (o.buttons.prior.cls) {
                            prior_button.addClass(o.buttons.prior.cls);
                        }
                        if (o.buttons.prior.group && o.buttons.prior.group !== 'left') {
                            prior_button.appendTo(group_right);
                        } else {
                            prior_button.appendTo(group_left);
                        }
                    }
                    prior_button.on('click', function () {
                        if (typeof o.onPrior === 'function') {
                            if (o.onPrior(that._currentStep + 1, element)) {
                                that.prior();
                            }
                        } else {
                            if (typeof window[o.onPrior] === 'function') {
                                if (window[o.onPrior](that._currentStep + 1, element)) {
                                    that.prior();
                                }
                            } else {
                                var result = eval('(function(){' + o.onPrior + '})');
                                if (result.call(that._currentStep + 1, element)) {
                                    that.prior();
                                }
                            }
                        }
                    });
                }
                if (o.buttons.next) {
                    next_button = $('<button type=\'button\'/>').addClass('btn-next').html(window.METRO_LOCALES[o.locale].buttons[5]);
                    if (typeof o.buttons.next === 'boolean') {
                        next_button.appendTo(group_right);
                    } else {
                        if (o.buttons.next.title) {
                            next_button.html(o.buttons.next.title);
                        }
                        if (o.buttons.next.cls) {
                            next_button.addClass(o.buttons.next.cls);
                        }
                        if (o.buttons.next.group && o.buttons.next.group !== 'left') {
                            next_button.appendTo(group_right);
                        } else {
                            next_button.appendTo(group_left);
                        }
                    }
                    next_button.on('click', function () {
                        if (typeof o.onNext === 'function') {
                            if (o.onNext(that._currentStep + 1, element)) {
                                that.next();
                            }
                        } else {
                            if (typeof window[o.onNext] === 'function') {
                                if (window[o.onNext](that._currentStep + 1, element)) {
                                    that.next();
                                }
                            } else {
                                var result = eval('(function(){' + o.onNext + '})');
                                if (result.call(that._currentStep + 1, element)) {
                                    that.next();
                                }
                            }
                        }
                    });
                }
                if (o.buttons.finish) {
                    finish_button = $('<button type=\'button\'/>').addClass('btn-finish').html(window.METRO_LOCALES[o.locale].buttons[6]);
                    if (typeof o.buttons.finish === 'boolean') {
                        finish_button.appendTo(group_right);
                    } else {
                        if (o.buttons.finish.title) {
                            finish_button.html(o.buttons.finish.title);
                        }
                        if (o.buttons.finish.cls) {
                            finish_button.addClass(o.buttons.finish.cls);
                        }
                        if (o.buttons.finish.group && o.buttons.finish.group !== 'left') {
                            finish_button.appendTo(group_right);
                        } else {
                            finish_button.appendTo(group_left);
                        }
                    }
                    finish_button.on('click', function () {
                        if (typeof o.onFinish === 'function') {
                            o.onFinish(that._currentStep + 1, element);
                        } else {
                            if (typeof window[o.onFinish] === 'function') {
                                window[o.onFinish](that._currentStep + 1, element);
                            } else {
                                var result = eval('(function(){' + o.onFinish + '})');
                                result.call(that._currentStep + 1, element);
                            }
                        }
                    });
                }
            }
        },
        next: function () {
            var element = this.element, that = this, o = this.options;
            var new_step = this._currentStep + 1;
            if (new_step === this._steps.length) {
                return false;
            }
            this._currentStep = new_step;
            this._steps.hide();
            $(this._steps[new_step]).show();
            if (typeof o.onPage === 'function') {
                o.onPage(that._currentStep + 1, element);
            } else {
                if (typeof window[o.onPage] === 'function') {
                    window[o.onPage](that._currentStep + 1, element);
                } else {
                    var result = eval('(function(){' + o.onPage + '})');
                    result.call(that._currentStep + 1, element);
                }
            }
            if (this._stepper !== undefined) {
                this._stepper.stepper('stepTo', this._currentStep + 1);
            }
            var finish = o.finishStep === 'default' ? this._steps.length - 1 : o.finishStep;
            if (new_step === finish) {
                this.element.find('.btn-finish').attr('disabled', false);
            } else {
                this.element.find('.btn-finish').attr('disabled', true);
            }
            if (new_step === this._steps.length - 1) {
                this.element.find('.btn-next').attr('disabled', true);
            } else {
                this.element.find('.btn-next').attr('disabled', false);
            }
            if (new_step > 0) {
                this.element.find('.btn-prior').attr('disabled', false);
            }
            return true;
        },
        prior: function () {
            var element = this.element, that = this, new_step = this._currentStep - 1;
            var o = this.options;
            if (new_step < 0) {
                return false;
            }
            this._currentStep = new_step;
            this._steps.hide();
            $(this._steps[new_step]).show();
            if (typeof o.onPage === 'function') {
                o.onPage(that._currentStep + 1, element);
            } else {
                if (typeof window[o.onPage] === 'function') {
                    window[o.onPage](that._currentStep + 1, element);
                } else {
                    var result = eval('(function(){' + o.onPage + '})');
                    result.call(that._currentStep + 1, element);
                }
            }
            if (this._stepper !== undefined) {
                this._stepper.stepper('stepTo', this._currentStep + 1);
            }
            var finish = o.finishStep === 'default' ? this._steps.length - 1 : o.finishStep;
            if (new_step === finish) {
                this.element.find('.btn-finish').attr('disabled', false);
            } else {
                this.element.find('.btn-finish').attr('disabled', true);
            }
            if (new_step === 0) {
                this.element.find('.btn-prior').attr('disabled', true);
            } else {
                this.element.find('.btn-prior').attr('disabled', false);
            }
            if (new_step < finish) {
                this.element.find('.btn-next').attr('disabled', false);
            }
            return true;
        },
        stepTo: function (step) {
            var element = this.element, that = this, new_step = step - 1;
            var o = this.options;
            if (new_step < 0) {
                return false;
            }
            this._currentStep = new_step;
            this._steps.hide();
            $(this._steps[new_step]).show();
            if (typeof o.onPage === 'function') {
                o.onPage(that._currentStep + 1, element);
            } else {
                if (typeof window[o.onPage] === 'function') {
                    window[o.onPage](that._currentStep + 1, element);
                } else {
                    var result = eval('(function(){' + o.onPage + '})');
                    result.call(that._currentStep + 1, element);
                }
            }
            if (this._stepper !== undefined) {
                this._stepper.stepper('stepTo', step);
            }
            var finish = o.finishStep === 'default' ? this._steps.length - 1 : o.finishStep;
            if (new_step === finish) {
                this.element.find('.btn-finish').attr('disabled', false);
            } else {
                this.element.find('.btn-finish').attr('disabled', true);
            }
            this.element.find('.btn-next').attr('disabled', new_step >= finish);
            this.element.find('.btn-prior').attr('disabled', new_step <= 0);
            return true;
        },
        stepper: function () {
            return this._stepper;
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    $.widget('metro.wizard2', {
        version: '3.0.0',
        options: {
            start: 1,
            finish: 'default',
            buttonLabels: {
                prev: '&lt;',
                next: '&gt;',
                finish: 'OK',
                help: '?'
            },
            onPrior: function (page, wiz) {
                return true;
            },
            onNext: function (page, wiz) {
                return true;
            },
            onFinish: function (page, wiz) {
            },
            onHelp: function (page, wiz) {
            },
            onPage: function (page, wiz) {
            }
        },
        _step: 1,
        _steps: undefined,
        _create: function () {
            var that = this, element = this.element, o = this.options;
            $.each(element.data(), function (key, value) {
                if (key in o) {
                    try {
                        o[key] = $.parseJSON(value);
                    } catch (e) {
                        o[key] = value;
                    }
                }
            });
            this._step = o.start;
            this._steps = element.children('.step');
            this._height = 0;
            this._width = 0;
            if (o.finish === 'default') {
                o.finish = this._steps.length;
            }
            $.each(this._steps, function (i, v) {
                if ($(v).outerHeight() > that._height) {
                    that._height = $(v).outerHeight();
                }
                if ($(v).hasClass('active')) {
                    that._step = i + 1;
                }
            });
            this._width = element.innerWidth() - ((this._steps.length - 1) * 24 + this._steps.length);
            element.children('.step').css({ height: this._height + 48 });
            $(window).resize(function () {
                that._width = element.innerWidth() - ((that._steps.length - 1) * 24 + that._steps.length);
                that.step(that._step);
            });
            this._createActionBar();
            this.step(o.start);
            this._placeActionBar();
            element.data('wizard2', this);
        },
        _createActionBar: function () {
            var that = this, element = this.element, o = this.options;
            var bar = $('<div/>').addClass('action-bar').appendTo(element);
            var btn_prev, btn_next, btn_help, btn_finish;
            btn_help = $('<button/>').html(o.buttonLabels.help).addClass('button cycle-button medium-button wiz-btn-help place-left').appendTo(bar);
            btn_finish = $('<button/>').html(o.buttonLabels.finish).addClass('button cycle-button medium-button wiz-btn-finish place-right').appendTo(bar);
            btn_next = $('<button/>').html(o.buttonLabels.next).addClass('button cycle-button medium-button wiz-btn-next place-right').appendTo(bar);
            btn_prev = $('<button/>').html(o.buttonLabels.prev).addClass('button cycle-button medium-button wiz-btn-prev place-right').appendTo(bar);
            btn_help.on('click', function () {
                if (typeof o.onHelp === 'function') {
                    o.onHelp(that._step, that);
                } else {
                    if (typeof window[o.onHelp] === 'function') {
                        window[o.onHelp](that._step, that);
                    } else {
                        var result = eval('(function(){' + o.onHelp + '})');
                        result.call(that._step, that);
                    }
                }
            });
            btn_finish.on('click', function () {
                if (typeof o.onFinish === 'function') {
                    o.onFinish(that._step, that);
                } else {
                    if (typeof window[o.onFinish] === 'function') {
                        window[o.onFinish](that._step, that);
                    } else {
                        var result = eval('(function(){' + o.onFinish + '})');
                        result.call(that._step, that);
                    }
                }
            });
            btn_prev.on('click', function () {
                if (typeof o.onPrior === 'function') {
                    if (o.onPrior(that._step, element)) {
                        that.prior();
                    }
                } else {
                    if (typeof window[o.onPrior] === 'function') {
                        if (window[o.onPrior](that._step, element)) {
                            that.prior();
                        }
                    } else {
                        var result = eval('(function(){' + o.onPrior + '})');
                        if (result.call(that._step, element)) {
                            that.prior();
                        }
                    }
                }
            });
            btn_next.on('click', function () {
                if (typeof o.onNext === 'function') {
                    if (o.onNext(that._step, element)) {
                        that.next();
                    }
                } else {
                    if (typeof window[o.onNext] === 'function') {
                        if (window[o.onNext](that._step, element)) {
                            that.next();
                        }
                    } else {
                        var result = eval('(function(){' + o.onNext + '})');
                        if (result.call(that._step, element)) {
                            that.next();
                        }
                    }
                }
            });
        },
        _placeActionBar: function () {
            var element = this.element, o = this.options;
            var action_bar = element.find('.action-bar');
            var curr_frame = element.find('.step.active');
            var left = curr_frame.position().left, right = curr_frame.innerWidth();
            action_bar.css({
                left: left,
                width: right
            });
        },
        step: function (index) {
            var o = this.options;
            this.element.children('.step').removeClass('active prev next');
            $(this.element.children('.step')[index - 1]).addClass('active').css('width', this._width);
            this.element.children('.step.active').prevAll().addClass('prev').css('width', 0);
            this.element.children('.step.active').nextAll().addClass('next').css('width', 0);
            this._placeActionBar();
            if (index === 1) {
                this.element.find('.wiz-btn-prev').hide();
            } else {
                this.element.find('.wiz-btn-prev').show();
            }
            if (index === this._steps.length) {
                this.element.find('.wiz-btn-next').hide();
            } else {
                this.element.find('.wiz-btn-next').show();
            }
            if (index !== o.finish) {
                this.element.find('.wiz-btn-finish').hide();
            } else {
                this.element.find('.wiz-btn-finish').show();
            }
        },
        prior: function () {
            var new_step = this._step - 1;
            if (new_step <= 0) {
                return false;
            }
            this._step = new_step;
            this.step(new_step);
            return true;
        },
        next: function () {
            var new_step = this._step + 1;
            if (new_step > this._steps.length) {
                return false;
            }
            this._step = new_step;
            this.step(new_step);
            return true;
        },
        _destroy: function () {
        },
        _setOption: function (key, value) {
            this._super('_setOption', key, value);
        }
    });
    return $.Metro.init();
}));
(function webpackUniversalModuleDefinition(root, factory) {
    if (typeof exports === 'object' && typeof module === 'object')
        module.exports = factory();
    else if (typeof define === 'function' && define.amd)
        define('echarts', [], factory);
    else if (typeof exports === 'object')
        exports['echarts'] = factory();
    else
        root['echarts'] = factory();
}(this, function () {
    return function (modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
                return installedModules[moduleId].exports;
            var module = installedModules[moduleId] = {
                exports: {},
                id: moduleId,
                loaded: false
            };
            modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
            module.loaded = true;
            return module.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = '';
        return __webpack_require__(0);
    }([
        function (module, exports, __webpack_require__) {
            module.exports = __webpack_require__(1);
            __webpack_require__(91);
            __webpack_require__(127);
            __webpack_require__(132);
            __webpack_require__(141);
            __webpack_require__(145);
            __webpack_require__(155);
            __webpack_require__(177);
            __webpack_require__(189);
            __webpack_require__(207);
            __webpack_require__(211);
            __webpack_require__(215);
            __webpack_require__(230);
            __webpack_require__(236);
            __webpack_require__(243);
            __webpack_require__(249);
            __webpack_require__(253);
            __webpack_require__(258);
            __webpack_require__(106);
            __webpack_require__(262);
            __webpack_require__(268);
            __webpack_require__(272);
            __webpack_require__(283);
            __webpack_require__(216);
            __webpack_require__(285);
            __webpack_require__(286);
            __webpack_require__(300);
            __webpack_require__(315);
            __webpack_require__(319);
            __webpack_require__(322);
            __webpack_require__(331);
            __webpack_require__(345);
        },
        function (module, exports, __webpack_require__) {
            var GlobalModel = __webpack_require__(2);
            var ExtensionAPI = __webpack_require__(24);
            var CoordinateSystemManager = __webpack_require__(25);
            var OptionManager = __webpack_require__(26);
            var ComponentModel = __webpack_require__(19);
            var SeriesModel = __webpack_require__(27);
            var ComponentView = __webpack_require__(28);
            var ChartView = __webpack_require__(41);
            var graphic = __webpack_require__(42);
            var zrender = __webpack_require__(77);
            var zrUtil = __webpack_require__(3);
            var colorTool = __webpack_require__(38);
            var env = __webpack_require__(78);
            var Eventful = __webpack_require__(32);
            var each = zrUtil.each;
            var VISUAL_CODING_STAGES = [
                'echarts',
                'chart',
                'component'
            ];
            var PROCESSOR_STAGES = [
                'transform',
                'filter',
                'statistic'
            ];
            function createRegisterEventWithLowercaseName(method) {
                return function (eventName, handler, context) {
                    eventName = eventName && eventName.toLowerCase();
                    Eventful.prototype[method].call(this, eventName, handler, context);
                };
            }
            function MessageCenter() {
                Eventful.call(this);
            }
            MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');
            MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');
            MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');
            zrUtil.mixin(MessageCenter, Eventful);
            function ECharts(dom, theme, opts) {
                opts = opts || {};
                if (typeof theme === 'string') {
                    theme = themeStorage[theme];
                }
                if (theme) {
                    each(optionPreprocessorFuncs, function (preProcess) {
                        preProcess(theme);
                    });
                }
                this.id;
                this.group;
                this._dom = dom;
                this._zr = zrender.init(dom, {
                    renderer: opts.renderer || 'canvas',
                    devicePixelRatio: opts.devicePixelRatio
                });
                this._theme = zrUtil.clone(theme);
                this._chartsViews = [];
                this._chartsMap = {};
                this._componentsViews = [];
                this._componentsMap = {};
                this._api = new ExtensionAPI(this);
                this._coordSysMgr = new CoordinateSystemManager();
                Eventful.call(this);
                this._messageCenter = new MessageCenter();
                this._initEvents();
                this.resize = zrUtil.bind(this.resize, this);
            }
            var echartsProto = ECharts.prototype;
            echartsProto.getDom = function () {
                return this._dom;
            };
            echartsProto.getZr = function () {
                return this._zr;
            };
            echartsProto.setOption = function (option, notMerge, notRefreshImmediately) {
                if (!this._model || notMerge) {
                    this._model = new GlobalModel(null, null, this._theme, new OptionManager(this._api));
                }
                this._model.setOption(option, optionPreprocessorFuncs);
                updateMethods.prepareAndUpdate.call(this);
                !notRefreshImmediately && this._zr.refreshImmediately();
            };
            echartsProto.setTheme = function () {
                console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
            };
            echartsProto.getModel = function () {
                return this._model;
            };
            echartsProto.getOption = function () {
                return this._model.getOption();
            };
            echartsProto.getWidth = function () {
                return this._zr.getWidth();
            };
            echartsProto.getHeight = function () {
                return this._zr.getHeight();
            };
            echartsProto.getRenderedCanvas = function (opts) {
                if (!env.canvasSupported) {
                    return;
                }
                opts = opts || {};
                opts.pixelRatio = opts.pixelRatio || 1;
                opts.backgroundColor = opts.backgroundColor || this._model.get('backgroundColor');
                var zr = this._zr;
                var list = zr.storage.getDisplayList();
                zrUtil.each(list, function (el) {
                    el.stopAnimation(true);
                });
                return zr.painter.getRenderedCanvas(opts);
            };
            echartsProto.getDataURL = function (opts) {
                opts = opts || {};
                var excludeComponents = opts.excludeComponents;
                var ecModel = this._model;
                var excludesComponentViews = [];
                var self = this;
                each(excludeComponents, function (componentType) {
                    ecModel.eachComponent({ mainType: componentType }, function (component) {
                        var view = self._componentsMap[component.__viewId];
                        if (!view.group.ignore) {
                            excludesComponentViews.push(view);
                            view.group.ignore = true;
                        }
                    });
                });
                var url = this.getRenderedCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'));
                each(excludesComponentViews, function (view) {
                    view.group.ignore = false;
                });
                return url;
            };
            echartsProto.getConnectedDataURL = function (opts) {
                if (!env.canvasSupported) {
                    return;
                }
                var groupId = this.group;
                var mathMin = Math.min;
                var mathMax = Math.max;
                var MAX_NUMBER = Infinity;
                if (connectedGroups[groupId]) {
                    var left = MAX_NUMBER;
                    var top = MAX_NUMBER;
                    var right = -MAX_NUMBER;
                    var bottom = -MAX_NUMBER;
                    var canvasList = [];
                    var dpr = opts && opts.pixelRatio || 1;
                    for (var id in instances) {
                        var chart = instances[id];
                        if (chart.group === groupId) {
                            var canvas = chart.getRenderedCanvas(zrUtil.clone(opts));
                            var boundingRect = chart.getDom().getBoundingClientRect();
                            left = mathMin(boundingRect.left, left);
                            top = mathMin(boundingRect.top, top);
                            right = mathMax(boundingRect.right, right);
                            bottom = mathMax(boundingRect.bottom, bottom);
                            canvasList.push({
                                dom: canvas,
                                left: boundingRect.left,
                                top: boundingRect.top
                            });
                        }
                    }
                    left *= dpr;
                    top *= dpr;
                    right *= dpr;
                    bottom *= dpr;
                    var width = right - left;
                    var height = bottom - top;
                    var targetCanvas = zrUtil.createCanvas();
                    targetCanvas.width = width;
                    targetCanvas.height = height;
                    var zr = zrender.init(targetCanvas);
                    each(canvasList, function (item) {
                        var img = new graphic.Image({
                            style: {
                                x: item.left * dpr - left,
                                y: item.top * dpr - top,
                                image: item.dom
                            }
                        });
                        zr.add(img);
                    });
                    zr.refreshImmediately();
                    return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
                } else {
                    return this.getDataURL(opts);
                }
            };
            var updateMethods = {
                update: function (payload) {
                    var ecModel = this._model;
                    var api = this._api;
                    var coordSysMgr = this._coordSysMgr;
                    if (!ecModel) {
                        return;
                    }
                    ecModel.restoreData();
                    coordSysMgr.create(this._model, this._api);
                    processData.call(this, ecModel, api);
                    stackSeriesData.call(this, ecModel);
                    coordSysMgr.update(ecModel, api);
                    doLayout.call(this, ecModel, payload);
                    doVisualCoding.call(this, ecModel, payload);
                    doRender.call(this, ecModel, payload);
                    var backgroundColor = ecModel.get('backgroundColor') || 'transparent';
                    var painter = this._zr.painter;
                    if (painter.isSingleCanvas && painter.isSingleCanvas()) {
                        this._zr.configLayer(0, { clearColor: backgroundColor });
                    } else {
                        if (!env.canvasSupported) {
                            var colorArr = colorTool.parse(backgroundColor);
                            backgroundColor = colorTool.stringify(colorArr, 'rgb');
                            if (colorArr[3] === 0) {
                                backgroundColor = 'transparent';
                            }
                        }
                        backgroundColor = backgroundColor;
                        this._dom.style.backgroundColor = backgroundColor;
                    }
                },
                updateView: function (payload) {
                    var ecModel = this._model;
                    if (!ecModel) {
                        return;
                    }
                    doLayout.call(this, ecModel, payload);
                    doVisualCoding.call(this, ecModel, payload);
                    invokeUpdateMethod.call(this, 'updateView', ecModel, payload);
                },
                updateVisual: function (payload) {
                    var ecModel = this._model;
                    if (!ecModel) {
                        return;
                    }
                    doVisualCoding.call(this, ecModel, payload);
                    invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);
                },
                updateLayout: function (payload) {
                    var ecModel = this._model;
                    if (!ecModel) {
                        return;
                    }
                    doLayout.call(this, ecModel, payload);
                    invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);
                },
                highlight: function (payload) {
                    toggleHighlight.call(this, 'highlight', payload);
                },
                downplay: function (payload) {
                    toggleHighlight.call(this, 'downplay', payload);
                },
                prepareAndUpdate: function (payload) {
                    var ecModel = this._model;
                    prepareView.call(this, 'component', ecModel);
                    prepareView.call(this, 'chart', ecModel);
                    updateMethods.update.call(this, payload);
                }
            };
            function toggleHighlight(method, payload) {
                var ecModel = this._model;
                if (!ecModel) {
                    return;
                }
                ecModel.eachComponent({
                    mainType: 'series',
                    query: payload
                }, function (seriesModel, index) {
                    var chartView = this._chartsMap[seriesModel.__viewId];
                    if (chartView && chartView.__alive) {
                        chartView[method](seriesModel, ecModel, this._api, payload);
                    }
                }, this);
            }
            echartsProto.resize = function () {
                this._zr.resize();
                var optionChanged = this._model && this._model.resetOption('media');
                updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);
                this._loadingFX && this._loadingFX.resize();
            };
            var defaultLoadingEffect = __webpack_require__(87);
            echartsProto.showLoading = function (name, cfg) {
                if (zrUtil.isObject(name)) {
                    cfg = name;
                    name = 'default';
                }
                this.hideLoading();
                var el = defaultLoadingEffect(this._api, cfg);
                var zr = this._zr;
                this._loadingFX = el;
                zr.add(el);
            };
            echartsProto.hideLoading = function () {
                this._loadingFX && this._zr.remove(this._loadingFX);
                this._loadingFX = null;
            };
            echartsProto.makeActionFromEvent = function (eventObj) {
                var payload = zrUtil.extend({}, eventObj);
                payload.type = eventActionMap[eventObj.type];
                return payload;
            };
            echartsProto.dispatchAction = function (payload, silent) {
                var actionWrap = actions[payload.type];
                if (actionWrap) {
                    var actionInfo = actionWrap.actionInfo;
                    var updateMethod = actionInfo.update || 'update';
                    var payloads = [payload];
                    var batched = false;
                    if (payload.batch) {
                        batched = true;
                        payloads = zrUtil.map(payload.batch, function (item) {
                            item = zrUtil.defaults(zrUtil.extend({}, item), payload);
                            item.batch = null;
                            return item;
                        });
                    }
                    var eventObjBatch = [];
                    var eventObj;
                    var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';
                    for (var i = 0; i < payloads.length; i++) {
                        var batchItem = payloads[i];
                        eventObj = actionWrap.action(batchItem, this._model);
                        eventObj = eventObj || zrUtil.extend({}, batchItem);
                        eventObj.type = actionInfo.event || eventObj.type;
                        eventObjBatch.push(eventObj);
                        isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);
                    }
                    updateMethod !== 'none' && !isHighlightOrDownplay && updateMethods[updateMethod].call(this, payload);
                    if (!silent) {
                        if (batched) {
                            eventObj = {
                                type: actionInfo.event || payload.type,
                                batch: eventObjBatch
                            };
                        } else {
                            eventObj = eventObjBatch[0];
                        }
                        this._messageCenter.trigger(eventObj.type, eventObj);
                    }
                }
            };
            echartsProto.on = createRegisterEventWithLowercaseName('on');
            echartsProto.off = createRegisterEventWithLowercaseName('off');
            echartsProto.one = createRegisterEventWithLowercaseName('one');
            function invokeUpdateMethod(methodName, ecModel, payload) {
                var api = this._api;
                each(this._componentsViews, function (component) {
                    var componentModel = component.__model;
                    component[methodName](componentModel, ecModel, api, payload);
                    updateZ(componentModel, component);
                }, this);
                ecModel.eachSeries(function (seriesModel, idx) {
                    var chart = this._chartsMap[seriesModel.__viewId];
                    chart[methodName](seriesModel, ecModel, api, payload);
                    updateZ(seriesModel, chart);
                }, this);
            }
            function prepareView(type, ecModel) {
                var isComponent = type === 'component';
                var viewList = isComponent ? this._componentsViews : this._chartsViews;
                var viewMap = isComponent ? this._componentsMap : this._chartsMap;
                var zr = this._zr;
                for (var i = 0; i < viewList.length; i++) {
                    viewList[i].__alive = false;
                }
                ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {
                    if (isComponent) {
                        if (componentType === 'series') {
                            return;
                        }
                    } else {
                        model = componentType;
                    }
                    var viewId = model.id + '_' + model.type;
                    var view = viewMap[viewId];
                    if (!view) {
                        var classType = ComponentModel.parseClassType(model.type);
                        var Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) : ChartView.getClass(classType.sub);
                        if (Clazz) {
                            view = new Clazz();
                            view.init(ecModel, this._api);
                            viewMap[viewId] = view;
                            viewList.push(view);
                            zr.add(view.group);
                        } else {
                            return;
                        }
                    }
                    model.__viewId = viewId;
                    view.__alive = true;
                    view.__id = viewId;
                    view.__model = model;
                }, this);
                for (var i = 0; i < viewList.length;) {
                    var view = viewList[i];
                    if (!view.__alive) {
                        zr.remove(view.group);
                        view.dispose(ecModel, this._api);
                        viewList.splice(i, 1);
                        delete viewMap[view.__id];
                    } else {
                        i++;
                    }
                }
            }
            function processData(ecModel, api) {
                each(PROCESSOR_STAGES, function (stage) {
                    each(dataProcessorFuncs[stage] || [], function (process) {
                        process(ecModel, api);
                    });
                });
            }
            function stackSeriesData(ecModel) {
                var stackedDataMap = {};
                ecModel.eachSeries(function (series) {
                    var stack = series.get('stack');
                    var data = series.getData();
                    if (stack && data.type === 'list') {
                        var previousStack = stackedDataMap[stack];
                        if (previousStack) {
                            data.stackedOn = previousStack;
                        }
                        stackedDataMap[stack] = data;
                    }
                });
            }
            function doLayout(ecModel, payload) {
                var api = this._api;
                each(layoutFuncs, function (layout) {
                    layout(ecModel, api, payload);
                });
            }
            function doVisualCoding(ecModel, payload) {
                each(VISUAL_CODING_STAGES, function (stage) {
                    each(visualCodingFuncs[stage] || [], function (visualCoding) {
                        visualCoding(ecModel, payload);
                    });
                });
            }
            function doRender(ecModel, payload) {
                var api = this._api;
                each(this._componentsViews, function (componentView) {
                    var componentModel = componentView.__model;
                    componentView.render(componentModel, ecModel, api, payload);
                    updateZ(componentModel, componentView);
                }, this);
                each(this._chartsViews, function (chart) {
                    chart.__alive = false;
                }, this);
                ecModel.eachSeries(function (seriesModel, idx) {
                    var chartView = this._chartsMap[seriesModel.__viewId];
                    chartView.__alive = true;
                    chartView.render(seriesModel, ecModel, api, payload);
                    chartView.group.silent = !!seriesModel.get('silent');
                    updateZ(seriesModel, chartView);
                }, this);
                each(this._chartsViews, function (chart) {
                    if (!chart.__alive) {
                        chart.remove(ecModel, api);
                    }
                }, this);
            }
            var MOUSE_EVENT_NAMES = [
                'click',
                'dblclick',
                'mouseover',
                'mouseout',
                'mousedown',
                'mouseup',
                'globalout'
            ];
            echartsProto._initEvents = function () {
                var zr = this._zr;
                each(MOUSE_EVENT_NAMES, function (eveName) {
                    zr.on(eveName, function (e) {
                        var ecModel = this.getModel();
                        var el = e.target;
                        if (el && el.dataIndex != null) {
                            var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
                            var params = dataModel && dataModel.getDataParams(el.dataIndex) || {};
                            params.event = e;
                            params.type = eveName;
                            this.trigger(eveName, params);
                        } else if (el && el.eventData) {
                            this.trigger(eveName, el.eventData);
                        }
                    }, this);
                }, this);
                each(eventActionMap, function (actionType, eventType) {
                    this._messageCenter.on(eventType, function (event) {
                        this.trigger(eventType, event);
                    }, this);
                }, this);
            };
            echartsProto.isDisposed = function () {
                return this._disposed;
            };
            echartsProto.clear = function () {
                this.setOption({}, true);
            };
            echartsProto.dispose = function () {
                this._disposed = true;
                var api = this._api;
                var ecModel = this._model;
                each(this._componentsViews, function (component) {
                    component.dispose(ecModel, api);
                });
                each(this._chartsViews, function (chart) {
                    chart.dispose(ecModel, api);
                });
                this._zr.dispose();
                delete instances[this.id];
            };
            zrUtil.mixin(ECharts, Eventful);
            function updateZ(model, view) {
                var z = model.get('z');
                var zlevel = model.get('zlevel');
                view.group.traverse(function (el) {
                    z != null && (el.z = z);
                    zlevel != null && (el.zlevel = zlevel);
                });
            }
            var actions = [];
            var eventActionMap = {};
            var layoutFuncs = [];
            var dataProcessorFuncs = {};
            var optionPreprocessorFuncs = [];
            var visualCodingFuncs = {};
            var themeStorage = {};
            var instances = {};
            var connectedGroups = {};
            var idBase = new Date() - 0;
            var groupIdBase = new Date() - 0;
            var DOM_ATTRIBUTE_KEY = '_echarts_instance_';
            var echarts = {
                version: '3.1.7',
                dependencies: { zrender: '3.0.8' }
            };
            function enableConnect(chart) {
                var STATUS_PENDING = 0;
                var STATUS_UPDATING = 1;
                var STATUS_UPDATED = 2;
                var STATUS_KEY = '__connectUpdateStatus';
                function updateConnectedChartsStatus(charts, status) {
                    for (var i = 0; i < charts.length; i++) {
                        var otherChart = charts[i];
                        otherChart[STATUS_KEY] = status;
                    }
                }
                zrUtil.each(eventActionMap, function (actionType, eventType) {
                    chart._messageCenter.on(eventType, function (event) {
                        if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
                            var action = chart.makeActionFromEvent(event);
                            var otherCharts = [];
                            for (var id in instances) {
                                var otherChart = instances[id];
                                if (otherChart !== chart && otherChart.group === chart.group) {
                                    otherCharts.push(otherChart);
                                }
                            }
                            updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
                            each(otherCharts, function (otherChart) {
                                if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
                                    otherChart.dispatchAction(action);
                                }
                            });
                            updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
                        }
                    });
                });
            }
            echarts.init = function (dom, theme, opts) {
                if (zrender.version.replace('.', '') - 0 < echarts.dependencies.zrender.replace('.', '') - 0) {
                    throw new Error('ZRender ' + zrender.version + ' is too old for ECharts ' + echarts.version + '. Current version need ZRender ' + echarts.dependencies.zrender + '+');
                }
                if (!dom) {
                    throw new Error('Initialize failed: invalid dom.');
                }
                var chart = new ECharts(dom, theme, opts);
                chart.id = 'ec_' + idBase++;
                instances[chart.id] = chart;
                dom.setAttribute && dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);
                enableConnect(chart);
                return chart;
            };
            echarts.connect = function (groupId) {
                if (zrUtil.isArray(groupId)) {
                    var charts = groupId;
                    groupId = null;
                    zrUtil.each(charts, function (chart) {
                        if (chart.group != null) {
                            groupId = chart.group;
                        }
                    });
                    groupId = groupId || 'g_' + groupIdBase++;
                    zrUtil.each(charts, function (chart) {
                        chart.group = groupId;
                    });
                }
                connectedGroups[groupId] = true;
                return groupId;
            };
            echarts.disConnect = function (groupId) {
                connectedGroups[groupId] = false;
            };
            echarts.dispose = function (chart) {
                if (zrUtil.isDom(chart)) {
                    chart = echarts.getInstanceByDom(chart);
                } else if (typeof chart === 'string') {
                    chart = instances[chart];
                }
                if (chart instanceof ECharts && !chart.isDisposed()) {
                    chart.dispose();
                }
            };
            echarts.getInstanceByDom = function (dom) {
                var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
                return instances[key];
            };
            echarts.getInstanceById = function (key) {
                return instances[key];
            };
            echarts.registerTheme = function (name, theme) {
                themeStorage[name] = theme;
            };
            echarts.registerPreprocessor = function (preprocessorFunc) {
                optionPreprocessorFuncs.push(preprocessorFunc);
            };
            echarts.registerProcessor = function (stage, processorFunc) {
                if (zrUtil.indexOf(PROCESSOR_STAGES, stage) < 0) {
                    throw new Error('stage should be one of ' + PROCESSOR_STAGES);
                }
                var funcs = dataProcessorFuncs[stage] || (dataProcessorFuncs[stage] = []);
                funcs.push(processorFunc);
            };
            echarts.registerAction = function (actionInfo, eventName, action) {
                if (typeof eventName === 'function') {
                    action = eventName;
                    eventName = '';
                }
                var actionType = zrUtil.isObject(actionInfo) ? actionInfo.type : [
                    actionInfo,
                    actionInfo = { event: eventName }
                ][0];
                actionInfo.event = (actionInfo.event || actionType).toLowerCase();
                eventName = actionInfo.event;
                if (!actions[actionType]) {
                    actions[actionType] = {
                        action: action,
                        actionInfo: actionInfo
                    };
                }
                eventActionMap[eventName] = actionType;
            };
            echarts.registerCoordinateSystem = function (type, CoordinateSystem) {
                CoordinateSystemManager.register(type, CoordinateSystem);
            };
            echarts.registerLayout = function (layout) {
                if (zrUtil.indexOf(layoutFuncs, layout) < 0) {
                    layoutFuncs.push(layout);
                }
            };
            echarts.registerVisualCoding = function (stage, visualCodingFunc) {
                if (zrUtil.indexOf(VISUAL_CODING_STAGES, stage) < 0) {
                    throw new Error('stage should be one of ' + VISUAL_CODING_STAGES);
                }
                var funcs = visualCodingFuncs[stage] || (visualCodingFuncs[stage] = []);
                funcs.push(visualCodingFunc);
            };
            echarts.extendChartView = function (opts) {
                return ChartView.extend(opts);
            };
            echarts.extendComponentModel = function (opts) {
                return ComponentModel.extend(opts);
            };
            echarts.extendSeriesModel = function (opts) {
                return SeriesModel.extend(opts);
            };
            echarts.extendComponentView = function (opts) {
                return ComponentView.extend(opts);
            };
            echarts.setCanvasCreator = function (creator) {
                zrUtil.createCanvas = creator;
            };
            echarts.registerVisualCoding('echarts', zrUtil.curry(__webpack_require__(88), '', 'itemStyle'));
            echarts.registerPreprocessor(__webpack_require__(89));
            echarts.registerAction({
                type: 'highlight',
                event: 'highlight',
                update: 'highlight'
            }, zrUtil.noop);
            echarts.registerAction({
                type: 'downplay',
                event: 'downplay',
                update: 'downplay'
            }, zrUtil.noop);
            echarts.graphic = __webpack_require__(42);
            echarts.number = __webpack_require__(7);
            echarts.format = __webpack_require__(6);
            echarts.matrix = __webpack_require__(17);
            echarts.vector = __webpack_require__(16);
            echarts.util = {};
            each([
                'map',
                'each',
                'filter',
                'indexOf',
                'inherits',
                'reduce',
                'filter',
                'bind',
                'curry',
                'isArray',
                'isString',
                'isObject',
                'isFunction',
                'extend'
            ], function (name) {
                echarts.util[name] = zrUtil[name];
            });
            module.exports = echarts;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var modelUtil = __webpack_require__(5);
            var Model = __webpack_require__(8);
            var each = zrUtil.each;
            var filter = zrUtil.filter;
            var map = zrUtil.map;
            var isArray = zrUtil.isArray;
            var indexOf = zrUtil.indexOf;
            var isObject = zrUtil.isObject;
            var ComponentModel = __webpack_require__(19);
            var globalDefault = __webpack_require__(23);
            var OPTION_INNER_KEY = '\0_ec_inner';
            var GlobalModel = Model.extend({
                constructor: GlobalModel,
                init: function (option, parentModel, theme, optionManager) {
                    theme = theme || {};
                    this.option = null;
                    this._theme = new Model(theme);
                    this._optionManager = optionManager;
                },
                setOption: function (option, optionPreprocessorFuncs) {
                    zrUtil.assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');
                    this._optionManager.setOption(option, optionPreprocessorFuncs);
                    this.resetOption();
                },
                resetOption: function (type) {
                    var optionChanged = false;
                    var optionManager = this._optionManager;
                    if (!type || type === 'recreate') {
                        var baseOption = optionManager.mountOption(type === 'recreate');
                        if (!this.option || type === 'recreate') {
                            initBase.call(this, baseOption);
                        } else {
                            this.restoreData();
                            this.mergeOption(baseOption);
                        }
                        optionChanged = true;
                    }
                    if (type === 'timeline' || type === 'media') {
                        this.restoreData();
                    }
                    if (!type || type === 'recreate' || type === 'timeline') {
                        var timelineOption = optionManager.getTimelineOption(this);
                        timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
                    }
                    if (!type || type === 'recreate' || type === 'media') {
                        var mediaOptions = optionManager.getMediaOption(this, this._api);
                        if (mediaOptions.length) {
                            each(mediaOptions, function (mediaOption) {
                                this.mergeOption(mediaOption, optionChanged = true);
                            }, this);
                        }
                    }
                    return optionChanged;
                },
                mergeOption: function (newOption) {
                    var option = this.option;
                    var componentsMap = this._componentsMap;
                    var newCptTypes = [];
                    each(newOption, function (componentOption, mainType) {
                        if (componentOption == null) {
                            return;
                        }
                        if (!ComponentModel.hasClass(mainType)) {
                            option[mainType] = option[mainType] == null ? zrUtil.clone(componentOption) : zrUtil.merge(option[mainType], componentOption, true);
                        } else {
                            newCptTypes.push(mainType);
                        }
                    });
                    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);
                    function visitComponent(mainType, dependencies) {
                        var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);
                        var mapResult = modelUtil.mappingToExists(componentsMap[mainType], newCptOptionList);
                        makeKeyInfo(mainType, mapResult);
                        var dependentModels = getComponentsByTypes(componentsMap, dependencies);
                        option[mainType] = [];
                        componentsMap[mainType] = [];
                        each(mapResult, function (resultItem, index) {
                            var componentModel = resultItem.exist;
                            var newCptOption = resultItem.option;
                            zrUtil.assert(isObject(newCptOption) || componentModel, 'Empty component definition');
                            if (!newCptOption) {
                                componentModel.mergeOption({}, this);
                                componentModel.optionUpdated(this);
                            } else {
                                var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);
                                if (componentModel && componentModel instanceof ComponentModelClass) {
                                    componentModel.mergeOption(newCptOption, this);
                                    componentModel.optionUpdated(this);
                                } else {
                                    componentModel = new ComponentModelClass(newCptOption, this, this, zrUtil.extend({
                                        dependentModels: dependentModels,
                                        componentIndex: index
                                    }, resultItem.keyInfo));
                                    componentModel.optionUpdated(this);
                                }
                            }
                            componentsMap[mainType][index] = componentModel;
                            option[mainType][index] = componentModel.option;
                        }, this);
                        if (mainType === 'series') {
                            this._seriesIndices = createSeriesIndices(componentsMap.series);
                        }
                    }
                },
                getOption: function () {
                    var option = zrUtil.clone(this.option);
                    each(option, function (opts, mainType) {
                        if (ComponentModel.hasClass(mainType)) {
                            var opts = modelUtil.normalizeToArray(opts);
                            for (var i = opts.length - 1; i >= 0; i--) {
                                if (modelUtil.isIdInner(opts[i])) {
                                    opts.splice(i, 1);
                                }
                            }
                            option[mainType] = opts;
                        }
                    });
                    delete option[OPTION_INNER_KEY];
                    return option;
                },
                getTheme: function () {
                    return this._theme;
                },
                getComponent: function (mainType, idx) {
                    var list = this._componentsMap[mainType];
                    if (list) {
                        return list[idx || 0];
                    }
                },
                queryComponents: function (condition) {
                    var mainType = condition.mainType;
                    if (!mainType) {
                        return [];
                    }
                    var index = condition.index;
                    var id = condition.id;
                    var name = condition.name;
                    var cpts = this._componentsMap[mainType];
                    if (!cpts || !cpts.length) {
                        return [];
                    }
                    var result;
                    if (index != null) {
                        if (!isArray(index)) {
                            index = [index];
                        }
                        result = filter(map(index, function (idx) {
                            return cpts[idx];
                        }), function (val) {
                            return !!val;
                        });
                    } else if (id != null) {
                        var isIdArray = isArray(id);
                        result = filter(cpts, function (cpt) {
                            return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;
                        });
                    } else if (name != null) {
                        var isNameArray = isArray(name);
                        result = filter(cpts, function (cpt) {
                            return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;
                        });
                    }
                    return filterBySubType(result, condition);
                },
                findComponents: function (condition) {
                    var query = condition.query;
                    var mainType = condition.mainType;
                    var queryCond = getQueryCond(query);
                    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap[mainType];
                    return doFilter(filterBySubType(result, condition));
                    function getQueryCond(q) {
                        var indexAttr = mainType + 'Index';
                        var idAttr = mainType + 'Id';
                        var nameAttr = mainType + 'Name';
                        return q && (q.hasOwnProperty(indexAttr) || q.hasOwnProperty(idAttr) || q.hasOwnProperty(nameAttr)) ? {
                            mainType: mainType,
                            index: q[indexAttr],
                            id: q[idAttr],
                            name: q[nameAttr]
                        } : null;
                    }
                    function doFilter(res) {
                        return condition.filter ? filter(res, condition.filter) : res;
                    }
                },
                eachComponent: function (mainType, cb, context) {
                    var componentsMap = this._componentsMap;
                    if (typeof mainType === 'function') {
                        context = cb;
                        cb = mainType;
                        each(componentsMap, function (components, componentType) {
                            each(components, function (component, index) {
                                cb.call(context, componentType, component, index);
                            });
                        });
                    } else if (zrUtil.isString(mainType)) {
                        each(componentsMap[mainType], cb, context);
                    } else if (isObject(mainType)) {
                        var queryResult = this.findComponents(mainType);
                        each(queryResult, cb, context);
                    }
                },
                getSeriesByName: function (name) {
                    var series = this._componentsMap.series;
                    return filter(series, function (oneSeries) {
                        return oneSeries.name === name;
                    });
                },
                getSeriesByIndex: function (seriesIndex) {
                    return this._componentsMap.series[seriesIndex];
                },
                getSeriesByType: function (subType) {
                    var series = this._componentsMap.series;
                    return filter(series, function (oneSeries) {
                        return oneSeries.subType === subType;
                    });
                },
                getSeries: function () {
                    return this._componentsMap.series.slice();
                },
                eachSeries: function (cb, context) {
                    assertSeriesInitialized(this);
                    each(this._seriesIndices, function (rawSeriesIndex) {
                        var series = this._componentsMap.series[rawSeriesIndex];
                        cb.call(context, series, rawSeriesIndex);
                    }, this);
                },
                eachRawSeries: function (cb, context) {
                    each(this._componentsMap.series, cb, context);
                },
                eachSeriesByType: function (subType, cb, context) {
                    assertSeriesInitialized(this);
                    each(this._seriesIndices, function (rawSeriesIndex) {
                        var series = this._componentsMap.series[rawSeriesIndex];
                        if (series.subType === subType) {
                            cb.call(context, series, rawSeriesIndex);
                        }
                    }, this);
                },
                eachRawSeriesByType: function (subType, cb, context) {
                    return each(this.getSeriesByType(subType), cb, context);
                },
                isSeriesFiltered: function (seriesModel) {
                    assertSeriesInitialized(this);
                    return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;
                },
                filterSeries: function (cb, context) {
                    assertSeriesInitialized(this);
                    var filteredSeries = filter(this._componentsMap.series, cb, context);
                    this._seriesIndices = createSeriesIndices(filteredSeries);
                },
                restoreData: function () {
                    var componentsMap = this._componentsMap;
                    this._seriesIndices = createSeriesIndices(componentsMap.series);
                    var componentTypes = [];
                    each(componentsMap, function (components, componentType) {
                        componentTypes.push(componentType);
                    });
                    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {
                        each(componentsMap[componentType], function (component) {
                            component.restoreData();
                        });
                    });
                }
            });
            function mergeTheme(option, theme) {
                for (var name in theme) {
                    if (!ComponentModel.hasClass(name)) {
                        if (typeof theme[name] === 'object') {
                            option[name] = !option[name] ? zrUtil.clone(theme[name]) : zrUtil.merge(option[name], theme[name], false);
                        } else {
                            if (option[name] == null) {
                                option[name] = theme[name];
                            }
                        }
                    }
                }
            }
            function initBase(baseOption) {
                baseOption = baseOption;
                this.option = {};
                this.option[OPTION_INNER_KEY] = 1;
                this._componentsMap = {};
                this._seriesIndices = null;
                mergeTheme(baseOption, this._theme.option);
                zrUtil.merge(baseOption, globalDefault, false);
                this.mergeOption(baseOption);
            }
            function getComponentsByTypes(componentsMap, types) {
                if (!zrUtil.isArray(types)) {
                    types = types ? [types] : [];
                }
                var ret = {};
                each(types, function (type) {
                    ret[type] = (componentsMap[type] || []).slice();
                });
                return ret;
            }
            function makeKeyInfo(mainType, mapResult) {
                var idMap = {};
                each(mapResult, function (item, index) {
                    var existCpt = item.exist;
                    existCpt && (idMap[existCpt.id] = item);
                });
                each(mapResult, function (item, index) {
                    var opt = item.option;
                    zrUtil.assert(!opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item, 'id duplicates: ' + (opt && opt.id));
                    opt && opt.id != null && (idMap[opt.id] = item);
                    if (isObject(opt)) {
                        var subType = determineSubType(mainType, opt, item.exist);
                        item.keyInfo = {
                            mainType: mainType,
                            subType: subType
                        };
                    }
                });
                each(mapResult, function (item, index) {
                    var existCpt = item.exist;
                    var opt = item.option;
                    var keyInfo = item.keyInfo;
                    if (!isObject(opt)) {
                        return;
                    }
                    keyInfo.name = opt.name != null ? opt.name + '' : existCpt ? existCpt.name : '\0-';
                    if (existCpt) {
                        keyInfo.id = existCpt.id;
                    } else if (opt.id != null) {
                        keyInfo.id = opt.id + '';
                    } else {
                        var idNum = 0;
                        do {
                            keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
                        } while (idMap[keyInfo.id]);
                    }
                    idMap[keyInfo.id] = item;
                });
            }
            function determineSubType(mainType, newCptOption, existComponent) {
                var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType : ComponentModel.determineSubType(mainType, newCptOption);
                return subType;
            }
            function createSeriesIndices(seriesModels) {
                return map(seriesModels, function (series) {
                    return series.componentIndex;
                }) || [];
            }
            function filterBySubType(components, condition) {
                return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {
                    return cpt.subType === condition.subType;
                }) : components;
            }
            function assertSeriesInitialized(ecModel) {
                if (!ecModel._seriesIndices) {
                    throw new Error('Series has not been initialized yet.');
                }
            }
            module.exports = GlobalModel;
        },
        function (module, exports, __webpack_require__) {
            var Gradient = __webpack_require__(4);
            var BUILTIN_OBJECT = {
                '[object Function]': 1,
                '[object RegExp]': 1,
                '[object Date]': 1,
                '[object Error]': 1,
                '[object CanvasGradient]': 1
            };
            var objToString = Object.prototype.toString;
            var arrayProto = Array.prototype;
            var nativeForEach = arrayProto.forEach;
            var nativeFilter = arrayProto.filter;
            var nativeSlice = arrayProto.slice;
            var nativeMap = arrayProto.map;
            var nativeReduce = arrayProto.reduce;
            function clone(source) {
                if (typeof source == 'object' && source !== null) {
                    var result = source;
                    if (source instanceof Array) {
                        result = [];
                        for (var i = 0, len = source.length; i < len; i++) {
                            result[i] = clone(source[i]);
                        }
                    } else if (!isBuildInObject(source) && !isDom(source)) {
                        result = {};
                        for (var key in source) {
                            if (source.hasOwnProperty(key)) {
                                result[key] = clone(source[key]);
                            }
                        }
                    }
                    return result;
                }
                return source;
            }
            function merge(target, source, overwrite) {
                if (!isObject(source) || !isObject(target)) {
                    return overwrite ? clone(source) : target;
                }
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        var targetProp = target[key];
                        var sourceProp = source[key];
                        if (isObject(sourceProp) && isObject(targetProp) && !isArray(sourceProp) && !isArray(targetProp) && !isDom(sourceProp) && !isDom(targetProp) && !isBuildInObject(sourceProp) && !isBuildInObject(targetProp)) {
                            merge(targetProp, sourceProp, overwrite);
                        } else if (overwrite || !(key in target)) {
                            target[key] = clone(source[key], true);
                        }
                    }
                }
                return target;
            }
            function mergeAll(targetAndSources, overwrite) {
                var result = targetAndSources[0];
                for (var i = 1, len = targetAndSources.length; i < len; i++) {
                    result = merge(result, targetAndSources[i], overwrite);
                }
                return result;
            }
            function extend(target, source) {
                for (var key in source) {
                    if (source.hasOwnProperty(key)) {
                        target[key] = source[key];
                    }
                }
                return target;
            }
            function defaults(target, source, overlay) {
                for (var key in source) {
                    if (source.hasOwnProperty(key) && (overlay ? source[key] != null : target[key] == null)) {
                        target[key] = source[key];
                    }
                }
                return target;
            }
            function createCanvas() {
                return document.createElement('canvas');
            }
            var _ctx;
            function getContext() {
                if (!_ctx) {
                    _ctx = util.createCanvas().getContext('2d');
                }
                return _ctx;
            }
            function indexOf(array, value) {
                if (array) {
                    if (array.indexOf) {
                        return array.indexOf(value);
                    }
                    for (var i = 0, len = array.length; i < len; i++) {
                        if (array[i] === value) {
                            return i;
                        }
                    }
                }
                return -1;
            }
            function inherits(clazz, baseClazz) {
                var clazzPrototype = clazz.prototype;
                function F() {
                }
                F.prototype = baseClazz.prototype;
                clazz.prototype = new F();
                for (var prop in clazzPrototype) {
                    clazz.prototype[prop] = clazzPrototype[prop];
                }
                clazz.prototype.constructor = clazz;
                clazz.superClass = baseClazz;
            }
            function mixin(target, source, overlay) {
                target = 'prototype' in target ? target.prototype : target;
                source = 'prototype' in source ? source.prototype : source;
                defaults(target, source, overlay);
            }
            function isArrayLike(data) {
                if (!data) {
                    return;
                }
                if (typeof data == 'string') {
                    return false;
                }
                return typeof data.length == 'number';
            }
            function each(obj, cb, context) {
                if (!(obj && cb)) {
                    return;
                }
                if (obj.forEach && obj.forEach === nativeForEach) {
                    obj.forEach(cb, context);
                } else if (obj.length === +obj.length) {
                    for (var i = 0, len = obj.length; i < len; i++) {
                        cb.call(context, obj[i], i, obj);
                    }
                } else {
                    for (var key in obj) {
                        if (obj.hasOwnProperty(key)) {
                            cb.call(context, obj[key], key, obj);
                        }
                    }
                }
            }
            function map(obj, cb, context) {
                if (!(obj && cb)) {
                    return;
                }
                if (obj.map && obj.map === nativeMap) {
                    return obj.map(cb, context);
                } else {
                    var result = [];
                    for (var i = 0, len = obj.length; i < len; i++) {
                        result.push(cb.call(context, obj[i], i, obj));
                    }
                    return result;
                }
            }
            function reduce(obj, cb, memo, context) {
                if (!(obj && cb)) {
                    return;
                }
                if (obj.reduce && obj.reduce === nativeReduce) {
                    return obj.reduce(cb, memo, context);
                } else {
                    for (var i = 0, len = obj.length; i < len; i++) {
                        memo = cb.call(context, memo, obj[i], i, obj);
                    }
                    return memo;
                }
            }
            function filter(obj, cb, context) {
                if (!(obj && cb)) {
                    return;
                }
                if (obj.filter && obj.filter === nativeFilter) {
                    return obj.filter(cb, context);
                } else {
                    var result = [];
                    for (var i = 0, len = obj.length; i < len; i++) {
                        if (cb.call(context, obj[i], i, obj)) {
                            result.push(obj[i]);
                        }
                    }
                    return result;
                }
            }
            function find(obj, cb, context) {
                if (!(obj && cb)) {
                    return;
                }
                for (var i = 0, len = obj.length; i < len; i++) {
                    if (cb.call(context, obj[i], i, obj)) {
                        return obj[i];
                    }
                }
            }
            function bind(func, context) {
                var args = nativeSlice.call(arguments, 2);
                return function () {
                    return func.apply(context, args.concat(nativeSlice.call(arguments)));
                };
            }
            function curry(func) {
                var args = nativeSlice.call(arguments, 1);
                return function () {
                    return func.apply(this, args.concat(nativeSlice.call(arguments)));
                };
            }
            function isArray(value) {
                return objToString.call(value) === '[object Array]';
            }
            function isFunction(value) {
                return typeof value === 'function';
            }
            function isString(value) {
                return objToString.call(value) === '[object String]';
            }
            function isObject(value) {
                var type = typeof value;
                return type === 'function' || !!value && type == 'object';
            }
            function isBuildInObject(value) {
                return !!BUILTIN_OBJECT[objToString.call(value)] || value instanceof Gradient;
            }
            function isDom(value) {
                return value && value.nodeType === 1 && typeof value.nodeName == 'string';
            }
            function retrieve(values) {
                for (var i = 0, len = arguments.length; i < len; i++) {
                    if (arguments[i] != null) {
                        return arguments[i];
                    }
                }
            }
            function slice() {
                return Function.call.apply(nativeSlice, arguments);
            }
            function assert(condition, message) {
                if (!condition) {
                    throw new Error(message);
                }
            }
            var util = {
                inherits: inherits,
                mixin: mixin,
                clone: clone,
                merge: merge,
                mergeAll: mergeAll,
                extend: extend,
                defaults: defaults,
                getContext: getContext,
                createCanvas: createCanvas,
                indexOf: indexOf,
                slice: slice,
                find: find,
                isArrayLike: isArrayLike,
                each: each,
                map: map,
                reduce: reduce,
                filter: filter,
                bind: bind,
                curry: curry,
                isArray: isArray,
                isString: isString,
                isObject: isObject,
                isFunction: isFunction,
                isBuildInObject: isBuildInObject,
                isDom: isDom,
                retrieve: retrieve,
                assert: assert,
                noop: function () {
                }
            };
            module.exports = util;
        },
        function (module, exports) {
            var Gradient = function (colorStops) {
                this.colorStops = colorStops || [];
            };
            Gradient.prototype = {
                constructor: Gradient,
                addColorStop: function (offset, color) {
                    this.colorStops.push({
                        offset: offset,
                        color: color
                    });
                }
            };
            module.exports = Gradient;
        },
        function (module, exports, __webpack_require__) {
            var formatUtil = __webpack_require__(6);
            var nubmerUtil = __webpack_require__(7);
            var zrUtil = __webpack_require__(3);
            var Model = __webpack_require__(8);
            var AXIS_DIMS = [
                'x',
                'y',
                'z',
                'radius',
                'angle'
            ];
            var modelUtil = {};
            modelUtil.createNameEach = function (names, attrs) {
                names = names.slice();
                var capitalNames = zrUtil.map(names, modelUtil.capitalFirst);
                attrs = (attrs || []).slice();
                var capitalAttrs = zrUtil.map(attrs, modelUtil.capitalFirst);
                return function (callback, context) {
                    zrUtil.each(names, function (name, index) {
                        var nameObj = {
                            name: name,
                            capital: capitalNames[index]
                        };
                        for (var j = 0; j < attrs.length; j++) {
                            nameObj[attrs[j]] = name + capitalAttrs[j];
                        }
                        callback.call(context, nameObj);
                    });
                };
            };
            modelUtil.capitalFirst = function (str) {
                return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
            };
            modelUtil.eachAxisDim = modelUtil.createNameEach(AXIS_DIMS, [
                'axisIndex',
                'axis',
                'index'
            ]);
            modelUtil.normalizeToArray = function (value) {
                return zrUtil.isArray(value) ? value : value == null ? [] : [value];
            };
            modelUtil.createLinkedNodesFinder = function (forEachNode, forEachEdgeType, edgeIdGetter) {
                return function (sourceNode) {
                    var result = {
                        nodes: [],
                        records: {}
                    };
                    forEachEdgeType(function (edgeType) {
                        result.records[edgeType.name] = {};
                    });
                    if (!sourceNode) {
                        return result;
                    }
                    absorb(sourceNode, result);
                    var existsLink;
                    do {
                        existsLink = false;
                        forEachNode(processSingleNode);
                    } while (existsLink);
                    function processSingleNode(node) {
                        if (!isNodeAbsorded(node, result) && isLinked(node, result)) {
                            absorb(node, result);
                            existsLink = true;
                        }
                    }
                    return result;
                };
                function isNodeAbsorded(node, result) {
                    return zrUtil.indexOf(result.nodes, node) >= 0;
                }
                function isLinked(node, result) {
                    var hasLink = false;
                    forEachEdgeType(function (edgeType) {
                        zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {
                            result.records[edgeType.name][edgeId] && (hasLink = true);
                        });
                    });
                    return hasLink;
                }
                function absorb(node, result) {
                    result.nodes.push(node);
                    forEachEdgeType(function (edgeType) {
                        zrUtil.each(edgeIdGetter(node, edgeType) || [], function (edgeId) {
                            result.records[edgeType.name][edgeId] = true;
                        });
                    });
                }
            };
            modelUtil.defaultEmphasis = function (opt, subOpts) {
                if (opt) {
                    var emphasisOpt = opt.emphasis = opt.emphasis || {};
                    var normalOpt = opt.normal = opt.normal || {};
                    zrUtil.each(subOpts, function (subOptName) {
                        var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);
                        if (val != null) {
                            emphasisOpt[subOptName] = val;
                        }
                    });
                }
            };
            modelUtil.createDataFormatModel = function (opt, data, rawData) {
                var model = new Model();
                zrUtil.mixin(model, modelUtil.dataFormatMixin);
                model.seriesIndex = opt.seriesIndex;
                model.name = opt.name || '';
                model.getData = function () {
                    return data;
                };
                model.getRawDataArray = function () {
                    return rawData;
                };
                return model;
            };
            modelUtil.getDataItemValue = function (dataItem) {
                return dataItem && (dataItem.value == null ? dataItem : dataItem.value);
            };
            modelUtil.converDataValue = function (value, dimInfo) {
                var dimType = dimInfo && dimInfo.type;
                if (dimType === 'ordinal') {
                    return value;
                }
                if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {
                    value = +nubmerUtil.parseDate(value);
                }
                return value == null || value === '' ? NaN : +value;
            };
            modelUtil.dataFormatMixin = {
                getDataParams: function (dataIndex) {
                    var data = this.getData();
                    var seriesIndex = this.seriesIndex;
                    var seriesName = this.name;
                    var rawValue = this.getRawValue(dataIndex);
                    var rawDataIndex = data.getRawIndex(dataIndex);
                    var name = data.getName(dataIndex, true);
                    var rawDataArray = this.getRawDataArray();
                    var itemOpt = rawDataArray && rawDataArray[rawDataIndex];
                    return {
                        componentType: 'series',
                        seriesType: this.subType,
                        seriesIndex: seriesIndex,
                        seriesName: seriesName,
                        name: name,
                        dataIndex: rawDataIndex,
                        data: itemOpt,
                        value: rawValue,
                        color: data.getItemVisual(dataIndex, 'color'),
                        $vars: [
                            'seriesName',
                            'name',
                            'value'
                        ]
                    };
                },
                getFormattedLabel: function (dataIndex, status, formatter) {
                    status = status || 'normal';
                    var data = this.getData();
                    var itemModel = data.getItemModel(dataIndex);
                    var params = this.getDataParams(dataIndex);
                    if (formatter == null) {
                        formatter = itemModel.get([
                            'label',
                            status,
                            'formatter'
                        ]);
                    }
                    if (typeof formatter === 'function') {
                        params.status = status;
                        return formatter(params);
                    } else if (typeof formatter === 'string') {
                        return formatUtil.formatTpl(formatter, params);
                    }
                },
                getRawValue: function (idx) {
                    var itemModel = this.getData().getItemModel(idx);
                    if (itemModel && itemModel.option != null) {
                        var dataItem = itemModel.option;
                        return zrUtil.isObject(dataItem) && !zrUtil.isArray(dataItem) ? dataItem.value : dataItem;
                    }
                }
            };
            modelUtil.mappingToExists = function (exists, newCptOptions) {
                newCptOptions = (newCptOptions || []).slice();
                var result = zrUtil.map(exists || [], function (obj, index) {
                    return { exist: obj };
                });
                zrUtil.each(newCptOptions, function (cptOption, index) {
                    if (!zrUtil.isObject(cptOption)) {
                        return;
                    }
                    for (var i = 0; i < result.length; i++) {
                        var exist = result[i].exist;
                        if (!result[i].option && (cptOption.id != null && exist.id === cptOption.id + '' || cptOption.name != null && !modelUtil.isIdInner(cptOption) && !modelUtil.isIdInner(exist) && exist.name === cptOption.name + '')) {
                            result[i].option = cptOption;
                            newCptOptions[index] = null;
                            break;
                        }
                    }
                });
                zrUtil.each(newCptOptions, function (cptOption, index) {
                    if (!zrUtil.isObject(cptOption)) {
                        return;
                    }
                    var i = 0;
                    for (; i < result.length; i++) {
                        var exist = result[i].exist;
                        if (!result[i].option && !modelUtil.isIdInner(exist) && cptOption.id == null) {
                            result[i].option = cptOption;
                            break;
                        }
                    }
                    if (i >= result.length) {
                        result.push({ option: cptOption });
                    }
                });
                return result;
            };
            modelUtil.isIdInner = function (cptOption) {
                return zrUtil.isObject(cptOption) && cptOption.id && (cptOption.id + '').indexOf('\0_ec_\0') === 0;
            };
            module.exports = modelUtil;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var numberUtil = __webpack_require__(7);
            function addCommas(x) {
                if (isNaN(x)) {
                    return '-';
                }
                x = (x + '').split('.');
                return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (x.length > 1 ? '.' + x[1] : '');
            }
            function toCamelCase(str) {
                return str.toLowerCase().replace(/-(.)/g, function (match, group1) {
                    return group1.toUpperCase();
                });
            }
            function normalizeCssArray(val) {
                var len = val.length;
                if (typeof val === 'number') {
                    return [
                        val,
                        val,
                        val,
                        val
                    ];
                } else if (len === 2) {
                    return [
                        val[0],
                        val[1],
                        val[0],
                        val[1]
                    ];
                } else if (len === 3) {
                    return [
                        val[0],
                        val[1],
                        val[2],
                        val[1]
                    ];
                }
                return val;
            }
            function encodeHTML(source) {
                return String(source).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
            }
            var TPL_VAR_ALIAS = [
                'a',
                'b',
                'c',
                'd',
                'e',
                'f',
                'g'
            ];
            function wrapVar(varName, seriesIdx) {
                return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
            }
            function formatTpl(tpl, paramsList) {
                if (!zrUtil.isArray(paramsList)) {
                    paramsList = [paramsList];
                }
                var seriesLen = paramsList.length;
                if (!seriesLen) {
                    return '';
                }
                var $vars = paramsList[0].$vars;
                for (var i = 0; i < $vars.length; i++) {
                    var alias = TPL_VAR_ALIAS[i];
                    tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0));
                }
                for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
                    for (var k = 0; k < $vars.length; k++) {
                        tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), paramsList[seriesIdx][$vars[k]]);
                    }
                }
                return tpl;
            }
            function formatTime(tpl, value) {
                if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {
                    tpl = 'MM-dd\nyyyy';
                }
                var date = numberUtil.parseDate(value);
                var y = date.getFullYear();
                var M = date.getMonth() + 1;
                var d = date.getDate();
                var h = date.getHours();
                var m = date.getMinutes();
                var s = date.getSeconds();
                tpl = tpl.replace('MM', s2d(M)).toLowerCase().replace('yyyy', y).replace('yy', y % 100).replace('dd', s2d(d)).replace('d', d).replace('hh', s2d(h)).replace('h', h).replace('mm', s2d(m)).replace('m', m).replace('ss', s2d(s)).replace('s', s);
                return tpl;
            }
            function s2d(str) {
                return str < 10 ? '0' + str : str;
            }
            module.exports = {
                normalizeCssArray: normalizeCssArray,
                addCommas: addCommas,
                toCamelCase: toCamelCase,
                encodeHTML: encodeHTML,
                formatTpl: formatTpl,
                formatTime: formatTime
            };
        },
        function (module, exports) {
            var number = {};
            var RADIAN_EPSILON = 0.0001;
            function _trim(str) {
                return str.replace(/^\s+/, '').replace(/\s+$/, '');
            }
            number.linearMap = function (val, domain, range, clamp) {
                var sub = domain[1] - domain[0];
                if (sub === 0) {
                    return (range[0] + range[1]) / 2;
                }
                var t = (val - domain[0]) / sub;
                if (clamp) {
                    t = Math.min(Math.max(t, 0), 1);
                }
                return t * (range[1] - range[0]) + range[0];
            };
            number.parsePercent = function (percent, all) {
                switch (percent) {
                case 'center':
                case 'middle':
                    percent = '50%';
                    break;
                case 'left':
                case 'top':
                    percent = '0%';
                    break;
                case 'right':
                case 'bottom':
                    percent = '100%';
                    break;
                }
                if (typeof percent === 'string') {
                    if (_trim(percent).match(/%$/)) {
                        return parseFloat(percent) / 100 * all;
                    }
                    return parseFloat(percent);
                }
                return percent == null ? NaN : +percent;
            };
            number.round = function (x) {
                return +(+x).toFixed(10);
            };
            number.asc = function (arr) {
                arr.sort(function (a, b) {
                    return a - b;
                });
                return arr;
            };
            number.getPrecision = function (val) {
                if (isNaN(val)) {
                    return 0;
                }
                var e = 1;
                var count = 0;
                while (Math.round(val * e) / e !== val) {
                    e *= 10;
                    count++;
                }
                return count;
            };
            number.getPixelPrecision = function (dataExtent, pixelExtent) {
                var log = Math.log;
                var LN10 = Math.LN10;
                var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
                var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
                return Math.max(-dataQuantity + sizeQuantity, 0);
            };
            number.MAX_SAFE_INTEGER = 9007199254740991;
            number.remRadian = function (radian) {
                var pi2 = Math.PI * 2;
                return (radian % pi2 + pi2) % pi2;
            };
            number.isRadianAroundZero = function (val) {
                return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
            };
            number.parseDate = function (value) {
                return value instanceof Date ? value : new Date(typeof value === 'string' ? value.replace(/-/g, '/') : Math.round(value));
            };
            number.nice = function (val, round) {
                var exp = Math.floor(Math.log(val) / Math.LN10);
                var exp10 = Math.pow(10, exp);
                var f = val / exp10;
                var nf;
                if (round) {
                    if (f < 1.5) {
                        nf = 1;
                    } else if (f < 2.5) {
                        nf = 2;
                    } else if (f < 4) {
                        nf = 3;
                    } else if (f < 7) {
                        nf = 5;
                    } else {
                        nf = 10;
                    }
                } else {
                    if (f < 1) {
                        nf = 1;
                    } else if (f < 2) {
                        nf = 2;
                    } else if (f < 3) {
                        nf = 3;
                    } else if (f < 5) {
                        nf = 5;
                    } else {
                        nf = 10;
                    }
                }
                return nf * exp10;
            };
            module.exports = number;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var clazzUtil = __webpack_require__(9);
            function Model(option, parentModel, ecModel, extraOpt) {
                this.parentModel = parentModel;
                this.ecModel = ecModel;
                this.option = option;
                if (this.init) {
                    if (arguments.length <= 4) {
                        this.init(option, parentModel, ecModel, extraOpt);
                    } else {
                        this.init.apply(this, arguments);
                    }
                }
            }
            Model.prototype = {
                constructor: Model,
                init: null,
                mergeOption: function (option) {
                    zrUtil.merge(this.option, option, true);
                },
                get: function (path, ignoreParent) {
                    if (!path) {
                        return this.option;
                    }
                    if (typeof path === 'string') {
                        path = path.split('.');
                    }
                    var obj = this.option;
                    var parentModel = this.parentModel;
                    for (var i = 0; i < path.length; i++) {
                        obj = obj && typeof obj === 'object' ? obj[path[i]] : null;
                        if (obj == null) {
                            break;
                        }
                    }
                    if (obj == null && parentModel && !ignoreParent) {
                        obj = parentModel.get(path);
                    }
                    return obj;
                },
                getShallow: function (key, ignoreParent) {
                    var option = this.option;
                    var val = option && option[key];
                    var parentModel = this.parentModel;
                    if (val == null && parentModel && !ignoreParent) {
                        val = parentModel.getShallow(key);
                    }
                    return val;
                },
                getModel: function (path, parentModel) {
                    var obj = this.get(path, true);
                    var thisParentModel = this.parentModel;
                    var model = new Model(obj, parentModel || thisParentModel && thisParentModel.getModel(path), this.ecModel);
                    return model;
                },
                isEmpty: function () {
                    return this.option == null;
                },
                restoreData: function () {
                },
                clone: function () {
                    var Ctor = this.constructor;
                    return new Ctor(zrUtil.clone(this.option));
                },
                setReadOnly: function (properties) {
                    clazzUtil.setReadOnly(this, properties);
                }
            };
            clazzUtil.enableClassExtend(Model);
            var mixin = zrUtil.mixin;
            mixin(Model, __webpack_require__(10));
            mixin(Model, __webpack_require__(12));
            mixin(Model, __webpack_require__(13));
            mixin(Model, __webpack_require__(18));
            module.exports = Model;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var clazz = {};
            var TYPE_DELIMITER = '.';
            var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
            var parseClassType = clazz.parseClassType = function (componentType) {
                var ret = {
                    main: '',
                    sub: ''
                };
                if (componentType) {
                    componentType = componentType.split(TYPE_DELIMITER);
                    ret.main = componentType[0] || '';
                    ret.sub = componentType[1] || '';
                }
                return ret;
            };
            clazz.enableClassExtend = function (RootClass, preConstruct) {
                RootClass.extend = function (proto) {
                    var ExtendedClass = function () {
                        preConstruct && preConstruct.apply(this, arguments);
                        RootClass.apply(this, arguments);
                    };
                    zrUtil.extend(ExtendedClass.prototype, proto);
                    ExtendedClass.extend = this.extend;
                    ExtendedClass.superCall = superCall;
                    ExtendedClass.superApply = superApply;
                    zrUtil.inherits(ExtendedClass, this);
                    ExtendedClass.superClass = this;
                    return ExtendedClass;
                };
            };
            function superCall(context, methodName) {
                var args = zrUtil.slice(arguments, 2);
                return this.superClass.prototype[methodName].apply(context, args);
            }
            function superApply(context, methodName, args) {
                return this.superClass.prototype[methodName].apply(context, args);
            }
            clazz.enableClassManagement = function (entity, options) {
                options = options || {};
                var storage = {};
                entity.registerClass = function (Clazz, componentType) {
                    if (componentType) {
                        componentType = parseClassType(componentType);
                        if (!componentType.sub) {
                            if (storage[componentType.main]) {
                                throw new Error(componentType.main + 'exists.');
                            }
                            storage[componentType.main] = Clazz;
                        } else if (componentType.sub !== IS_CONTAINER) {
                            var container = makeContainer(componentType);
                            container[componentType.sub] = Clazz;
                        }
                    }
                    return Clazz;
                };
                entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
                    var Clazz = storage[componentTypeMain];
                    if (Clazz && Clazz[IS_CONTAINER]) {
                        Clazz = subType ? Clazz[subType] : null;
                    }
                    if (throwWhenNotFound && !Clazz) {
                        throw new Error('Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.');
                    }
                    return Clazz;
                };
                entity.getClassesByMainType = function (componentType) {
                    componentType = parseClassType(componentType);
                    var result = [];
                    var obj = storage[componentType.main];
                    if (obj && obj[IS_CONTAINER]) {
                        zrUtil.each(obj, function (o, type) {
                            type !== IS_CONTAINER && result.push(o);
                        });
                    } else {
                        result.push(obj);
                    }
                    return result;
                };
                entity.hasClass = function (componentType) {
                    componentType = parseClassType(componentType);
                    return !!storage[componentType.main];
                };
                entity.getAllClassMainTypes = function () {
                    var types = [];
                    zrUtil.each(storage, function (obj, type) {
                        types.push(type);
                    });
                    return types;
                };
                entity.hasSubTypes = function (componentType) {
                    componentType = parseClassType(componentType);
                    var obj = storage[componentType.main];
                    return obj && obj[IS_CONTAINER];
                };
                entity.parseClassType = parseClassType;
                function makeContainer(componentType) {
                    var container = storage[componentType.main];
                    if (!container || !container[IS_CONTAINER]) {
                        container = storage[componentType.main] = {};
                        container[IS_CONTAINER] = true;
                    }
                    return container;
                }
                if (options.registerWhenExtend) {
                    var originalExtend = entity.extend;
                    if (originalExtend) {
                        entity.extend = function (proto) {
                            var ExtendedClass = originalExtend.call(this, proto);
                            return entity.registerClass(ExtendedClass, proto.type);
                        };
                    }
                }
                return entity;
            };
            clazz.setReadOnly = function (obj, properties) {
            };
            module.exports = clazz;
        },
        function (module, exports, __webpack_require__) {
            var getLineStyle = __webpack_require__(11)([
                [
                    'lineWidth',
                    'width'
                ],
                [
                    'stroke',
                    'color'
                ],
                ['opacity'],
                ['shadowBlur'],
                ['shadowOffsetX'],
                ['shadowOffsetY'],
                ['shadowColor']
            ]);
            module.exports = {
                getLineStyle: function (excludes) {
                    var style = getLineStyle.call(this, excludes);
                    var lineDash = this.getLineDash();
                    lineDash && (style.lineDash = lineDash);
                    return style;
                },
                getLineDash: function () {
                    var lineType = this.get('type');
                    return lineType === 'solid' || lineType == null ? null : lineType === 'dashed' ? [
                        5,
                        5
                    ] : [
                        1,
                        1
                    ];
                }
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            module.exports = function (properties) {
                for (var i = 0; i < properties.length; i++) {
                    if (!properties[i][1]) {
                        properties[i][1] = properties[i][0];
                    }
                }
                return function (excludes) {
                    var style = {};
                    for (var i = 0; i < properties.length; i++) {
                        var propName = properties[i][1];
                        if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {
                            continue;
                        }
                        var val = this.getShallow(propName);
                        if (val != null) {
                            style[properties[i][0]] = val;
                        }
                    }
                    return style;
                };
            };
        },
        function (module, exports, __webpack_require__) {
            module.exports = {
                getAreaStyle: __webpack_require__(11)([
                    [
                        'fill',
                        'color'
                    ],
                    ['shadowBlur'],
                    ['shadowOffsetX'],
                    ['shadowOffsetY'],
                    ['opacity'],
                    ['shadowColor']
                ])
            };
        },
        function (module, exports, __webpack_require__) {
            var textContain = __webpack_require__(14);
            function getShallow(model, path) {
                return model && model.getShallow(path);
            }
            module.exports = {
                getTextColor: function () {
                    var ecModel = this.ecModel;
                    return this.getShallow('color') || ecModel && ecModel.get('textStyle.color');
                },
                getFont: function () {
                    var ecModel = this.ecModel;
                    var gTextStyleModel = ecModel && ecModel.getModel('textStyle');
                    return [
                        this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),
                        this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),
                        (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',
                        this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'
                    ].join(' ');
                },
                getTextRect: function (text) {
                    var textStyle = this.get('textStyle') || {};
                    return textContain.getBoundingRect(text, this.getFont(), textStyle.align, textStyle.baseline);
                },
                ellipsis: function (text, containerWidth, options) {
                    return textContain.ellipsis(text, this.getFont(), containerWidth, options);
                }
            };
        },
        function (module, exports, __webpack_require__) {
            var textWidthCache = {};
            var textWidthCacheCounter = 0;
            var TEXT_CACHE_MAX = 5000;
            var util = __webpack_require__(3);
            var BoundingRect = __webpack_require__(15);
            function getTextWidth(text, textFont) {
                var key = text + ':' + textFont;
                if (textWidthCache[key]) {
                    return textWidthCache[key];
                }
                var textLines = (text + '').split('\n');
                var width = 0;
                for (var i = 0, l = textLines.length; i < l; i++) {
                    width = Math.max(textContain.measureText(textLines[i], textFont).width, width);
                }
                if (textWidthCacheCounter > TEXT_CACHE_MAX) {
                    textWidthCacheCounter = 0;
                    textWidthCache = {};
                }
                textWidthCacheCounter++;
                textWidthCache[key] = width;
                return width;
            }
            function getTextRect(text, textFont, textAlign, textBaseline) {
                var textLineLen = ((text || '') + '').split('\n').length;
                var width = getTextWidth(text, textFont);
                var lineHeight = getTextWidth('国', textFont);
                var height = textLineLen * lineHeight;
                var rect = new BoundingRect(0, 0, width, height);
                rect.lineHeight = lineHeight;
                switch (textBaseline) {
                case 'bottom':
                case 'alphabetic':
                    rect.y -= lineHeight;
                    break;
                case 'middle':
                    rect.y -= lineHeight / 2;
                    break;
                }
                switch (textAlign) {
                case 'end':
                case 'right':
                    rect.x -= rect.width;
                    break;
                case 'center':
                    rect.x -= rect.width / 2;
                    break;
                }
                return rect;
            }
            function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {
                var x = rect.x;
                var y = rect.y;
                var height = rect.height;
                var width = rect.width;
                var textHeight = textRect.height;
                var halfHeight = height / 2 - textHeight / 2;
                var textAlign = 'left';
                switch (textPosition) {
                case 'left':
                    x -= distance;
                    y += halfHeight;
                    textAlign = 'right';
                    break;
                case 'right':
                    x += distance + width;
                    y += halfHeight;
                    textAlign = 'left';
                    break;
                case 'top':
                    x += width / 2;
                    y -= distance + textHeight;
                    textAlign = 'center';
                    break;
                case 'bottom':
                    x += width / 2;
                    y += height + distance;
                    textAlign = 'center';
                    break;
                case 'inside':
                    x += width / 2;
                    y += halfHeight;
                    textAlign = 'center';
                    break;
                case 'insideLeft':
                    x += distance;
                    y += halfHeight;
                    textAlign = 'left';
                    break;
                case 'insideRight':
                    x += width - distance;
                    y += halfHeight;
                    textAlign = 'right';
                    break;
                case 'insideTop':
                    x += width / 2;
                    y += distance;
                    textAlign = 'center';
                    break;
                case 'insideBottom':
                    x += width / 2;
                    y += height - textHeight - distance;
                    textAlign = 'center';
                    break;
                case 'insideTopLeft':
                    x += distance;
                    y += distance;
                    textAlign = 'left';
                    break;
                case 'insideTopRight':
                    x += width - distance;
                    y += distance;
                    textAlign = 'right';
                    break;
                case 'insideBottomLeft':
                    x += distance;
                    y += height - textHeight - distance;
                    break;
                case 'insideBottomRight':
                    x += width - distance;
                    y += height - textHeight - distance;
                    textAlign = 'right';
                    break;
                }
                return {
                    x: x,
                    y: y,
                    textAlign: textAlign,
                    textBaseline: 'top'
                };
            }
            function textEllipsis(text, textFont, containerWidth, options) {
                if (!containerWidth) {
                    return '';
                }
                options = util.defaults({
                    ellipsis: '...',
                    minCharacters: 3,
                    maxIterations: 3,
                    cnCharWidth: getTextWidth('国', textFont),
                    ascCharWidth: getTextWidth('a', textFont)
                }, options, true);
                containerWidth -= getTextWidth(options.ellipsis);
                var textLines = (text + '').split('\n');
                for (var i = 0, len = textLines.length; i < len; i++) {
                    textLines[i] = textLineTruncate(textLines[i], textFont, containerWidth, options);
                }
                return textLines.join('\n');
            }
            function textLineTruncate(text, textFont, containerWidth, options) {
                for (var i = 0;; i++) {
                    var lineWidth = getTextWidth(text, textFont);
                    if (lineWidth < containerWidth || i >= options.maxIterations) {
                        text += options.ellipsis;
                        break;
                    }
                    var subLength = i === 0 ? estimateLength(text, containerWidth, options) : Math.floor(text.length * containerWidth / lineWidth);
                    if (subLength < options.minCharacters) {
                        text = '';
                        break;
                    }
                    text = text.substr(0, subLength);
                }
                return text;
            }
            function estimateLength(text, containerWidth, options) {
                var width = 0;
                var i = 0;
                for (var len = text.length; i < len && width < containerWidth; i++) {
                    var charCode = text.charCodeAt(i);
                    width += 0 <= charCode && charCode <= 127 ? options.ascCharWidth : options.cnCharWidth;
                }
                return i;
            }
            var textContain = {
                getWidth: getTextWidth,
                getBoundingRect: getTextRect,
                adjustTextPositionOnRect: adjustTextPositionOnRect,
                ellipsis: textEllipsis,
                measureText: function (text, textFont) {
                    var ctx = util.getContext();
                    ctx.font = textFont;
                    return ctx.measureText(text);
                }
            };
            module.exports = textContain;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var vec2 = __webpack_require__(16);
            var matrix = __webpack_require__(17);
            var v2ApplyTransform = vec2.applyTransform;
            var mathMin = Math.min;
            var mathAbs = Math.abs;
            var mathMax = Math.max;
            function BoundingRect(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
            }
            BoundingRect.prototype = {
                constructor: BoundingRect,
                union: function (other) {
                    var x = mathMin(other.x, this.x);
                    var y = mathMin(other.y, this.y);
                    this.width = mathMax(other.x + other.width, this.x + this.width) - x;
                    this.height = mathMax(other.y + other.height, this.y + this.height) - y;
                    this.x = x;
                    this.y = y;
                },
                applyTransform: function () {
                    var min = [];
                    var max = [];
                    return function (m) {
                        if (!m) {
                            return;
                        }
                        min[0] = this.x;
                        min[1] = this.y;
                        max[0] = this.x + this.width;
                        max[1] = this.y + this.height;
                        v2ApplyTransform(min, min, m);
                        v2ApplyTransform(max, max, m);
                        this.x = mathMin(min[0], max[0]);
                        this.y = mathMin(min[1], max[1]);
                        this.width = mathAbs(max[0] - min[0]);
                        this.height = mathAbs(max[1] - min[1]);
                    };
                }(),
                calculateTransform: function (b) {
                    var a = this;
                    var sx = b.width / a.width;
                    var sy = b.height / a.height;
                    var m = matrix.create();
                    matrix.translate(m, m, [
                        -a.x,
                        -a.y
                    ]);
                    matrix.scale(m, m, [
                        sx,
                        sy
                    ]);
                    matrix.translate(m, m, [
                        b.x,
                        b.y
                    ]);
                    return m;
                },
                intersect: function (b) {
                    var a = this;
                    var ax0 = a.x;
                    var ax1 = a.x + a.width;
                    var ay0 = a.y;
                    var ay1 = a.y + a.height;
                    var bx0 = b.x;
                    var bx1 = b.x + b.width;
                    var by0 = b.y;
                    var by1 = b.y + b.height;
                    return !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
                },
                contain: function (x, y) {
                    var rect = this;
                    return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;
                },
                clone: function () {
                    return new BoundingRect(this.x, this.y, this.width, this.height);
                },
                copy: function (other) {
                    this.x = other.x;
                    this.y = other.y;
                    this.width = other.width;
                    this.height = other.height;
                }
            };
            module.exports = BoundingRect;
        },
        function (module, exports) {
            var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
            var vector = {
                create: function (x, y) {
                    var out = new ArrayCtor(2);
                    out[0] = x || 0;
                    out[1] = y || 0;
                    return out;
                },
                copy: function (out, v) {
                    out[0] = v[0];
                    out[1] = v[1];
                    return out;
                },
                clone: function (v) {
                    var out = new ArrayCtor(2);
                    out[0] = v[0];
                    out[1] = v[1];
                    return out;
                },
                set: function (out, a, b) {
                    out[0] = a;
                    out[1] = b;
                    return out;
                },
                add: function (out, v1, v2) {
                    out[0] = v1[0] + v2[0];
                    out[1] = v1[1] + v2[1];
                    return out;
                },
                scaleAndAdd: function (out, v1, v2, a) {
                    out[0] = v1[0] + v2[0] * a;
                    out[1] = v1[1] + v2[1] * a;
                    return out;
                },
                sub: function (out, v1, v2) {
                    out[0] = v1[0] - v2[0];
                    out[1] = v1[1] - v2[1];
                    return out;
                },
                len: function (v) {
                    return Math.sqrt(this.lenSquare(v));
                },
                lenSquare: function (v) {
                    return v[0] * v[0] + v[1] * v[1];
                },
                mul: function (out, v1, v2) {
                    out[0] = v1[0] * v2[0];
                    out[1] = v1[1] * v2[1];
                    return out;
                },
                div: function (out, v1, v2) {
                    out[0] = v1[0] / v2[0];
                    out[1] = v1[1] / v2[1];
                    return out;
                },
                dot: function (v1, v2) {
                    return v1[0] * v2[0] + v1[1] * v2[1];
                },
                scale: function (out, v, s) {
                    out[0] = v[0] * s;
                    out[1] = v[1] * s;
                    return out;
                },
                normalize: function (out, v) {
                    var d = vector.len(v);
                    if (d === 0) {
                        out[0] = 0;
                        out[1] = 0;
                    } else {
                        out[0] = v[0] / d;
                        out[1] = v[1] / d;
                    }
                    return out;
                },
                distance: function (v1, v2) {
                    return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]));
                },
                distanceSquare: function (v1, v2) {
                    return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
                },
                negate: function (out, v) {
                    out[0] = -v[0];
                    out[1] = -v[1];
                    return out;
                },
                lerp: function (out, v1, v2, t) {
                    out[0] = v1[0] + t * (v2[0] - v1[0]);
                    out[1] = v1[1] + t * (v2[1] - v1[1]);
                    return out;
                },
                applyTransform: function (out, v, m) {
                    var x = v[0];
                    var y = v[1];
                    out[0] = m[0] * x + m[2] * y + m[4];
                    out[1] = m[1] * x + m[3] * y + m[5];
                    return out;
                },
                min: function (out, v1, v2) {
                    out[0] = Math.min(v1[0], v2[0]);
                    out[1] = Math.min(v1[1], v2[1]);
                    return out;
                },
                max: function (out, v1, v2) {
                    out[0] = Math.max(v1[0], v2[0]);
                    out[1] = Math.max(v1[1], v2[1]);
                    return out;
                }
            };
            vector.length = vector.len;
            vector.lengthSquare = vector.lenSquare;
            vector.dist = vector.distance;
            vector.distSquare = vector.distanceSquare;
            module.exports = vector;
        },
        function (module, exports) {
            var ArrayCtor = typeof Float32Array === 'undefined' ? Array : Float32Array;
            var matrix = {
                create: function () {
                    var out = new ArrayCtor(6);
                    matrix.identity(out);
                    return out;
                },
                identity: function (out) {
                    out[0] = 1;
                    out[1] = 0;
                    out[2] = 0;
                    out[3] = 1;
                    out[4] = 0;
                    out[5] = 0;
                    return out;
                },
                copy: function (out, m) {
                    out[0] = m[0];
                    out[1] = m[1];
                    out[2] = m[2];
                    out[3] = m[3];
                    out[4] = m[4];
                    out[5] = m[5];
                    return out;
                },
                mul: function (out, m1, m2) {
                    var out0 = m1[0] * m2[0] + m1[2] * m2[1];
                    var out1 = m1[1] * m2[0] + m1[3] * m2[1];
                    var out2 = m1[0] * m2[2] + m1[2] * m2[3];
                    var out3 = m1[1] * m2[2] + m1[3] * m2[3];
                    var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
                    var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
                    out[0] = out0;
                    out[1] = out1;
                    out[2] = out2;
                    out[3] = out3;
                    out[4] = out4;
                    out[5] = out5;
                    return out;
                },
                translate: function (out, a, v) {
                    out[0] = a[0];
                    out[1] = a[1];
                    out[2] = a[2];
                    out[3] = a[3];
                    out[4] = a[4] + v[0];
                    out[5] = a[5] + v[1];
                    return out;
                },
                rotate: function (out, a, rad) {
                    var aa = a[0];
                    var ac = a[2];
                    var atx = a[4];
                    var ab = a[1];
                    var ad = a[3];
                    var aty = a[5];
                    var st = Math.sin(rad);
                    var ct = Math.cos(rad);
                    out[0] = aa * ct + ab * st;
                    out[1] = -aa * st + ab * ct;
                    out[2] = ac * ct + ad * st;
                    out[3] = -ac * st + ct * ad;
                    out[4] = ct * atx + st * aty;
                    out[5] = ct * aty - st * atx;
                    return out;
                },
                scale: function (out, a, v) {
                    var vx = v[0];
                    var vy = v[1];
                    out[0] = a[0] * vx;
                    out[1] = a[1] * vy;
                    out[2] = a[2] * vx;
                    out[3] = a[3] * vy;
                    out[4] = a[4] * vx;
                    out[5] = a[5] * vy;
                    return out;
                },
                invert: function (out, a) {
                    var aa = a[0];
                    var ac = a[2];
                    var atx = a[4];
                    var ab = a[1];
                    var ad = a[3];
                    var aty = a[5];
                    var det = aa * ad - ab * ac;
                    if (!det) {
                        return null;
                    }
                    det = 1 / det;
                    out[0] = ad * det;
                    out[1] = -ab * det;
                    out[2] = -ac * det;
                    out[3] = aa * det;
                    out[4] = (ac * aty - ad * atx) * det;
                    out[5] = (ab * atx - aa * aty) * det;
                    return out;
                }
            };
            module.exports = matrix;
        },
        function (module, exports, __webpack_require__) {
            module.exports = {
                getItemStyle: __webpack_require__(11)([
                    [
                        'fill',
                        'color'
                    ],
                    [
                        'stroke',
                        'borderColor'
                    ],
                    [
                        'lineWidth',
                        'borderWidth'
                    ],
                    ['opacity'],
                    ['shadowBlur'],
                    ['shadowOffsetX'],
                    ['shadowOffsetY'],
                    ['shadowColor']
                ])
            };
        },
        function (module, exports, __webpack_require__) {
            var Model = __webpack_require__(8);
            var zrUtil = __webpack_require__(3);
            var arrayPush = Array.prototype.push;
            var componentUtil = __webpack_require__(20);
            var clazzUtil = __webpack_require__(9);
            var layout = __webpack_require__(21);
            var ComponentModel = Model.extend({
                type: 'component',
                id: '',
                name: '',
                mainType: '',
                subType: '',
                componentIndex: 0,
                defaultOption: null,
                ecModel: null,
                dependentModels: [],
                uid: null,
                layoutMode: null,
                init: function (option, parentModel, ecModel, extraOpt) {
                    this.mergeDefaultAndTheme(this.option, this.ecModel);
                },
                mergeDefaultAndTheme: function (option, ecModel) {
                    var layoutMode = this.layoutMode;
                    var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
                    var themeModel = ecModel.getTheme();
                    zrUtil.merge(option, themeModel.get(this.mainType));
                    zrUtil.merge(option, this.getDefaultOption());
                    if (layoutMode) {
                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
                    }
                },
                mergeOption: function (option) {
                    zrUtil.merge(this.option, option, true);
                    var layoutMode = this.layoutMode;
                    if (layoutMode) {
                        layout.mergeLayoutParam(this.option, option, layoutMode);
                    }
                },
                optionUpdated: function (ecModel) {
                },
                getDefaultOption: function () {
                    if (!this.hasOwnProperty('__defaultOption')) {
                        var optList = [];
                        var Class = this.constructor;
                        while (Class) {
                            var opt = Class.prototype.defaultOption;
                            opt && optList.push(opt);
                            Class = Class.superClass;
                        }
                        var defaultOption = {};
                        for (var i = optList.length - 1; i >= 0; i--) {
                            defaultOption = zrUtil.merge(defaultOption, optList[i], true);
                        }
                        this.__defaultOption = defaultOption;
                    }
                    return this.__defaultOption;
                }
            });
            clazzUtil.enableClassExtend(ComponentModel, function (option, parentModel, ecModel, extraOpt) {
                zrUtil.extend(this, extraOpt);
                this.uid = componentUtil.getUID('componentModel');
            });
            clazzUtil.enableClassManagement(ComponentModel, { registerWhenExtend: true });
            componentUtil.enableSubTypeDefaulter(ComponentModel);
            componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);
            function getDependencies(componentType) {
                var deps = [];
                zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {
                    arrayPush.apply(deps, Clazz.prototype.dependencies || []);
                });
                return zrUtil.map(deps, function (type) {
                    return clazzUtil.parseClassType(type).main;
                });
            }
            zrUtil.mixin(ComponentModel, __webpack_require__(22));
            module.exports = ComponentModel;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var clazz = __webpack_require__(9);
            var parseClassType = clazz.parseClassType;
            var base = 0;
            var componentUtil = {};
            var DELIMITER = '_';
            componentUtil.getUID = function (type) {
                return [
                    type || '',
                    base++,
                    Math.random()
                ].join(DELIMITER);
            };
            componentUtil.enableSubTypeDefaulter = function (entity) {
                var subTypeDefaulters = {};
                entity.registerSubTypeDefaulter = function (componentType, defaulter) {
                    componentType = parseClassType(componentType);
                    subTypeDefaulters[componentType.main] = defaulter;
                };
                entity.determineSubType = function (componentType, option) {
                    var type = option.type;
                    if (!type) {
                        var componentTypeMain = parseClassType(componentType).main;
                        if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
                            type = subTypeDefaulters[componentTypeMain](option);
                        }
                    }
                    return type;
                };
                return entity;
            };
            componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {
                entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
                    if (!targetNameList.length) {
                        return;
                    }
                    var result = makeDepndencyGraph(fullNameList);
                    var graph = result.graph;
                    var stack = result.noEntryList;
                    var targetNameSet = {};
                    zrUtil.each(targetNameList, function (name) {
                        targetNameSet[name] = true;
                    });
                    while (stack.length) {
                        var currComponentType = stack.pop();
                        var currVertex = graph[currComponentType];
                        var isInTargetNameSet = !!targetNameSet[currComponentType];
                        if (isInTargetNameSet) {
                            callback.call(context, currComponentType, currVertex.originalDeps.slice());
                            delete targetNameSet[currComponentType];
                        }
                        zrUtil.each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge);
                    }
                    zrUtil.each(targetNameSet, function () {
                        throw new Error('Circle dependency may exists');
                    });
                    function removeEdge(succComponentType) {
                        graph[succComponentType].entryCount--;
                        if (graph[succComponentType].entryCount === 0) {
                            stack.push(succComponentType);
                        }
                    }
                    function removeEdgeAndAdd(succComponentType) {
                        targetNameSet[succComponentType] = true;
                        removeEdge(succComponentType);
                    }
                };
                function makeDepndencyGraph(fullNameList) {
                    var graph = {};
                    var noEntryList = [];
                    zrUtil.each(fullNameList, function (name) {
                        var thisItem = createDependencyGraphItem(graph, name);
                        var originalDeps = thisItem.originalDeps = dependencyGetter(name);
                        var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
                        thisItem.entryCount = availableDeps.length;
                        if (thisItem.entryCount === 0) {
                            noEntryList.push(name);
                        }
                        zrUtil.each(availableDeps, function (dependentName) {
                            if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {
                                thisItem.predecessor.push(dependentName);
                            }
                            var thatItem = createDependencyGraphItem(graph, dependentName);
                            if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {
                                thatItem.successor.push(name);
                            }
                        });
                    });
                    return {
                        graph: graph,
                        noEntryList: noEntryList
                    };
                }
                function createDependencyGraphItem(graph, name) {
                    if (!graph[name]) {
                        graph[name] = {
                            predecessor: [],
                            successor: []
                        };
                    }
                    return graph[name];
                }
                function getAvailableDependencies(originalDeps, fullNameList) {
                    var availableDeps = [];
                    zrUtil.each(originalDeps, function (dep) {
                        zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
                    });
                    return availableDeps;
                }
            };
            module.exports = componentUtil;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var BoundingRect = __webpack_require__(15);
            var numberUtil = __webpack_require__(7);
            var formatUtil = __webpack_require__(6);
            var parsePercent = numberUtil.parsePercent;
            var each = zrUtil.each;
            var layout = {};
            var LOCATION_PARAMS = [
                'left',
                'right',
                'top',
                'bottom',
                'width',
                'height'
            ];
            function boxLayout(orient, group, gap, maxWidth, maxHeight) {
                var x = 0;
                var y = 0;
                if (maxWidth == null) {
                    maxWidth = Infinity;
                }
                if (maxHeight == null) {
                    maxHeight = Infinity;
                }
                var currentLineMaxSize = 0;
                group.eachChild(function (child, idx) {
                    var position = child.position;
                    var rect = child.getBoundingRect();
                    var nextChild = group.childAt(idx + 1);
                    var nextChildRect = nextChild && nextChild.getBoundingRect();
                    var nextX;
                    var nextY;
                    if (orient === 'horizontal') {
                        var moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0);
                        nextX = x + moveX;
                        if (nextX > maxWidth || child.newline) {
                            x = 0;
                            nextX = moveX;
                            y += currentLineMaxSize + gap;
                            currentLineMaxSize = rect.height;
                        } else {
                            currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
                        }
                    } else {
                        var moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0);
                        nextY = y + moveY;
                        if (nextY > maxHeight || child.newline) {
                            x += currentLineMaxSize + gap;
                            y = 0;
                            nextY = moveY;
                            currentLineMaxSize = rect.width;
                        } else {
                            currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
                        }
                    }
                    if (child.newline) {
                        return;
                    }
                    position[0] = x;
                    position[1] = y;
                    orient === 'horizontal' ? x = nextX + gap : y = nextY + gap;
                });
            }
            layout.box = boxLayout;
            layout.vbox = zrUtil.curry(boxLayout, 'vertical');
            layout.hbox = zrUtil.curry(boxLayout, 'horizontal');
            layout.getAvailableSize = function (positionInfo, containerRect, margin) {
                var containerWidth = containerRect.width;
                var containerHeight = containerRect.height;
                var x = parsePercent(positionInfo.x, containerWidth);
                var y = parsePercent(positionInfo.y, containerHeight);
                var x2 = parsePercent(positionInfo.x2, containerWidth);
                var y2 = parsePercent(positionInfo.y2, containerHeight);
                (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
                (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
                (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
                (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);
                margin = formatUtil.normalizeCssArray(margin || 0);
                return {
                    width: Math.max(x2 - x - margin[1] - margin[3], 0),
                    height: Math.max(y2 - y - margin[0] - margin[2], 0)
                };
            };
            layout.getLayoutRect = function (positionInfo, containerRect, margin) {
                margin = formatUtil.normalizeCssArray(margin || 0);
                var containerWidth = containerRect.width;
                var containerHeight = containerRect.height;
                var left = parsePercent(positionInfo.left, containerWidth);
                var top = parsePercent(positionInfo.top, containerHeight);
                var right = parsePercent(positionInfo.right, containerWidth);
                var bottom = parsePercent(positionInfo.bottom, containerHeight);
                var width = parsePercent(positionInfo.width, containerWidth);
                var height = parsePercent(positionInfo.height, containerHeight);
                var verticalMargin = margin[2] + margin[0];
                var horizontalMargin = margin[1] + margin[3];
                var aspect = positionInfo.aspect;
                if (isNaN(width)) {
                    width = containerWidth - right - horizontalMargin - left;
                }
                if (isNaN(height)) {
                    height = containerHeight - bottom - verticalMargin - top;
                }
                if (isNaN(width) && isNaN(height)) {
                    if (aspect > containerWidth / containerHeight) {
                        width = containerWidth * 0.8;
                    } else {
                        height = containerHeight * 0.8;
                    }
                }
                if (aspect != null) {
                    if (isNaN(width)) {
                        width = aspect * height;
                    }
                    if (isNaN(height)) {
                        height = width / aspect;
                    }
                }
                if (isNaN(left)) {
                    left = containerWidth - right - width - horizontalMargin;
                }
                if (isNaN(top)) {
                    top = containerHeight - bottom - height - verticalMargin;
                }
                switch (positionInfo.left || positionInfo.right) {
                case 'center':
                    left = containerWidth / 2 - width / 2 - margin[3];
                    break;
                case 'right':
                    left = containerWidth - width - horizontalMargin;
                    break;
                }
                switch (positionInfo.top || positionInfo.bottom) {
                case 'middle':
                case 'center':
                    top = containerHeight / 2 - height / 2 - margin[0];
                    break;
                case 'bottom':
                    top = containerHeight - height - verticalMargin;
                    break;
                }
                left = left || 0;
                top = top || 0;
                if (isNaN(width)) {
                    width = containerWidth - left - (right || 0);
                }
                if (isNaN(height)) {
                    height = containerHeight - top - (bottom || 0);
                }
                var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
                rect.margin = margin;
                return rect;
            };
            layout.positionGroup = function (group, positionInfo, containerRect, margin) {
                var groupRect = group.getBoundingRect();
                positionInfo = zrUtil.extend(zrUtil.clone(positionInfo), {
                    width: groupRect.width,
                    height: groupRect.height
                });
                positionInfo = layout.getLayoutRect(positionInfo, containerRect, margin);
                group.position = [
                    positionInfo.x - groupRect.x,
                    positionInfo.y - groupRect.y
                ];
            };
            layout.mergeLayoutParam = function (targetOption, newOption, opt) {
                !zrUtil.isObject(opt) && (opt = {});
                var hNames = [
                    'width',
                    'left',
                    'right'
                ];
                var vNames = [
                    'height',
                    'top',
                    'bottom'
                ];
                var hResult = merge(hNames);
                var vResult = merge(vNames);
                copy(hNames, targetOption, hResult);
                copy(vNames, targetOption, vResult);
                function merge(names) {
                    var newParams = {};
                    var newValueCount = 0;
                    var merged = {};
                    var mergedValueCount = 0;
                    var enoughParamNumber = opt.ignoreSize ? 1 : 2;
                    each(names, function (name) {
                        merged[name] = targetOption[name];
                    });
                    each(names, function (name) {
                        hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
                        hasValue(newParams, name) && newValueCount++;
                        hasValue(merged, name) && mergedValueCount++;
                    });
                    if (mergedValueCount === enoughParamNumber || !newValueCount) {
                        return merged;
                    } else if (newValueCount >= enoughParamNumber) {
                        return newParams;
                    } else {
                        for (var i = 0; i < names.length; i++) {
                            var name = names[i];
                            if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
                                newParams[name] = targetOption[name];
                                break;
                            }
                        }
                        return newParams;
                    }
                }
                function hasProp(obj, name) {
                    return obj.hasOwnProperty(name);
                }
                function hasValue(obj, name) {
                    return obj[name] != null && obj[name] !== 'auto';
                }
                function copy(names, target, source) {
                    each(names, function (name) {
                        target[name] = source[name];
                    });
                }
            };
            layout.getLayoutParams = function (source) {
                return layout.copyLayoutParams({}, source);
            };
            layout.copyLayoutParams = function (target, source) {
                source && target && each(LOCATION_PARAMS, function (name) {
                    source.hasOwnProperty(name) && (target[name] = source[name]);
                });
                return target;
            };
            module.exports = layout;
        },
        function (module, exports) {
            module.exports = {
                getBoxLayoutParams: function () {
                    return {
                        left: this.get('left'),
                        top: this.get('top'),
                        right: this.get('right'),
                        bottom: this.get('bottom'),
                        width: this.get('width'),
                        height: this.get('height')
                    };
                }
            };
        },
        function (module, exports) {
            var platform = '';
            if (typeof navigator !== 'undefined') {
                platform = navigator.platform || '';
            }
            module.exports = {
                color: [
                    '#c23531',
                    '#2f4554',
                    '#61a0a8',
                    '#d48265',
                    '#91c7ae',
                    '#749f83',
                    '#ca8622',
                    '#bda29a',
                    '#6e7074',
                    '#546570',
                    '#c4ccd3'
                ],
                grid: {},
                textStyle: {
                    fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
                    fontSize: 12,
                    fontStyle: 'normal',
                    fontWeight: 'normal'
                },
                animation: true,
                animationThreshold: 2000,
                animationDuration: 1000,
                animationDurationUpdate: 300,
                animationEasing: 'exponentialOut',
                animationEasingUpdate: 'cubicOut'
            };
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var echartsAPIList = [
                'getDom',
                'getZr',
                'getWidth',
                'getHeight',
                'dispatchAction',
                'on',
                'off',
                'getDataURL',
                'getConnectedDataURL',
                'getModel',
                'getOption'
            ];
            function ExtensionAPI(chartInstance) {
                zrUtil.each(echartsAPIList, function (name) {
                    this[name] = zrUtil.bind(chartInstance[name], chartInstance);
                }, this);
            }
            module.exports = ExtensionAPI;
        },
        function (module, exports) {
            'use strict';
            var coordinateSystemCreators = {};
            function CoordinateSystemManager() {
                this._coordinateSystems = [];
            }
            CoordinateSystemManager.prototype = {
                constructor: CoordinateSystemManager,
                create: function (ecModel, api) {
                    var coordinateSystems = [];
                    for (var type in coordinateSystemCreators) {
                        var list = coordinateSystemCreators[type].create(ecModel, api);
                        list && (coordinateSystems = coordinateSystems.concat(list));
                    }
                    this._coordinateSystems = coordinateSystems;
                },
                update: function (ecModel, api) {
                    var coordinateSystems = this._coordinateSystems;
                    for (var i = 0; i < coordinateSystems.length; i++) {
                        coordinateSystems[i].update && coordinateSystems[i].update(ecModel, api);
                    }
                }
            };
            CoordinateSystemManager.register = function (type, coordinateSystemCreator) {
                coordinateSystemCreators[type] = coordinateSystemCreator;
            };
            CoordinateSystemManager.get = function (type) {
                return coordinateSystemCreators[type];
            };
            module.exports = CoordinateSystemManager;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var modelUtil = __webpack_require__(5);
            var ComponentModel = __webpack_require__(19);
            var each = zrUtil.each;
            var clone = zrUtil.clone;
            var map = zrUtil.map;
            var merge = zrUtil.merge;
            var QUERY_REG = /^(min|max)?(.+)$/;
            function OptionManager(api) {
                this._api = api;
                this._timelineOptions = [];
                this._mediaList = [];
                this._mediaDefault;
                this._currentMediaIndices = [];
                this._optionBackup;
                this._newOptionBackup;
            }
            OptionManager.prototype = {
                constructor: OptionManager,
                setOption: function (rawOption, optionPreprocessorFuncs) {
                    rawOption = clone(rawOption, true);
                    var oldOptionBackup = this._optionBackup;
                    var newOptionBackup = this._newOptionBackup = parseRawOption.call(this, rawOption, optionPreprocessorFuncs);
                    if (oldOptionBackup) {
                        mergeOption(oldOptionBackup.baseOption, newOptionBackup.baseOption);
                        if (newOptionBackup.timelineOptions.length) {
                            oldOptionBackup.timelineOptions = newOptionBackup.timelineOptions;
                        }
                        if (newOptionBackup.mediaList.length) {
                            oldOptionBackup.mediaList = newOptionBackup.mediaList;
                        }
                        if (newOptionBackup.mediaDefault) {
                            oldOptionBackup.mediaDefault = newOptionBackup.mediaDefault;
                        }
                    } else {
                        this._optionBackup = newOptionBackup;
                    }
                },
                mountOption: function (isRecreate) {
                    var optionBackup = isRecreate ? this._optionBackup : this._newOptionBackup;
                    this._timelineOptions = map(optionBackup.timelineOptions, clone);
                    this._mediaList = map(optionBackup.mediaList, clone);
                    this._mediaDefault = clone(optionBackup.mediaDefault);
                    this._currentMediaIndices = [];
                    return clone(optionBackup.baseOption);
                },
                getTimelineOption: function (ecModel) {
                    var option;
                    var timelineOptions = this._timelineOptions;
                    if (timelineOptions.length) {
                        var timelineModel = ecModel.getComponent('timeline');
                        if (timelineModel) {
                            option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);
                        }
                    }
                    return option;
                },
                getMediaOption: function (ecModel) {
                    var ecWidth = this._api.getWidth();
                    var ecHeight = this._api.getHeight();
                    var mediaList = this._mediaList;
                    var mediaDefault = this._mediaDefault;
                    var indices = [];
                    var result = [];
                    if (!mediaList.length && !mediaDefault) {
                        return result;
                    }
                    for (var i = 0, len = mediaList.length; i < len; i++) {
                        if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
                            indices.push(i);
                        }
                    }
                    if (!indices.length && mediaDefault) {
                        indices = [-1];
                    }
                    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
                        result = map(indices, function (index) {
                            return clone(index === -1 ? mediaDefault.option : mediaList[index].option);
                        });
                    }
                    this._currentMediaIndices = indices;
                    return result;
                }
            };
            function parseRawOption(rawOption, optionPreprocessorFuncs) {
                var timelineOptions = [];
                var mediaList = [];
                var mediaDefault;
                var baseOption;
                var timelineOpt = rawOption.timeline;
                if (rawOption.baseOption) {
                    baseOption = rawOption.baseOption;
                }
                if (timelineOpt || rawOption.options) {
                    baseOption = baseOption || {};
                    timelineOptions = (rawOption.options || []).slice();
                }
                if (rawOption.media) {
                    baseOption = baseOption || {};
                    var media = rawOption.media;
                    each(media, function (singleMedia) {
                        if (singleMedia && singleMedia.option) {
                            if (singleMedia.query) {
                                mediaList.push(singleMedia);
                            } else if (!mediaDefault) {
                                mediaDefault = singleMedia;
                            }
                        }
                    });
                }
                if (!baseOption) {
                    baseOption = rawOption;
                }
                if (!baseOption.timeline) {
                    baseOption.timeline = timelineOpt;
                }
                each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {
                    return media.option;
                })), function (option) {
                    each(optionPreprocessorFuncs, function (preProcess) {
                        preProcess(option);
                    });
                });
                return {
                    baseOption: baseOption,
                    timelineOptions: timelineOptions,
                    mediaDefault: mediaDefault,
                    mediaList: mediaList
                };
            }
            function applyMediaQuery(query, ecWidth, ecHeight) {
                var realMap = {
                    width: ecWidth,
                    height: ecHeight,
                    aspectratio: ecWidth / ecHeight
                };
                var applicatable = true;
                zrUtil.each(query, function (value, attr) {
                    var matched = attr.match(QUERY_REG);
                    if (!matched || !matched[1] || !matched[2]) {
                        return;
                    }
                    var operator = matched[1];
                    var realAttr = matched[2].toLowerCase();
                    if (!compare(realMap[realAttr], value, operator)) {
                        applicatable = false;
                    }
                });
                return applicatable;
            }
            function compare(real, expect, operator) {
                if (operator === 'min') {
                    return real >= expect;
                } else if (operator === 'max') {
                    return real <= expect;
                } else {
                    return real === expect;
                }
            }
            function indicesEquals(indices1, indices2) {
                return indices1.join(',') === indices2.join(',');
            }
            function mergeOption(oldOption, newOption) {
                newOption = newOption || {};
                each(newOption, function (newCptOpt, mainType) {
                    if (newCptOpt == null) {
                        return;
                    }
                    var oldCptOpt = oldOption[mainType];
                    if (!ComponentModel.hasClass(mainType)) {
                        oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);
                    } else {
                        newCptOpt = modelUtil.normalizeToArray(newCptOpt);
                        oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);
                        var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);
                        oldOption[mainType] = map(mapResult, function (item) {
                            return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;
                        });
                    }
                });
            }
            module.exports = OptionManager;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var formatUtil = __webpack_require__(6);
            var modelUtil = __webpack_require__(5);
            var ComponentModel = __webpack_require__(19);
            var encodeHTML = formatUtil.encodeHTML;
            var addCommas = formatUtil.addCommas;
            var SeriesModel = ComponentModel.extend({
                type: 'series.__base__',
                seriesIndex: 0,
                coordinateSystem: null,
                defaultOption: null,
                legendDataProvider: null,
                init: function (option, parentModel, ecModel, extraOpt) {
                    this.seriesIndex = this.componentIndex;
                    this.mergeDefaultAndTheme(option, ecModel);
                    this._dataBeforeProcessed = this.getInitialData(option, ecModel);
                    this._data = this._dataBeforeProcessed.cloneShallow();
                },
                mergeDefaultAndTheme: function (option, ecModel) {
                    zrUtil.merge(option, ecModel.getTheme().get(this.subType));
                    zrUtil.merge(option, this.getDefaultOption());
                    modelUtil.defaultEmphasis(option.label, [
                        'position',
                        'show',
                        'textStyle',
                        'distance',
                        'formatter'
                    ]);
                    var data = option.data || [];
                    for (var i = 0; i < data.length; i++) {
                        if (data[i] && data[i].label) {
                            modelUtil.defaultEmphasis(data[i].label, [
                                'position',
                                'show',
                                'textStyle',
                                'distance',
                                'formatter'
                            ]);
                        }
                    }
                },
                mergeOption: function (newSeriesOption, ecModel) {
                    newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);
                    var data = this.getInitialData(newSeriesOption, ecModel);
                    if (data) {
                        this._data = data;
                        this._dataBeforeProcessed = data.cloneShallow();
                    }
                },
                getInitialData: function () {
                },
                getData: function () {
                    return this._data;
                },
                setData: function (data) {
                    this._data = data;
                },
                getRawData: function () {
                    return this._dataBeforeProcessed;
                },
                getRawDataArray: function () {
                    return this.option.data;
                },
                coordDimToDataDim: function (coordDim) {
                    return [coordDim];
                },
                dataDimToCoordDim: function (dataDim) {
                    return dataDim;
                },
                getBaseAxis: function () {
                    var coordSys = this.coordinateSystem;
                    return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
                },
                formatTooltip: function (dataIndex, multipleSeries) {
                    var data = this._data;
                    var value = this.getRawValue(dataIndex);
                    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);
                    var name = data.getName(dataIndex);
                    var color = data.getItemVisual(dataIndex, 'color');
                    var colorEl = '<span style="display:inline-block;margin-right:5px;' + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '"></span>';
                    return !multipleSeries ? encodeHTML(this.name) + '<br />' + colorEl + (name ? encodeHTML(name) + ' : ' + formattedValue : formattedValue) : colorEl + encodeHTML(this.name) + ' : ' + formattedValue;
                },
                restoreData: function () {
                    this._data = this._dataBeforeProcessed.cloneShallow();
                }
            });
            zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);
            module.exports = SeriesModel;
        },
        function (module, exports, __webpack_require__) {
            var Group = __webpack_require__(29);
            var componentUtil = __webpack_require__(20);
            var clazzUtil = __webpack_require__(9);
            var Component = function () {
                this.group = new Group();
                this.uid = componentUtil.getUID('viewComponent');
            };
            Component.prototype = {
                constructor: Component,
                init: function (ecModel, api) {
                },
                render: function (componentModel, ecModel, api, payload) {
                },
                dispose: function () {
                }
            };
            var componentProto = Component.prototype;
            componentProto.updateView = componentProto.updateLayout = componentProto.updateVisual = function (seriesModel, ecModel, api, payload) {
            };
            clazzUtil.enableClassExtend(Component);
            clazzUtil.enableClassManagement(Component, { registerWhenExtend: true });
            module.exports = Component;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var Element = __webpack_require__(30);
            var BoundingRect = __webpack_require__(15);
            var Group = function (opts) {
                opts = opts || {};
                Element.call(this, opts);
                for (var key in opts) {
                    this[key] = opts[key];
                }
                this._children = [];
                this.__storage = null;
                this.__dirty = true;
            };
            Group.prototype = {
                constructor: Group,
                type: 'group',
                silent: false,
                children: function () {
                    return this._children.slice();
                },
                childAt: function (idx) {
                    return this._children[idx];
                },
                childOfName: function (name) {
                    var children = this._children;
                    for (var i = 0; i < children.length; i++) {
                        if (children[i].name === name) {
                            return children[i];
                        }
                    }
                },
                childCount: function () {
                    return this._children.length;
                },
                add: function (child) {
                    if (child && child !== this && child.parent !== this) {
                        this._children.push(child);
                        this._doAdd(child);
                    }
                    return this;
                },
                addBefore: function (child, nextSibling) {
                    if (child && child !== this && child.parent !== this && nextSibling && nextSibling.parent === this) {
                        var children = this._children;
                        var idx = children.indexOf(nextSibling);
                        if (idx >= 0) {
                            children.splice(idx, 0, child);
                            this._doAdd(child);
                        }
                    }
                    return this;
                },
                _doAdd: function (child) {
                    if (child.parent) {
                        child.parent.remove(child);
                    }
                    child.parent = this;
                    var storage = this.__storage;
                    var zr = this.__zr;
                    if (storage && storage !== child.__storage) {
                        storage.addToMap(child);
                        if (child instanceof Group) {
                            child.addChildrenToStorage(storage);
                        }
                    }
                    zr && zr.refresh();
                },
                remove: function (child) {
                    var zr = this.__zr;
                    var storage = this.__storage;
                    var children = this._children;
                    var idx = zrUtil.indexOf(children, child);
                    if (idx < 0) {
                        return this;
                    }
                    children.splice(idx, 1);
                    child.parent = null;
                    if (storage) {
                        storage.delFromMap(child.id);
                        if (child instanceof Group) {
                            child.delChildrenFromStorage(storage);
                        }
                    }
                    zr && zr.refresh();
                    return this;
                },
                removeAll: function () {
                    var children = this._children;
                    var storage = this.__storage;
                    var child;
                    var i;
                    for (i = 0; i < children.length; i++) {
                        child = children[i];
                        if (storage) {
                            storage.delFromMap(child.id);
                            if (child instanceof Group) {
                                child.delChildrenFromStorage(storage);
                            }
                        }
                        child.parent = null;
                    }
                    children.length = 0;
                    return this;
                },
                eachChild: function (cb, context) {
                    var children = this._children;
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        cb.call(context, child, i);
                    }
                    return this;
                },
                traverse: function (cb, context) {
                    for (var i = 0; i < this._children.length; i++) {
                        var child = this._children[i];
                        cb.call(context, child);
                        if (child.type === 'group') {
                            child.traverse(cb, context);
                        }
                    }
                    return this;
                },
                addChildrenToStorage: function (storage) {
                    for (var i = 0; i < this._children.length; i++) {
                        var child = this._children[i];
                        storage.addToMap(child);
                        if (child instanceof Group) {
                            child.addChildrenToStorage(storage);
                        }
                    }
                },
                delChildrenFromStorage: function (storage) {
                    for (var i = 0; i < this._children.length; i++) {
                        var child = this._children[i];
                        storage.delFromMap(child.id);
                        if (child instanceof Group) {
                            child.delChildrenFromStorage(storage);
                        }
                    }
                },
                dirty: function () {
                    this.__dirty = true;
                    this.__zr && this.__zr.refresh();
                    return this;
                },
                getBoundingRect: function (includeChildren) {
                    var rect = null;
                    var tmpRect = new BoundingRect(0, 0, 0, 0);
                    var children = includeChildren || this._children;
                    var tmpMat = [];
                    for (var i = 0; i < children.length; i++) {
                        var child = children[i];
                        if (child.ignore || child.invisible) {
                            continue;
                        }
                        var childRect = child.getBoundingRect();
                        var transform = child.getLocalTransform(tmpMat);
                        if (transform) {
                            tmpRect.copy(childRect);
                            tmpRect.applyTransform(transform);
                            rect = rect || tmpRect.clone();
                            rect.union(tmpRect);
                        } else {
                            rect = rect || childRect.clone();
                            rect.union(childRect);
                        }
                    }
                    return rect || tmpRect;
                }
            };
            zrUtil.inherits(Group, Element);
            module.exports = Group;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var guid = __webpack_require__(31);
            var Eventful = __webpack_require__(32);
            var Transformable = __webpack_require__(33);
            var Animatable = __webpack_require__(34);
            var zrUtil = __webpack_require__(3);
            var Element = function (opts) {
                Transformable.call(this, opts);
                Eventful.call(this, opts);
                Animatable.call(this, opts);
                this.id = opts.id || guid();
            };
            Element.prototype = {
                type: 'element',
                name: '',
                __zr: null,
                ignore: false,
                clipPath: null,
                drift: function (dx, dy) {
                    switch (this.draggable) {
                    case 'horizontal':
                        dy = 0;
                        break;
                    case 'vertical':
                        dx = 0;
                        break;
                    }
                    var m = this.transform;
                    if (!m) {
                        m = this.transform = [
                            1,
                            0,
                            0,
                            1,
                            0,
                            0
                        ];
                    }
                    m[4] += dx;
                    m[5] += dy;
                    this.decomposeTransform();
                    this.dirty();
                },
                beforeUpdate: function () {
                },
                afterUpdate: function () {
                },
                update: function () {
                    this.updateTransform();
                },
                traverse: function (cb, context) {
                },
                attrKV: function (key, value) {
                    if (key === 'position' || key === 'scale' || key === 'origin') {
                        if (value) {
                            var target = this[key];
                            if (!target) {
                                target = this[key] = [];
                            }
                            target[0] = value[0];
                            target[1] = value[1];
                        }
                    } else {
                        this[key] = value;
                    }
                },
                hide: function () {
                    this.ignore = true;
                    this.__zr && this.__zr.refresh();
                },
                show: function () {
                    this.ignore = false;
                    this.__zr && this.__zr.refresh();
                },
                attr: function (key, value) {
                    if (typeof key === 'string') {
                        this.attrKV(key, value);
                    } else if (zrUtil.isObject(key)) {
                        for (var name in key) {
                            if (key.hasOwnProperty(name)) {
                                this.attrKV(name, key[name]);
                            }
                        }
                    }
                    this.dirty();
                    return this;
                },
                setClipPath: function (clipPath) {
                    var zr = this.__zr;
                    if (zr) {
                        clipPath.addSelfToZr(zr);
                    }
                    if (this.clipPath && this.clipPath !== clipPath) {
                        this.removeClipPath();
                    }
                    this.clipPath = clipPath;
                    clipPath.__zr = zr;
                    clipPath.__clipTarget = this;
                    this.dirty();
                },
                removeClipPath: function () {
                    var clipPath = this.clipPath;
                    if (clipPath) {
                        if (clipPath.__zr) {
                            clipPath.removeSelfFromZr(clipPath.__zr);
                        }
                        clipPath.__zr = null;
                        clipPath.__clipTarget = null;
                        this.clipPath = null;
                        this.dirty();
                    }
                },
                addSelfToZr: function (zr) {
                    this.__zr = zr;
                    var animators = this.animators;
                    if (animators) {
                        for (var i = 0; i < animators.length; i++) {
                            zr.animation.addAnimator(animators[i]);
                        }
                    }
                    if (this.clipPath) {
                        this.clipPath.addSelfToZr(zr);
                    }
                },
                removeSelfFromZr: function (zr) {
                    this.__zr = null;
                    var animators = this.animators;
                    if (animators) {
                        for (var i = 0; i < animators.length; i++) {
                            zr.animation.removeAnimator(animators[i]);
                        }
                    }
                    if (this.clipPath) {
                        this.clipPath.removeSelfFromZr(zr);
                    }
                }
            };
            zrUtil.mixin(Element, Animatable);
            zrUtil.mixin(Element, Transformable);
            zrUtil.mixin(Element, Eventful);
            module.exports = Element;
        },
        function (module, exports) {
            var idStart = 2311;
            module.exports = function () {
                return 'zr_' + idStart++;
            };
        },
        function (module, exports, __webpack_require__) {
            var arrySlice = Array.prototype.slice;
            var zrUtil = __webpack_require__(3);
            var indexOf = zrUtil.indexOf;
            var Eventful = function () {
                this._$handlers = {};
            };
            Eventful.prototype = {
                constructor: Eventful,
                one: function (event, handler, context) {
                    var _h = this._$handlers;
                    if (!handler || !event) {
                        return this;
                    }
                    if (!_h[event]) {
                        _h[event] = [];
                    }
                    if (indexOf(_h[event], event) >= 0) {
                        return this;
                    }
                    _h[event].push({
                        h: handler,
                        one: true,
                        ctx: context || this
                    });
                    return this;
                },
                on: function (event, handler, context) {
                    var _h = this._$handlers;
                    if (!handler || !event) {
                        return this;
                    }
                    if (!_h[event]) {
                        _h[event] = [];
                    }
                    _h[event].push({
                        h: handler,
                        one: false,
                        ctx: context || this
                    });
                    return this;
                },
                isSilent: function (event) {
                    var _h = this._$handlers;
                    return _h[event] && _h[event].length;
                },
                off: function (event, handler) {
                    var _h = this._$handlers;
                    if (!event) {
                        this._$handlers = {};
                        return this;
                    }
                    if (handler) {
                        if (_h[event]) {
                            var newList = [];
                            for (var i = 0, l = _h[event].length; i < l; i++) {
                                if (_h[event][i]['h'] != handler) {
                                    newList.push(_h[event][i]);
                                }
                            }
                            _h[event] = newList;
                        }
                        if (_h[event] && _h[event].length === 0) {
                            delete _h[event];
                        }
                    } else {
                        delete _h[event];
                    }
                    return this;
                },
                trigger: function (type) {
                    if (this._$handlers[type]) {
                        var args = arguments;
                        var argLen = args.length;
                        if (argLen > 3) {
                            args = arrySlice.call(args, 1);
                        }
                        var _h = this._$handlers[type];
                        var len = _h.length;
                        for (var i = 0; i < len;) {
                            switch (argLen) {
                            case 1:
                                _h[i]['h'].call(_h[i]['ctx']);
                                break;
                            case 2:
                                _h[i]['h'].call(_h[i]['ctx'], args[1]);
                                break;
                            case 3:
                                _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
                                break;
                            default:
                                _h[i]['h'].apply(_h[i]['ctx'], args);
                                break;
                            }
                            if (_h[i]['one']) {
                                _h.splice(i, 1);
                                len--;
                            } else {
                                i++;
                            }
                        }
                    }
                    return this;
                },
                triggerWithContext: function (type) {
                    if (this._$handlers[type]) {
                        var args = arguments;
                        var argLen = args.length;
                        if (argLen > 4) {
                            args = arrySlice.call(args, 1, args.length - 1);
                        }
                        var ctx = args[args.length - 1];
                        var _h = this._$handlers[type];
                        var len = _h.length;
                        for (var i = 0; i < len;) {
                            switch (argLen) {
                            case 1:
                                _h[i]['h'].call(ctx);
                                break;
                            case 2:
                                _h[i]['h'].call(ctx, args[1]);
                                break;
                            case 3:
                                _h[i]['h'].call(ctx, args[1], args[2]);
                                break;
                            default:
                                _h[i]['h'].apply(ctx, args);
                                break;
                            }
                            if (_h[i]['one']) {
                                _h.splice(i, 1);
                                len--;
                            } else {
                                i++;
                            }
                        }
                    }
                    return this;
                }
            };
            module.exports = Eventful;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var matrix = __webpack_require__(17);
            var vector = __webpack_require__(16);
            var mIdentity = matrix.identity;
            var EPSILON = 0.00005;
            function isNotAroundZero(val) {
                return val > EPSILON || val < -EPSILON;
            }
            var Transformable = function (opts) {
                opts = opts || {};
                if (!opts.position) {
                    this.position = [
                        0,
                        0
                    ];
                }
                if (opts.rotation == null) {
                    this.rotation = 0;
                }
                if (!opts.scale) {
                    this.scale = [
                        1,
                        1
                    ];
                }
                this.origin = this.origin || null;
            };
            var transformableProto = Transformable.prototype;
            transformableProto.transform = null;
            transformableProto.needLocalTransform = function () {
                return isNotAroundZero(this.rotation) || isNotAroundZero(this.position[0]) || isNotAroundZero(this.position[1]) || isNotAroundZero(this.scale[0] - 1) || isNotAroundZero(this.scale[1] - 1);
            };
            transformableProto.updateTransform = function () {
                var parent = this.parent;
                var parentHasTransform = parent && parent.transform;
                var needLocalTransform = this.needLocalTransform();
                var m = this.transform;
                if (!(needLocalTransform || parentHasTransform)) {
                    m && mIdentity(m);
                    return;
                }
                m = m || matrix.create();
                if (needLocalTransform) {
                    this.getLocalTransform(m);
                } else {
                    mIdentity(m);
                }
                if (parentHasTransform) {
                    if (needLocalTransform) {
                        matrix.mul(m, parent.transform, m);
                    } else {
                        matrix.copy(m, parent.transform);
                    }
                }
                this.transform = m;
                this.invTransform = this.invTransform || matrix.create();
                matrix.invert(this.invTransform, m);
            };
            transformableProto.getLocalTransform = function (m) {
                m = m || [];
                mIdentity(m);
                var origin = this.origin;
                var scale = this.scale;
                var rotation = this.rotation;
                var position = this.position;
                if (origin) {
                    m[4] -= origin[0];
                    m[5] -= origin[1];
                }
                matrix.scale(m, m, scale);
                if (rotation) {
                    matrix.rotate(m, m, rotation);
                }
                if (origin) {
                    m[4] += origin[0];
                    m[5] += origin[1];
                }
                m[4] += position[0];
                m[5] += position[1];
                return m;
            };
            transformableProto.setTransform = function (ctx) {
                var m = this.transform;
                if (m) {
                    ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
            };
            var tmpTransform = [];
            transformableProto.decomposeTransform = function () {
                if (!this.transform) {
                    return;
                }
                var parent = this.parent;
                var m = this.transform;
                if (parent && parent.transform) {
                    matrix.mul(tmpTransform, parent.invTransform, m);
                    m = tmpTransform;
                }
                var sx = m[0] * m[0] + m[1] * m[1];
                var sy = m[2] * m[2] + m[3] * m[3];
                var position = this.position;
                var scale = this.scale;
                if (isNotAroundZero(sx - 1)) {
                    sx = Math.sqrt(sx);
                }
                if (isNotAroundZero(sy - 1)) {
                    sy = Math.sqrt(sy);
                }
                if (m[0] < 0) {
                    sx = -sx;
                }
                if (m[3] < 0) {
                    sy = -sy;
                }
                position[0] = m[4];
                position[1] = m[5];
                scale[0] = sx;
                scale[1] = sy;
                this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
            };
            transformableProto.transformCoordToLocal = function (x, y) {
                var v2 = [
                    x,
                    y
                ];
                var invTransform = this.invTransform;
                if (invTransform) {
                    vector.applyTransform(v2, v2, invTransform);
                }
                return v2;
            };
            transformableProto.transformCoordToGlobal = function (x, y) {
                var v2 = [
                    x,
                    y
                ];
                var transform = this.transform;
                if (transform) {
                    vector.applyTransform(v2, v2, transform);
                }
                return v2;
            };
            module.exports = Transformable;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var Animator = __webpack_require__(35);
            var util = __webpack_require__(3);
            var isString = util.isString;
            var isFunction = util.isFunction;
            var isObject = util.isObject;
            var log = __webpack_require__(39);
            var Animatable = function () {
                this.animators = [];
            };
            Animatable.prototype = {
                constructor: Animatable,
                animate: function (path, loop) {
                    var target;
                    var animatingShape = false;
                    var el = this;
                    var zr = this.__zr;
                    if (path) {
                        var pathSplitted = path.split('.');
                        var prop = el;
                        animatingShape = pathSplitted[0] === 'shape';
                        for (var i = 0, l = pathSplitted.length; i < l; i++) {
                            if (!prop) {
                                continue;
                            }
                            prop = prop[pathSplitted[i]];
                        }
                        if (prop) {
                            target = prop;
                        }
                    } else {
                        target = el;
                    }
                    if (!target) {
                        log('Property "' + path + '" is not existed in element ' + el.id);
                        return;
                    }
                    var animators = el.animators;
                    var animator = new Animator(target, loop);
                    animator.during(function (target) {
                        el.dirty(animatingShape);
                    }).done(function () {
                        animators.splice(util.indexOf(animators, animator), 1);
                    });
                    animators.push(animator);
                    if (zr) {
                        zr.animation.addAnimator(animator);
                    }
                    return animator;
                },
                stopAnimation: function (forwardToLast) {
                    var animators = this.animators;
                    var len = animators.length;
                    for (var i = 0; i < len; i++) {
                        animators[i].stop(forwardToLast);
                    }
                    animators.length = 0;
                    return this;
                },
                animateTo: function (target, time, delay, easing, callback) {
                    if (isString(delay)) {
                        callback = easing;
                        easing = delay;
                        delay = 0;
                    } else if (isFunction(easing)) {
                        callback = easing;
                        easing = 'linear';
                        delay = 0;
                    } else if (isFunction(delay)) {
                        callback = delay;
                        delay = 0;
                    } else if (isFunction(time)) {
                        callback = time;
                        time = 500;
                    } else if (!time) {
                        time = 500;
                    }
                    this.stopAnimation();
                    this._animateToShallow('', this, target, time, delay, easing, callback);
                    var animators = this.animators.slice();
                    var count = animators.length;
                    function done() {
                        count--;
                        if (!count) {
                            callback && callback();
                        }
                    }
                    if (!count) {
                        callback && callback();
                    }
                    for (var i = 0; i < animators.length; i++) {
                        animators[i].done(done).start(easing);
                    }
                },
                _animateToShallow: function (path, source, target, time, delay) {
                    var objShallow = {};
                    var propertyCount = 0;
                    for (var name in target) {
                        if (source[name] != null) {
                            if (isObject(target[name]) && !util.isArrayLike(target[name])) {
                                this._animateToShallow(path ? path + '.' + name : name, source[name], target[name], time, delay);
                            } else {
                                objShallow[name] = target[name];
                                propertyCount++;
                            }
                        } else if (target[name] != null) {
                            if (!path) {
                                this.attr(name, target[name]);
                            } else {
                                var props = {};
                                props[path] = {};
                                props[path][name] = target[name];
                                this.attr(props);
                            }
                        }
                    }
                    if (propertyCount > 0) {
                        this.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);
                    }
                    return this;
                }
            };
            module.exports = Animatable;
        },
        function (module, exports, __webpack_require__) {
            var Clip = __webpack_require__(36);
            var color = __webpack_require__(38);
            var util = __webpack_require__(3);
            var isArrayLike = util.isArrayLike;
            var arraySlice = Array.prototype.slice;
            function defaultGetter(target, key) {
                return target[key];
            }
            function defaultSetter(target, key, value) {
                target[key] = value;
            }
            function interpolateNumber(p0, p1, percent) {
                return (p1 - p0) * percent + p0;
            }
            function interpolateString(p0, p1, percent) {
                return percent > 0.5 ? p1 : p0;
            }
            function interpolateArray(p0, p1, percent, out, arrDim) {
                var len = p0.length;
                if (arrDim == 1) {
                    for (var i = 0; i < len; i++) {
                        out[i] = interpolateNumber(p0[i], p1[i], percent);
                    }
                } else {
                    var len2 = p0[0].length;
                    for (var i = 0; i < len; i++) {
                        for (var j = 0; j < len2; j++) {
                            out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent);
                        }
                    }
                }
            }
            function fillArr(arr0, arr1, arrDim) {
                var arr0Len = arr0.length;
                var arr1Len = arr1.length;
                if (arr0Len === arr1Len) {
                    return;
                }
                var isPreviousLarger = arr0Len > arr1Len;
                if (isPreviousLarger) {
                    arr0.length = arr1Len;
                } else {
                    for (var i = arr0Len; i < arr1Len; i++) {
                        arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]));
                    }
                }
            }
            function isArraySame(arr0, arr1, arrDim) {
                if (arr0 === arr1) {
                    return true;
                }
                var len = arr0.length;
                if (len !== arr1.length) {
                    return false;
                }
                if (arrDim === 1) {
                    for (var i = 0; i < len; i++) {
                        if (arr0[i] !== arr1[i]) {
                            return false;
                        }
                    }
                } else {
                    var len2 = arr0[0].length;
                    for (var i = 0; i < len; i++) {
                        for (var j = 0; j < len2; j++) {
                            if (arr0[i][j] !== arr1[i][j]) {
                                return false;
                            }
                        }
                    }
                }
                return true;
            }
            function catmullRomInterpolateArray(p0, p1, p2, p3, t, t2, t3, out, arrDim) {
                var len = p0.length;
                if (arrDim == 1) {
                    for (var i = 0; i < len; i++) {
                        out[i] = catmullRomInterpolate(p0[i], p1[i], p2[i], p3[i], t, t2, t3);
                    }
                } else {
                    var len2 = p0[0].length;
                    for (var i = 0; i < len; i++) {
                        for (var j = 0; j < len2; j++) {
                            out[i][j] = catmullRomInterpolate(p0[i][j], p1[i][j], p2[i][j], p3[i][j], t, t2, t3);
                        }
                    }
                }
            }
            function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
                var v0 = (p2 - p0) * 0.5;
                var v1 = (p3 - p1) * 0.5;
                return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
            }
            function cloneValue(value) {
                if (isArrayLike(value)) {
                    var len = value.length;
                    if (isArrayLike(value[0])) {
                        var ret = [];
                        for (var i = 0; i < len; i++) {
                            ret.push(arraySlice.call(value[i]));
                        }
                        return ret;
                    }
                    return arraySlice.call(value);
                }
                return value;
            }
            function rgba2String(rgba) {
                rgba[0] = Math.floor(rgba[0]);
                rgba[1] = Math.floor(rgba[1]);
                rgba[2] = Math.floor(rgba[2]);
                return 'rgba(' + rgba.join(',') + ')';
            }
            function createTrackClip(animator, easing, oneTrackDone, keyframes, propName) {
                var getter = animator._getter;
                var setter = animator._setter;
                var useSpline = easing === 'spline';
                var trackLen = keyframes.length;
                if (!trackLen) {
                    return;
                }
                var firstVal = keyframes[0].value;
                var isValueArray = isArrayLike(firstVal);
                var isValueColor = false;
                var isValueString = false;
                var arrDim = isValueArray && isArrayLike(firstVal[0]) ? 2 : 1;
                var trackMaxTime;
                keyframes.sort(function (a, b) {
                    return a.time - b.time;
                });
                trackMaxTime = keyframes[trackLen - 1].time;
                var kfPercents = [];
                var kfValues = [];
                var prevValue = keyframes[0].value;
                var isAllValueEqual = true;
                for (var i = 0; i < trackLen; i++) {
                    kfPercents.push(keyframes[i].time / trackMaxTime);
                    var value = keyframes[i].value;
                    if (!(isValueArray && isArraySame(value, prevValue, arrDim) || !isValueArray && value === prevValue)) {
                        isAllValueEqual = false;
                    }
                    prevValue = value;
                    if (typeof value == 'string') {
                        var colorArray = color.parse(value);
                        if (colorArray) {
                            value = colorArray;
                            isValueColor = true;
                        } else {
                            isValueString = true;
                        }
                    }
                    kfValues.push(value);
                }
                if (isAllValueEqual) {
                    return;
                }
                if (isValueArray) {
                    var lastValue = kfValues[trackLen - 1];
                    for (var i = 0; i < trackLen - 1; i++) {
                        fillArr(kfValues[i], lastValue, arrDim);
                    }
                    fillArr(getter(animator._target, propName), lastValue, arrDim);
                }
                var lastFrame = 0;
                var lastFramePercent = 0;
                var start;
                var w;
                var p0;
                var p1;
                var p2;
                var p3;
                if (isValueColor) {
                    var rgba = [
                        0,
                        0,
                        0,
                        0
                    ];
                }
                var onframe = function (target, percent) {
                    var frame;
                    if (percent < lastFramePercent) {
                        start = Math.min(lastFrame + 1, trackLen - 1);
                        for (frame = start; frame >= 0; frame--) {
                            if (kfPercents[frame] <= percent) {
                                break;
                            }
                        }
                        frame = Math.min(frame, trackLen - 2);
                    } else {
                        for (frame = lastFrame; frame < trackLen; frame++) {
                            if (kfPercents[frame] > percent) {
                                break;
                            }
                        }
                        frame = Math.min(frame - 1, trackLen - 2);
                    }
                    lastFrame = frame;
                    lastFramePercent = percent;
                    var range = kfPercents[frame + 1] - kfPercents[frame];
                    if (range === 0) {
                        return;
                    } else {
                        w = (percent - kfPercents[frame]) / range;
                    }
                    if (useSpline) {
                        p1 = kfValues[frame];
                        p0 = kfValues[frame === 0 ? frame : frame - 1];
                        p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
                        p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
                        if (isValueArray) {
                            catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, getter(target, propName), arrDim);
                        } else {
                            var value;
                            if (isValueColor) {
                                value = catmullRomInterpolateArray(p0, p1, p2, p3, w, w * w, w * w * w, rgba, 1);
                                value = rgba2String(rgba);
                            } else if (isValueString) {
                                return interpolateString(p1, p2, w);
                            } else {
                                value = catmullRomInterpolate(p0, p1, p2, p3, w, w * w, w * w * w);
                            }
                            setter(target, propName, value);
                        }
                    } else {
                        if (isValueArray) {
                            interpolateArray(kfValues[frame], kfValues[frame + 1], w, getter(target, propName), arrDim);
                        } else {
                            var value;
                            if (isValueColor) {
                                interpolateArray(kfValues[frame], kfValues[frame + 1], w, rgba, 1);
                                value = rgba2String(rgba);
                            } else if (isValueString) {
                                return interpolateString(kfValues[frame], kfValues[frame + 1], w);
                            } else {
                                value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
                            }
                            setter(target, propName, value);
                        }
                    }
                };
                var clip = new Clip({
                    target: animator._target,
                    life: trackMaxTime,
                    loop: animator._loop,
                    delay: animator._delay,
                    onframe: onframe,
                    ondestroy: oneTrackDone
                });
                if (easing && easing !== 'spline') {
                    clip.easing = easing;
                }
                return clip;
            }
            var Animator = function (target, loop, getter, setter) {
                this._tracks = {};
                this._target = target;
                this._loop = loop || false;
                this._getter = getter || defaultGetter;
                this._setter = setter || defaultSetter;
                this._clipCount = 0;
                this._delay = 0;
                this._doneList = [];
                this._onframeList = [];
                this._clipList = [];
            };
            Animator.prototype = {
                when: function (time, props) {
                    var tracks = this._tracks;
                    for (var propName in props) {
                        if (!tracks[propName]) {
                            tracks[propName] = [];
                            var value = this._getter(this._target, propName);
                            if (value == null) {
                                continue;
                            }
                            if (time !== 0) {
                                tracks[propName].push({
                                    time: 0,
                                    value: cloneValue(value)
                                });
                            }
                        }
                        tracks[propName].push({
                            time: time,
                            value: props[propName]
                        });
                    }
                    return this;
                },
                during: function (callback) {
                    this._onframeList.push(callback);
                    return this;
                },
                _doneCallback: function () {
                    this._tracks = {};
                    this._clipList.length = 0;
                    var doneList = this._doneList;
                    var len = doneList.length;
                    for (var i = 0; i < len; i++) {
                        doneList[i].call(this);
                    }
                },
                start: function (easing) {
                    var self = this;
                    var clipCount = 0;
                    var oneTrackDone = function () {
                        clipCount--;
                        if (!clipCount) {
                            self._doneCallback();
                        }
                    };
                    var lastClip;
                    for (var propName in this._tracks) {
                        var clip = createTrackClip(this, easing, oneTrackDone, this._tracks[propName], propName);
                        if (clip) {
                            this._clipList.push(clip);
                            clipCount++;
                            if (this.animation) {
                                this.animation.addClip(clip);
                            }
                            lastClip = clip;
                        }
                    }
                    if (lastClip) {
                        var oldOnFrame = lastClip.onframe;
                        lastClip.onframe = function (target, percent) {
                            oldOnFrame(target, percent);
                            for (var i = 0; i < self._onframeList.length; i++) {
                                self._onframeList[i](target, percent);
                            }
                        };
                    }
                    if (!clipCount) {
                        this._doneCallback();
                    }
                    return this;
                },
                stop: function (forwardToLast) {
                    var clipList = this._clipList;
                    var animation = this.animation;
                    for (var i = 0; i < clipList.length; i++) {
                        var clip = clipList[i];
                        if (forwardToLast) {
                            clip.onframe(this._target, 1);
                        }
                        animation && animation.removeClip(clip);
                    }
                    clipList.length = 0;
                },
                delay: function (time) {
                    this._delay = time;
                    return this;
                },
                done: function (cb) {
                    if (cb) {
                        this._doneList.push(cb);
                    }
                    return this;
                },
                getClips: function () {
                    return this._clipList;
                }
            };
            module.exports = Animator;
        },
        function (module, exports, __webpack_require__) {
            var easingFuncs = __webpack_require__(37);
            function Clip(options) {
                this._target = options.target;
                this._life = options.life || 1000;
                this._delay = options.delay || 0;
                this._initialized = false;
                this.loop = options.loop == null ? false : options.loop;
                this.gap = options.gap || 0;
                this.easing = options.easing || 'Linear';
                this.onframe = options.onframe;
                this.ondestroy = options.ondestroy;
                this.onrestart = options.onrestart;
            }
            Clip.prototype = {
                constructor: Clip,
                step: function (time) {
                    if (!this._initialized) {
                        this._startTime = new Date().getTime() + this._delay;
                        this._initialized = true;
                    }
                    var percent = (time - this._startTime) / this._life;
                    if (percent < 0) {
                        return;
                    }
                    percent = Math.min(percent, 1);
                    var easing = this.easing;
                    var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
                    var schedule = typeof easingFunc === 'function' ? easingFunc(percent) : percent;
                    this.fire('frame', schedule);
                    if (percent == 1) {
                        if (this.loop) {
                            this.restart();
                            return 'restart';
                        }
                        this._needsRemove = true;
                        return 'destroy';
                    }
                    return null;
                },
                restart: function () {
                    var time = new Date().getTime();
                    var remainder = (time - this._startTime) % this._life;
                    this._startTime = new Date().getTime() - remainder + this.gap;
                    this._needsRemove = false;
                },
                fire: function (eventType, arg) {
                    eventType = 'on' + eventType;
                    if (this[eventType]) {
                        this[eventType](this._target, arg);
                    }
                }
            };
            module.exports = Clip;
        },
        function (module, exports) {
            var easing = {
                linear: function (k) {
                    return k;
                },
                quadraticIn: function (k) {
                    return k * k;
                },
                quadraticOut: function (k) {
                    return k * (2 - k);
                },
                quadraticInOut: function (k) {
                    if ((k *= 2) < 1) {
                        return 0.5 * k * k;
                    }
                    return -0.5 * (--k * (k - 2) - 1);
                },
                cubicIn: function (k) {
                    return k * k * k;
                },
                cubicOut: function (k) {
                    return --k * k * k + 1;
                },
                cubicInOut: function (k) {
                    if ((k *= 2) < 1) {
                        return 0.5 * k * k * k;
                    }
                    return 0.5 * ((k -= 2) * k * k + 2);
                },
                quarticIn: function (k) {
                    return k * k * k * k;
                },
                quarticOut: function (k) {
                    return 1 - --k * k * k * k;
                },
                quarticInOut: function (k) {
                    if ((k *= 2) < 1) {
                        return 0.5 * k * k * k * k;
                    }
                    return -0.5 * ((k -= 2) * k * k * k - 2);
                },
                quinticIn: function (k) {
                    return k * k * k * k * k;
                },
                quinticOut: function (k) {
                    return --k * k * k * k * k + 1;
                },
                quinticInOut: function (k) {
                    if ((k *= 2) < 1) {
                        return 0.5 * k * k * k * k * k;
                    }
                    return 0.5 * ((k -= 2) * k * k * k * k + 2);
                },
                sinusoidalIn: function (k) {
                    return 1 - Math.cos(k * Math.PI / 2);
                },
                sinusoidalOut: function (k) {
                    return Math.sin(k * Math.PI / 2);
                },
                sinusoidalInOut: function (k) {
                    return 0.5 * (1 - Math.cos(Math.PI * k));
                },
                exponentialIn: function (k) {
                    return k === 0 ? 0 : Math.pow(1024, k - 1);
                },
                exponentialOut: function (k) {
                    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
                },
                exponentialInOut: function (k) {
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if ((k *= 2) < 1) {
                        return 0.5 * Math.pow(1024, k - 1);
                    }
                    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
                },
                circularIn: function (k) {
                    return 1 - Math.sqrt(1 - k * k);
                },
                circularOut: function (k) {
                    return Math.sqrt(1 - --k * k);
                },
                circularInOut: function (k) {
                    if ((k *= 2) < 1) {
                        return -0.5 * (Math.sqrt(1 - k * k) - 1);
                    }
                    return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
                },
                elasticIn: function (k) {
                    var s;
                    var a = 0.1;
                    var p = 0.4;
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if (!a || a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    }
                    return -(a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                },
                elasticOut: function (k) {
                    var s;
                    var a = 0.1;
                    var p = 0.4;
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if (!a || a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    }
                    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;
                },
                elasticInOut: function (k) {
                    var s;
                    var a = 0.1;
                    var p = 0.4;
                    if (k === 0) {
                        return 0;
                    }
                    if (k === 1) {
                        return 1;
                    }
                    if (!a || a < 1) {
                        a = 1;
                        s = p / 4;
                    } else {
                        s = p * Math.asin(1 / a) / (2 * Math.PI);
                    }
                    if ((k *= 2) < 1) {
                        return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p));
                    }
                    return a * Math.pow(2, -10 * (k -= 1)) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;
                },
                backIn: function (k) {
                    var s = 1.70158;
                    return k * k * ((s + 1) * k - s);
                },
                backOut: function (k) {
                    var s = 1.70158;
                    return --k * k * ((s + 1) * k + s) + 1;
                },
                backInOut: function (k) {
                    var s = 1.70158 * 1.525;
                    if ((k *= 2) < 1) {
                        return 0.5 * (k * k * ((s + 1) * k - s));
                    }
                    return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
                },
                bounceIn: function (k) {
                    return 1 - easing.bounceOut(1 - k);
                },
                bounceOut: function (k) {
                    if (k < 1 / 2.75) {
                        return 7.5625 * k * k;
                    } else if (k < 2 / 2.75) {
                        return 7.5625 * (k -= 1.5 / 2.75) * k + 0.75;
                    } else if (k < 2.5 / 2.75) {
                        return 7.5625 * (k -= 2.25 / 2.75) * k + 0.9375;
                    } else {
                        return 7.5625 * (k -= 2.625 / 2.75) * k + 0.984375;
                    }
                },
                bounceInOut: function (k) {
                    if (k < 0.5) {
                        return easing.bounceIn(k * 2) * 0.5;
                    }
                    return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
                }
            };
            module.exports = easing;
        },
        function (module, exports) {
            var kCSSColorTable = {
                'transparent': [
                    0,
                    0,
                    0,
                    0
                ],
                'aliceblue': [
                    240,
                    248,
                    255,
                    1
                ],
                'antiquewhite': [
                    250,
                    235,
                    215,
                    1
                ],
                'aqua': [
                    0,
                    255,
                    255,
                    1
                ],
                'aquamarine': [
                    127,
                    255,
                    212,
                    1
                ],
                'azure': [
                    240,
                    255,
                    255,
                    1
                ],
                'beige': [
                    245,
                    245,
                    220,
                    1
                ],
                'bisque': [
                    255,
                    228,
                    196,
                    1
                ],
                'black': [
                    0,
                    0,
                    0,
                    1
                ],
                'blanchedalmond': [
                    255,
                    235,
                    205,
                    1
                ],
                'blue': [
                    0,
                    0,
                    255,
                    1
                ],
                'blueviolet': [
                    138,
                    43,
                    226,
                    1
                ],
                'brown': [
                    165,
                    42,
                    42,
                    1
                ],
                'burlywood': [
                    222,
                    184,
                    135,
                    1
                ],
                'cadetblue': [
                    95,
                    158,
                    160,
                    1
                ],
                'chartreuse': [
                    127,
                    255,
                    0,
                    1
                ],
                'chocolate': [
                    210,
                    105,
                    30,
                    1
                ],
                'coral': [
                    255,
                    127,
                    80,
                    1
                ],
                'cornflowerblue': [
                    100,
                    149,
                    237,
                    1
                ],
                'cornsilk': [
                    255,
                    248,
                    220,
                    1
                ],
                'crimson': [
                    220,
                    20,
                    60,
                    1
                ],
                'cyan': [
                    0,
                    255,
                    255,
                    1
                ],
                'darkblue': [
                    0,
                    0,
                    139,
                    1
                ],
                'darkcyan': [
                    0,
                    139,
                    139,
                    1
                ],
                'darkgoldenrod': [
                    184,
                    134,
                    11,
                    1
                ],
                'darkgray': [
                    169,
                    169,
                    169,
                    1
                ],
                'darkgreen': [
                    0,
                    100,
                    0,
                    1
                ],
                'darkgrey': [
                    169,
                    169,
                    169,
                    1
                ],
                'darkkhaki': [
                    189,
                    183,
                    107,
                    1
                ],
                'darkmagenta': [
                    139,
                    0,
                    139,
                    1
                ],
                'darkolivegreen': [
                    85,
                    107,
                    47,
                    1
                ],
                'darkorange': [
                    255,
                    140,
                    0,
                    1
                ],
                'darkorchid': [
                    153,
                    50,
                    204,
                    1
                ],
                'darkred': [
                    139,
                    0,
                    0,
                    1
                ],
                'darksalmon': [
                    233,
                    150,
                    122,
                    1
                ],
                'darkseagreen': [
                    143,
                    188,
                    143,
                    1
                ],
                'darkslateblue': [
                    72,
                    61,
                    139,
                    1
                ],
                'darkslategray': [
                    47,
                    79,
                    79,
                    1
                ],
                'darkslategrey': [
                    47,
                    79,
                    79,
                    1
                ],
                'darkturquoise': [
                    0,
                    206,
                    209,
                    1
                ],
                'darkviolet': [
                    148,
                    0,
                    211,
                    1
                ],
                'deeppink': [
                    255,
                    20,
                    147,
                    1
                ],
                'deepskyblue': [
                    0,
                    191,
                    255,
                    1
                ],
                'dimgray': [
                    105,
                    105,
                    105,
                    1
                ],
                'dimgrey': [
                    105,
                    105,
                    105,
                    1
                ],
                'dodgerblue': [
                    30,
                    144,
                    255,
                    1
                ],
                'firebrick': [
                    178,
                    34,
                    34,
                    1
                ],
                'floralwhite': [
                    255,
                    250,
                    240,
                    1
                ],
                'forestgreen': [
                    34,
                    139,
                    34,
                    1
                ],
                'fuchsia': [
                    255,
                    0,
                    255,
                    1
                ],
                'gainsboro': [
                    220,
                    220,
                    220,
                    1
                ],
                'ghostwhite': [
                    248,
                    248,
                    255,
                    1
                ],
                'gold': [
                    255,
                    215,
                    0,
                    1
                ],
                'goldenrod': [
                    218,
                    165,
                    32,
                    1
                ],
                'gray': [
                    128,
                    128,
                    128,
                    1
                ],
                'green': [
                    0,
                    128,
                    0,
                    1
                ],
                'greenyellow': [
                    173,
                    255,
                    47,
                    1
                ],
                'grey': [
                    128,
                    128,
                    128,
                    1
                ],
                'honeydew': [
                    240,
                    255,
                    240,
                    1
                ],
                'hotpink': [
                    255,
                    105,
                    180,
                    1
                ],
                'indianred': [
                    205,
                    92,
                    92,
                    1
                ],
                'indigo': [
                    75,
                    0,
                    130,
                    1
                ],
                'ivory': [
                    255,
                    255,
                    240,
                    1
                ],
                'khaki': [
                    240,
                    230,
                    140,
                    1
                ],
                'lavender': [
                    230,
                    230,
                    250,
                    1
                ],
                'lavenderblush': [
                    255,
                    240,
                    245,
                    1
                ],
                'lawngreen': [
                    124,
                    252,
                    0,
                    1
                ],
                'lemonchiffon': [
                    255,
                    250,
                    205,
                    1
                ],
                'lightblue': [
                    173,
                    216,
                    230,
                    1
                ],
                'lightcoral': [
                    240,
                    128,
                    128,
                    1
                ],
                'lightcyan': [
                    224,
                    255,
                    255,
                    1
                ],
                'lightgoldenrodyellow': [
                    250,
                    250,
                    210,
                    1
                ],
                'lightgray': [
                    211,
                    211,
                    211,
                    1
                ],
                'lightgreen': [
                    144,
                    238,
                    144,
                    1
                ],
                'lightgrey': [
                    211,
                    211,
                    211,
                    1
                ],
                'lightpink': [
                    255,
                    182,
                    193,
                    1
                ],
                'lightsalmon': [
                    255,
                    160,
                    122,
                    1
                ],
                'lightseagreen': [
                    32,
                    178,
                    170,
                    1
                ],
                'lightskyblue': [
                    135,
                    206,
                    250,
                    1
                ],
                'lightslategray': [
                    119,
                    136,
                    153,
                    1
                ],
                'lightslategrey': [
                    119,
                    136,
                    153,
                    1
                ],
                'lightsteelblue': [
                    176,
                    196,
                    222,
                    1
                ],
                'lightyellow': [
                    255,
                    255,
                    224,
                    1
                ],
                'lime': [
                    0,
                    255,
                    0,
                    1
                ],
                'limegreen': [
                    50,
                    205,
                    50,
                    1
                ],
                'linen': [
                    250,
                    240,
                    230,
                    1
                ],
                'magenta': [
                    255,
                    0,
                    255,
                    1
                ],
                'maroon': [
                    128,
                    0,
                    0,
                    1
                ],
                'mediumaquamarine': [
                    102,
                    205,
                    170,
                    1
                ],
                'mediumblue': [
                    0,
                    0,
                    205,
                    1
                ],
                'mediumorchid': [
                    186,
                    85,
                    211,
                    1
                ],
                'mediumpurple': [
                    147,
                    112,
                    219,
                    1
                ],
                'mediumseagreen': [
                    60,
                    179,
                    113,
                    1
                ],
                'mediumslateblue': [
                    123,
                    104,
                    238,
                    1
                ],
                'mediumspringgreen': [
                    0,
                    250,
                    154,
                    1
                ],
                'mediumturquoise': [
                    72,
                    209,
                    204,
                    1
                ],
                'mediumvioletred': [
                    199,
                    21,
                    133,
                    1
                ],
                'midnightblue': [
                    25,
                    25,
                    112,
                    1
                ],
                'mintcream': [
                    245,
                    255,
                    250,
                    1
                ],
                'mistyrose': [
                    255,
                    228,
                    225,
                    1
                ],
                'moccasin': [
                    255,
                    228,
                    181,
                    1
                ],
                'navajowhite': [
                    255,
                    222,
                    173,
                    1
                ],
                'navy': [
                    0,
                    0,
                    128,
                    1
                ],
                'oldlace': [
                    253,
                    245,
                    230,
                    1
                ],
                'olive': [
                    128,
                    128,
                    0,
                    1
                ],
                'olivedrab': [
                    107,
                    142,
                    35,
                    1
                ],
                'orange': [
                    255,
                    165,
                    0,
                    1
                ],
                'orangered': [
                    255,
                    69,
                    0,
                    1
                ],
                'orchid': [
                    218,
                    112,
                    214,
                    1
                ],
                'palegoldenrod': [
                    238,
                    232,
                    170,
                    1
                ],
                'palegreen': [
                    152,
                    251,
                    152,
                    1
                ],
                'paleturquoise': [
                    175,
                    238,
                    238,
                    1
                ],
                'palevioletred': [
                    219,
                    112,
                    147,
                    1
                ],
                'papayawhip': [
                    255,
                    239,
                    213,
                    1
                ],
                'peachpuff': [
                    255,
                    218,
                    185,
                    1
                ],
                'peru': [
                    205,
                    133,
                    63,
                    1
                ],
                'pink': [
                    255,
                    192,
                    203,
                    1
                ],
                'plum': [
                    221,
                    160,
                    221,
                    1
                ],
                'powderblue': [
                    176,
                    224,
                    230,
                    1
                ],
                'purple': [
                    128,
                    0,
                    128,
                    1
                ],
                'red': [
                    255,
                    0,
                    0,
                    1
                ],
                'rosybrown': [
                    188,
                    143,
                    143,
                    1
                ],
                'royalblue': [
                    65,
                    105,
                    225,
                    1
                ],
                'saddlebrown': [
                    139,
                    69,
                    19,
                    1
                ],
                'salmon': [
                    250,
                    128,
                    114,
                    1
                ],
                'sandybrown': [
                    244,
                    164,
                    96,
                    1
                ],
                'seagreen': [
                    46,
                    139,
                    87,
                    1
                ],
                'seashell': [
                    255,
                    245,
                    238,
                    1
                ],
                'sienna': [
                    160,
                    82,
                    45,
                    1
                ],
                'silver': [
                    192,
                    192,
                    192,
                    1
                ],
                'skyblue': [
                    135,
                    206,
                    235,
                    1
                ],
                'slateblue': [
                    106,
                    90,
                    205,
                    1
                ],
                'slategray': [
                    112,
                    128,
                    144,
                    1
                ],
                'slategrey': [
                    112,
                    128,
                    144,
                    1
                ],
                'snow': [
                    255,
                    250,
                    250,
                    1
                ],
                'springgreen': [
                    0,
                    255,
                    127,
                    1
                ],
                'steelblue': [
                    70,
                    130,
                    180,
                    1
                ],
                'tan': [
                    210,
                    180,
                    140,
                    1
                ],
                'teal': [
                    0,
                    128,
                    128,
                    1
                ],
                'thistle': [
                    216,
                    191,
                    216,
                    1
                ],
                'tomato': [
                    255,
                    99,
                    71,
                    1
                ],
                'turquoise': [
                    64,
                    224,
                    208,
                    1
                ],
                'violet': [
                    238,
                    130,
                    238,
                    1
                ],
                'wheat': [
                    245,
                    222,
                    179,
                    1
                ],
                'white': [
                    255,
                    255,
                    255,
                    1
                ],
                'whitesmoke': [
                    245,
                    245,
                    245,
                    1
                ],
                'yellow': [
                    255,
                    255,
                    0,
                    1
                ],
                'yellowgreen': [
                    154,
                    205,
                    50,
                    1
                ]
            };
            function clampCssByte(i) {
                i = Math.round(i);
                return i < 0 ? 0 : i > 255 ? 255 : i;
            }
            function clampCssAngle(i) {
                i = Math.round(i);
                return i < 0 ? 0 : i > 360 ? 360 : i;
            }
            function clampCssFloat(f) {
                return f < 0 ? 0 : f > 1 ? 1 : f;
            }
            function parseCssInt(str) {
                if (str.length && str.charAt(str.length - 1) === '%') {
                    return clampCssByte(parseFloat(str) / 100 * 255);
                }
                return clampCssByte(parseInt(str, 10));
            }
            function parseCssFloat(str) {
                if (str.length && str.charAt(str.length - 1) === '%') {
                    return clampCssFloat(parseFloat(str) / 100);
                }
                return clampCssFloat(parseFloat(str));
            }
            function cssHueToRgb(m1, m2, h) {
                if (h < 0) {
                    h += 1;
                } else if (h > 1) {
                    h -= 1;
                }
                if (h * 6 < 1) {
                    return m1 + (m2 - m1) * h * 6;
                }
                if (h * 2 < 1) {
                    return m2;
                }
                if (h * 3 < 2) {
                    return m1 + (m2 - m1) * (2 / 3 - h) * 6;
                }
                return m1;
            }
            function lerp(a, b, p) {
                return a + (b - a) * p;
            }
            function parse(colorStr) {
                if (!colorStr) {
                    return;
                }
                colorStr = colorStr + '';
                var str = colorStr.replace(/ /g, '').toLowerCase();
                if (str in kCSSColorTable) {
                    return kCSSColorTable[str].slice();
                }
                if (str.charAt(0) === '#') {
                    if (str.length === 4) {
                        var iv = parseInt(str.substr(1), 16);
                        if (!(iv >= 0 && iv <= 4095)) {
                            return;
                        }
                        return [
                            (iv & 3840) >> 4 | (iv & 3840) >> 8,
                            iv & 240 | (iv & 240) >> 4,
                            iv & 15 | (iv & 15) << 4,
                            1
                        ];
                    } else if (str.length === 7) {
                        var iv = parseInt(str.substr(1), 16);
                        if (!(iv >= 0 && iv <= 16777215)) {
                            return;
                        }
                        return [
                            (iv & 16711680) >> 16,
                            (iv & 65280) >> 8,
                            iv & 255,
                            1
                        ];
                    }
                    return;
                }
                var op = str.indexOf('('), ep = str.indexOf(')');
                if (op !== -1 && ep + 1 === str.length) {
                    var fname = str.substr(0, op);
                    var params = str.substr(op + 1, ep - (op + 1)).split(',');
                    var alpha = 1;
                    switch (fname) {
                    case 'rgba':
                        if (params.length !== 4) {
                            return;
                        }
                        alpha = parseCssFloat(params.pop());
                    case 'rgb':
                        if (params.length !== 3) {
                            return;
                        }
                        return [
                            parseCssInt(params[0]),
                            parseCssInt(params[1]),
                            parseCssInt(params[2]),
                            alpha
                        ];
                    case 'hsla':
                        if (params.length !== 4) {
                            return;
                        }
                        params[3] = parseCssFloat(params[3]);
                        return hsla2rgba(params);
                    case 'hsl':
                        if (params.length !== 3) {
                            return;
                        }
                        return hsla2rgba(params);
                    default:
                        return;
                    }
                }
                return;
            }
            function hsla2rgba(hsla) {
                var h = (parseFloat(hsla[0]) % 360 + 360) % 360 / 360;
                var s = parseCssFloat(hsla[1]);
                var l = parseCssFloat(hsla[2]);
                var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
                var m1 = l * 2 - m2;
                var rgba = [
                    clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),
                    clampCssByte(cssHueToRgb(m1, m2, h) * 255),
                    clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)
                ];
                if (hsla.length === 4) {
                    rgba[3] = hsla[3];
                }
                return rgba;
            }
            function rgba2hsla(rgba) {
                if (!rgba) {
                    return;
                }
                var R = rgba[0] / 255;
                var G = rgba[1] / 255;
                var B = rgba[2] / 255;
                var vMin = Math.min(R, G, B);
                var vMax = Math.max(R, G, B);
                var delta = vMax - vMin;
                var L = (vMax + vMin) / 2;
                var H;
                var S;
                if (delta === 0) {
                    H = 0;
                    S = 0;
                } else {
                    if (L < 0.5) {
                        S = delta / (vMax + vMin);
                    } else {
                        S = delta / (2 - vMax - vMin);
                    }
                    var deltaR = ((vMax - R) / 6 + delta / 2) / delta;
                    var deltaG = ((vMax - G) / 6 + delta / 2) / delta;
                    var deltaB = ((vMax - B) / 6 + delta / 2) / delta;
                    if (R === vMax) {
                        H = deltaB - deltaG;
                    } else if (G === vMax) {
                        H = 1 / 3 + deltaR - deltaB;
                    } else if (B === vMax) {
                        H = 2 / 3 + deltaG - deltaR;
                    }
                    if (H < 0) {
                        H += 1;
                    }
                    if (H > 1) {
                        H -= 1;
                    }
                }
                var hsla = [
                    H * 360,
                    S,
                    L
                ];
                if (rgba[3] != null) {
                    hsla.push(rgba[3]);
                }
                return hsla;
            }
            function lift(color, level) {
                var colorArr = parse(color);
                if (colorArr) {
                    for (var i = 0; i < 3; i++) {
                        if (level < 0) {
                            colorArr[i] = colorArr[i] * (1 - level) | 0;
                        } else {
                            colorArr[i] = (255 - colorArr[i]) * level + colorArr[i] | 0;
                        }
                    }
                    return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
                }
            }
            function toHex(color, level) {
                var colorArr = parse(color);
                if (colorArr) {
                    return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + +colorArr[2]).toString(16).slice(1);
                }
            }
            function fastMapToColor(normalizedValue, colors, out) {
                if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
                    return;
                }
                out = out || [
                    0,
                    0,
                    0,
                    0
                ];
                var value = normalizedValue * (colors.length - 1);
                var leftIndex = Math.floor(value);
                var rightIndex = Math.ceil(value);
                var leftColor = colors[leftIndex];
                var rightColor = colors[rightIndex];
                var dv = value - leftIndex;
                out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));
                out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));
                out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));
                out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));
                return out;
            }
            function mapToColor(normalizedValue, colors, fullOutput) {
                if (!(colors && colors.length) || !(normalizedValue >= 0 && normalizedValue <= 1)) {
                    return;
                }
                var value = normalizedValue * (colors.length - 1);
                var leftIndex = Math.floor(value);
                var rightIndex = Math.ceil(value);
                var leftColor = parse(colors[leftIndex]);
                var rightColor = parse(colors[rightIndex]);
                var dv = value - leftIndex;
                var color = stringify([
                    clampCssByte(lerp(leftColor[0], rightColor[0], dv)),
                    clampCssByte(lerp(leftColor[1], rightColor[1], dv)),
                    clampCssByte(lerp(leftColor[2], rightColor[2], dv)),
                    clampCssFloat(lerp(leftColor[3], rightColor[3], dv))
                ], 'rgba');
                return fullOutput ? {
                    color: color,
                    leftIndex: leftIndex,
                    rightIndex: rightIndex,
                    value: value
                } : color;
            }
            function mapIntervalToColor(interval, colors) {
                if (interval.length !== 2 || interval[1] < interval[0]) {
                    return;
                }
                var info0 = mapToColor(interval[0], colors, true);
                var info1 = mapToColor(interval[1], colors, true);
                var result = [{
                        color: info0.color,
                        offset: 0
                    }];
                var during = info1.value - info0.value;
                var start = Math.max(info0.value, info0.rightIndex);
                var end = Math.min(info1.value, info1.leftIndex);
                for (var i = start; during > 0 && i <= end; i++) {
                    result.push({
                        color: colors[i],
                        offset: (i - info0.value) / during
                    });
                }
                result.push({
                    color: info1.color,
                    offset: 1
                });
                return result;
            }
            function modifyHSL(color, h, s, l) {
                color = parse(color);
                if (color) {
                    color = rgba2hsla(color);
                    h != null && (color[0] = clampCssAngle(h));
                    s != null && (color[1] = parseCssFloat(s));
                    l != null && (color[2] = parseCssFloat(l));
                    return stringify(hsla2rgba(color), 'rgba');
                }
            }
            function modifyAlpha(color, alpha) {
                color = parse(color);
                if (color && alpha != null) {
                    color[3] = clampCssFloat(alpha);
                    return stringify(color, 'rgba');
                }
            }
            function stringify(arrColor, type) {
                if (type === 'rgb' || type === 'hsv' || type === 'hsl') {
                    arrColor = arrColor.slice(0, 3);
                }
                return type + '(' + arrColor.join(',') + ')';
            }
            module.exports = {
                parse: parse,
                lift: lift,
                toHex: toHex,
                fastMapToColor: fastMapToColor,
                mapToColor: mapToColor,
                mapIntervalToColor: mapIntervalToColor,
                modifyHSL: modifyHSL,
                modifyAlpha: modifyAlpha,
                stringify: stringify
            };
        },
        function (module, exports, __webpack_require__) {
            var config = __webpack_require__(40);
            module.exports = function () {
                if (config.debugMode === 0) {
                    return;
                } else if (config.debugMode == 1) {
                    for (var k in arguments) {
                        throw new Error(arguments[k]);
                    }
                } else if (config.debugMode > 1) {
                    for (var k in arguments) {
                        console.log(arguments[k]);
                    }
                }
            };
        },
        function (module, exports) {
            var dpr = 1;
            if (typeof window !== 'undefined') {
                dpr = Math.max(window.devicePixelRatio || 1, 1);
            }
            var config = {
                debugMode: 0,
                devicePixelRatio: dpr
            };
            module.exports = config;
        },
        function (module, exports, __webpack_require__) {
            var Group = __webpack_require__(29);
            var componentUtil = __webpack_require__(20);
            var clazzUtil = __webpack_require__(9);
            function Chart() {
                this.group = new Group();
                this.uid = componentUtil.getUID('viewChart');
            }
            Chart.prototype = {
                type: 'chart',
                init: function (ecModel, api) {
                },
                render: function (seriesModel, ecModel, api, payload) {
                },
                highlight: function (seriesModel, ecModel, api, payload) {
                    toggleHighlight(seriesModel.getData(), payload, 'emphasis');
                },
                downplay: function (seriesModel, ecModel, api, payload) {
                    toggleHighlight(seriesModel.getData(), payload, 'normal');
                },
                remove: function (ecModel, api) {
                    this.group.removeAll();
                },
                dispose: function () {
                }
            };
            var chartProto = Chart.prototype;
            chartProto.updateView = chartProto.updateLayout = chartProto.updateVisual = function (seriesModel, ecModel, api, payload) {
                this.render(seriesModel, ecModel, api, payload);
            };
            function elSetState(el, state) {
                if (el) {
                    el.trigger(state);
                    if (el.type === 'group') {
                        for (var i = 0; i < el.childCount(); i++) {
                            elSetState(el.childAt(i), state);
                        }
                    }
                }
            }
            function toggleHighlight(data, payload, state) {
                if (payload.dataIndex != null) {
                    var el = data.getItemGraphicEl(payload.dataIndex);
                    elSetState(el, state);
                } else if (payload.name) {
                    var dataIndex = data.indexOfName(payload.name);
                    var el = data.getItemGraphicEl(dataIndex);
                    elSetState(el, state);
                } else {
                    data.eachItemGraphicEl(function (el) {
                        elSetState(el, state);
                    });
                }
            }
            clazzUtil.enableClassExtend(Chart);
            clazzUtil.enableClassManagement(Chart, { registerWhenExtend: true });
            module.exports = Chart;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var pathTool = __webpack_require__(43);
            var round = Math.round;
            var Path = __webpack_require__(44);
            var colorTool = __webpack_require__(38);
            var matrix = __webpack_require__(17);
            var vector = __webpack_require__(16);
            var Gradient = __webpack_require__(4);
            var graphic = {};
            graphic.Group = __webpack_require__(29);
            graphic.Image = __webpack_require__(59);
            graphic.Text = __webpack_require__(62);
            graphic.Circle = __webpack_require__(63);
            graphic.Sector = __webpack_require__(64);
            graphic.Ring = __webpack_require__(65);
            graphic.Polygon = __webpack_require__(66);
            graphic.Polyline = __webpack_require__(70);
            graphic.Rect = __webpack_require__(71);
            graphic.Line = __webpack_require__(72);
            graphic.BezierCurve = __webpack_require__(73);
            graphic.Arc = __webpack_require__(74);
            graphic.LinearGradient = __webpack_require__(75);
            graphic.RadialGradient = __webpack_require__(76);
            graphic.BoundingRect = __webpack_require__(15);
            graphic.extendShape = function (opts) {
                return Path.extend(opts);
            };
            graphic.extendPath = function (pathData, opts) {
                return pathTool.extendFromString(pathData, opts);
            };
            graphic.makePath = function (pathData, opts, rect, layout) {
                var path = pathTool.createFromString(pathData, opts);
                var boundingRect = path.getBoundingRect();
                if (rect) {
                    var aspect = boundingRect.width / boundingRect.height;
                    if (layout === 'center') {
                        var width = rect.height * aspect;
                        var height;
                        if (width <= rect.width) {
                            height = rect.height;
                        } else {
                            width = rect.width;
                            height = width / aspect;
                        }
                        var cx = rect.x + rect.width / 2;
                        var cy = rect.y + rect.height / 2;
                        rect.x = cx - width / 2;
                        rect.y = cy - height / 2;
                        rect.width = width;
                        rect.height = height;
                    }
                    this.resizePath(path, rect);
                }
                return path;
            };
            graphic.mergePath = pathTool.mergePath, graphic.resizePath = function (path, rect) {
                if (!path.applyTransform) {
                    return;
                }
                var pathRect = path.getBoundingRect();
                var m = pathRect.calculateTransform(rect);
                path.applyTransform(m);
            };
            graphic.subPixelOptimizeLine = function (param) {
                var subPixelOptimize = graphic.subPixelOptimize;
                var shape = param.shape;
                var lineWidth = param.style.lineWidth;
                if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
                    shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
                }
                if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
                    shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
                }
                return param;
            };
            graphic.subPixelOptimizeRect = function (param) {
                var subPixelOptimize = graphic.subPixelOptimize;
                var shape = param.shape;
                var lineWidth = param.style.lineWidth;
                var originX = shape.x;
                var originY = shape.y;
                var originWidth = shape.width;
                var originHeight = shape.height;
                shape.x = subPixelOptimize(shape.x, lineWidth, true);
                shape.y = subPixelOptimize(shape.y, lineWidth, true);
                shape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x, originWidth === 0 ? 0 : 1);
                shape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y, originHeight === 0 ? 0 : 1);
                return param;
            };
            graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
                var doubledPosition = round(position * 2);
                return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
            };
            function doSingleEnterHover(el) {
                if (el.__isHover) {
                    return;
                }
                if (el.__hoverStlDirty) {
                    var stroke = el.style.stroke;
                    var fill = el.style.fill;
                    var hoverStyle = el.__hoverStl;
                    var lift = colorTool.lift;
                    hoverStyle.fill = hoverStyle.fill || fill && (fill instanceof Gradient ? fill : lift(fill, -0.1));
                    hoverStyle.stroke = hoverStyle.stroke || stroke && (stroke instanceof Gradient ? stroke : lift(stroke, -0.1));
                    var normalStyle = {};
                    for (var name in hoverStyle) {
                        if (hoverStyle.hasOwnProperty(name)) {
                            normalStyle[name] = el.style[name];
                        }
                    }
                    el.__normalStl = normalStyle;
                    el.__hoverStlDirty = false;
                }
                el.setStyle(el.__hoverStl);
                el.z2 += 1;
                el.__isHover = true;
            }
            function doSingleLeaveHover(el) {
                if (!el.__isHover) {
                    return;
                }
                var normalStl = el.__normalStl;
                normalStl && el.setStyle(normalStl);
                el.z2 -= 1;
                el.__isHover = false;
            }
            function doEnterHover(el) {
                el.type === 'group' ? el.traverse(function (child) {
                    if (child.type !== 'group') {
                        doSingleEnterHover(child);
                    }
                }) : doSingleEnterHover(el);
            }
            function doLeaveHover(el) {
                el.type === 'group' ? el.traverse(function (child) {
                    if (child.type !== 'group') {
                        doSingleLeaveHover(child);
                    }
                }) : doSingleLeaveHover(el);
            }
            function setElementHoverStl(el, hoverStl) {
                el.__hoverStl = el.hoverStyle || hoverStl || {};
                el.__hoverStlDirty = true;
            }
            function onElementMouseOver() {
                !this.__isEmphasis && doEnterHover(this);
            }
            function onElementMouseOut() {
                !this.__isEmphasis && doLeaveHover(this);
            }
            function enterEmphasis() {
                this.__isEmphasis = true;
                doEnterHover(this);
            }
            function leaveEmphasis() {
                this.__isEmphasis = false;
                doLeaveHover(this);
            }
            graphic.setHoverStyle = function (el, hoverStyle) {
                el.type === 'group' ? el.traverse(function (child) {
                    if (child.type !== 'group') {
                        setElementHoverStl(child, hoverStyle);
                    }
                }) : setElementHoverStl(el, hoverStyle);
                el.on('mouseover', onElementMouseOver).on('mouseout', onElementMouseOut);
                el.on('emphasis', enterEmphasis).on('normal', leaveEmphasis);
            };
            graphic.setText = function (textStyle, labelModel, color) {
                var labelPosition = labelModel.getShallow('position') || 'inside';
                var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
                var textStyleModel = labelModel.getModel('textStyle');
                zrUtil.extend(textStyle, {
                    textDistance: labelModel.getShallow('distance') || 5,
                    textFont: textStyleModel.getFont(),
                    textPosition: labelPosition,
                    textFill: textStyleModel.getTextColor() || labelColor
                });
            };
            function animateOrSetProps(isUpdate, el, props, animatableModel, cb) {
                var postfix = isUpdate ? 'Update' : '';
                var duration = animatableModel && animatableModel.getShallow('animationDuration' + postfix);
                var animationEasing = animatableModel && animatableModel.getShallow('animationEasing' + postfix);
                animatableModel && animatableModel.getShallow('animation') ? el.animateTo(props, duration, animationEasing, cb) : (el.attr(props), cb && cb());
            }
            graphic.updateProps = zrUtil.curry(animateOrSetProps, true);
            graphic.initProps = zrUtil.curry(animateOrSetProps, false);
            graphic.getTransform = function (target, ancestor) {
                var mat = matrix.identity([]);
                while (target && target !== ancestor) {
                    matrix.mul(mat, target.getLocalTransform(), mat);
                    target = target.parent;
                }
                return mat;
            };
            graphic.applyTransform = function (vertex, transform, invert) {
                if (invert) {
                    transform = matrix.invert([], transform);
                }
                return vector.applyTransform([], vertex, transform);
            };
            graphic.transformDirection = function (direction, transform, invert) {
                var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);
                var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);
                var vertex = [
                    direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
                    direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
                ];
                vertex = graphic.applyTransform(vertex, transform, invert);
                return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';
            };
            module.exports = graphic;
        },
        function (module, exports, __webpack_require__) {
            var Path = __webpack_require__(44);
            var PathProxy = __webpack_require__(48);
            var transformPath = __webpack_require__(58);
            var matrix = __webpack_require__(17);
            var cc = [
                'm',
                'M',
                'l',
                'L',
                'v',
                'V',
                'h',
                'H',
                'z',
                'Z',
                'c',
                'C',
                'q',
                'Q',
                't',
                'T',
                's',
                'S',
                'a',
                'A'
            ];
            var mathSqrt = Math.sqrt;
            var mathSin = Math.sin;
            var mathCos = Math.cos;
            var PI = Math.PI;
            var vMag = function (v) {
                return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
            };
            var vRatio = function (u, v) {
                return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
            };
            var vAngle = function (u, v) {
                return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
            };
            function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
                var psi = psiDeg * (PI / 180);
                var xp = mathCos(psi) * (x1 - x2) / 2 + mathSin(psi) * (y1 - y2) / 2;
                var yp = -1 * mathSin(psi) * (x1 - x2) / 2 + mathCos(psi) * (y1 - y2) / 2;
                var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
                if (lambda > 1) {
                    rx *= mathSqrt(lambda);
                    ry *= mathSqrt(lambda);
                }
                var f = (fa === fs ? -1 : 1) * mathSqrt((rx * rx * (ry * ry) - rx * rx * (yp * yp) - ry * ry * (xp * xp)) / (rx * rx * (yp * yp) + ry * ry * (xp * xp))) || 0;
                var cxp = f * rx * yp / ry;
                var cyp = f * -ry * xp / rx;
                var cx = (x1 + x2) / 2 + mathCos(psi) * cxp - mathSin(psi) * cyp;
                var cy = (y1 + y2) / 2 + mathSin(psi) * cxp + mathCos(psi) * cyp;
                var theta = vAngle([
                    1,
                    0
                ], [
                    (xp - cxp) / rx,
                    (yp - cyp) / ry
                ]);
                var u = [
                    (xp - cxp) / rx,
                    (yp - cyp) / ry
                ];
                var v = [
                    (-1 * xp - cxp) / rx,
                    (-1 * yp - cyp) / ry
                ];
                var dTheta = vAngle(u, v);
                if (vRatio(u, v) <= -1) {
                    dTheta = PI;
                }
                if (vRatio(u, v) >= 1) {
                    dTheta = 0;
                }
                if (fs === 0 && dTheta > 0) {
                    dTheta = dTheta - 2 * PI;
                }
                if (fs === 1 && dTheta < 0) {
                    dTheta = dTheta + 2 * PI;
                }
                path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
            }
            function createPathProxyFromString(data) {
                if (!data) {
                    return [];
                }
                var cs = data.replace(/-/g, ' -').replace(/  /g, ' ').replace(/ /g, ',').replace(/,,/g, ',');
                var n;
                for (n = 0; n < cc.length; n++) {
                    cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
                }
                var arr = cs.split('|');
                var cpx = 0;
                var cpy = 0;
                var path = new PathProxy();
                var CMD = PathProxy.CMD;
                var prevCmd;
                for (n = 1; n < arr.length; n++) {
                    var str = arr[n];
                    var c = str.charAt(0);
                    var off = 0;
                    var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
                    var cmd;
                    if (p.length > 0 && p[0] === '') {
                        p.shift();
                    }
                    for (var i = 0; i < p.length; i++) {
                        p[i] = parseFloat(p[i]);
                    }
                    while (off < p.length && !isNaN(p[off])) {
                        if (isNaN(p[0])) {
                            break;
                        }
                        var ctlPtx;
                        var ctlPty;
                        var rx;
                        var ry;
                        var psi;
                        var fa;
                        var fs;
                        var x1 = cpx;
                        var y1 = cpy;
                        switch (c) {
                        case 'l':
                            cpx += p[off++];
                            cpy += p[off++];
                            cmd = CMD.L;
                            path.addData(cmd, cpx, cpy);
                            break;
                        case 'L':
                            cpx = p[off++];
                            cpy = p[off++];
                            cmd = CMD.L;
                            path.addData(cmd, cpx, cpy);
                            break;
                        case 'm':
                            cpx += p[off++];
                            cpy += p[off++];
                            cmd = CMD.M;
                            path.addData(cmd, cpx, cpy);
                            c = 'l';
                            break;
                        case 'M':
                            cpx = p[off++];
                            cpy = p[off++];
                            cmd = CMD.M;
                            path.addData(cmd, cpx, cpy);
                            c = 'L';
                            break;
                        case 'h':
                            cpx += p[off++];
                            cmd = CMD.L;
                            path.addData(cmd, cpx, cpy);
                            break;
                        case 'H':
                            cpx = p[off++];
                            cmd = CMD.L;
                            path.addData(cmd, cpx, cpy);
                            break;
                        case 'v':
                            cpy += p[off++];
                            cmd = CMD.L;
                            path.addData(cmd, cpx, cpy);
                            break;
                        case 'V':
                            cpy = p[off++];
                            cmd = CMD.L;
                            path.addData(cmd, cpx, cpy);
                            break;
                        case 'C':
                            cmd = CMD.C;
                            path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]);
                            cpx = p[off - 2];
                            cpy = p[off - 1];
                            break;
                        case 'c':
                            cmd = CMD.C;
                            path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy);
                            cpx += p[off - 2];
                            cpy += p[off - 1];
                            break;
                        case 'S':
                            ctlPtx = cpx;
                            ctlPty = cpy;
                            var len = path.len();
                            var pathData = path.data;
                            if (prevCmd === CMD.C) {
                                ctlPtx += cpx - pathData[len - 4];
                                ctlPty += cpy - pathData[len - 3];
                            }
                            cmd = CMD.C;
                            x1 = p[off++];
                            y1 = p[off++];
                            cpx = p[off++];
                            cpy = p[off++];
                            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
                            break;
                        case 's':
                            ctlPtx = cpx;
                            ctlPty = cpy;
                            var len = path.len();
                            var pathData = path.data;
                            if (prevCmd === CMD.C) {
                                ctlPtx += cpx - pathData[len - 4];
                                ctlPty += cpy - pathData[len - 3];
                            }
                            cmd = CMD.C;
                            x1 = cpx + p[off++];
                            y1 = cpy + p[off++];
                            cpx += p[off++];
                            cpy += p[off++];
                            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
                            break;
                        case 'Q':
                            x1 = p[off++];
                            y1 = p[off++];
                            cpx = p[off++];
                            cpy = p[off++];
                            cmd = CMD.Q;
                            path.addData(cmd, x1, y1, cpx, cpy);
                            break;
                        case 'q':
                            x1 = p[off++] + cpx;
                            y1 = p[off++] + cpy;
                            cpx += p[off++];
                            cpy += p[off++];
                            cmd = CMD.Q;
                            path.addData(cmd, x1, y1, cpx, cpy);
                            break;
                        case 'T':
                            ctlPtx = cpx;
                            ctlPty = cpy;
                            var len = path.len();
                            var pathData = path.data;
                            if (prevCmd === CMD.Q) {
                                ctlPtx += cpx - pathData[len - 4];
                                ctlPty += cpy - pathData[len - 3];
                            }
                            cpx = p[off++];
                            cpy = p[off++];
                            cmd = CMD.Q;
                            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
                            break;
                        case 't':
                            ctlPtx = cpx;
                            ctlPty = cpy;
                            var len = path.len();
                            var pathData = path.data;
                            if (prevCmd === CMD.Q) {
                                ctlPtx += cpx - pathData[len - 4];
                                ctlPty += cpy - pathData[len - 3];
                            }
                            cpx += p[off++];
                            cpy += p[off++];
                            cmd = CMD.Q;
                            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
                            break;
                        case 'A':
                            rx = p[off++];
                            ry = p[off++];
                            psi = p[off++];
                            fa = p[off++];
                            fs = p[off++];
                            x1 = cpx, y1 = cpy;
                            cpx = p[off++];
                            cpy = p[off++];
                            cmd = CMD.A;
                            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
                            break;
                        case 'a':
                            rx = p[off++];
                            ry = p[off++];
                            psi = p[off++];
                            fa = p[off++];
                            fs = p[off++];
                            x1 = cpx, y1 = cpy;
                            cpx += p[off++];
                            cpy += p[off++];
                            cmd = CMD.A;
                            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path);
                            break;
                        }
                    }
                    if (c === 'z' || c === 'Z') {
                        cmd = CMD.Z;
                        path.addData(cmd);
                    }
                    prevCmd = cmd;
                }
                path.toStatic();
                return path;
            }
            function createPathOptions(str, opts) {
                var pathProxy = createPathProxyFromString(str);
                var transform;
                opts = opts || {};
                opts.buildPath = function (path) {
                    path.setData(pathProxy.data);
                    transform && transformPath(path, transform);
                    var ctx = path.getContext();
                    if (ctx) {
                        path.rebuildPath(ctx);
                    }
                };
                opts.applyTransform = function (m) {
                    if (!transform) {
                        transform = matrix.create();
                    }
                    matrix.mul(transform, m, transform);
                };
                return opts;
            }
            module.exports = {
                createFromString: function (str, opts) {
                    return new Path(createPathOptions(str, opts));
                },
                extendFromString: function (str, opts) {
                    return Path.extend(createPathOptions(str, opts));
                },
                mergePath: function (pathEls, opts) {
                    var pathList = [];
                    var len = pathEls.length;
                    var pathEl;
                    var i;
                    for (i = 0; i < len; i++) {
                        pathEl = pathEls[i];
                        if (pathEl.__dirty) {
                            pathEl.buildPath(pathEl.path, pathEl.shape);
                        }
                        pathList.push(pathEl.path);
                    }
                    var pathBundle = new Path(opts);
                    pathBundle.buildPath = function (path) {
                        path.appendPath(pathList);
                        var ctx = path.getContext();
                        if (ctx) {
                            path.rebuildPath(ctx);
                        }
                    };
                    return pathBundle;
                }
            };
        },
        function (module, exports, __webpack_require__) {
            var Displayable = __webpack_require__(45);
            var zrUtil = __webpack_require__(3);
            var PathProxy = __webpack_require__(48);
            var pathContain = __webpack_require__(51);
            var Gradient = __webpack_require__(4);
            function pathHasFill(style) {
                var fill = style.fill;
                return fill != null && fill !== 'none';
            }
            function pathHasStroke(style) {
                var stroke = style.stroke;
                return stroke != null && stroke !== 'none' && style.lineWidth > 0;
            }
            var abs = Math.abs;
            function Path(opts) {
                Displayable.call(this, opts);
                this.path = new PathProxy();
            }
            Path.prototype = {
                constructor: Path,
                type: 'path',
                __dirtyPath: true,
                strokeContainThreshold: 5,
                brush: function (ctx) {
                    ctx.save();
                    var style = this.style;
                    var path = this.path;
                    var hasStroke = pathHasStroke(style);
                    var hasFill = pathHasFill(style);
                    if (this.__dirtyPath) {
                        if (hasFill && style.fill instanceof Gradient) {
                            style.fill.updateCanvasGradient(this, ctx);
                        }
                        if (hasStroke && style.stroke instanceof Gradient) {
                            style.stroke.updateCanvasGradient(this, ctx);
                        }
                    }
                    style.bind(ctx, this);
                    this.setTransform(ctx);
                    var lineDash = style.lineDash;
                    var lineDashOffset = style.lineDashOffset;
                    var ctxLineDash = !!ctx.setLineDash;
                    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {
                        path = this.path.beginPath(ctx);
                        if (lineDash && !ctxLineDash) {
                            path.setLineDash(lineDash);
                            path.setLineDashOffset(lineDashOffset);
                        }
                        this.buildPath(path, this.shape);
                        this.__dirtyPath = false;
                    } else {
                        ctx.beginPath();
                        this.path.rebuildPath(ctx);
                    }
                    hasFill && path.fill(ctx);
                    if (lineDash && ctxLineDash) {
                        ctx.setLineDash(lineDash);
                        ctx.lineDashOffset = lineDashOffset;
                    }
                    hasStroke && path.stroke(ctx);
                    if (style.text != null) {
                        this.drawRectText(ctx, this.getBoundingRect());
                    }
                    ctx.restore();
                },
                buildPath: function (ctx, shapeCfg) {
                },
                getBoundingRect: function () {
                    var rect = this._rect;
                    var style = this.style;
                    var needsUpdateRect = !rect;
                    if (needsUpdateRect) {
                        var path = this.path;
                        if (this.__dirtyPath) {
                            path.beginPath();
                            this.buildPath(path, this.shape);
                        }
                        rect = path.getBoundingRect();
                    }
                    this._rect = rect;
                    if (pathHasStroke(style)) {
                        var rectWithStroke = this._rectWithStroke;
                        if (this.__dirty || needsUpdateRect) {
                            var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
                            rectWithStroke.copy(rect);
                            var w = style.lineWidth;
                            var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
                            if (!pathHasFill(style)) {
                                w = Math.max(w, this.strokeContainThreshold);
                            }
                            if (lineScale > 1e-10) {
                                rectWithStroke.width += w / lineScale;
                                rectWithStroke.height += w / lineScale;
                                rectWithStroke.x -= w / lineScale / 2;
                                rectWithStroke.y -= w / lineScale / 2;
                            }
                        }
                        return rectWithStroke;
                    }
                    return rect;
                },
                contain: function (x, y) {
                    var localPos = this.transformCoordToLocal(x, y);
                    var rect = this.getBoundingRect();
                    var style = this.style;
                    x = localPos[0];
                    y = localPos[1];
                    if (rect.contain(x, y)) {
                        var pathData = this.path.data;
                        if (pathHasStroke(style)) {
                            var lineWidth = style.lineWidth;
                            var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
                            if (lineScale > 1e-10) {
                                if (!pathHasFill(style)) {
                                    lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
                                }
                                if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {
                                    return true;
                                }
                            }
                        }
                        if (pathHasFill(style)) {
                            return pathContain.contain(pathData, x, y);
                        }
                    }
                    return false;
                },
                dirty: function (dirtyPath) {
                    if (arguments.length === 0) {
                        dirtyPath = true;
                    }
                    if (dirtyPath) {
                        this.__dirtyPath = dirtyPath;
                        this._rect = null;
                    }
                    this.__dirty = true;
                    this.__zr && this.__zr.refresh();
                    if (this.__clipTarget) {
                        this.__clipTarget.dirty();
                    }
                },
                animateShape: function (loop) {
                    return this.animate('shape', loop);
                },
                attrKV: function (key, value) {
                    if (key === 'shape') {
                        this.setShape(value);
                    } else {
                        Displayable.prototype.attrKV.call(this, key, value);
                    }
                },
                setShape: function (key, value) {
                    var shape = this.shape;
                    if (shape) {
                        if (zrUtil.isObject(key)) {
                            for (var name in key) {
                                shape[name] = key[name];
                            }
                        } else {
                            shape[key] = value;
                        }
                        this.dirty(true);
                    }
                    return this;
                },
                getLineScale: function () {
                    var m = this.transform;
                    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;
                }
            };
            Path.extend = function (defaults) {
                var Sub = function (opts) {
                    Path.call(this, opts);
                    if (defaults.style) {
                        this.style.extendFrom(defaults.style, false);
                    }
                    var defaultShape = defaults.shape;
                    if (defaultShape) {
                        this.shape = this.shape || {};
                        var thisShape = this.shape;
                        for (var name in defaultShape) {
                            if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {
                                thisShape[name] = defaultShape[name];
                            }
                        }
                    }
                    defaults.init && defaults.init.call(this, opts);
                };
                zrUtil.inherits(Sub, Path);
                for (var name in defaults) {
                    if (name !== 'style' && name !== 'shape') {
                        Sub.prototype[name] = defaults[name];
                    }
                }
                return Sub;
            };
            zrUtil.inherits(Path, Displayable);
            module.exports = Path;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var Style = __webpack_require__(46);
            var Element = __webpack_require__(30);
            var RectText = __webpack_require__(47);
            function Displayable(opts) {
                opts = opts || {};
                Element.call(this, opts);
                for (var name in opts) {
                    if (opts.hasOwnProperty(name) && name !== 'style') {
                        this[name] = opts[name];
                    }
                }
                this.style = new Style(opts.style);
                this._rect = null;
                this.__clipPaths = [];
            }
            Displayable.prototype = {
                constructor: Displayable,
                type: 'displayable',
                __dirty: true,
                invisible: false,
                z: 0,
                z2: 0,
                zlevel: 0,
                draggable: false,
                dragging: false,
                silent: false,
                culling: false,
                cursor: 'pointer',
                rectHover: false,
                beforeBrush: function (ctx) {
                },
                afterBrush: function (ctx) {
                },
                brush: function (ctx) {
                },
                getBoundingRect: function () {
                },
                contain: function (x, y) {
                    return this.rectContain(x, y);
                },
                traverse: function (cb, context) {
                    cb.call(context, this);
                },
                rectContain: function (x, y) {
                    var coord = this.transformCoordToLocal(x, y);
                    var rect = this.getBoundingRect();
                    return rect.contain(coord[0], coord[1]);
                },
                dirty: function () {
                    this.__dirty = true;
                    this._rect = null;
                    this.__zr && this.__zr.refresh();
                },
                animateStyle: function (loop) {
                    return this.animate('style', loop);
                },
                attrKV: function (key, value) {
                    if (key !== 'style') {
                        Element.prototype.attrKV.call(this, key, value);
                    } else {
                        this.style.set(value);
                    }
                },
                setStyle: function (key, value) {
                    this.style.set(key, value);
                    this.dirty(false);
                    return this;
                }
            };
            zrUtil.inherits(Displayable, Element);
            zrUtil.mixin(Displayable, RectText);
            module.exports = Displayable;
        },
        function (module, exports) {
            var STYLE_LIST_COMMON = [
                'lineCap',
                'lineJoin',
                'miterLimit',
                'shadowBlur',
                'shadowOffsetX',
                'shadowOffsetY',
                'shadowColor'
            ];
            var Style = function (opts) {
                this.extendFrom(opts);
            };
            Style.prototype = {
                constructor: Style,
                fill: '#000000',
                stroke: null,
                opacity: 1,
                lineDash: null,
                lineDashOffset: 0,
                shadowBlur: 0,
                shadowOffsetX: 0,
                shadowOffsetY: 0,
                lineWidth: 1,
                strokeNoScale: false,
                text: null,
                textFill: '#000',
                textStroke: null,
                textPosition: 'inside',
                textBaseline: null,
                textAlign: null,
                textVerticalAlign: null,
                textDistance: 5,
                textShadowBlur: 0,
                textShadowOffsetX: 0,
                textShadowOffsetY: 0,
                bind: function (ctx, el) {
                    var fill = this.fill;
                    var stroke = this.stroke;
                    for (var i = 0; i < STYLE_LIST_COMMON.length; i++) {
                        var styleName = STYLE_LIST_COMMON[i];
                        if (this[styleName] != null) {
                            ctx[styleName] = this[styleName];
                        }
                    }
                    if (stroke != null) {
                        var lineWidth = this.lineWidth;
                        ctx.lineWidth = lineWidth / (this.strokeNoScale && el && el.getLineScale ? el.getLineScale() : 1);
                    }
                    if (fill != null) {
                        ctx.fillStyle = fill.canvasGradient ? fill.canvasGradient : fill;
                    }
                    if (stroke != null) {
                        ctx.strokeStyle = stroke.canvasGradient ? stroke.canvasGradient : stroke;
                    }
                    this.opacity != null && (ctx.globalAlpha = this.opacity);
                },
                extendFrom: function (otherStyle, overwrite) {
                    if (otherStyle) {
                        var target = this;
                        for (var name in otherStyle) {
                            if (otherStyle.hasOwnProperty(name) && (overwrite || !target.hasOwnProperty(name))) {
                                target[name] = otherStyle[name];
                            }
                        }
                    }
                },
                set: function (obj, value) {
                    if (typeof obj === 'string') {
                        this[obj] = value;
                    } else {
                        this.extendFrom(obj, true);
                    }
                },
                clone: function () {
                    var newStyle = new this.constructor();
                    newStyle.extendFrom(this, true);
                    return newStyle;
                }
            };
            var styleProto = Style.prototype;
            var name;
            var i;
            for (i = 0; i < STYLE_LIST_COMMON.length; i++) {
                name = STYLE_LIST_COMMON[i];
                if (!(name in styleProto)) {
                    styleProto[name] = null;
                }
            }
            module.exports = Style;
        },
        function (module, exports, __webpack_require__) {
            var textContain = __webpack_require__(14);
            var BoundingRect = __webpack_require__(15);
            var tmpRect = new BoundingRect();
            var RectText = function () {
            };
            function parsePercent(value, maxValue) {
                if (typeof value === 'string') {
                    if (value.lastIndexOf('%') >= 0) {
                        return parseFloat(value) / 100 * maxValue;
                    }
                    return parseFloat(value);
                }
                return value;
            }
            function setTransform(ctx, m) {
                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
            }
            RectText.prototype = {
                constructor: RectText,
                drawRectText: function (ctx, rect, textRect) {
                    var style = this.style;
                    var text = style.text;
                    text != null && (text += '');
                    if (!text) {
                        return;
                    }
                    var x;
                    var y;
                    var textPosition = style.textPosition;
                    var distance = style.textDistance;
                    var align = style.textAlign;
                    var font = style.textFont || style.font;
                    var baseline = style.textBaseline;
                    var verticalAlign = style.textVerticalAlign;
                    textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
                    var transform = this.transform;
                    var invTransform = this.invTransform;
                    if (transform) {
                        tmpRect.copy(rect);
                        tmpRect.applyTransform(transform);
                        rect = tmpRect;
                        setTransform(ctx, invTransform);
                    }
                    if (textPosition instanceof Array) {
                        x = rect.x + parsePercent(textPosition[0], rect.width);
                        y = rect.y + parsePercent(textPosition[1], rect.height);
                        align = align || 'left';
                        baseline = baseline || 'top';
                    } else {
                        var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);
                        x = res.x;
                        y = res.y;
                        align = align || res.textAlign;
                        baseline = baseline || res.textBaseline;
                    }
                    ctx.textAlign = align;
                    if (verticalAlign) {
                        switch (verticalAlign) {
                        case 'middle':
                            y -= textRect.height / 2;
                            break;
                        case 'bottom':
                            y -= textRect.height;
                            break;
                        }
                        ctx.textBaseline = 'top';
                    } else {
                        ctx.textBaseline = baseline;
                    }
                    var textFill = style.textFill;
                    var textStroke = style.textStroke;
                    textFill && (ctx.fillStyle = textFill);
                    textStroke && (ctx.strokeStyle = textStroke);
                    ctx.font = font;
                    ctx.shadowColor = style.textShadowColor;
                    ctx.shadowBlur = style.textShadowBlur;
                    ctx.shadowOffsetX = style.textShadowOffsetX;
                    ctx.shadowOffsetY = style.textShadowOffsetY;
                    var textLines = text.split('\n');
                    for (var i = 0; i < textLines.length; i++) {
                        textFill && ctx.fillText(textLines[i], x, y);
                        textStroke && ctx.strokeText(textLines[i], x, y);
                        y += textRect.lineHeight;
                    }
                    transform && setTransform(ctx, transform);
                }
            };
            module.exports = RectText;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var curve = __webpack_require__(49);
            var vec2 = __webpack_require__(16);
            var bbox = __webpack_require__(50);
            var BoundingRect = __webpack_require__(15);
            var CMD = {
                M: 1,
                L: 2,
                C: 3,
                Q: 4,
                A: 5,
                Z: 6,
                R: 7
            };
            var min = [];
            var max = [];
            var min2 = [];
            var max2 = [];
            var mathMin = Math.min;
            var mathMax = Math.max;
            var mathCos = Math.cos;
            var mathSin = Math.sin;
            var mathSqrt = Math.sqrt;
            var hasTypedArray = typeof Float32Array != 'undefined';
            var PathProxy = function () {
                this.data = [];
                this._len = 0;
                this._ctx = null;
                this._xi = 0;
                this._yi = 0;
                this._x0 = 0;
                this._y0 = 0;
            };
            PathProxy.prototype = {
                constructor: PathProxy,
                _lineDash: null,
                _dashOffset: 0,
                _dashIdx: 0,
                _dashSum: 0,
                getContext: function () {
                    return this._ctx;
                },
                beginPath: function (ctx) {
                    this._ctx = ctx;
                    ctx && ctx.beginPath();
                    this._len = 0;
                    if (this._lineDash) {
                        this._lineDash = null;
                        this._dashOffset = 0;
                    }
                    return this;
                },
                moveTo: function (x, y) {
                    this.addData(CMD.M, x, y);
                    this._ctx && this._ctx.moveTo(x, y);
                    this._x0 = x;
                    this._y0 = y;
                    this._xi = x;
                    this._yi = y;
                    return this;
                },
                lineTo: function (x, y) {
                    this.addData(CMD.L, x, y);
                    if (this._ctx) {
                        this._needsDash() ? this._dashedLineTo(x, y) : this._ctx.lineTo(x, y);
                    }
                    this._xi = x;
                    this._yi = y;
                    return this;
                },
                bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
                    this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
                    if (this._ctx) {
                        this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3) : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
                    }
                    this._xi = x3;
                    this._yi = y3;
                    return this;
                },
                quadraticCurveTo: function (x1, y1, x2, y2) {
                    this.addData(CMD.Q, x1, y1, x2, y2);
                    if (this._ctx) {
                        this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2) : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
                    }
                    this._xi = x2;
                    this._yi = y2;
                    return this;
                },
                arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
                    this.addData(CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1);
                    this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);
                    this._xi = mathCos(endAngle) * r + cx;
                    this._xi = mathSin(endAngle) * r + cx;
                    return this;
                },
                arcTo: function (x1, y1, x2, y2, radius) {
                    if (this._ctx) {
                        this._ctx.arcTo(x1, y1, x2, y2, radius);
                    }
                    return this;
                },
                rect: function (x, y, w, h) {
                    this._ctx && this._ctx.rect(x, y, w, h);
                    this.addData(CMD.R, x, y, w, h);
                    return this;
                },
                closePath: function () {
                    this.addData(CMD.Z);
                    var ctx = this._ctx;
                    var x0 = this._x0;
                    var y0 = this._y0;
                    if (ctx) {
                        this._needsDash() && this._dashedLineTo(x0, y0);
                        ctx.closePath();
                    }
                    this._xi = x0;
                    this._yi = y0;
                    return this;
                },
                fill: function (ctx) {
                    ctx && ctx.fill();
                    this.toStatic();
                },
                stroke: function (ctx) {
                    ctx && ctx.stroke();
                    this.toStatic();
                },
                setLineDash: function (lineDash) {
                    if (lineDash instanceof Array) {
                        this._lineDash = lineDash;
                        this._dashIdx = 0;
                        var lineDashSum = 0;
                        for (var i = 0; i < lineDash.length; i++) {
                            lineDashSum += lineDash[i];
                        }
                        this._dashSum = lineDashSum;
                    }
                    return this;
                },
                setLineDashOffset: function (offset) {
                    this._dashOffset = offset;
                    return this;
                },
                len: function () {
                    return this._len;
                },
                setData: function (data) {
                    var len = data.length;
                    if (!(this.data && this.data.length == len) && hasTypedArray) {
                        this.data = new Float32Array(len);
                    }
                    for (var i = 0; i < len; i++) {
                        this.data[i] = data[i];
                    }
                    this._len = len;
                },
                appendPath: function (path) {
                    if (!(path instanceof Array)) {
                        path = [path];
                    }
                    var len = path.length;
                    var appendSize = 0;
                    var offset = this._len;
                    for (var i = 0; i < len; i++) {
                        appendSize += path[i].len();
                    }
                    if (hasTypedArray && this.data instanceof Float32Array) {
                        this.data = new Float32Array(offset + appendSize);
                    }
                    for (var i = 0; i < len; i++) {
                        var appendPathData = path[i].data;
                        for (var k = 0; k < appendPathData.length; k++) {
                            this.data[offset++] = appendPathData[k];
                        }
                    }
                    this._len = offset;
                },
                addData: function (cmd) {
                    var data = this.data;
                    if (this._len + arguments.length > data.length) {
                        this._expandData();
                        data = this.data;
                    }
                    for (var i = 0; i < arguments.length; i++) {
                        data[this._len++] = arguments[i];
                    }
                    this._prevCmd = cmd;
                },
                _expandData: function () {
                    if (!(this.data instanceof Array)) {
                        var newData = [];
                        for (var i = 0; i < this._len; i++) {
                            newData[i] = this.data[i];
                        }
                        this.data = newData;
                    }
                },
                _needsDash: function () {
                    return this._lineDash;
                },
                _dashedLineTo: function (x1, y1) {
                    var dashSum = this._dashSum;
                    var offset = this._dashOffset;
                    var lineDash = this._lineDash;
                    var ctx = this._ctx;
                    var x0 = this._xi;
                    var y0 = this._yi;
                    var dx = x1 - x0;
                    var dy = y1 - y0;
                    var dist = mathSqrt(dx * dx + dy * dy);
                    var x = x0;
                    var y = y0;
                    var dash;
                    var nDash = lineDash.length;
                    var idx;
                    dx /= dist;
                    dy /= dist;
                    if (offset < 0) {
                        offset = dashSum + offset;
                    }
                    offset %= dashSum;
                    x -= offset * dx;
                    y -= offset * dy;
                    while (dx >= 0 && x <= x1 || dx < 0 && x > x1) {
                        idx = this._dashIdx;
                        dash = lineDash[idx];
                        x += dx * dash;
                        y += dy * dash;
                        this._dashIdx = (idx + 1) % nDash;
                        if (dx > 0 && x < x0 || dx < 0 && x > x0) {
                            continue;
                        }
                        ctx[idx % 2 ? 'moveTo' : 'lineTo'](dx >= 0 ? mathMin(x, x1) : mathMax(x, x1), dy >= 0 ? mathMin(y, y1) : mathMax(y, y1));
                    }
                    dx = x - x1;
                    dy = y - y1;
                    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
                },
                _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
                    var dashSum = this._dashSum;
                    var offset = this._dashOffset;
                    var lineDash = this._lineDash;
                    var ctx = this._ctx;
                    var x0 = this._xi;
                    var y0 = this._yi;
                    var t;
                    var dx;
                    var dy;
                    var cubicAt = curve.cubicAt;
                    var bezierLen = 0;
                    var idx = this._dashIdx;
                    var nDash = lineDash.length;
                    var x;
                    var y;
                    var tmpLen = 0;
                    if (offset < 0) {
                        offset = dashSum + offset;
                    }
                    offset %= dashSum;
                    for (t = 0; t < 1; t += 0.1) {
                        dx = cubicAt(x0, x1, x2, x3, t + 0.1) - cubicAt(x0, x1, x2, x3, t);
                        dy = cubicAt(y0, y1, y2, y3, t + 0.1) - cubicAt(y0, y1, y2, y3, t);
                        bezierLen += mathSqrt(dx * dx + dy * dy);
                    }
                    for (; idx < nDash; idx++) {
                        tmpLen += lineDash[idx];
                        if (tmpLen > offset) {
                            break;
                        }
                    }
                    t = (tmpLen - offset) / bezierLen;
                    while (t <= 1) {
                        x = cubicAt(x0, x1, x2, x3, t);
                        y = cubicAt(y0, y1, y2, y3, t);
                        idx % 2 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                        t += lineDash[idx] / bezierLen;
                        idx = (idx + 1) % nDash;
                    }
                    idx % 2 !== 0 && ctx.lineTo(x3, y3);
                    dx = x3 - x;
                    dy = y3 - y;
                    this._dashOffset = -mathSqrt(dx * dx + dy * dy);
                },
                _dashedQuadraticTo: function (x1, y1, x2, y2) {
                    var x3 = x2;
                    var y3 = y2;
                    x2 = (x2 + 2 * x1) / 3;
                    y2 = (y2 + 2 * y1) / 3;
                    x1 = (this._xi + 2 * x1) / 3;
                    y1 = (this._yi + 2 * y1) / 3;
                    this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
                },
                toStatic: function () {
                    var data = this.data;
                    if (data instanceof Array) {
                        data.length = this._len;
                        if (hasTypedArray) {
                            this.data = new Float32Array(data);
                        }
                    }
                },
                getBoundingRect: function () {
                    min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
                    max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;
                    var data = this.data;
                    var xi = 0;
                    var yi = 0;
                    var x0 = 0;
                    var y0 = 0;
                    for (var i = 0; i < data.length;) {
                        var cmd = data[i++];
                        if (i == 1) {
                            xi = data[i];
                            yi = data[i + 1];
                            x0 = xi;
                            y0 = yi;
                        }
                        switch (cmd) {
                        case CMD.M:
                            x0 = data[i++];
                            y0 = data[i++];
                            xi = x0;
                            yi = y0;
                            min2[0] = x0;
                            min2[1] = y0;
                            max2[0] = x0;
                            max2[1] = y0;
                            break;
                        case CMD.L:
                            bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
                            xi = data[i++];
                            yi = data[i++];
                            break;
                        case CMD.C:
                            bbox.fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2);
                            xi = data[i++];
                            yi = data[i++];
                            break;
                        case CMD.Q:
                            bbox.fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2);
                            xi = data[i++];
                            yi = data[i++];
                            break;
                        case CMD.A:
                            var cx = data[i++];
                            var cy = data[i++];
                            var rx = data[i++];
                            var ry = data[i++];
                            var startAngle = data[i++];
                            var endAngle = data[i++] + startAngle;
                            var psi = data[i++];
                            var anticlockwise = 1 - data[i++];
                            if (i == 1) {
                                x0 = mathCos(startAngle) * rx + cx;
                                y0 = mathSin(startAngle) * ry + cy;
                            }
                            bbox.fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2);
                            xi = mathCos(endAngle) * rx + cx;
                            yi = mathSin(endAngle) * ry + cy;
                            break;
                        case CMD.R:
                            x0 = xi = data[i++];
                            y0 = yi = data[i++];
                            var width = data[i++];
                            var height = data[i++];
                            bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
                            break;
                        case CMD.Z:
                            xi = x0;
                            yi = y0;
                            break;
                        }
                        vec2.min(min, min, min2);
                        vec2.max(max, max, max2);
                    }
                    if (i === 0) {
                        min[0] = min[1] = max[0] = max[1] = 0;
                    }
                    return new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
                },
                rebuildPath: function (ctx) {
                    var d = this.data;
                    for (var i = 0; i < this._len;) {
                        var cmd = d[i++];
                        switch (cmd) {
                        case CMD.M:
                            ctx.moveTo(d[i++], d[i++]);
                            break;
                        case CMD.L:
                            ctx.lineTo(d[i++], d[i++]);
                            break;
                        case CMD.C:
                            ctx.bezierCurveTo(d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]);
                            break;
                        case CMD.Q:
                            ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
                            break;
                        case CMD.A:
                            var cx = d[i++];
                            var cy = d[i++];
                            var rx = d[i++];
                            var ry = d[i++];
                            var theta = d[i++];
                            var dTheta = d[i++];
                            var psi = d[i++];
                            var fs = d[i++];
                            var r = rx > ry ? rx : ry;
                            var scaleX = rx > ry ? 1 : rx / ry;
                            var scaleY = rx > ry ? ry / rx : 1;
                            var isEllipse = Math.abs(rx - ry) > 0.001;
                            if (isEllipse) {
                                ctx.translate(cx, cy);
                                ctx.rotate(psi);
                                ctx.scale(scaleX, scaleY);
                                ctx.arc(0, 0, r, theta, theta + dTheta, 1 - fs);
                                ctx.scale(1 / scaleX, 1 / scaleY);
                                ctx.rotate(-psi);
                                ctx.translate(-cx, -cy);
                            } else {
                                ctx.arc(cx, cy, r, theta, theta + dTheta, 1 - fs);
                            }
                            break;
                        case CMD.R:
                            ctx.rect(d[i++], d[i++], d[i++], d[i++]);
                            break;
                        case CMD.Z:
                            ctx.closePath();
                        }
                    }
                }
            };
            PathProxy.CMD = CMD;
            module.exports = PathProxy;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var vec2 = __webpack_require__(16);
            var v2Create = vec2.create;
            var v2DistSquare = vec2.distSquare;
            var mathPow = Math.pow;
            var mathSqrt = Math.sqrt;
            var EPSILON = 1e-8;
            var EPSILON_NUMERIC = 0.0001;
            var THREE_SQRT = mathSqrt(3);
            var ONE_THIRD = 1 / 3;
            var _v0 = v2Create();
            var _v1 = v2Create();
            var _v2 = v2Create();
            function isAroundZero(val) {
                return val > -EPSILON && val < EPSILON;
            }
            function isNotAroundZero(val) {
                return val > EPSILON || val < -EPSILON;
            }
            function cubicAt(p0, p1, p2, p3, t) {
                var onet = 1 - t;
                return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
            }
            function cubicDerivativeAt(p0, p1, p2, p3, t) {
                var onet = 1 - t;
                return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet + (p3 - p2) * t * t);
            }
            function cubicRootAt(p0, p1, p2, p3, val, roots) {
                var a = p3 + 3 * (p1 - p2) - p0;
                var b = 3 * (p2 - p1 * 2 + p0);
                var c = 3 * (p1 - p0);
                var d = p0 - val;
                var A = b * b - 3 * a * c;
                var B = b * c - 9 * a * d;
                var C = c * c - 3 * b * d;
                var n = 0;
                if (isAroundZero(A) && isAroundZero(B)) {
                    if (isAroundZero(b)) {
                        roots[0] = 0;
                    } else {
                        var t1 = -c / b;
                        if (t1 >= 0 && t1 <= 1) {
                            roots[n++] = t1;
                        }
                    }
                } else {
                    var disc = B * B - 4 * A * C;
                    if (isAroundZero(disc)) {
                        var K = B / A;
                        var t1 = -b / a + K;
                        var t2 = -K / 2;
                        if (t1 >= 0 && t1 <= 1) {
                            roots[n++] = t1;
                        }
                        if (t2 >= 0 && t2 <= 1) {
                            roots[n++] = t2;
                        }
                    } else if (disc > 0) {
                        var discSqrt = mathSqrt(disc);
                        var Y1 = A * b + 1.5 * a * (-B + discSqrt);
                        var Y2 = A * b + 1.5 * a * (-B - discSqrt);
                        if (Y1 < 0) {
                            Y1 = -mathPow(-Y1, ONE_THIRD);
                        } else {
                            Y1 = mathPow(Y1, ONE_THIRD);
                        }
                        if (Y2 < 0) {
                            Y2 = -mathPow(-Y2, ONE_THIRD);
                        } else {
                            Y2 = mathPow(Y2, ONE_THIRD);
                        }
                        var t1 = (-b - (Y1 + Y2)) / (3 * a);
                        if (t1 >= 0 && t1 <= 1) {
                            roots[n++] = t1;
                        }
                    } else {
                        var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
                        var theta = Math.acos(T) / 3;
                        var ASqrt = mathSqrt(A);
                        var tmp = Math.cos(theta);
                        var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
                        var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
                        var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
                        if (t1 >= 0 && t1 <= 1) {
                            roots[n++] = t1;
                        }
                        if (t2 >= 0 && t2 <= 1) {
                            roots[n++] = t2;
                        }
                        if (t3 >= 0 && t3 <= 1) {
                            roots[n++] = t3;
                        }
                    }
                }
                return n;
            }
            function cubicExtrema(p0, p1, p2, p3, extrema) {
                var b = 6 * p2 - 12 * p1 + 6 * p0;
                var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
                var c = 3 * p1 - 3 * p0;
                var n = 0;
                if (isAroundZero(a)) {
                    if (isNotAroundZero(b)) {
                        var t1 = -c / b;
                        if (t1 >= 0 && t1 <= 1) {
                            extrema[n++] = t1;
                        }
                    }
                } else {
                    var disc = b * b - 4 * a * c;
                    if (isAroundZero(disc)) {
                        extrema[0] = -b / (2 * a);
                    } else if (disc > 0) {
                        var discSqrt = mathSqrt(disc);
                        var t1 = (-b + discSqrt) / (2 * a);
                        var t2 = (-b - discSqrt) / (2 * a);
                        if (t1 >= 0 && t1 <= 1) {
                            extrema[n++] = t1;
                        }
                        if (t2 >= 0 && t2 <= 1) {
                            extrema[n++] = t2;
                        }
                    }
                }
                return n;
            }
            function cubicSubdivide(p0, p1, p2, p3, t, out) {
                var p01 = (p1 - p0) * t + p0;
                var p12 = (p2 - p1) * t + p1;
                var p23 = (p3 - p2) * t + p2;
                var p012 = (p12 - p01) * t + p01;
                var p123 = (p23 - p12) * t + p12;
                var p0123 = (p123 - p012) * t + p012;
                out[0] = p0;
                out[1] = p01;
                out[2] = p012;
                out[3] = p0123;
                out[4] = p0123;
                out[5] = p123;
                out[6] = p23;
                out[7] = p3;
            }
            function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
                var t;
                var interval = 0.005;
                var d = Infinity;
                var prev;
                var next;
                var d1;
                var d2;
                _v0[0] = x;
                _v0[1] = y;
                for (var _t = 0; _t < 1; _t += 0.05) {
                    _v1[0] = cubicAt(x0, x1, x2, x3, _t);
                    _v1[1] = cubicAt(y0, y1, y2, y3, _t);
                    d1 = v2DistSquare(_v0, _v1);
                    if (d1 < d) {
                        t = _t;
                        d = d1;
                    }
                }
                d = Infinity;
                for (var i = 0; i < 32; i++) {
                    if (interval < EPSILON_NUMERIC) {
                        break;
                    }
                    prev = t - interval;
                    next = t + interval;
                    _v1[0] = cubicAt(x0, x1, x2, x3, prev);
                    _v1[1] = cubicAt(y0, y1, y2, y3, prev);
                    d1 = v2DistSquare(_v1, _v0);
                    if (prev >= 0 && d1 < d) {
                        t = prev;
                        d = d1;
                    } else {
                        _v2[0] = cubicAt(x0, x1, x2, x3, next);
                        _v2[1] = cubicAt(y0, y1, y2, y3, next);
                        d2 = v2DistSquare(_v2, _v0);
                        if (next <= 1 && d2 < d) {
                            t = next;
                            d = d2;
                        } else {
                            interval *= 0.5;
                        }
                    }
                }
                if (out) {
                    out[0] = cubicAt(x0, x1, x2, x3, t);
                    out[1] = cubicAt(y0, y1, y2, y3, t);
                }
                return mathSqrt(d);
            }
            function quadraticAt(p0, p1, p2, t) {
                var onet = 1 - t;
                return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
            }
            function quadraticDerivativeAt(p0, p1, p2, t) {
                return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
            }
            function quadraticRootAt(p0, p1, p2, val, roots) {
                var a = p0 - 2 * p1 + p2;
                var b = 2 * (p1 - p0);
                var c = p0 - val;
                var n = 0;
                if (isAroundZero(a)) {
                    if (isNotAroundZero(b)) {
                        var t1 = -c / b;
                        if (t1 >= 0 && t1 <= 1) {
                            roots[n++] = t1;
                        }
                    }
                } else {
                    var disc = b * b - 4 * a * c;
                    if (isAroundZero(disc)) {
                        var t1 = -b / (2 * a);
                        if (t1 >= 0 && t1 <= 1) {
                            roots[n++] = t1;
                        }
                    } else if (disc > 0) {
                        var discSqrt = mathSqrt(disc);
                        var t1 = (-b + discSqrt) / (2 * a);
                        var t2 = (-b - discSqrt) / (2 * a);
                        if (t1 >= 0 && t1 <= 1) {
                            roots[n++] = t1;
                        }
                        if (t2 >= 0 && t2 <= 1) {
                            roots[n++] = t2;
                        }
                    }
                }
                return n;
            }
            function quadraticExtremum(p0, p1, p2) {
                var divider = p0 + p2 - 2 * p1;
                if (divider === 0) {
                    return 0.5;
                } else {
                    return (p0 - p1) / divider;
                }
            }
            function quadraticSubdivide(p0, p1, p2, t, out) {
                var p01 = (p1 - p0) * t + p0;
                var p12 = (p2 - p1) * t + p1;
                var p012 = (p12 - p01) * t + p01;
                out[0] = p0;
                out[1] = p01;
                out[2] = p012;
                out[3] = p012;
                out[4] = p12;
                out[5] = p2;
            }
            function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
                var t;
                var interval = 0.005;
                var d = Infinity;
                _v0[0] = x;
                _v0[1] = y;
                for (var _t = 0; _t < 1; _t += 0.05) {
                    _v1[0] = quadraticAt(x0, x1, x2, _t);
                    _v1[1] = quadraticAt(y0, y1, y2, _t);
                    var d1 = v2DistSquare(_v0, _v1);
                    if (d1 < d) {
                        t = _t;
                        d = d1;
                    }
                }
                d = Infinity;
                for (var i = 0; i < 32; i++) {
                    if (interval < EPSILON_NUMERIC) {
                        break;
                    }
                    var prev = t - interval;
                    var next = t + interval;
                    _v1[0] = quadraticAt(x0, x1, x2, prev);
                    _v1[1] = quadraticAt(y0, y1, y2, prev);
                    var d1 = v2DistSquare(_v1, _v0);
                    if (prev >= 0 && d1 < d) {
                        t = prev;
                        d = d1;
                    } else {
                        _v2[0] = quadraticAt(x0, x1, x2, next);
                        _v2[1] = quadraticAt(y0, y1, y2, next);
                        var d2 = v2DistSquare(_v2, _v0);
                        if (next <= 1 && d2 < d) {
                            t = next;
                            d = d2;
                        } else {
                            interval *= 0.5;
                        }
                    }
                }
                if (out) {
                    out[0] = quadraticAt(x0, x1, x2, t);
                    out[1] = quadraticAt(y0, y1, y2, t);
                }
                return mathSqrt(d);
            }
            module.exports = {
                cubicAt: cubicAt,
                cubicDerivativeAt: cubicDerivativeAt,
                cubicRootAt: cubicRootAt,
                cubicExtrema: cubicExtrema,
                cubicSubdivide: cubicSubdivide,
                cubicProjectPoint: cubicProjectPoint,
                quadraticAt: quadraticAt,
                quadraticDerivativeAt: quadraticDerivativeAt,
                quadraticRootAt: quadraticRootAt,
                quadraticExtremum: quadraticExtremum,
                quadraticSubdivide: quadraticSubdivide,
                quadraticProjectPoint: quadraticProjectPoint
            };
        },
        function (module, exports, __webpack_require__) {
            var vec2 = __webpack_require__(16);
            var curve = __webpack_require__(49);
            var bbox = {};
            var mathMin = Math.min;
            var mathMax = Math.max;
            var mathSin = Math.sin;
            var mathCos = Math.cos;
            var start = vec2.create();
            var end = vec2.create();
            var extremity = vec2.create();
            var PI2 = Math.PI * 2;
            bbox.fromPoints = function (points, min, max) {
                if (points.length === 0) {
                    return;
                }
                var p = points[0];
                var left = p[0];
                var right = p[0];
                var top = p[1];
                var bottom = p[1];
                var i;
                for (i = 1; i < points.length; i++) {
                    p = points[i];
                    left = mathMin(left, p[0]);
                    right = mathMax(right, p[0]);
                    top = mathMin(top, p[1]);
                    bottom = mathMax(bottom, p[1]);
                }
                min[0] = left;
                min[1] = top;
                max[0] = right;
                max[1] = bottom;
            };
            bbox.fromLine = function (x0, y0, x1, y1, min, max) {
                min[0] = mathMin(x0, x1);
                min[1] = mathMin(y0, y1);
                max[0] = mathMax(x0, x1);
                max[1] = mathMax(y0, y1);
            };
            var xDim = [];
            var yDim = [];
            bbox.fromCubic = function (x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
                var cubicExtrema = curve.cubicExtrema;
                var cubicAt = curve.cubicAt;
                var i;
                var n = cubicExtrema(x0, x1, x2, x3, xDim);
                min[0] = Infinity;
                min[1] = Infinity;
                max[0] = -Infinity;
                max[1] = -Infinity;
                for (i = 0; i < n; i++) {
                    var x = cubicAt(x0, x1, x2, x3, xDim[i]);
                    min[0] = mathMin(x, min[0]);
                    max[0] = mathMax(x, max[0]);
                }
                n = cubicExtrema(y0, y1, y2, y3, yDim);
                for (i = 0; i < n; i++) {
                    var y = cubicAt(y0, y1, y2, y3, yDim[i]);
                    min[1] = mathMin(y, min[1]);
                    max[1] = mathMax(y, max[1]);
                }
                min[0] = mathMin(x0, min[0]);
                max[0] = mathMax(x0, max[0]);
                min[0] = mathMin(x3, min[0]);
                max[0] = mathMax(x3, max[0]);
                min[1] = mathMin(y0, min[1]);
                max[1] = mathMax(y0, max[1]);
                min[1] = mathMin(y3, min[1]);
                max[1] = mathMax(y3, max[1]);
            };
            bbox.fromQuadratic = function (x0, y0, x1, y1, x2, y2, min, max) {
                var quadraticExtremum = curve.quadraticExtremum;
                var quadraticAt = curve.quadraticAt;
                var tx = mathMax(mathMin(quadraticExtremum(x0, x1, x2), 1), 0);
                var ty = mathMax(mathMin(quadraticExtremum(y0, y1, y2), 1), 0);
                var x = quadraticAt(x0, x1, x2, tx);
                var y = quadraticAt(y0, y1, y2, ty);
                min[0] = mathMin(x0, x2, x);
                min[1] = mathMin(y0, y2, y);
                max[0] = mathMax(x0, x2, x);
                max[1] = mathMax(y0, y2, y);
            };
            bbox.fromArc = function (x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max) {
                var vec2Min = vec2.min;
                var vec2Max = vec2.max;
                var diff = Math.abs(startAngle - endAngle);
                if (diff % PI2 < 0.0001 && diff > 0.0001) {
                    min[0] = x - rx;
                    min[1] = y - ry;
                    max[0] = x + rx;
                    max[1] = y + ry;
                    return;
                }
                start[0] = mathCos(startAngle) * rx + x;
                start[1] = mathSin(startAngle) * ry + y;
                end[0] = mathCos(endAngle) * rx + x;
                end[1] = mathSin(endAngle) * ry + y;
                vec2Min(min, start, end);
                vec2Max(max, start, end);
                startAngle = startAngle % PI2;
                if (startAngle < 0) {
                    startAngle = startAngle + PI2;
                }
                endAngle = endAngle % PI2;
                if (endAngle < 0) {
                    endAngle = endAngle + PI2;
                }
                if (startAngle > endAngle && !anticlockwise) {
                    endAngle += PI2;
                } else if (startAngle < endAngle && anticlockwise) {
                    startAngle += PI2;
                }
                if (anticlockwise) {
                    var tmp = endAngle;
                    endAngle = startAngle;
                    startAngle = tmp;
                }
                for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
                    if (angle > startAngle) {
                        extremity[0] = mathCos(angle) * rx + x;
                        extremity[1] = mathSin(angle) * ry + y;
                        vec2Min(min, extremity, min);
                        vec2Max(max, extremity, max);
                    }
                }
            };
            module.exports = bbox;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var CMD = __webpack_require__(48).CMD;
            var line = __webpack_require__(52);
            var cubic = __webpack_require__(53);
            var quadratic = __webpack_require__(54);
            var arc = __webpack_require__(55);
            var normalizeRadian = __webpack_require__(56).normalizeRadian;
            var curve = __webpack_require__(49);
            var windingLine = __webpack_require__(57);
            var containStroke = line.containStroke;
            var PI2 = Math.PI * 2;
            var EPSILON = 0.0001;
            function isAroundEqual(a, b) {
                return Math.abs(a - b) < EPSILON;
            }
            var roots = [
                -1,
                -1,
                -1
            ];
            var extrema = [
                -1,
                -1
            ];
            function swapExtrema() {
                var tmp = extrema[0];
                extrema[0] = extrema[1];
                extrema[1] = tmp;
            }
            function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
                if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) {
                    return 0;
                }
                var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
                if (nRoots === 0) {
                    return 0;
                } else {
                    var w = 0;
                    var nExtrema = -1;
                    var y0_, y1_;
                    for (var i = 0; i < nRoots; i++) {
                        var t = roots[i];
                        var x_ = curve.cubicAt(x0, x1, x2, x3, t);
                        if (x_ < x) {
                            continue;
                        }
                        if (nExtrema < 0) {
                            nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
                            if (extrema[1] < extrema[0] && nExtrema > 1) {
                                swapExtrema();
                            }
                            y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
                            if (nExtrema > 1) {
                                y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
                            }
                        }
                        if (nExtrema == 2) {
                            if (t < extrema[0]) {
                                w += y0_ < y0 ? 1 : -1;
                            } else if (t < extrema[1]) {
                                w += y1_ < y0_ ? 1 : -1;
                            } else {
                                w += y3 < y1_ ? 1 : -1;
                            }
                        } else {
                            if (t < extrema[0]) {
                                w += y0_ < y0 ? 1 : -1;
                            } else {
                                w += y3 < y0_ ? 1 : -1;
                            }
                        }
                    }
                    return w;
                }
            }
            function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
                if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) {
                    return 0;
                }
                var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
                if (nRoots === 0) {
                    return 0;
                } else {
                    var t = curve.quadraticExtremum(y0, y1, y2);
                    if (t >= 0 && t <= 1) {
                        var w = 0;
                        var y_ = curve.quadraticAt(y0, y1, y2, t);
                        for (var i = 0; i < nRoots; i++) {
                            var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
                            if (x_ < x) {
                                continue;
                            }
                            if (roots[i] < t) {
                                w += y_ < y0 ? 1 : -1;
                            } else {
                                w += y2 < y_ ? 1 : -1;
                            }
                        }
                        return w;
                    } else {
                        var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
                        if (x_ < x) {
                            return 0;
                        }
                        return y2 < y0 ? 1 : -1;
                    }
                }
            }
            function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
                y -= cy;
                if (y > r || y < -r) {
                    return 0;
                }
                var tmp = Math.sqrt(r * r - y * y);
                roots[0] = -tmp;
                roots[1] = tmp;
                var diff = Math.abs(startAngle - endAngle);
                if (diff < 0.0001) {
                    return 0;
                }
                if (diff % PI2 < 0.0001) {
                    startAngle = 0;
                    endAngle = PI2;
                    var dir = anticlockwise ? 1 : -1;
                    if (x >= roots[0] + cx && x <= roots[1] + cx) {
                        return dir;
                    } else {
                        return 0;
                    }
                }
                if (anticlockwise) {
                    var tmp = startAngle;
                    startAngle = normalizeRadian(endAngle);
                    endAngle = normalizeRadian(tmp);
                } else {
                    startAngle = normalizeRadian(startAngle);
                    endAngle = normalizeRadian(endAngle);
                }
                if (startAngle > endAngle) {
                    endAngle += PI2;
                }
                var w = 0;
                for (var i = 0; i < 2; i++) {
                    var x_ = roots[i];
                    if (x_ + cx > x) {
                        var angle = Math.atan2(y, x_);
                        var dir = anticlockwise ? 1 : -1;
                        if (angle < 0) {
                            angle = PI2 + angle;
                        }
                        if (angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle) {
                            if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
                                dir = -dir;
                            }
                            w += dir;
                        }
                    }
                }
                return w;
            }
            function containPath(data, lineWidth, isStroke, x, y) {
                var w = 0;
                var xi = 0;
                var yi = 0;
                var x0 = 0;
                var y0 = 0;
                for (var i = 0; i < data.length;) {
                    var cmd = data[i++];
                    if (cmd === CMD.M && i > 1) {
                        if (!isStroke) {
                            w += windingLine(xi, yi, x0, y0, x, y);
                        }
                        if (w !== 0) {
                            return true;
                        }
                    }
                    if (i == 1) {
                        xi = data[i];
                        yi = data[i + 1];
                        x0 = xi;
                        y0 = yi;
                    }
                    switch (cmd) {
                    case CMD.M:
                        x0 = data[i++];
                        y0 = data[i++];
                        xi = x0;
                        yi = y0;
                        break;
                    case CMD.L:
                        if (isStroke) {
                            if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
                                return true;
                            }
                        } else {
                            w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
                        }
                        xi = data[i++];
                        yi = data[i++];
                        break;
                    case CMD.C:
                        if (isStroke) {
                            if (cubic.containStroke(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                                return true;
                            }
                        } else {
                            w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
                        }
                        xi = data[i++];
                        yi = data[i++];
                        break;
                    case CMD.Q:
                        if (isStroke) {
                            if (quadratic.containStroke(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
                                return true;
                            }
                        } else {
                            w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0;
                        }
                        xi = data[i++];
                        yi = data[i++];
                        break;
                    case CMD.A:
                        var cx = data[i++];
                        var cy = data[i++];
                        var rx = data[i++];
                        var ry = data[i++];
                        var theta = data[i++];
                        var dTheta = data[i++];
                        var psi = data[i++];
                        var anticlockwise = 1 - data[i++];
                        var x1 = Math.cos(theta) * rx + cx;
                        var y1 = Math.sin(theta) * ry + cy;
                        if (i > 1) {
                            w += windingLine(xi, yi, x1, y1, x, y);
                        } else {
                            x0 = x1;
                            y0 = y1;
                        }
                        var _x = (x - cx) * ry / rx + cx;
                        if (isStroke) {
                            if (arc.containStroke(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
                                return true;
                            }
                        } else {
                            w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y);
                        }
                        xi = Math.cos(theta + dTheta) * rx + cx;
                        yi = Math.sin(theta + dTheta) * ry + cy;
                        break;
                    case CMD.R:
                        x0 = xi = data[i++];
                        y0 = yi = data[i++];
                        var width = data[i++];
                        var height = data[i++];
                        var x1 = x0 + width;
                        var y1 = y0 + height;
                        if (isStroke) {
                            if (containStroke(x0, y0, x1, y0, lineWidth, x, y) || containStroke(x1, y0, x1, y1, lineWidth, x, y) || containStroke(x1, y1, x0, y1, lineWidth, x, y) || containStroke(x0, y1, x1, y1, lineWidth, x, y)) {
                                return true;
                            }
                        } else {
                            w += windingLine(x1, y0, x1, y1, x, y);
                            w += windingLine(x0, y1, x0, y0, x, y);
                        }
                        break;
                    case CMD.Z:
                        if (isStroke) {
                            if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
                                return true;
                            }
                        } else {
                            w += windingLine(xi, yi, x0, y0, x, y);
                            if (w !== 0) {
                                return true;
                            }
                        }
                        xi = x0;
                        yi = y0;
                        break;
                    }
                }
                if (!isStroke && !isAroundEqual(yi, y0)) {
                    w += windingLine(xi, yi, x0, y0, x, y) || 0;
                }
                return w !== 0;
            }
            module.exports = {
                contain: function (pathData, x, y) {
                    return containPath(pathData, 0, false, x, y);
                },
                containStroke: function (pathData, lineWidth, x, y) {
                    return containPath(pathData, lineWidth, true, x, y);
                }
            };
        },
        function (module, exports) {
            module.exports = {
                containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {
                    if (lineWidth === 0) {
                        return false;
                    }
                    var _l = lineWidth;
                    var _a = 0;
                    var _b = x0;
                    if (y > y0 + _l && y > y1 + _l || y < y0 - _l && y < y1 - _l || x > x0 + _l && x > x1 + _l || x < x0 - _l && x < x1 - _l) {
                        return false;
                    }
                    if (x0 !== x1) {
                        _a = (y0 - y1) / (x0 - x1);
                        _b = (x0 * y1 - x1 * y0) / (x0 - x1);
                    } else {
                        return Math.abs(x - x0) <= _l / 2;
                    }
                    var tmp = _a * x - y + _b;
                    var _s = tmp * tmp / (_a * _a + 1);
                    return _s <= _l / 2 * _l / 2;
                }
            };
        },
        function (module, exports, __webpack_require__) {
            var curve = __webpack_require__(49);
            module.exports = {
                containStroke: function (x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
                    if (lineWidth === 0) {
                        return false;
                    }
                    var _l = lineWidth;
                    if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) {
                        return false;
                    }
                    var d = curve.cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null);
                    return d <= _l / 2;
                }
            };
        },
        function (module, exports, __webpack_require__) {
            var curve = __webpack_require__(49);
            module.exports = {
                containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
                    if (lineWidth === 0) {
                        return false;
                    }
                    var _l = lineWidth;
                    if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) {
                        return false;
                    }
                    var d = curve.quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null);
                    return d <= _l / 2;
                }
            };
        },
        function (module, exports, __webpack_require__) {
            var normalizeRadian = __webpack_require__(56).normalizeRadian;
            var PI2 = Math.PI * 2;
            module.exports = {
                containStroke: function (cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
                    if (lineWidth === 0) {
                        return false;
                    }
                    var _l = lineWidth;
                    x -= cx;
                    y -= cy;
                    var d = Math.sqrt(x * x + y * y);
                    if (d - _l > r || d + _l < r) {
                        return false;
                    }
                    if (Math.abs(startAngle - endAngle) % PI2 < 0.0001) {
                        return true;
                    }
                    if (anticlockwise) {
                        var tmp = startAngle;
                        startAngle = normalizeRadian(endAngle);
                        endAngle = normalizeRadian(tmp);
                    } else {
                        startAngle = normalizeRadian(startAngle);
                        endAngle = normalizeRadian(endAngle);
                    }
                    if (startAngle > endAngle) {
                        endAngle += PI2;
                    }
                    var angle = Math.atan2(y, x);
                    if (angle < 0) {
                        angle += PI2;
                    }
                    return angle >= startAngle && angle <= endAngle || angle + PI2 >= startAngle && angle + PI2 <= endAngle;
                }
            };
        },
        function (module, exports) {
            var PI2 = Math.PI * 2;
            module.exports = {
                normalizeRadian: function (angle) {
                    angle %= PI2;
                    if (angle < 0) {
                        angle += PI2;
                    }
                    return angle;
                }
            };
        },
        function (module, exports) {
            module.exports = function windingLine(x0, y0, x1, y1, x, y) {
                if (y > y0 && y > y1 || y < y0 && y < y1) {
                    return 0;
                }
                if (y1 === y0) {
                    return 0;
                }
                var dir = y1 < y0 ? 1 : -1;
                var t = (y - y0) / (y1 - y0);
                var x_ = t * (x1 - x0) + x0;
                return x_ > x ? dir : 0;
            };
        },
        function (module, exports, __webpack_require__) {
            var CMD = __webpack_require__(48).CMD;
            var vec2 = __webpack_require__(16);
            var v2ApplyTransform = vec2.applyTransform;
            var points = [
                [],
                [],
                []
            ];
            var mathSqrt = Math.sqrt;
            var mathAtan2 = Math.atan2;
            function transformPath(path, m) {
                var data = path.data;
                var cmd;
                var nPoint;
                var i;
                var j;
                var k;
                var p;
                var M = CMD.M;
                var C = CMD.C;
                var L = CMD.L;
                var R = CMD.R;
                var A = CMD.A;
                var Q = CMD.Q;
                for (i = 0, j = 0; i < data.length;) {
                    cmd = data[i++];
                    j = i;
                    nPoint = 0;
                    switch (cmd) {
                    case M:
                        nPoint = 1;
                        break;
                    case L:
                        nPoint = 1;
                        break;
                    case C:
                        nPoint = 3;
                        break;
                    case Q:
                        nPoint = 2;
                        break;
                    case A:
                        var x = m[4];
                        var y = m[5];
                        var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
                        var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
                        var angle = mathAtan2(-m[1] / sy, m[0] / sx);
                        data[i++] += x;
                        data[i++] += y;
                        data[i++] *= sx;
                        data[i++] *= sy;
                        data[i++] += angle;
                        data[i++] += angle;
                        i += 2;
                        j = i;
                        break;
                    case R:
                        p[0] = data[i++];
                        p[1] = data[i++];
                        v2ApplyTransform(p, p, m);
                        data[j++] = p[0];
                        data[j++] = p[1];
                        p[0] += data[i++];
                        p[1] += data[i++];
                        v2ApplyTransform(p, p, m);
                        data[j++] = p[0];
                        data[j++] = p[1];
                    }
                    for (k = 0; k < nPoint; k++) {
                        var p = points[k];
                        p[0] = data[i++];
                        p[1] = data[i++];
                        v2ApplyTransform(p, p, m);
                        data[j++] = p[0];
                        data[j++] = p[1];
                    }
                }
            }
            module.exports = transformPath;
        },
        function (module, exports, __webpack_require__) {
            var Displayable = __webpack_require__(45);
            var BoundingRect = __webpack_require__(15);
            var zrUtil = __webpack_require__(3);
            var roundRectHelper = __webpack_require__(60);
            var LRU = __webpack_require__(61);
            var globalImageCache = new LRU(50);
            function ZImage(opts) {
                Displayable.call(this, opts);
            }
            ZImage.prototype = {
                constructor: ZImage,
                type: 'image',
                brush: function (ctx) {
                    var style = this.style;
                    var src = style.image;
                    var image;
                    if (typeof src === 'string') {
                        image = this._image;
                    } else {
                        image = src;
                    }
                    if (!image && src) {
                        var cachedImgObj = globalImageCache.get(src);
                        if (!cachedImgObj) {
                            image = new Image();
                            image.onload = function () {
                                image.onload = null;
                                for (var i = 0; i < cachedImgObj.pending.length; i++) {
                                    cachedImgObj.pending[i].dirty();
                                }
                            };
                            cachedImgObj = {
                                image: image,
                                pending: [this]
                            };
                            image.src = src;
                            globalImageCache.put(src, cachedImgObj);
                            this._image = image;
                            return;
                        } else {
                            image = cachedImgObj.image;
                            this._image = image;
                            if (!image.width || !image.height) {
                                cachedImgObj.pending.push(this);
                                return;
                            }
                        }
                    }
                    if (image) {
                        var width = style.width || image.width;
                        var height = style.height || image.height;
                        var x = style.x || 0;
                        var y = style.y || 0;
                        if (!image.width || !image.height) {
                            return;
                        }
                        ctx.save();
                        style.bind(ctx);
                        this.setTransform(ctx);
                        if (style.r) {
                            ctx.beginPath();
                            roundRectHelper.buildPath(ctx, style);
                            ctx.clip();
                        }
                        if (style.sWidth && style.sHeight) {
                            var sx = style.sx || 0;
                            var sy = style.sy || 0;
                            ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height);
                        } else if (style.sx && style.sy) {
                            var sx = style.sx;
                            var sy = style.sy;
                            var sWidth = width - sx;
                            var sHeight = height - sy;
                            ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height);
                        } else {
                            ctx.drawImage(image, x, y, width, height);
                        }
                        if (style.width == null) {
                            style.width = width;
                        }
                        if (style.height == null) {
                            style.height = height;
                        }
                        if (style.text != null) {
                            this.drawRectText(ctx, this.getBoundingRect());
                        }
                        ctx.restore();
                    }
                },
                getBoundingRect: function () {
                    var style = this.style;
                    if (!this._rect) {
                        this._rect = new BoundingRect(style.x || 0, style.y || 0, style.width || 0, style.height || 0);
                    }
                    return this._rect;
                }
            };
            zrUtil.inherits(ZImage, Displayable);
            module.exports = ZImage;
        },
        function (module, exports) {
            module.exports = {
                buildPath: function (ctx, shape) {
                    var x = shape.x;
                    var y = shape.y;
                    var width = shape.width;
                    var height = shape.height;
                    var r = shape.r;
                    var r1;
                    var r2;
                    var r3;
                    var r4;
                    if (width < 0) {
                        x = x + width;
                        width = -width;
                    }
                    if (height < 0) {
                        y = y + height;
                        height = -height;
                    }
                    if (typeof r === 'number') {
                        r1 = r2 = r3 = r4 = r;
                    } else if (r instanceof Array) {
                        if (r.length === 1) {
                            r1 = r2 = r3 = r4 = r[0];
                        } else if (r.length === 2) {
                            r1 = r3 = r[0];
                            r2 = r4 = r[1];
                        } else if (r.length === 3) {
                            r1 = r[0];
                            r2 = r4 = r[1];
                            r3 = r[2];
                        } else {
                            r1 = r[0];
                            r2 = r[1];
                            r3 = r[2];
                            r4 = r[3];
                        }
                    } else {
                        r1 = r2 = r3 = r4 = 0;
                    }
                    var total;
                    if (r1 + r2 > width) {
                        total = r1 + r2;
                        r1 *= width / total;
                        r2 *= width / total;
                    }
                    if (r3 + r4 > width) {
                        total = r3 + r4;
                        r3 *= width / total;
                        r4 *= width / total;
                    }
                    if (r2 + r3 > height) {
                        total = r2 + r3;
                        r2 *= height / total;
                        r3 *= height / total;
                    }
                    if (r1 + r4 > height) {
                        total = r1 + r4;
                        r1 *= height / total;
                        r4 *= height / total;
                    }
                    ctx.moveTo(x + r1, y);
                    ctx.lineTo(x + width - r2, y);
                    r2 !== 0 && ctx.quadraticCurveTo(x + width, y, x + width, y + r2);
                    ctx.lineTo(x + width, y + height - r3);
                    r3 !== 0 && ctx.quadraticCurveTo(x + width, y + height, x + width - r3, y + height);
                    ctx.lineTo(x + r4, y + height);
                    r4 !== 0 && ctx.quadraticCurveTo(x, y + height, x, y + height - r4);
                    ctx.lineTo(x, y + r1);
                    r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
                }
            };
        },
        function (module, exports) {
            var LinkedList = function () {
                this.head = null;
                this.tail = null;
                this._len = 0;
            };
            var linkedListProto = LinkedList.prototype;
            linkedListProto.insert = function (val) {
                var entry = new Entry(val);
                this.insertEntry(entry);
                return entry;
            };
            linkedListProto.insertEntry = function (entry) {
                if (!this.head) {
                    this.head = this.tail = entry;
                } else {
                    this.tail.next = entry;
                    entry.prev = this.tail;
                    this.tail = entry;
                }
                this._len++;
            };
            linkedListProto.remove = function (entry) {
                var prev = entry.prev;
                var next = entry.next;
                if (prev) {
                    prev.next = next;
                } else {
                    this.head = next;
                }
                if (next) {
                    next.prev = prev;
                } else {
                    this.tail = prev;
                }
                entry.next = entry.prev = null;
                this._len--;
            };
            linkedListProto.len = function () {
                return this._len;
            };
            var Entry = function (val) {
                this.value = val;
                this.next;
                this.prev;
            };
            var LRU = function (maxSize) {
                this._list = new LinkedList();
                this._map = {};
                this._maxSize = maxSize || 10;
            };
            var LRUProto = LRU.prototype;
            LRUProto.put = function (key, value) {
                var list = this._list;
                var map = this._map;
                if (map[key] == null) {
                    var len = list.len();
                    if (len >= this._maxSize && len > 0) {
                        var leastUsedEntry = list.head;
                        list.remove(leastUsedEntry);
                        delete map[leastUsedEntry.key];
                    }
                    var entry = list.insert(value);
                    entry.key = key;
                    map[key] = entry;
                }
            };
            LRUProto.get = function (key) {
                var entry = this._map[key];
                var list = this._list;
                if (entry != null) {
                    if (entry !== list.tail) {
                        list.remove(entry);
                        list.insertEntry(entry);
                    }
                    return entry.value;
                }
            };
            LRUProto.clear = function () {
                this._list.clear();
                this._map = {};
            };
            module.exports = LRU;
        },
        function (module, exports, __webpack_require__) {
            var Displayable = __webpack_require__(45);
            var zrUtil = __webpack_require__(3);
            var textContain = __webpack_require__(14);
            var Text = function (opts) {
                Displayable.call(this, opts);
            };
            Text.prototype = {
                constructor: Text,
                type: 'text',
                brush: function (ctx) {
                    var style = this.style;
                    var x = style.x || 0;
                    var y = style.y || 0;
                    var text = style.text;
                    var textFill = style.fill;
                    var textStroke = style.stroke;
                    text != null && (text += '');
                    if (text) {
                        ctx.save();
                        this.style.bind(ctx);
                        this.setTransform(ctx);
                        textFill && (ctx.fillStyle = textFill);
                        textStroke && (ctx.strokeStyle = textStroke);
                        ctx.font = style.textFont || style.font;
                        ctx.textAlign = style.textAlign;
                        if (style.textVerticalAlign) {
                            var rect = textContain.getBoundingRect(text, ctx.font, style.textAlign, 'top');
                            ctx.textBaseline = 'top';
                            switch (style.textVerticalAlign) {
                            case 'middle':
                                y -= rect.height / 2;
                                break;
                            case 'bottom':
                                y -= rect.height;
                                break;
                            }
                        } else {
                            ctx.textBaseline = style.textBaseline;
                        }
                        var lineHeight = textContain.measureText('国', ctx.font).width;
                        var textLines = text.split('\n');
                        for (var i = 0; i < textLines.length; i++) {
                            textFill && ctx.fillText(textLines[i], x, y);
                            textStroke && ctx.strokeText(textLines[i], x, y);
                            y += lineHeight;
                        }
                        ctx.restore();
                    }
                },
                getBoundingRect: function () {
                    if (!this._rect) {
                        var style = this.style;
                        var textVerticalAlign = style.textVerticalAlign;
                        var rect = textContain.getBoundingRect(style.text + '', style.textFont || style.font, style.textAlign, textVerticalAlign ? 'top' : style.textBaseline);
                        switch (textVerticalAlign) {
                        case 'middle':
                            rect.y -= rect.height / 2;
                            break;
                        case 'bottom':
                            rect.y -= rect.height;
                            break;
                        }
                        rect.x += style.x || 0;
                        rect.y += style.y || 0;
                        this._rect = rect;
                    }
                    return this._rect;
                }
            };
            zrUtil.inherits(Text, Displayable);
            module.exports = Text;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            module.exports = __webpack_require__(44).extend({
                type: 'circle',
                shape: {
                    cx: 0,
                    cy: 0,
                    r: 0
                },
                buildPath: function (ctx, shape) {
                    ctx.moveTo(shape.cx + shape.r, shape.cy);
                    ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
                    return;
                }
            });
        },
        function (module, exports, __webpack_require__) {
            module.exports = __webpack_require__(44).extend({
                type: 'sector',
                shape: {
                    cx: 0,
                    cy: 0,
                    r0: 0,
                    r: 0,
                    startAngle: 0,
                    endAngle: Math.PI * 2,
                    clockwise: true
                },
                buildPath: function (ctx, shape) {
                    var x = shape.cx;
                    var y = shape.cy;
                    var r0 = Math.max(shape.r0 || 0, 0);
                    var r = Math.max(shape.r, 0);
                    var startAngle = shape.startAngle;
                    var endAngle = shape.endAngle;
                    var clockwise = shape.clockwise;
                    var unitX = Math.cos(startAngle);
                    var unitY = Math.sin(startAngle);
                    ctx.moveTo(unitX * r0 + x, unitY * r0 + y);
                    ctx.lineTo(unitX * r + x, unitY * r + y);
                    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
                    ctx.lineTo(Math.cos(endAngle) * r0 + x, Math.sin(endAngle) * r0 + y);
                    if (r0 !== 0) {
                        ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
                    }
                    ctx.closePath();
                }
            });
        },
        function (module, exports, __webpack_require__) {
            module.exports = __webpack_require__(44).extend({
                type: 'ring',
                shape: {
                    cx: 0,
                    cy: 0,
                    r: 0,
                    r0: 0
                },
                buildPath: function (ctx, shape) {
                    var x = shape.cx;
                    var y = shape.cy;
                    var PI2 = Math.PI * 2;
                    ctx.moveTo(x + shape.r, y);
                    ctx.arc(x, y, shape.r, 0, PI2, false);
                    ctx.moveTo(x + shape.r0, y);
                    ctx.arc(x, y, shape.r0, 0, PI2, true);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var polyHelper = __webpack_require__(67);
            module.exports = __webpack_require__(44).extend({
                type: 'polygon',
                shape: {
                    points: null,
                    smooth: false,
                    smoothConstraint: null
                },
                buildPath: function (ctx, shape) {
                    polyHelper.buildPath(ctx, shape, true);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var smoothSpline = __webpack_require__(68);
            var smoothBezier = __webpack_require__(69);
            module.exports = {
                buildPath: function (ctx, shape, closePath) {
                    var points = shape.points;
                    var smooth = shape.smooth;
                    if (points && points.length >= 2) {
                        if (smooth && smooth !== 'spline') {
                            var controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint);
                            ctx.moveTo(points[0][0], points[0][1]);
                            var len = points.length;
                            for (var i = 0; i < (closePath ? len : len - 1); i++) {
                                var cp1 = controlPoints[i * 2];
                                var cp2 = controlPoints[i * 2 + 1];
                                var p = points[(i + 1) % len];
                                ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]);
                            }
                        } else {
                            if (smooth === 'spline') {
                                points = smoothSpline(points, closePath);
                            }
                            ctx.moveTo(points[0][0], points[0][1]);
                            for (var i = 1, l = points.length; i < l; i++) {
                                ctx.lineTo(points[i][0], points[i][1]);
                            }
                        }
                        closePath && ctx.closePath();
                    }
                }
            };
        },
        function (module, exports, __webpack_require__) {
            var vec2 = __webpack_require__(16);
            function interpolate(p0, p1, p2, p3, t, t2, t3) {
                var v0 = (p2 - p0) * 0.5;
                var v1 = (p3 - p1) * 0.5;
                return (2 * (p1 - p2) + v0 + v1) * t3 + (-3 * (p1 - p2) - 2 * v0 - v1) * t2 + v0 * t + p1;
            }
            module.exports = function (points, isLoop) {
                var len = points.length;
                var ret = [];
                var distance = 0;
                for (var i = 1; i < len; i++) {
                    distance += vec2.distance(points[i - 1], points[i]);
                }
                var segs = distance / 2;
                segs = segs < len ? len : segs;
                for (var i = 0; i < segs; i++) {
                    var pos = i / (segs - 1) * (isLoop ? len : len - 1);
                    var idx = Math.floor(pos);
                    var w = pos - idx;
                    var p0;
                    var p1 = points[idx % len];
                    var p2;
                    var p3;
                    if (!isLoop) {
                        p0 = points[idx === 0 ? idx : idx - 1];
                        p2 = points[idx > len - 2 ? len - 1 : idx + 1];
                        p3 = points[idx > len - 3 ? len - 1 : idx + 2];
                    } else {
                        p0 = points[(idx - 1 + len) % len];
                        p2 = points[(idx + 1) % len];
                        p3 = points[(idx + 2) % len];
                    }
                    var w2 = w * w;
                    var w3 = w * w2;
                    ret.push([
                        interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
                        interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
                    ]);
                }
                return ret;
            };
        },
        function (module, exports, __webpack_require__) {
            var vec2 = __webpack_require__(16);
            var v2Min = vec2.min;
            var v2Max = vec2.max;
            var v2Scale = vec2.scale;
            var v2Distance = vec2.distance;
            var v2Add = vec2.add;
            module.exports = function (points, smooth, isLoop, constraint) {
                var cps = [];
                var v = [];
                var v1 = [];
                var v2 = [];
                var prevPoint;
                var nextPoint;
                var min, max;
                if (constraint) {
                    min = [
                        Infinity,
                        Infinity
                    ];
                    max = [
                        -Infinity,
                        -Infinity
                    ];
                    for (var i = 0, len = points.length; i < len; i++) {
                        v2Min(min, min, points[i]);
                        v2Max(max, max, points[i]);
                    }
                    v2Min(min, min, constraint[0]);
                    v2Max(max, max, constraint[1]);
                }
                for (var i = 0, len = points.length; i < len; i++) {
                    var point = points[i];
                    if (isLoop) {
                        prevPoint = points[i ? i - 1 : len - 1];
                        nextPoint = points[(i + 1) % len];
                    } else {
                        if (i === 0 || i === len - 1) {
                            cps.push(vec2.clone(points[i]));
                            continue;
                        } else {
                            prevPoint = points[i - 1];
                            nextPoint = points[i + 1];
                        }
                    }
                    vec2.sub(v, nextPoint, prevPoint);
                    v2Scale(v, v, smooth);
                    var d0 = v2Distance(point, prevPoint);
                    var d1 = v2Distance(point, nextPoint);
                    var sum = d0 + d1;
                    if (sum !== 0) {
                        d0 /= sum;
                        d1 /= sum;
                    }
                    v2Scale(v1, v, -d0);
                    v2Scale(v2, v, d1);
                    var cp0 = v2Add([], point, v1);
                    var cp1 = v2Add([], point, v2);
                    if (constraint) {
                        v2Max(cp0, cp0, min);
                        v2Min(cp0, cp0, max);
                        v2Max(cp1, cp1, min);
                        v2Min(cp1, cp1, max);
                    }
                    cps.push(cp0);
                    cps.push(cp1);
                }
                if (isLoop) {
                    cps.push(cps.shift());
                }
                return cps;
            };
        },
        function (module, exports, __webpack_require__) {
            var polyHelper = __webpack_require__(67);
            module.exports = __webpack_require__(44).extend({
                type: 'polyline',
                shape: {
                    points: null,
                    smooth: false,
                    smoothConstraint: null
                },
                style: {
                    stroke: '#000',
                    fill: null
                },
                buildPath: function (ctx, shape) {
                    polyHelper.buildPath(ctx, shape, false);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var roundRectHelper = __webpack_require__(60);
            module.exports = __webpack_require__(44).extend({
                type: 'rect',
                shape: {
                    r: 0,
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function (ctx, shape) {
                    var x = shape.x;
                    var y = shape.y;
                    var width = shape.width;
                    var height = shape.height;
                    if (!shape.r) {
                        ctx.rect(x, y, width, height);
                    } else {
                        roundRectHelper.buildPath(ctx, shape);
                    }
                    ctx.closePath();
                    return;
                }
            });
        },
        function (module, exports, __webpack_require__) {
            module.exports = __webpack_require__(44).extend({
                type: 'line',
                shape: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                    percent: 1
                },
                style: {
                    stroke: '#000',
                    fill: null
                },
                buildPath: function (ctx, shape) {
                    var x1 = shape.x1;
                    var y1 = shape.y1;
                    var x2 = shape.x2;
                    var y2 = shape.y2;
                    var percent = shape.percent;
                    if (percent === 0) {
                        return;
                    }
                    ctx.moveTo(x1, y1);
                    if (percent < 1) {
                        x2 = x1 * (1 - percent) + x2 * percent;
                        y2 = y1 * (1 - percent) + y2 * percent;
                    }
                    ctx.lineTo(x2, y2);
                },
                pointAt: function (p) {
                    var shape = this.shape;
                    return [
                        shape.x1 * (1 - p) + shape.x2 * p,
                        shape.y1 * (1 - p) + shape.y2 * p
                    ];
                }
            });
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var curveTool = __webpack_require__(49);
            var quadraticSubdivide = curveTool.quadraticSubdivide;
            var cubicSubdivide = curveTool.cubicSubdivide;
            var quadraticAt = curveTool.quadraticAt;
            var cubicAt = curveTool.cubicAt;
            var out = [];
            module.exports = __webpack_require__(44).extend({
                type: 'bezier-curve',
                shape: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                    cpx1: 0,
                    cpy1: 0,
                    percent: 1
                },
                style: {
                    stroke: '#000',
                    fill: null
                },
                buildPath: function (ctx, shape) {
                    var x1 = shape.x1;
                    var y1 = shape.y1;
                    var x2 = shape.x2;
                    var y2 = shape.y2;
                    var cpx1 = shape.cpx1;
                    var cpy1 = shape.cpy1;
                    var cpx2 = shape.cpx2;
                    var cpy2 = shape.cpy2;
                    var percent = shape.percent;
                    if (percent === 0) {
                        return;
                    }
                    ctx.moveTo(x1, y1);
                    if (cpx2 == null || cpy2 == null) {
                        if (percent < 1) {
                            quadraticSubdivide(x1, cpx1, x2, percent, out);
                            cpx1 = out[1];
                            x2 = out[2];
                            quadraticSubdivide(y1, cpy1, y2, percent, out);
                            cpy1 = out[1];
                            y2 = out[2];
                        }
                        ctx.quadraticCurveTo(cpx1, cpy1, x2, y2);
                    } else {
                        if (percent < 1) {
                            cubicSubdivide(x1, cpx1, cpx2, x2, percent, out);
                            cpx1 = out[1];
                            cpx2 = out[2];
                            x2 = out[3];
                            cubicSubdivide(y1, cpy1, cpy2, y2, percent, out);
                            cpy1 = out[1];
                            cpy2 = out[2];
                            y2 = out[3];
                        }
                        ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
                    }
                },
                pointAt: function (p) {
                    var shape = this.shape;
                    var cpx2 = shape.cpx2;
                    var cpy2 = shape.cpy2;
                    if (cpx2 === null || cpy2 === null) {
                        return [
                            quadraticAt(shape.x1, shape.cpx1, shape.x2, p),
                            quadraticAt(shape.y1, shape.cpy1, shape.y2, p)
                        ];
                    } else {
                        return [
                            cubicAt(shape.x1, shape.cpx1, shape.cpx1, shape.x2, p),
                            cubicAt(shape.y1, shape.cpy1, shape.cpy1, shape.y2, p)
                        ];
                    }
                }
            });
        },
        function (module, exports, __webpack_require__) {
            module.exports = __webpack_require__(44).extend({
                type: 'arc',
                shape: {
                    cx: 0,
                    cy: 0,
                    r: 0,
                    startAngle: 0,
                    endAngle: Math.PI * 2,
                    clockwise: true
                },
                style: {
                    stroke: '#000',
                    fill: null
                },
                buildPath: function (ctx, shape) {
                    var x = shape.cx;
                    var y = shape.cy;
                    var r = Math.max(shape.r, 0);
                    var startAngle = shape.startAngle;
                    var endAngle = shape.endAngle;
                    var clockwise = shape.clockwise;
                    var unitX = Math.cos(startAngle);
                    var unitY = Math.sin(startAngle);
                    ctx.moveTo(unitX * r + x, unitY * r + y);
                    ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var Gradient = __webpack_require__(4);
            var LinearGradient = function (x, y, x2, y2, colorStops) {
                this.x = x == null ? 0 : x;
                this.y = y == null ? 0 : y;
                this.x2 = x2 == null ? 1 : x2;
                this.y2 = y2 == null ? 0 : y2;
                Gradient.call(this, colorStops);
            };
            LinearGradient.prototype = {
                constructor: LinearGradient,
                type: 'linear',
                updateCanvasGradient: function (shape, ctx) {
                    var rect = shape.getBoundingRect();
                    var x = this.x * rect.width + rect.x;
                    var x2 = this.x2 * rect.width + rect.x;
                    var y = this.y * rect.height + rect.y;
                    var y2 = this.y2 * rect.height + rect.y;
                    var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);
                    var colorStops = this.colorStops;
                    for (var i = 0; i < colorStops.length; i++) {
                        canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
                    }
                    this.canvasGradient = canvasGradient;
                }
            };
            zrUtil.inherits(LinearGradient, Gradient);
            module.exports = LinearGradient;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var Gradient = __webpack_require__(4);
            var RadialGradient = function (x, y, r, colorStops) {
                this.x = x == null ? 0.5 : x;
                this.y = y == null ? 0.5 : y;
                this.r = r == null ? 0.5 : r;
                Gradient.call(this, colorStops);
            };
            RadialGradient.prototype = {
                constructor: RadialGradient,
                type: 'radial',
                updateCanvasGradient: function (shape, ctx) {
                    var rect = shape.getBoundingRect();
                    var width = rect.width;
                    var height = rect.height;
                    var min = Math.min(width, height);
                    var x = this.x * width + rect.x;
                    var y = this.y * height + rect.y;
                    var r = this.r * min;
                    var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);
                    var colorStops = this.colorStops;
                    for (var i = 0; i < colorStops.length; i++) {
                        canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color);
                    }
                    this.canvasGradient = canvasGradient;
                }
            };
            zrUtil.inherits(RadialGradient, Gradient);
            module.exports = RadialGradient;
        },
        function (module, exports, __webpack_require__) {
            var guid = __webpack_require__(31);
            var env = __webpack_require__(78);
            var Handler = __webpack_require__(79);
            var Storage = __webpack_require__(83);
            var Animation = __webpack_require__(84);
            var useVML = !env.canvasSupported;
            var painterCtors = { canvas: __webpack_require__(85) };
            var instances = {};
            var zrender = {};
            zrender.version = '3.0.8';
            zrender.init = function (dom, opts) {
                var zr = new ZRender(guid(), dom, opts);
                instances[zr.id] = zr;
                return zr;
            };
            zrender.dispose = function (zr) {
                if (zr) {
                    zr.dispose();
                } else {
                    for (var key in instances) {
                        instances[key].dispose();
                    }
                    instances = {};
                }
                return zrender;
            };
            zrender.getInstance = function (id) {
                return instances[id];
            };
            zrender.registerPainter = function (name, Ctor) {
                painterCtors[name] = Ctor;
            };
            function delInstance(id) {
                delete instances[id];
            }
            var ZRender = function (id, dom, opts) {
                opts = opts || {};
                this.dom = dom;
                this.id = id;
                var self = this;
                var storage = new Storage();
                var rendererType = opts.renderer;
                if (useVML) {
                    if (!painterCtors.vml) {
                        throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
                    }
                    rendererType = 'vml';
                } else if (!rendererType || !painterCtors[rendererType]) {
                    rendererType = 'canvas';
                }
                var painter = new painterCtors[rendererType](dom, storage, opts);
                this.storage = storage;
                this.painter = painter;
                if (!env.node) {
                    this.handler = new Handler(painter.getViewportRoot(), storage, painter);
                }
                this.animation = new Animation({
                    stage: {
                        update: function () {
                            if (self._needsRefresh) {
                                self.refreshImmediately();
                            }
                        }
                    }
                });
                this.animation.start();
                this._needsRefresh;
                var oldDelFromMap = storage.delFromMap;
                var oldAddToMap = storage.addToMap;
                storage.delFromMap = function (elId) {
                    var el = storage.get(elId);
                    oldDelFromMap.call(storage, elId);
                    el && el.removeSelfFromZr(self);
                };
                storage.addToMap = function (el) {
                    oldAddToMap.call(storage, el);
                    el.addSelfToZr(self);
                };
            };
            ZRender.prototype = {
                constructor: ZRender,
                getId: function () {
                    return this.id;
                },
                add: function (el) {
                    this.storage.addRoot(el);
                    this._needsRefresh = true;
                },
                remove: function (el) {
                    this.storage.delRoot(el);
                    this._needsRefresh = true;
                },
                configLayer: function (zLevel, config) {
                    this.painter.configLayer(zLevel, config);
                    this._needsRefresh = true;
                },
                refreshImmediately: function () {
                    this._needsRefresh = false;
                    this.painter.refresh();
                    this._needsRefresh = false;
                },
                refresh: function () {
                    this._needsRefresh = true;
                },
                resize: function () {
                    this.painter.resize();
                    this.handler && this.handler.resize();
                },
                clearAnimation: function () {
                    this.animation.clear();
                },
                getWidth: function () {
                    return this.painter.getWidth();
                },
                getHeight: function () {
                    return this.painter.getHeight();
                },
                toDataURL: function (type, backgroundColor, args) {
                    return this.painter.toDataURL(type, backgroundColor, args);
                },
                pathToImage: function (e, width, height) {
                    var id = guid();
                    return this.painter.pathToImage(id, e, width, height);
                },
                setDefaultCursorStyle: function (cursorStyle) {
                    this.handler.setDefaultCursorStyle(cursorStyle);
                },
                on: function (eventName, eventHandler, context) {
                    this.handler && this.handler.on(eventName, eventHandler, context);
                },
                off: function (eventName, eventHandler) {
                    this.handler && this.handler.off(eventName, eventHandler);
                },
                trigger: function (eventName, event) {
                    this.handler && this.handler.trigger(eventName, event);
                },
                clear: function () {
                    this.storage.delRoot();
                    this.painter.clear();
                },
                dispose: function () {
                    this.animation.stop();
                    this.clear();
                    this.storage.dispose();
                    this.painter.dispose();
                    this.handler && this.handler.dispose();
                    this.animation = this.storage = this.painter = this.handler = null;
                    delInstance(this.id);
                }
            };
            module.exports = zrender;
        },
        function (module, exports) {
            var env = {};
            if (typeof navigator === 'undefined') {
                env = {
                    browser: {},
                    os: {},
                    node: true,
                    canvasSupported: true
                };
            } else {
                env = detect(navigator.userAgent);
            }
            module.exports = env;
            function detect(ua) {
                var os = {};
                var browser = {};
                var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
                var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
                var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
                var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
                var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
                var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
                var touchpad = webos && ua.match(/TouchPad/);
                var kindle = ua.match(/Kindle\/([\d.]+)/);
                var silk = ua.match(/Silk\/([\d._]+)/);
                var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
                var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
                var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
                var playbook = ua.match(/PlayBook/);
                var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
                var firefox = ua.match(/Firefox\/([\d.]+)/);
                var safari = webkit && ua.match(/Mobile\//) && !chrome;
                var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
                var ie = ua.match(/MSIE\s([\d.]+)/) || ua.match(/Trident\/.+?rv:(([\d.]+))/);
                var edge = ua.match(/Edge\/([\d.]+)/);
                if (browser.webkit = !!webkit)
                    browser.version = webkit[1];
                if (android)
                    os.android = true, os.version = android[2];
                if (iphone && !ipod)
                    os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
                if (ipad)
                    os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
                if (ipod)
                    os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
                if (webos)
                    os.webos = true, os.version = webos[2];
                if (touchpad)
                    os.touchpad = true;
                if (blackberry)
                    os.blackberry = true, os.version = blackberry[2];
                if (bb10)
                    os.bb10 = true, os.version = bb10[2];
                if (rimtabletos)
                    os.rimtabletos = true, os.version = rimtabletos[2];
                if (playbook)
                    browser.playbook = true;
                if (kindle)
                    os.kindle = true, os.version = kindle[1];
                if (silk)
                    browser.silk = true, browser.version = silk[1];
                if (!silk && os.android && ua.match(/Kindle Fire/))
                    browser.silk = true;
                if (chrome)
                    browser.chrome = true, browser.version = chrome[1];
                if (firefox)
                    browser.firefox = true, browser.version = firefox[1];
                if (ie)
                    browser.ie = true, browser.version = ie[1];
                if (safari && (ua.match(/Safari/) || !!os.ios))
                    browser.safari = true;
                if (webview)
                    browser.webview = true;
                if (ie)
                    browser.ie = true, browser.version = ie[1];
                if (edge)
                    browser.edge = true, browser.version = edge[1];
                os.tablet = !!(ipad || playbook || android && !ua.match(/Mobile/) || firefox && ua.match(/Tablet/) || ie && !ua.match(/Phone/) && ua.match(/Touch/));
                os.phone = !!(!os.tablet && !os.ipod && (android || iphone || webos || blackberry || bb10 || chrome && ua.match(/Android/) || chrome && ua.match(/CriOS\/([\d.]+)/) || firefox && ua.match(/Mobile/) || ie && ua.match(/Touch/)));
                return {
                    browser: browser,
                    os: os,
                    node: false,
                    canvasSupported: document.createElement('canvas').getContext ? true : false,
                    touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
                    pointerEventsSupported: 'onpointerdown' in window && (browser.edge || browser.ie && browser.version >= 10)
                };
            }
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var env = __webpack_require__(78);
            var eventTool = __webpack_require__(80);
            var util = __webpack_require__(3);
            var Draggable = __webpack_require__(81);
            var GestureMgr = __webpack_require__(82);
            var Eventful = __webpack_require__(32);
            var mouseHandlerNames = [
                'click',
                'dblclick',
                'mousewheel',
                'mouseout'
            ];
            !usePointerEvent() && mouseHandlerNames.push('mouseup', 'mousedown', 'mousemove');
            var touchHandlerNames = [
                'touchstart',
                'touchend',
                'touchmove'
            ];
            var pointerHandlerNames = [
                'pointerdown',
                'pointerup',
                'pointermove'
            ];
            var TOUCH_CLICK_DELAY = 300;
            var addEventListener = eventTool.addEventListener;
            var removeEventListener = eventTool.removeEventListener;
            var normalizeEvent = eventTool.normalizeEvent;
            function makeEventPacket(eveType, target, event) {
                return {
                    type: eveType,
                    event: event,
                    target: target,
                    cancelBubble: false,
                    offsetX: event.zrX,
                    offsetY: event.zrY,
                    gestureEvent: event.gestureEvent,
                    pinchX: event.pinchX,
                    pinchY: event.pinchY,
                    pinchScale: event.pinchScale,
                    wheelDelta: event.zrDelta
                };
            }
            var domHandlers = {
                mousemove: function (event) {
                    event = normalizeEvent(this.root, event);
                    var x = event.zrX;
                    var y = event.zrY;
                    var hovered = this.findHover(x, y, null);
                    var lastHovered = this._hovered;
                    this._hovered = hovered;
                    this.root.style.cursor = hovered ? hovered.cursor : this._defaultCursorStyle;
                    if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {
                        this._dispatchProxy(lastHovered, 'mouseout', event);
                    }
                    this._dispatchProxy(hovered, 'mousemove', event);
                    if (hovered && hovered !== lastHovered) {
                        this._dispatchProxy(hovered, 'mouseover', event);
                    }
                },
                mouseout: function (event) {
                    event = normalizeEvent(this.root, event);
                    var element = event.toElement || event.relatedTarget;
                    if (element != this.root) {
                        while (element && element.nodeType != 9) {
                            if (element === this.root) {
                                return;
                            }
                            element = element.parentNode;
                        }
                    }
                    this._dispatchProxy(this._hovered, 'mouseout', event);
                    this.trigger('globalout', { event: event });
                },
                touchstart: function (event) {
                    event = normalizeEvent(this.root, event);
                    this._lastTouchMoment = new Date();
                    processGesture(this, event, 'start');
                    domHandlers.mousemove.call(this, event);
                    domHandlers.mousedown.call(this, event);
                    setTouchTimer(this);
                },
                touchmove: function (event) {
                    event = normalizeEvent(this.root, event);
                    processGesture(this, event, 'change');
                    domHandlers.mousemove.call(this, event);
                    setTouchTimer(this);
                },
                touchend: function (event) {
                    event = normalizeEvent(this.root, event);
                    processGesture(this, event, 'end');
                    domHandlers.mouseup.call(this, event);
                    if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
                        domHandlers.click.call(this, event);
                    }
                    setTouchTimer(this);
                }
            };
            util.each([
                'click',
                'mousedown',
                'mouseup',
                'mousewheel',
                'dblclick'
            ], function (name) {
                domHandlers[name] = function (event) {
                    event = normalizeEvent(this.root, event);
                    var hovered = this.findHover(event.zrX, event.zrY, null);
                    this._dispatchProxy(hovered, name, event);
                };
            });
            function processGesture(zrHandler, event, stage) {
                var gestureMgr = zrHandler._gestureMgr;
                stage === 'start' && gestureMgr.clear();
                var gestureInfo = gestureMgr.recognize(event, zrHandler.findHover(event.zrX, event.zrY, null));
                stage === 'end' && gestureMgr.clear();
                if (gestureInfo) {
                    var type = gestureInfo.type;
                    event.gestureEvent = type;
                    zrHandler._dispatchProxy(gestureInfo.target, type, gestureInfo.event);
                }
            }
            function initDomHandler(instance) {
                var handlerNames = touchHandlerNames.concat(pointerHandlerNames);
                for (var i = 0; i < handlerNames.length; i++) {
                    var name = handlerNames[i];
                    instance._handlers[name] = util.bind(domHandlers[name], instance);
                }
                for (var i = 0; i < mouseHandlerNames.length; i++) {
                    var name = mouseHandlerNames[i];
                    instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
                }
                function makeMouseHandler(fn, instance) {
                    return function () {
                        if (instance._touching) {
                            return;
                        }
                        return fn.apply(instance, arguments);
                    };
                }
            }
            var Handler = function (root, storage, painter) {
                Eventful.call(this);
                this.root = root;
                this.storage = storage;
                this.painter = painter;
                this._hovered;
                this._lastTouchMoment;
                this._lastX;
                this._lastY;
                this._defaultCursorStyle = 'default';
                this._gestureMgr = new GestureMgr();
                this._handlers = [];
                this._touching = false;
                this._touchTimer;
                initDomHandler(this);
                if (usePointerEvent()) {
                    mountHandlers(pointerHandlerNames, this);
                } else if (useTouchEvent()) {
                    mountHandlers(touchHandlerNames, this);
                }
                mountHandlers(mouseHandlerNames, this);
                Draggable.call(this);
                function mountHandlers(handlerNames, instance) {
                    util.each(handlerNames, function (name) {
                        addEventListener(root, eventNameFix(name), instance._handlers[name]);
                    }, instance);
                }
            };
            Handler.prototype = {
                constructor: Handler,
                resize: function (event) {
                    this._hovered = null;
                },
                dispatch: function (eventName, eventArgs) {
                    var handler = this._handlers[eventName];
                    handler && handler.call(this, eventArgs);
                },
                dispose: function () {
                    var root = this.root;
                    var handlerNames = mouseHandlerNames.concat(touchHandlerNames);
                    for (var i = 0; i < handlerNames.length; i++) {
                        var name = handlerNames[i];
                        removeEventListener(root, eventNameFix(name), this._handlers[name]);
                    }
                    this.root = this.storage = this.painter = null;
                },
                setDefaultCursorStyle: function (cursorStyle) {
                    this._defaultCursorStyle = cursorStyle;
                },
                _dispatchProxy: function (targetEl, eventName, event) {
                    var eventHandler = 'on' + eventName;
                    var eventPacket = makeEventPacket(eventName, targetEl, event);
                    var el = targetEl;
                    while (el) {
                        el[eventHandler] && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));
                        el.trigger(eventName, eventPacket);
                        el = el.parent;
                        if (eventPacket.cancelBubble) {
                            break;
                        }
                    }
                    if (!eventPacket.cancelBubble) {
                        this.trigger(eventName, eventPacket);
                        this.painter && this.painter.eachOtherLayer(function (layer) {
                            if (typeof layer[eventHandler] == 'function') {
                                layer[eventHandler].call(layer, eventPacket);
                            }
                            if (layer.trigger) {
                                layer.trigger(eventName, eventPacket);
                            }
                        });
                    }
                },
                findHover: function (x, y, exclude) {
                    var list = this.storage.getDisplayList();
                    for (var i = list.length - 1; i >= 0; i--) {
                        if (!list[i].silent && list[i] !== exclude && !list[i].ignore && isHover(list[i], x, y)) {
                            return list[i];
                        }
                    }
                }
            };
            function isHover(displayable, x, y) {
                if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
                    var el = displayable;
                    while (el) {
                        if (el.silent || el.clipPath && !el.clipPath.contain(x, y)) {
                            return false;
                        }
                        el = el.parent;
                    }
                    return true;
                }
                return false;
            }
            function setTouchTimer(instance) {
                instance._touching = true;
                clearTimeout(instance._touchTimer);
                instance._touchTimer = setTimeout(function () {
                    instance._touching = false;
                }, 700);
            }
            function usePointerEvent() {
                return false;
            }
            function useTouchEvent() {
                return env.touchEventsSupported;
            }
            function eventNameFix(name) {
                return name === 'mousewheel' && env.browser.firefox ? 'DOMMouseScroll' : name;
            }
            util.mixin(Handler, Eventful);
            util.mixin(Handler, Draggable);
            module.exports = Handler;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var Eventful = __webpack_require__(32);
            var isDomLevel2 = typeof window !== 'undefined' && !!window.addEventListener;
            function getBoundingClientRect(el) {
                return el.getBoundingClientRect ? el.getBoundingClientRect() : {
                    left: 0,
                    top: 0
                };
            }
            function normalizeEvent(el, e) {
                e = e || window.event;
                if (e.zrX != null) {
                    return e;
                }
                var eventType = e.type;
                var isTouch = eventType && eventType.indexOf('touch') >= 0;
                if (!isTouch) {
                    var box = getBoundingClientRect(el);
                    e.zrX = e.clientX - box.left;
                    e.zrY = e.clientY - box.top;
                    e.zrDelta = e.wheelDelta ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
                } else {
                    var touch = eventType != 'touchend' ? e.targetTouches[0] : e.changedTouches[0];
                    if (touch) {
                        var rBounding = getBoundingClientRect(el);
                        e.zrX = touch.clientX - rBounding.left;
                        e.zrY = touch.clientY - rBounding.top;
                    }
                }
                return e;
            }
            function addEventListener(el, name, handler) {
                if (isDomLevel2) {
                    el.addEventListener(name, handler);
                } else {
                    el.attachEvent('on' + name, handler);
                }
            }
            function removeEventListener(el, name, handler) {
                if (isDomLevel2) {
                    el.removeEventListener(name, handler);
                } else {
                    el.detachEvent('on' + name, handler);
                }
            }
            var stop = isDomLevel2 ? function (e) {
                e.preventDefault();
                e.stopPropagation();
                e.cancelBubble = true;
            } : function (e) {
                e.returnValue = false;
                e.cancelBubble = true;
            };
            module.exports = {
                normalizeEvent: normalizeEvent,
                addEventListener: addEventListener,
                removeEventListener: removeEventListener,
                stop: stop,
                Dispatcher: Eventful
            };
        },
        function (module, exports) {
            function Draggable() {
                this.on('mousedown', this._dragStart, this);
                this.on('mousemove', this._drag, this);
                this.on('mouseup', this._dragEnd, this);
                this.on('globalout', this._dragEnd, this);
            }
            Draggable.prototype = {
                constructor: Draggable,
                _dragStart: function (e) {
                    var draggingTarget = e.target;
                    if (draggingTarget && draggingTarget.draggable) {
                        this._draggingTarget = draggingTarget;
                        draggingTarget.dragging = true;
                        this._x = e.offsetX;
                        this._y = e.offsetY;
                        this._dispatchProxy(draggingTarget, 'dragstart', e.event);
                    }
                },
                _drag: function (e) {
                    var draggingTarget = this._draggingTarget;
                    if (draggingTarget) {
                        var x = e.offsetX;
                        var y = e.offsetY;
                        var dx = x - this._x;
                        var dy = y - this._y;
                        this._x = x;
                        this._y = y;
                        draggingTarget.drift(dx, dy, e);
                        this._dispatchProxy(draggingTarget, 'drag', e.event);
                        var dropTarget = this.findHover(x, y, draggingTarget);
                        var lastDropTarget = this._dropTarget;
                        this._dropTarget = dropTarget;
                        if (draggingTarget !== dropTarget) {
                            if (lastDropTarget && dropTarget !== lastDropTarget) {
                                this._dispatchProxy(lastDropTarget, 'dragleave', e.event);
                            }
                            if (dropTarget && dropTarget !== lastDropTarget) {
                                this._dispatchProxy(dropTarget, 'dragenter', e.event);
                            }
                        }
                    }
                },
                _dragEnd: function (e) {
                    var draggingTarget = this._draggingTarget;
                    if (draggingTarget) {
                        draggingTarget.dragging = false;
                    }
                    this._dispatchProxy(draggingTarget, 'dragend', e.event);
                    if (this._dropTarget) {
                        this._dispatchProxy(this._dropTarget, 'drop', e.event);
                    }
                    this._draggingTarget = null;
                    this._dropTarget = null;
                }
            };
            module.exports = Draggable;
        },
        function (module, exports) {
            'use strict';
            var GestureMgr = function () {
                this._track = [];
            };
            GestureMgr.prototype = {
                constructor: GestureMgr,
                recognize: function (event, target) {
                    this._doTrack(event, target);
                    return this._recognize(event);
                },
                clear: function () {
                    this._track.length = 0;
                    return this;
                },
                _doTrack: function (event, target) {
                    var touches = event.touches;
                    if (!touches) {
                        return;
                    }
                    var trackItem = {
                        points: [],
                        touches: [],
                        target: target,
                        event: event
                    };
                    for (var i = 0, len = touches.length; i < len; i++) {
                        var touch = touches[i];
                        trackItem.points.push([
                            touch.clientX,
                            touch.clientY
                        ]);
                        trackItem.touches.push(touch);
                    }
                    this._track.push(trackItem);
                },
                _recognize: function (event) {
                    for (var eventName in recognizers) {
                        if (recognizers.hasOwnProperty(eventName)) {
                            var gestureInfo = recognizers[eventName](this._track, event);
                            if (gestureInfo) {
                                return gestureInfo;
                            }
                        }
                    }
                }
            };
            function dist(pointPair) {
                var dx = pointPair[1][0] - pointPair[0][0];
                var dy = pointPair[1][1] - pointPair[0][1];
                return Math.sqrt(dx * dx + dy * dy);
            }
            function center(pointPair) {
                return [
                    (pointPair[0][0] + pointPair[1][0]) / 2,
                    (pointPair[0][1] + pointPair[1][1]) / 2
                ];
            }
            var recognizers = {
                pinch: function (track, event) {
                    var trackLen = track.length;
                    if (!trackLen) {
                        return;
                    }
                    var pinchEnd = (track[trackLen - 1] || {}).points;
                    var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;
                    if (pinchPre && pinchPre.length > 1 && pinchEnd && pinchEnd.length > 1) {
                        var pinchScale = dist(pinchEnd) / dist(pinchPre);
                        !isFinite(pinchScale) && (pinchScale = 1);
                        event.pinchScale = pinchScale;
                        var pinchCenter = center(pinchEnd);
                        event.pinchX = pinchCenter[0];
                        event.pinchY = pinchCenter[1];
                        return {
                            type: 'pinch',
                            target: track[0].target,
                            event: event
                        };
                    }
                }
            };
            module.exports = GestureMgr;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var util = __webpack_require__(3);
            var Group = __webpack_require__(29);
            function shapeCompareFunc(a, b) {
                if (a.zlevel === b.zlevel) {
                    if (a.z === b.z) {
                        if (a.z2 === b.z2) {
                            return a.__renderidx - b.__renderidx;
                        }
                        return a.z2 - b.z2;
                    }
                    return a.z - b.z;
                }
                return a.zlevel - b.zlevel;
            }
            var Storage = function () {
                this._elements = {};
                this._roots = [];
                this._displayList = [];
                this._displayListLen = 0;
            };
            Storage.prototype = {
                constructor: Storage,
                getDisplayList: function (update, includeIgnore) {
                    includeIgnore = includeIgnore || false;
                    if (update) {
                        this.updateDisplayList(includeIgnore);
                    }
                    return this._displayList;
                },
                updateDisplayList: function (includeIgnore) {
                    this._displayListLen = 0;
                    var roots = this._roots;
                    var displayList = this._displayList;
                    for (var i = 0, len = roots.length; i < len; i++) {
                        this._updateAndAddDisplayable(roots[i], null, includeIgnore);
                    }
                    displayList.length = this._displayListLen;
                    for (var i = 0, len = displayList.length; i < len; i++) {
                        displayList[i].__renderidx = i;
                    }
                    displayList.sort(shapeCompareFunc);
                },
                _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {
                    if (el.ignore && !includeIgnore) {
                        return;
                    }
                    el.beforeUpdate();
                    el.update();
                    el.afterUpdate();
                    var clipPath = el.clipPath;
                    if (clipPath) {
                        clipPath.parent = el;
                        clipPath.updateTransform();
                        if (clipPaths) {
                            clipPaths = clipPaths.slice();
                            clipPaths.push(clipPath);
                        } else {
                            clipPaths = [clipPath];
                        }
                    }
                    if (el.type == 'group') {
                        var children = el._children;
                        for (var i = 0; i < children.length; i++) {
                            var child = children[i];
                            child.__dirty = el.__dirty || child.__dirty;
                            this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
                        }
                        el.__dirty = false;
                    } else {
                        el.__clipPaths = clipPaths;
                        this._displayList[this._displayListLen++] = el;
                    }
                },
                addRoot: function (el) {
                    if (this._elements[el.id]) {
                        return;
                    }
                    if (el instanceof Group) {
                        el.addChildrenToStorage(this);
                    }
                    this.addToMap(el);
                    this._roots.push(el);
                },
                delRoot: function (elId) {
                    if (elId == null) {
                        for (var i = 0; i < this._roots.length; i++) {
                            var root = this._roots[i];
                            if (root instanceof Group) {
                                root.delChildrenFromStorage(this);
                            }
                        }
                        this._elements = {};
                        this._roots = [];
                        this._displayList = [];
                        this._displayListLen = 0;
                        return;
                    }
                    if (elId instanceof Array) {
                        for (var i = 0, l = elId.length; i < l; i++) {
                            this.delRoot(elId[i]);
                        }
                        return;
                    }
                    var el;
                    if (typeof elId == 'string') {
                        el = this._elements[elId];
                    } else {
                        el = elId;
                    }
                    var idx = util.indexOf(this._roots, el);
                    if (idx >= 0) {
                        this.delFromMap(el.id);
                        this._roots.splice(idx, 1);
                        if (el instanceof Group) {
                            el.delChildrenFromStorage(this);
                        }
                    }
                },
                addToMap: function (el) {
                    if (el instanceof Group) {
                        el.__storage = this;
                    }
                    el.dirty();
                    this._elements[el.id] = el;
                    return this;
                },
                get: function (elId) {
                    return this._elements[elId];
                },
                delFromMap: function (elId) {
                    var elements = this._elements;
                    var el = elements[elId];
                    if (el) {
                        delete elements[elId];
                        if (el instanceof Group) {
                            el.__storage = null;
                        }
                    }
                    return this;
                },
                dispose: function () {
                    this._elements = this._renderList = this._roots = null;
                }
            };
            module.exports = Storage;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var util = __webpack_require__(3);
            var Dispatcher = __webpack_require__(80).Dispatcher;
            var requestAnimationFrame = typeof window !== 'undefined' && (window.requestAnimationFrame || window.msRequestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (func) {
                setTimeout(func, 16);
            };
            var Animator = __webpack_require__(35);
            var Animation = function (options) {
                options = options || {};
                this.stage = options.stage || {};
                this.onframe = options.onframe || function () {
                };
                this._clips = [];
                this._running = false;
                this._time = 0;
                Dispatcher.call(this);
            };
            Animation.prototype = {
                constructor: Animation,
                addClip: function (clip) {
                    this._clips.push(clip);
                },
                addAnimator: function (animator) {
                    animator.animation = this;
                    var clips = animator.getClips();
                    for (var i = 0; i < clips.length; i++) {
                        this.addClip(clips[i]);
                    }
                },
                removeClip: function (clip) {
                    var idx = util.indexOf(this._clips, clip);
                    if (idx >= 0) {
                        this._clips.splice(idx, 1);
                    }
                },
                removeAnimator: function (animator) {
                    var clips = animator.getClips();
                    for (var i = 0; i < clips.length; i++) {
                        this.removeClip(clips[i]);
                    }
                    animator.animation = null;
                },
                _update: function () {
                    var time = new Date().getTime();
                    var delta = time - this._time;
                    var clips = this._clips;
                    var len = clips.length;
                    var deferredEvents = [];
                    var deferredClips = [];
                    for (var i = 0; i < len; i++) {
                        var clip = clips[i];
                        var e = clip.step(time);
                        if (e) {
                            deferredEvents.push(e);
                            deferredClips.push(clip);
                        }
                    }
                    for (var i = 0; i < len;) {
                        if (clips[i]._needsRemove) {
                            clips[i] = clips[len - 1];
                            clips.pop();
                            len--;
                        } else {
                            i++;
                        }
                    }
                    len = deferredEvents.length;
                    for (var i = 0; i < len; i++) {
                        deferredClips[i].fire(deferredEvents[i]);
                    }
                    this._time = time;
                    this.onframe(delta);
                    this.trigger('frame', delta);
                    if (this.stage.update) {
                        this.stage.update();
                    }
                },
                start: function () {
                    var self = this;
                    this._running = true;
                    function step() {
                        if (self._running) {
                            requestAnimationFrame(step);
                            self._update();
                        }
                    }
                    this._time = new Date().getTime();
                    requestAnimationFrame(step);
                },
                stop: function () {
                    this._running = false;
                },
                clear: function () {
                    this._clips = [];
                },
                animate: function (target, options) {
                    options = options || {};
                    var animator = new Animator(target, options.loop, options.getter, options.setter);
                    return animator;
                }
            };
            util.mixin(Animation, Dispatcher);
            module.exports = Animation;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var config = __webpack_require__(40);
            var util = __webpack_require__(3);
            var log = __webpack_require__(39);
            var BoundingRect = __webpack_require__(15);
            var Layer = __webpack_require__(86);
            function parseInt10(val) {
                return parseInt(val, 10);
            }
            function isLayerValid(layer) {
                if (!layer) {
                    return false;
                }
                if (layer.isBuildin) {
                    return true;
                }
                if (typeof layer.resize !== 'function' || typeof layer.refresh !== 'function') {
                    return false;
                }
                return true;
            }
            function preProcessLayer(layer) {
                layer.__unusedCount++;
            }
            function postProcessLayer(layer) {
                layer.__dirty = false;
                if (layer.__unusedCount == 1) {
                    layer.clear();
                }
            }
            var tmpRect = new BoundingRect(0, 0, 0, 0);
            var viewRect = new BoundingRect(0, 0, 0, 0);
            function isDisplayableCulled(el, width, height) {
                tmpRect.copy(el.getBoundingRect());
                if (el.transform) {
                    tmpRect.applyTransform(el.transform);
                }
                viewRect.width = width;
                viewRect.height = height;
                return !tmpRect.intersect(viewRect);
            }
            function isClipPathChanged(clipPaths, prevClipPaths) {
                if (!clipPaths || !prevClipPaths || clipPaths.length !== prevClipPaths.length) {
                    return true;
                }
                for (var i = 0; i < clipPaths.length; i++) {
                    if (clipPaths[i] !== prevClipPaths[i]) {
                        return true;
                    }
                }
            }
            function doClip(clipPaths, ctx) {
                for (var i = 0; i < clipPaths.length; i++) {
                    var clipPath = clipPaths[i];
                    var m;
                    if (clipPath.transform) {
                        m = clipPath.transform;
                        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                    }
                    var path = clipPath.path;
                    path.beginPath(ctx);
                    clipPath.buildPath(path, clipPath.shape);
                    ctx.clip();
                    if (clipPath.transform) {
                        m = clipPath.invTransform;
                        ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                    }
                }
            }
            var Painter = function (root, storage, opts) {
                var singleCanvas = !root.nodeName || root.nodeName.toUpperCase() === 'CANVAS';
                opts = opts || {};
                this.dpr = opts.devicePixelRatio || config.devicePixelRatio;
                this._singleCanvas = singleCanvas;
                this.root = root;
                var rootStyle = root.style;
                if (rootStyle) {
                    rootStyle['-webkit-tap-highlight-color'] = 'transparent';
                    rootStyle['-webkit-user-select'] = 'none';
                    rootStyle['user-select'] = 'none';
                    rootStyle['-webkit-touch-callout'] = 'none';
                    root.innerHTML = '';
                }
                this.storage = storage;
                if (!singleCanvas) {
                    var width = this._getWidth();
                    var height = this._getHeight();
                    this._width = width;
                    this._height = height;
                    var domRoot = document.createElement('div');
                    this._domRoot = domRoot;
                    var domRootStyle = domRoot.style;
                    domRootStyle.position = 'relative';
                    domRootStyle.overflow = 'hidden';
                    domRootStyle.width = this._width + 'px';
                    domRootStyle.height = this._height + 'px';
                    root.appendChild(domRoot);
                    this._layers = {};
                    this._zlevelList = [];
                } else {
                    var width = root.width;
                    var height = root.height;
                    this._width = width;
                    this._height = height;
                    var mainLayer = new Layer(root, this, 1);
                    mainLayer.initContext();
                    this._layers = { 0: mainLayer };
                    this._zlevelList = [0];
                }
                this._layerConfig = {};
                this.pathToImage = this._createPathToImage();
            };
            Painter.prototype = {
                constructor: Painter,
                isSingleCanvas: function () {
                    return this._singleCanvas;
                },
                getViewportRoot: function () {
                    return this._singleCanvas ? this._layers[0].dom : this._domRoot;
                },
                refresh: function (paintAll) {
                    var list = this.storage.getDisplayList(true);
                    var zlevelList = this._zlevelList;
                    this._paintList(list, paintAll);
                    for (var i = 0; i < zlevelList.length; i++) {
                        var z = zlevelList[i];
                        var layer = this._layers[z];
                        if (!layer.isBuildin && layer.refresh) {
                            layer.refresh();
                        }
                    }
                    return this;
                },
                _paintList: function (list, paintAll) {
                    if (paintAll == null) {
                        paintAll = false;
                    }
                    this._updateLayerStatus(list);
                    var currentLayer;
                    var currentZLevel;
                    var ctx;
                    var viewWidth = this._width;
                    var viewHeight = this._height;
                    this.eachBuildinLayer(preProcessLayer);
                    var prevElClipPaths = null;
                    for (var i = 0, l = list.length; i < l; i++) {
                        var el = list[i];
                        var elZLevel = this._singleCanvas ? 0 : el.zlevel;
                        if (currentZLevel !== elZLevel) {
                            currentZLevel = elZLevel;
                            currentLayer = this.getLayer(currentZLevel);
                            if (!currentLayer.isBuildin) {
                                log('ZLevel ' + currentZLevel + ' has been used by unkown layer ' + currentLayer.id);
                            }
                            ctx = currentLayer.ctx;
                            currentLayer.__unusedCount = 0;
                            if (currentLayer.__dirty || paintAll) {
                                currentLayer.clear();
                            }
                        }
                        if ((currentLayer.__dirty || paintAll) && !el.invisible && el.style.opacity !== 0 && el.scale[0] && el.scale[1] && !(el.culling && isDisplayableCulled(el, viewWidth, viewHeight))) {
                            var clipPaths = el.__clipPaths;
                            if (isClipPathChanged(clipPaths, prevElClipPaths)) {
                                if (prevElClipPaths) {
                                    ctx.restore();
                                }
                                if (clipPaths) {
                                    ctx.save();
                                    doClip(clipPaths, ctx);
                                }
                                prevElClipPaths = clipPaths;
                            }
                            el.beforeBrush && el.beforeBrush(ctx);
                            el.brush(ctx, false);
                            el.afterBrush && el.afterBrush(ctx);
                        }
                        el.__dirty = false;
                    }
                    if (prevElClipPaths) {
                        ctx.restore();
                    }
                    this.eachBuildinLayer(postProcessLayer);
                },
                getLayer: function (zlevel) {
                    if (this._singleCanvas) {
                        return this._layers[0];
                    }
                    var layer = this._layers[zlevel];
                    if (!layer) {
                        layer = new Layer('zr_' + zlevel, this, this.dpr);
                        layer.isBuildin = true;
                        if (this._layerConfig[zlevel]) {
                            util.merge(layer, this._layerConfig[zlevel], true);
                        }
                        this.insertLayer(zlevel, layer);
                        layer.initContext();
                    }
                    return layer;
                },
                insertLayer: function (zlevel, layer) {
                    var layersMap = this._layers;
                    var zlevelList = this._zlevelList;
                    var len = zlevelList.length;
                    var prevLayer = null;
                    var i = -1;
                    var domRoot = this._domRoot;
                    if (layersMap[zlevel]) {
                        log('ZLevel ' + zlevel + ' has been used already');
                        return;
                    }
                    if (!isLayerValid(layer)) {
                        log('Layer of zlevel ' + zlevel + ' is not valid');
                        return;
                    }
                    if (len > 0 && zlevel > zlevelList[0]) {
                        for (i = 0; i < len - 1; i++) {
                            if (zlevelList[i] < zlevel && zlevelList[i + 1] > zlevel) {
                                break;
                            }
                        }
                        prevLayer = layersMap[zlevelList[i]];
                    }
                    zlevelList.splice(i + 1, 0, zlevel);
                    if (prevLayer) {
                        var prevDom = prevLayer.dom;
                        if (prevDom.nextSibling) {
                            domRoot.insertBefore(layer.dom, prevDom.nextSibling);
                        } else {
                            domRoot.appendChild(layer.dom);
                        }
                    } else {
                        if (domRoot.firstChild) {
                            domRoot.insertBefore(layer.dom, domRoot.firstChild);
                        } else {
                            domRoot.appendChild(layer.dom);
                        }
                    }
                    layersMap[zlevel] = layer;
                },
                eachLayer: function (cb, context) {
                    var zlevelList = this._zlevelList;
                    var z;
                    var i;
                    for (i = 0; i < zlevelList.length; i++) {
                        z = zlevelList[i];
                        cb.call(context, this._layers[z], z);
                    }
                },
                eachBuildinLayer: function (cb, context) {
                    var zlevelList = this._zlevelList;
                    var layer;
                    var z;
                    var i;
                    for (i = 0; i < zlevelList.length; i++) {
                        z = zlevelList[i];
                        layer = this._layers[z];
                        if (layer.isBuildin) {
                            cb.call(context, layer, z);
                        }
                    }
                },
                eachOtherLayer: function (cb, context) {
                    var zlevelList = this._zlevelList;
                    var layer;
                    var z;
                    var i;
                    for (i = 0; i < zlevelList.length; i++) {
                        z = zlevelList[i];
                        layer = this._layers[z];
                        if (!layer.isBuildin) {
                            cb.call(context, layer, z);
                        }
                    }
                },
                getLayers: function () {
                    return this._layers;
                },
                _updateLayerStatus: function (list) {
                    var layers = this._layers;
                    var elCounts = {};
                    this.eachBuildinLayer(function (layer, z) {
                        elCounts[z] = layer.elCount;
                        layer.elCount = 0;
                    });
                    for (var i = 0, l = list.length; i < l; i++) {
                        var el = list[i];
                        var zlevel = this._singleCanvas ? 0 : el.zlevel;
                        var layer = layers[zlevel];
                        if (layer) {
                            layer.elCount++;
                            if (layer.__dirty) {
                                continue;
                            }
                            layer.__dirty = el.__dirty;
                        }
                    }
                    this.eachBuildinLayer(function (layer, z) {
                        if (elCounts[z] !== layer.elCount) {
                            layer.__dirty = true;
                        }
                    });
                },
                clear: function () {
                    this.eachBuildinLayer(this._clearLayer);
                    return this;
                },
                _clearLayer: function (layer) {
                    layer.clear();
                },
                configLayer: function (zlevel, config) {
                    if (config) {
                        var layerConfig = this._layerConfig;
                        if (!layerConfig[zlevel]) {
                            layerConfig[zlevel] = config;
                        } else {
                            util.merge(layerConfig[zlevel], config, true);
                        }
                        var layer = this._layers[zlevel];
                        if (layer) {
                            util.merge(layer, layerConfig[zlevel], true);
                        }
                    }
                },
                delLayer: function (zlevel) {
                    var layers = this._layers;
                    var zlevelList = this._zlevelList;
                    var layer = layers[zlevel];
                    if (!layer) {
                        return;
                    }
                    layer.dom.parentNode.removeChild(layer.dom);
                    delete layers[zlevel];
                    zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
                },
                resize: function (width, height) {
                    var domRoot = this._domRoot;
                    domRoot.style.display = 'none';
                    width = width || this._getWidth();
                    height = height || this._getHeight();
                    domRoot.style.display = '';
                    if (this._width != width || height != this._height) {
                        domRoot.style.width = width + 'px';
                        domRoot.style.height = height + 'px';
                        for (var id in this._layers) {
                            this._layers[id].resize(width, height);
                        }
                        this.refresh(true);
                    }
                    this._width = width;
                    this._height = height;
                    return this;
                },
                clearLayer: function (zlevel) {
                    var layer = this._layers[zlevel];
                    if (layer) {
                        layer.clear();
                    }
                },
                dispose: function () {
                    this.root.innerHTML = '';
                    this.root = this.storage = this._domRoot = this._layers = null;
                },
                getRenderedCanvas: function (opts) {
                    opts = opts || {};
                    if (this._singleCanvas) {
                        return this._layers[0].dom;
                    }
                    var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
                    imageLayer.initContext();
                    var ctx = imageLayer.ctx;
                    imageLayer.clearColor = opts.backgroundColor;
                    imageLayer.clear();
                    var displayList = this.storage.getDisplayList(true);
                    for (var i = 0; i < displayList.length; i++) {
                        var el = displayList[i];
                        if (!el.invisible) {
                            el.beforeBrush && el.beforeBrush(ctx);
                            el.brush(ctx, false);
                            el.afterBrush && el.afterBrush(ctx);
                        }
                    }
                    return imageLayer.dom;
                },
                getWidth: function () {
                    return this._width;
                },
                getHeight: function () {
                    return this._height;
                },
                _getWidth: function () {
                    var root = this.root;
                    var stl = document.defaultView.getComputedStyle(root);
                    return (root.clientWidth || parseInt10(stl.width) || parseInt10(root.style.width)) - (parseInt10(stl.paddingLeft) || 0) - (parseInt10(stl.paddingRight) || 0) | 0;
                },
                _getHeight: function () {
                    var root = this.root;
                    var stl = document.defaultView.getComputedStyle(root);
                    return (root.clientHeight || parseInt10(stl.height) || parseInt10(root.style.height)) - (parseInt10(stl.paddingTop) || 0) - (parseInt10(stl.paddingBottom) || 0) | 0;
                },
                _pathToImage: function (id, path, width, height, dpr) {
                    var canvas = document.createElement('canvas');
                    var ctx = canvas.getContext('2d');
                    canvas.width = width * dpr;
                    canvas.height = height * dpr;
                    ctx.clearRect(0, 0, width * dpr, height * dpr);
                    var pathTransform = {
                        position: path.position,
                        rotation: path.rotation,
                        scale: path.scale
                    };
                    path.position = [
                        0,
                        0,
                        0
                    ];
                    path.rotation = 0;
                    path.scale = [
                        1,
                        1
                    ];
                    if (path) {
                        path.brush(ctx);
                    }
                    var ImageShape = __webpack_require__(59);
                    var imgShape = new ImageShape({
                        id: id,
                        style: {
                            x: 0,
                            y: 0,
                            image: canvas
                        }
                    });
                    if (pathTransform.position != null) {
                        imgShape.position = path.position = pathTransform.position;
                    }
                    if (pathTransform.rotation != null) {
                        imgShape.rotation = path.rotation = pathTransform.rotation;
                    }
                    if (pathTransform.scale != null) {
                        imgShape.scale = path.scale = pathTransform.scale;
                    }
                    return imgShape;
                },
                _createPathToImage: function () {
                    var me = this;
                    return function (id, e, width, height) {
                        return me._pathToImage(id, e, width, height, me.dpr);
                    };
                }
            };
            module.exports = Painter;
        },
        function (module, exports, __webpack_require__) {
            var util = __webpack_require__(3);
            var config = __webpack_require__(40);
            function returnFalse() {
                return false;
            }
            function createDom(id, type, painter, dpr) {
                var newDom = document.createElement(type);
                var width = painter.getWidth();
                var height = painter.getHeight();
                var newDomStyle = newDom.style;
                newDomStyle.position = 'absolute';
                newDomStyle.left = 0;
                newDomStyle.top = 0;
                newDomStyle.width = width + 'px';
                newDomStyle.height = height + 'px';
                newDom.width = width * dpr;
                newDom.height = height * dpr;
                newDom.setAttribute('data-zr-dom-id', id);
                return newDom;
            }
            var Layer = function (id, painter, dpr) {
                var dom;
                dpr = dpr || config.devicePixelRatio;
                if (typeof id === 'string') {
                    dom = createDom(id, 'canvas', painter, dpr);
                } else if (util.isObject(id)) {
                    dom = id;
                    id = dom.id;
                }
                this.id = id;
                this.dom = dom;
                var domStyle = dom.style;
                if (domStyle) {
                    dom.onselectstart = returnFalse;
                    domStyle['-webkit-user-select'] = 'none';
                    domStyle['user-select'] = 'none';
                    domStyle['-webkit-touch-callout'] = 'none';
                    domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
                }
                this.domBack = null;
                this.ctxBack = null;
                this.painter = painter;
                this.config = null;
                this.clearColor = 0;
                this.motionBlur = false;
                this.lastFrameAlpha = 0.7;
                this.dpr = dpr;
            };
            Layer.prototype = {
                constructor: Layer,
                elCount: 0,
                __dirty: true,
                initContext: function () {
                    this.ctx = this.dom.getContext('2d');
                    var dpr = this.dpr;
                    if (dpr != 1) {
                        this.ctx.scale(dpr, dpr);
                    }
                },
                createBackBuffer: function () {
                    var dpr = this.dpr;
                    this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);
                    this.ctxBack = this.domBack.getContext('2d');
                    if (dpr != 1) {
                        this.ctxBack.scale(dpr, dpr);
                    }
                },
                resize: function (width, height) {
                    var dpr = this.dpr;
                    var dom = this.dom;
                    var domStyle = dom.style;
                    var domBack = this.domBack;
                    domStyle.width = width + 'px';
                    domStyle.height = height + 'px';
                    dom.width = width * dpr;
                    dom.height = height * dpr;
                    if (dpr != 1) {
                        this.ctx.scale(dpr, dpr);
                    }
                    if (domBack) {
                        domBack.width = width * dpr;
                        domBack.height = height * dpr;
                        if (dpr != 1) {
                            this.ctxBack.scale(dpr, dpr);
                        }
                    }
                },
                clear: function (clearAll) {
                    var dom = this.dom;
                    var ctx = this.ctx;
                    var width = dom.width;
                    var height = dom.height;
                    var haveClearColor = this.clearColor;
                    var haveMotionBLur = this.motionBlur && !clearAll;
                    var lastFrameAlpha = this.lastFrameAlpha;
                    var dpr = this.dpr;
                    if (haveMotionBLur) {
                        if (!this.domBack) {
                            this.createBackBuffer();
                        }
                        this.ctxBack.globalCompositeOperation = 'copy';
                        this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr);
                    }
                    ctx.clearRect(0, 0, width / dpr, height / dpr);
                    if (haveClearColor) {
                        ctx.save();
                        ctx.fillStyle = this.clearColor;
                        ctx.fillRect(0, 0, width / dpr, height / dpr);
                        ctx.restore();
                    }
                    if (haveMotionBLur) {
                        var domBack = this.domBack;
                        ctx.save();
                        ctx.globalAlpha = lastFrameAlpha;
                        ctx.drawImage(domBack, 0, 0, width / dpr, height / dpr);
                        ctx.restore();
                    }
                }
            };
            module.exports = Layer;
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var zrUtil = __webpack_require__(3);
            var PI = Math.PI;
            module.exports = function (api, opts) {
                opts = opts || {};
                zrUtil.defaults(opts, {
                    text: 'loading',
                    color: '#c23531',
                    textColor: '#000',
                    maskColor: 'rgba(255, 255, 255, 0.8)',
                    zlevel: 0
                });
                var mask = new graphic.Rect({
                    style: { fill: opts.maskColor },
                    zlevel: opts.zlevel,
                    z: 10000
                });
                var arc = new graphic.Arc({
                    shape: {
                        startAngle: -PI / 2,
                        endAngle: -PI / 2 + 0.1,
                        r: 10
                    },
                    style: {
                        stroke: opts.color,
                        lineCap: 'round',
                        lineWidth: 5
                    },
                    zlevel: opts.zlevel,
                    z: 10001
                });
                var labelRect = new graphic.Rect({
                    style: {
                        fill: 'none',
                        text: opts.text,
                        textPosition: 'right',
                        textDistance: 10,
                        textFill: opts.textColor
                    },
                    zlevel: opts.zlevel,
                    z: 10001
                });
                arc.animateShape(true).when(1000, { endAngle: PI * 3 / 2 }).start('circularInOut');
                arc.animateShape(true).when(1000, { startAngle: PI * 3 / 2 }).delay(300).start('circularInOut');
                var group = new graphic.Group();
                group.add(arc);
                group.add(labelRect);
                group.add(mask);
                group.resize = function () {
                    var cx = api.getWidth() / 2;
                    var cy = api.getHeight() / 2;
                    arc.setShape({
                        cx: cx,
                        cy: cy
                    });
                    var r = arc.shape.r;
                    labelRect.setShape({
                        x: cx - r,
                        y: cy - r,
                        width: r * 2,
                        height: r * 2
                    });
                    mask.setShape({
                        x: 0,
                        y: 0,
                        width: api.getWidth(),
                        height: api.getHeight()
                    });
                };
                group.resize();
                return group;
            };
        },
        function (module, exports, __webpack_require__) {
            var Gradient = __webpack_require__(4);
            module.exports = function (seriesType, styleType, ecModel) {
                function encodeColor(seriesModel) {
                    var colorAccessPath = [
                        styleType,
                        'normal',
                        'color'
                    ];
                    var colorList = ecModel.get('color');
                    var data = seriesModel.getData();
                    var color = seriesModel.get(colorAccessPath) || colorList[seriesModel.seriesIndex % colorList.length];
                    data.setVisual('color', color);
                    if (!ecModel.isSeriesFiltered(seriesModel)) {
                        if (typeof color === 'function' && !(color instanceof Gradient)) {
                            data.each(function (idx) {
                                data.setItemVisual(idx, 'color', color(seriesModel.getDataParams(idx)));
                            });
                        }
                        data.each(function (idx) {
                            var itemModel = data.getItemModel(idx);
                            var color = itemModel.get(colorAccessPath, true);
                            if (color != null) {
                                data.setItemVisual(idx, 'color', color);
                            }
                        });
                    }
                }
                seriesType ? ecModel.eachSeriesByType(seriesType, encodeColor) : ecModel.eachSeries(encodeColor);
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var compatStyle = __webpack_require__(90);
            function get(opt, path) {
                path = path.split(',');
                var obj = opt;
                for (var i = 0; i < path.length; i++) {
                    obj = obj && obj[path[i]];
                    if (obj == null) {
                        break;
                    }
                }
                return obj;
            }
            function set(opt, path, val, overwrite) {
                path = path.split(',');
                var obj = opt;
                var key;
                for (var i = 0; i < path.length - 1; i++) {
                    key = path[i];
                    if (obj[key] == null) {
                        obj[key] = {};
                    }
                    obj = obj[key];
                }
                if (overwrite || obj[path[i]] == null) {
                    obj[path[i]] = val;
                }
            }
            function compatLayoutProperties(option) {
                each(LAYOUT_PROPERTIES, function (prop) {
                    if (prop[0] in option && !(prop[1] in option)) {
                        option[prop[1]] = option[prop[0]];
                    }
                });
            }
            var LAYOUT_PROPERTIES = [
                [
                    'x',
                    'left'
                ],
                [
                    'y',
                    'top'
                ],
                [
                    'x2',
                    'right'
                ],
                [
                    'y2',
                    'bottom'
                ]
            ];
            var COMPATITABLE_COMPONENTS = [
                'grid',
                'geo',
                'parallel',
                'legend',
                'toolbox',
                'title',
                'visualMap',
                'dataZoom',
                'timeline'
            ];
            var COMPATITABLE_SERIES = [
                'bar',
                'boxplot',
                'candlestick',
                'chord',
                'effectScatter',
                'funnel',
                'gauge',
                'lines',
                'graph',
                'heatmap',
                'line',
                'map',
                'parallel',
                'pie',
                'radar',
                'sankey',
                'scatter',
                'treemap'
            ];
            var each = zrUtil.each;
            module.exports = function (option) {
                each(option.series, function (seriesOpt) {
                    if (!zrUtil.isObject(seriesOpt)) {
                        return;
                    }
                    var seriesType = seriesOpt.type;
                    compatStyle(seriesOpt);
                    if (seriesType === 'pie' || seriesType === 'gauge') {
                        if (seriesOpt.clockWise != null) {
                            seriesOpt.clockwise = seriesOpt.clockWise;
                        }
                    }
                    if (seriesType === 'gauge') {
                        var pointerColor = get(seriesOpt, 'pointer.color');
                        pointerColor != null && set(seriesOpt, 'itemStyle.normal.color', pointerColor);
                    }
                    for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {
                        if (COMPATITABLE_SERIES[i] === seriesOpt.type) {
                            compatLayoutProperties(seriesOpt);
                            break;
                        }
                    }
                });
                if (option.dataRange) {
                    option.visualMap = option.dataRange;
                }
                each(COMPATITABLE_COMPONENTS, function (componentName) {
                    var options = option[componentName];
                    if (options) {
                        if (!zrUtil.isArray(options)) {
                            options = [options];
                        }
                        each(options, function (option) {
                            compatLayoutProperties(option);
                        });
                    }
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var POSSIBLE_STYLES = [
                'areaStyle',
                'lineStyle',
                'nodeStyle',
                'linkStyle',
                'chordStyle',
                'label',
                'labelLine'
            ];
            function compatItemStyle(opt) {
                var itemStyleOpt = opt && opt.itemStyle;
                if (itemStyleOpt) {
                    zrUtil.each(POSSIBLE_STYLES, function (styleName) {
                        var normalItemStyleOpt = itemStyleOpt.normal;
                        var emphasisItemStyleOpt = itemStyleOpt.emphasis;
                        if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
                            opt[styleName] = opt[styleName] || {};
                            if (!opt[styleName].normal) {
                                opt[styleName].normal = normalItemStyleOpt[styleName];
                            } else {
                                zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
                            }
                            normalItemStyleOpt[styleName] = null;
                        }
                        if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
                            opt[styleName] = opt[styleName] || {};
                            if (!opt[styleName].emphasis) {
                                opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
                            } else {
                                zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
                            }
                            emphasisItemStyleOpt[styleName] = null;
                        }
                    });
                }
            }
            module.exports = function (seriesOpt) {
                if (!seriesOpt) {
                    return;
                }
                compatItemStyle(seriesOpt);
                compatItemStyle(seriesOpt.markPoint);
                compatItemStyle(seriesOpt.markLine);
                var data = seriesOpt.data;
                if (data) {
                    for (var i = 0; i < data.length; i++) {
                        compatItemStyle(data[i]);
                    }
                    var markPoint = seriesOpt.markPoint;
                    if (markPoint && markPoint.data) {
                        var mpData = markPoint.data;
                        for (var i = 0; i < mpData.length; i++) {
                            compatItemStyle(mpData[i]);
                        }
                    }
                    var markLine = seriesOpt.markLine;
                    if (markLine && markLine.data) {
                        var mlData = markLine.data;
                        for (var i = 0; i < mlData.length; i++) {
                            if (zrUtil.isArray(mlData[i])) {
                                compatItemStyle(mlData[i][0]);
                                compatItemStyle(mlData[i][1]);
                            } else {
                                compatItemStyle(mlData[i]);
                            }
                        }
                    }
                }
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var echarts = __webpack_require__(1);
            __webpack_require__(92);
            __webpack_require__(97);
            echarts.registerVisualCoding('chart', zrUtil.curry(__webpack_require__(103), 'line', 'circle', 'line'));
            echarts.registerLayout(zrUtil.curry(__webpack_require__(104), 'line'));
            echarts.registerProcessor('statistic', zrUtil.curry(__webpack_require__(105), 'line'));
            __webpack_require__(106);
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var createListFromArray = __webpack_require__(93);
            var SeriesModel = __webpack_require__(27);
            module.exports = SeriesModel.extend({
                type: 'series.line',
                dependencies: [
                    'grid',
                    'polar'
                ],
                getInitialData: function (option, ecModel) {
                    return createListFromArray(option.data, this, ecModel);
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: 'cartesian2d',
                    legendHoverLink: true,
                    hoverAnimation: true,
                    xAxisIndex: 0,
                    yAxisIndex: 0,
                    polarIndex: 0,
                    clipOverflow: true,
                    label: { normal: { position: 'top' } },
                    lineStyle: {
                        normal: {
                            width: 2,
                            type: 'solid'
                        }
                    },
                    symbol: 'emptyCircle',
                    symbolSize: 4,
                    showSymbol: true,
                    animationEasing: 'linear'
                }
            });
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var List = __webpack_require__(94);
            var completeDimensions = __webpack_require__(96);
            var zrUtil = __webpack_require__(3);
            var modelUtil = __webpack_require__(5);
            var CoordinateSystem = __webpack_require__(25);
            var getDataItemValue = modelUtil.getDataItemValue;
            var converDataValue = modelUtil.converDataValue;
            function firstDataNotNull(data) {
                var i = 0;
                while (i < data.length && data[i] == null) {
                    i++;
                }
                return data[i];
            }
            function ifNeedCompleteOrdinalData(data) {
                var sampleItem = firstDataNotNull(data);
                return sampleItem != null && !zrUtil.isArray(getDataItemValue(sampleItem));
            }
            function createListFromArray(data, seriesModel, ecModel) {
                data = data || [];
                var coordSysName = seriesModel.get('coordinateSystem');
                var creator = creators[coordSysName];
                var registeredCoordSys = CoordinateSystem.get(coordSysName);
                var result = creator && creator(data, seriesModel, ecModel);
                var dimensions = result && result.dimensions;
                if (!dimensions) {
                    dimensions = registeredCoordSys && registeredCoordSys.dimensions || [
                        'x',
                        'y'
                    ];
                    dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));
                }
                var categoryAxisModel = result && result.categoryAxisModel;
                var categories;
                var categoryDimIndex = dimensions[0].type === 'ordinal' ? 0 : dimensions[1].type === 'ordinal' ? 1 : -1;
                var list = new List(dimensions, seriesModel);
                var nameList = createNameList(result, data);
                var dimValueGetter = categoryAxisModel && ifNeedCompleteOrdinalData(data) ? function (itemOpt, dimName, dataIndex, dimIndex) {
                    return dimIndex === categoryDimIndex ? dataIndex : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);
                } : function (itemOpt, dimName, dataIndex, dimIndex) {
                    var value = getDataItemValue(itemOpt);
                    var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);
                    if (categoryDimIndex === dimIndex) {
                        if (typeof val === 'string') {
                            categories = categories || categoryAxisModel.getCategories();
                            val = zrUtil.indexOf(categories, val);
                            if (val < 0 && !isNaN(val)) {
                                val = +val;
                            }
                        }
                    }
                    return val;
                };
                list.initData(data, nameList, dimValueGetter);
                return list;
            }
            function isStackable(axisType) {
                return axisType !== 'category' && axisType !== 'time';
            }
            function getDimTypeByAxis(axisType) {
                return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float';
            }
            var creators = {
                cartesian2d: function (data, seriesModel, ecModel) {
                    var xAxisModel = ecModel.getComponent('xAxis', seriesModel.get('xAxisIndex'));
                    var yAxisModel = ecModel.getComponent('yAxis', seriesModel.get('yAxisIndex'));
                    var xAxisType = xAxisModel.get('type');
                    var yAxisType = yAxisModel.get('type');
                    var dimensions = [
                        {
                            name: 'x',
                            type: getDimTypeByAxis(xAxisType),
                            stackable: isStackable(xAxisType)
                        },
                        {
                            name: 'y',
                            type: getDimTypeByAxis(yAxisType),
                            stackable: isStackable(yAxisType)
                        }
                    ];
                    var isXAxisCateogry = xAxisType === 'category';
                    completeDimensions(dimensions, data, [
                        'x',
                        'y',
                        'z'
                    ]);
                    return {
                        dimensions: dimensions,
                        categoryIndex: isXAxisCateogry ? 0 : 1,
                        categoryAxisModel: isXAxisCateogry ? xAxisModel : yAxisType === 'category' ? yAxisModel : null
                    };
                },
                polar: function (data, seriesModel, ecModel) {
                    var polarIndex = seriesModel.get('polarIndex') || 0;
                    var axisFinder = function (axisModel) {
                        return axisModel.get('polarIndex') === polarIndex;
                    };
                    var angleAxisModel = ecModel.findComponents({
                        mainType: 'angleAxis',
                        filter: axisFinder
                    })[0];
                    var radiusAxisModel = ecModel.findComponents({
                        mainType: 'radiusAxis',
                        filter: axisFinder
                    })[0];
                    var radiusAxisType = radiusAxisModel.get('type');
                    var angleAxisType = angleAxisModel.get('type');
                    var dimensions = [
                        {
                            name: 'radius',
                            type: getDimTypeByAxis(radiusAxisType),
                            stackable: isStackable(radiusAxisType)
                        },
                        {
                            name: 'angle',
                            type: getDimTypeByAxis(angleAxisType),
                            stackable: isStackable(angleAxisType)
                        }
                    ];
                    var isAngleAxisCateogry = angleAxisType === 'category';
                    completeDimensions(dimensions, data, [
                        'radius',
                        'angle',
                        'value'
                    ]);
                    return {
                        dimensions: dimensions,
                        categoryIndex: isAngleAxisCateogry ? 1 : 0,
                        categoryAxisModel: isAngleAxisCateogry ? angleAxisModel : radiusAxisType === 'category' ? radiusAxisModel : null
                    };
                },
                geo: function (data, seriesModel, ecModel) {
                    return {
                        dimensions: completeDimensions([
                            { name: 'lng' },
                            { name: 'lat' }
                        ], data, [
                            'lng',
                            'lat',
                            'value'
                        ])
                    };
                }
            };
            function createNameList(result, data) {
                var nameList = [];
                if (result && result.categoryAxisModel) {
                    var categories = result.categoryAxisModel.getCategories();
                    if (categories) {
                        var dataLen = data.length;
                        if (zrUtil.isArray(data[0]) && data[0].length > 1) {
                            nameList = [];
                            for (var i = 0; i < dataLen; i++) {
                                nameList[i] = categories[data[i][result.categoryIndex || 0]];
                            }
                        } else {
                            nameList = categories.slice(0);
                        }
                    }
                }
                return nameList;
            }
            module.exports = createListFromArray;
        },
        function (module, exports, __webpack_require__) {
            (function (global) {
                var UNDEFINED = 'undefined';
                var globalObj = typeof window === 'undefined' ? global : window;
                var Float64Array = typeof globalObj.Float64Array === UNDEFINED ? Array : globalObj.Float64Array;
                var Int32Array = typeof globalObj.Int32Array === UNDEFINED ? Array : globalObj.Int32Array;
                var dataCtors = {
                    'float': Float64Array,
                    'int': Int32Array,
                    'ordinal': Array,
                    'number': Array,
                    'time': Array
                };
                var Model = __webpack_require__(8);
                var DataDiffer = __webpack_require__(95);
                var zrUtil = __webpack_require__(3);
                var modelUtil = __webpack_require__(5);
                var isObject = zrUtil.isObject;
                var IMMUTABLE_PROPERTIES = [
                    'stackedOn',
                    '_nameList',
                    '_idList',
                    '_rawData'
                ];
                var transferImmuProperties = function (a, b, wrappedMethod) {
                    zrUtil.each(IMMUTABLE_PROPERTIES.concat(wrappedMethod || []), function (propName) {
                        if (b.hasOwnProperty(propName)) {
                            a[propName] = b[propName];
                        }
                    });
                };
                var List = function (dimensions, hostModel) {
                    dimensions = dimensions || [
                        'x',
                        'y'
                    ];
                    var dimensionInfos = {};
                    var dimensionNames = [];
                    for (var i = 0; i < dimensions.length; i++) {
                        var dimensionName;
                        var dimensionInfo = {};
                        if (typeof dimensions[i] === 'string') {
                            dimensionName = dimensions[i];
                            dimensionInfo = {
                                name: dimensionName,
                                stackable: false,
                                type: 'number'
                            };
                        } else {
                            dimensionInfo = dimensions[i];
                            dimensionName = dimensionInfo.name;
                            dimensionInfo.type = dimensionInfo.type || 'number';
                        }
                        dimensionNames.push(dimensionName);
                        dimensionInfos[dimensionName] = dimensionInfo;
                    }
                    this.dimensions = dimensionNames;
                    this._dimensionInfos = dimensionInfos;
                    this.hostModel = hostModel;
                    this.indices = [];
                    this._storage = {};
                    this._nameList = [];
                    this._idList = [];
                    this._optionModels = [];
                    this.stackedOn = null;
                    this._visual = {};
                    this._layout = {};
                    this._itemVisuals = [];
                    this._itemLayouts = [];
                    this._graphicEls = [];
                    this._rawData;
                    this._extent;
                };
                var listProto = List.prototype;
                listProto.type = 'list';
                listProto.getDimension = function (dim) {
                    if (!isNaN(dim)) {
                        dim = this.dimensions[dim] || dim;
                    }
                    return dim;
                };
                listProto.getDimensionInfo = function (dim) {
                    return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);
                };
                listProto.initData = function (data, nameList, dimValueGetter) {
                    data = data || [];
                    this._rawData = data;
                    var storage = this._storage = {};
                    var indices = this.indices = [];
                    var dimensions = this.dimensions;
                    var size = data.length;
                    var dimensionInfoMap = this._dimensionInfos;
                    var idList = [];
                    var nameRepeatCount = {};
                    nameList = nameList || [];
                    for (var i = 0; i < dimensions.length; i++) {
                        var dimInfo = dimensionInfoMap[dimensions[i]];
                        var DataCtor = dataCtors[dimInfo.type];
                        storage[dimensions[i]] = new DataCtor(size);
                    }
                    dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {
                        var value = modelUtil.getDataItemValue(dataItem);
                        return modelUtil.converDataValue(zrUtil.isArray(value) ? value[dimIndex] : value, dimensionInfoMap[dimName]);
                    };
                    for (var idx = 0; idx < data.length; idx++) {
                        var dataItem = data[idx];
                        for (var k = 0; k < dimensions.length; k++) {
                            var dim = dimensions[k];
                            var dimStorage = storage[dim];
                            dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);
                        }
                        indices.push(idx);
                    }
                    for (var i = 0; i < data.length; i++) {
                        var id = '';
                        if (!nameList[i]) {
                            nameList[i] = data[i].name;
                            id = data[i].id;
                        }
                        var name = nameList[i] || '';
                        if (!id && name) {
                            nameRepeatCount[name] = nameRepeatCount[name] || 0;
                            id = name;
                            if (nameRepeatCount[name] > 0) {
                                id += '__ec__' + nameRepeatCount[name];
                            }
                            nameRepeatCount[name]++;
                        }
                        id && (idList[i] = id);
                    }
                    this._nameList = nameList;
                    this._idList = idList;
                };
                listProto.count = function () {
                    return this.indices.length;
                };
                listProto.get = function (dim, idx, stack) {
                    var storage = this._storage;
                    var dataIndex = this.indices[idx];
                    if (dataIndex == null) {
                        return NaN;
                    }
                    var value = storage[dim] && storage[dim][dataIndex];
                    if (stack) {
                        var dimensionInfo = this._dimensionInfos[dim];
                        if (dimensionInfo && dimensionInfo.stackable) {
                            var stackedOn = this.stackedOn;
                            while (stackedOn) {
                                var stackedValue = stackedOn.get(dim, idx);
                                if (value >= 0 && stackedValue > 0 || value <= 0 && stackedValue < 0) {
                                    value += stackedValue;
                                }
                                stackedOn = stackedOn.stackedOn;
                            }
                        }
                    }
                    return value;
                };
                listProto.getValues = function (dimensions, idx, stack) {
                    var values = [];
                    if (!zrUtil.isArray(dimensions)) {
                        stack = idx;
                        idx = dimensions;
                        dimensions = this.dimensions;
                    }
                    for (var i = 0, len = dimensions.length; i < len; i++) {
                        values.push(this.get(dimensions[i], idx, stack));
                    }
                    return values;
                };
                listProto.hasValue = function (idx) {
                    var dimensions = this.dimensions;
                    var dimensionInfos = this._dimensionInfos;
                    for (var i = 0, len = dimensions.length; i < len; i++) {
                        if (dimensionInfos[dimensions[i]].type !== 'ordinal' && isNaN(this.get(dimensions[i], idx))) {
                            return false;
                        }
                    }
                    return true;
                };
                listProto.getDataExtent = function (dim, stack) {
                    var dimData = this._storage[dim];
                    var dimInfo = this.getDimensionInfo(dim);
                    stack = dimInfo && dimInfo.stackable && stack;
                    var dimExtent = (this._extent || (this._extent = {}))[dim + !!stack];
                    var value;
                    if (dimExtent) {
                        return dimExtent;
                    }
                    if (dimData) {
                        var min = Infinity;
                        var max = -Infinity;
                        for (var i = 0, len = this.count(); i < len; i++) {
                            value = this.get(dim, i, stack);
                            value < min && (min = value);
                            value > max && (max = value);
                        }
                        return this._extent[dim + stack] = [
                            min,
                            max
                        ];
                    } else {
                        return [
                            Infinity,
                            -Infinity
                        ];
                    }
                };
                listProto.getSum = function (dim, stack) {
                    var dimData = this._storage[dim];
                    var sum = 0;
                    if (dimData) {
                        for (var i = 0, len = this.count(); i < len; i++) {
                            var value = this.get(dim, i, stack);
                            if (!isNaN(value)) {
                                sum += value;
                            }
                        }
                    }
                    return sum;
                };
                listProto.indexOf = function (dim, value) {
                    var storage = this._storage;
                    var dimData = storage[dim];
                    var indices = this.indices;
                    if (dimData) {
                        for (var i = 0, len = indices.length; i < len; i++) {
                            var rawIndex = indices[i];
                            if (dimData[rawIndex] === value) {
                                return i;
                            }
                        }
                    }
                    return -1;
                };
                listProto.indexOfName = function (name) {
                    var indices = this.indices;
                    var nameList = this._nameList;
                    for (var i = 0, len = indices.length; i < len; i++) {
                        var rawIndex = indices[i];
                        if (nameList[rawIndex] === name) {
                            return i;
                        }
                    }
                    return -1;
                };
                listProto.indexOfNearest = function (dim, value, stack) {
                    var storage = this._storage;
                    var dimData = storage[dim];
                    if (dimData) {
                        var minDist = Number.MAX_VALUE;
                        var nearestIdx = -1;
                        for (var i = 0, len = this.count(); i < len; i++) {
                            var diff = value - this.get(dim, i, stack);
                            var dist = Math.abs(diff);
                            if (dist < minDist || dist === minDist && diff > 0) {
                                minDist = dist;
                                nearestIdx = i;
                            }
                        }
                        return nearestIdx;
                    }
                    return -1;
                };
                listProto.getRawIndex = function (idx) {
                    var rawIdx = this.indices[idx];
                    return rawIdx == null ? -1 : rawIdx;
                };
                listProto.getName = function (idx) {
                    return this._nameList[this.indices[idx]] || '';
                };
                listProto.getId = function (idx) {
                    return this._idList[this.indices[idx]] || this.getRawIndex(idx) + '';
                };
                function normalizeDimensions(dimensions) {
                    if (!zrUtil.isArray(dimensions)) {
                        dimensions = [dimensions];
                    }
                    return dimensions;
                }
                listProto.each = function (dimensions, cb, stack, context) {
                    if (typeof dimensions === 'function') {
                        context = stack;
                        stack = cb;
                        cb = dimensions;
                        dimensions = [];
                    }
                    dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
                    var value = [];
                    var dimSize = dimensions.length;
                    var indices = this.indices;
                    context = context || this;
                    for (var i = 0; i < indices.length; i++) {
                        if (dimSize === 0) {
                            cb.call(context, i);
                        } else if (dimSize === 1) {
                            cb.call(context, this.get(dimensions[0], i, stack), i);
                        } else {
                            for (var k = 0; k < dimSize; k++) {
                                value[k] = this.get(dimensions[k], i, stack);
                            }
                            value[k] = i;
                            cb.apply(context, value);
                        }
                    }
                };
                listProto.filterSelf = function (dimensions, cb, stack, context) {
                    if (typeof dimensions === 'function') {
                        context = stack;
                        stack = cb;
                        cb = dimensions;
                        dimensions = [];
                    }
                    dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
                    var newIndices = [];
                    var value = [];
                    var dimSize = dimensions.length;
                    var indices = this.indices;
                    context = context || this;
                    for (var i = 0; i < indices.length; i++) {
                        var keep;
                        if (dimSize === 1) {
                            keep = cb.call(context, this.get(dimensions[0], i, stack), i);
                        } else {
                            for (var k = 0; k < dimSize; k++) {
                                value[k] = this.get(dimensions[k], i, stack);
                            }
                            value[k] = i;
                            keep = cb.apply(context, value);
                        }
                        if (keep) {
                            newIndices.push(indices[i]);
                        }
                    }
                    this.indices = newIndices;
                    this._extent = {};
                    return this;
                };
                listProto.mapArray = function (dimensions, cb, stack, context) {
                    if (typeof dimensions === 'function') {
                        context = stack;
                        stack = cb;
                        cb = dimensions;
                        dimensions = [];
                    }
                    var result = [];
                    this.each(dimensions, function () {
                        result.push(cb && cb.apply(this, arguments));
                    }, stack, context);
                    return result;
                };
                function cloneListForMapAndSample(original, excludeDimensions) {
                    var allDimensions = original.dimensions;
                    var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel);
                    transferImmuProperties(list, original, original._wrappedMethods);
                    var storage = list._storage = {};
                    var originalStorage = original._storage;
                    for (var i = 0; i < allDimensions.length; i++) {
                        var dim = allDimensions[i];
                        var dimStore = originalStorage[dim];
                        if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {
                            storage[dim] = new dimStore.constructor(originalStorage[dim].length);
                        } else {
                            storage[dim] = originalStorage[dim];
                        }
                    }
                    return list;
                }
                listProto.map = function (dimensions, cb, stack, context) {
                    dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);
                    var list = cloneListForMapAndSample(this, dimensions);
                    var indices = list.indices = this.indices;
                    var storage = list._storage;
                    var tmpRetValue = [];
                    this.each(dimensions, function () {
                        var idx = arguments[arguments.length - 1];
                        var retValue = cb && cb.apply(this, arguments);
                        if (retValue != null) {
                            if (typeof retValue === 'number') {
                                tmpRetValue[0] = retValue;
                                retValue = tmpRetValue;
                            }
                            for (var i = 0; i < retValue.length; i++) {
                                var dim = dimensions[i];
                                var dimStore = storage[dim];
                                var rawIdx = indices[idx];
                                if (dimStore) {
                                    dimStore[rawIdx] = retValue[i];
                                }
                            }
                        }
                    }, stack, context);
                    return list;
                };
                listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {
                    var list = cloneListForMapAndSample(this, [dimension]);
                    var storage = this._storage;
                    var targetStorage = list._storage;
                    var originalIndices = this.indices;
                    var indices = list.indices = [];
                    var frameValues = [];
                    var frameIndices = [];
                    var frameSize = Math.floor(1 / rate);
                    var dimStore = targetStorage[dimension];
                    var len = this.count();
                    for (var i = 0; i < storage[dimension].length; i++) {
                        targetStorage[dimension][i] = storage[dimension][i];
                    }
                    for (var i = 0; i < len; i += frameSize) {
                        if (frameSize > len - i) {
                            frameSize = len - i;
                            frameValues.length = frameSize;
                        }
                        for (var k = 0; k < frameSize; k++) {
                            var idx = originalIndices[i + k];
                            frameValues[k] = dimStore[idx];
                            frameIndices[k] = idx;
                        }
                        var value = sampleValue(frameValues);
                        var idx = frameIndices[sampleIndex(frameValues, value) || 0];
                        dimStore[idx] = value;
                        indices.push(idx);
                    }
                    return list;
                };
                listProto.getItemModel = function (idx) {
                    var hostModel = this.hostModel;
                    idx = this.indices[idx];
                    return new Model(this._rawData[idx], hostModel, hostModel.ecModel);
                };
                listProto.diff = function (otherList) {
                    var idList = this._idList;
                    var otherIdList = otherList && otherList._idList;
                    return new DataDiffer(otherList ? otherList.indices : [], this.indices, function (idx) {
                        return otherIdList[idx] || idx + '';
                    }, function (idx) {
                        return idList[idx] || idx + '';
                    });
                };
                listProto.getVisual = function (key) {
                    var visual = this._visual;
                    return visual && visual[key];
                };
                listProto.setVisual = function (key, val) {
                    if (isObject(key)) {
                        for (var name in key) {
                            if (key.hasOwnProperty(name)) {
                                this.setVisual(name, key[name]);
                            }
                        }
                        return;
                    }
                    this._visual = this._visual || {};
                    this._visual[key] = val;
                };
                listProto.setLayout = function (key, val) {
                    if (isObject(key)) {
                        for (var name in key) {
                            if (key.hasOwnProperty(name)) {
                                this.setLayout(name, key[name]);
                            }
                        }
                        return;
                    }
                    this._layout[key] = val;
                };
                listProto.getLayout = function (key) {
                    return this._layout[key];
                };
                listProto.getItemLayout = function (idx) {
                    return this._itemLayouts[idx];
                }, listProto.setItemLayout = function (idx, layout, merge) {
                    this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;
                }, listProto.getItemVisual = function (idx, key, ignoreParent) {
                    var itemVisual = this._itemVisuals[idx];
                    var val = itemVisual && itemVisual[key];
                    if (val == null && !ignoreParent) {
                        return this.getVisual(key);
                    }
                    return val;
                }, listProto.setItemVisual = function (idx, key, value) {
                    var itemVisual = this._itemVisuals[idx] || {};
                    this._itemVisuals[idx] = itemVisual;
                    if (isObject(key)) {
                        for (var name in key) {
                            if (key.hasOwnProperty(name)) {
                                itemVisual[name] = key[name];
                            }
                        }
                        return;
                    }
                    itemVisual[key] = value;
                };
                var setItemDataAndSeriesIndex = function (child) {
                    child.seriesIndex = this.seriesIndex;
                    child.dataIndex = this.dataIndex;
                };
                listProto.setItemGraphicEl = function (idx, el) {
                    var hostModel = this.hostModel;
                    if (el) {
                        el.dataIndex = idx;
                        el.seriesIndex = hostModel && hostModel.seriesIndex;
                        if (el.type === 'group') {
                            el.traverse(setItemDataAndSeriesIndex, el);
                        }
                    }
                    this._graphicEls[idx] = el;
                };
                listProto.getItemGraphicEl = function (idx) {
                    return this._graphicEls[idx];
                };
                listProto.eachItemGraphicEl = function (cb, context) {
                    zrUtil.each(this._graphicEls, function (el, idx) {
                        if (el) {
                            cb && cb.call(context, el, idx);
                        }
                    });
                };
                listProto.cloneShallow = function () {
                    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);
                    var list = new List(dimensionInfoList, this.hostModel);
                    list._storage = this._storage;
                    transferImmuProperties(list, this, this._wrappedMethods);
                    list.indices = this.indices.slice();
                    return list;
                };
                listProto.wrapMethod = function (methodName, injectFunction) {
                    var originalMethod = this[methodName];
                    if (typeof originalMethod !== 'function') {
                        return;
                    }
                    this._wrappedMethods = this._wrappedMethods || [];
                    this._wrappedMethods.push(methodName);
                    this[methodName] = function () {
                        var res = originalMethod.apply(this, arguments);
                        return injectFunction.call(this, res);
                    };
                };
                module.exports = List;
            }.call(exports, function () {
                return this;
            }()));
        },
        function (module, exports) {
            'use strict';
            function defaultKeyGetter(item) {
                return item;
            }
            function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {
                this._old = oldArr;
                this._new = newArr;
                this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
                this._newKeyGetter = newKeyGetter || defaultKeyGetter;
            }
            DataDiffer.prototype = {
                constructor: DataDiffer,
                add: function (func) {
                    this._add = func;
                    return this;
                },
                update: function (func) {
                    this._update = func;
                    return this;
                },
                remove: function (func) {
                    this._remove = func;
                    return this;
                },
                execute: function () {
                    var oldArr = this._old;
                    var newArr = this._new;
                    var oldKeyGetter = this._oldKeyGetter;
                    var newKeyGetter = this._newKeyGetter;
                    var oldDataIndexMap = {};
                    var newDataIndexMap = {};
                    var i;
                    initIndexMap(oldArr, oldDataIndexMap, oldKeyGetter);
                    initIndexMap(newArr, newDataIndexMap, newKeyGetter);
                    for (i = 0; i < oldArr.length; i++) {
                        var key = oldKeyGetter(oldArr[i]);
                        var idx = newDataIndexMap[key];
                        if (idx != null) {
                            var len = idx.length;
                            if (len) {
                                len === 1 && (newDataIndexMap[key] = null);
                                idx = idx.unshift();
                            } else {
                                newDataIndexMap[key] = null;
                            }
                            this._update && this._update(idx, i);
                        } else {
                            this._remove && this._remove(i);
                        }
                    }
                    for (var key in newDataIndexMap) {
                        if (newDataIndexMap.hasOwnProperty(key)) {
                            var idx = newDataIndexMap[key];
                            if (idx == null) {
                                continue;
                            }
                            if (!idx.length) {
                                this._add && this._add(idx);
                            } else {
                                for (var i = 0, len = idx.length; i < len; i++) {
                                    this._add && this._add(idx[i]);
                                }
                            }
                        }
                    }
                }
            };
            function initIndexMap(arr, map, keyGetter) {
                for (var i = 0; i < arr.length; i++) {
                    var key = keyGetter(arr[i]);
                    var existence = map[key];
                    if (existence == null) {
                        map[key] = i;
                    } else {
                        if (!existence.length) {
                            map[key] = existence = [existence];
                        }
                        existence.push(i);
                    }
                }
            }
            module.exports = DataDiffer;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            function completeDimensions(dimensions, data, defaultNames, extraPrefix) {
                if (!data) {
                    return dimensions;
                }
                var value0 = retrieveValue(data[0]);
                var dimSize = zrUtil.isArray(value0) && value0.length || 1;
                defaultNames = defaultNames || [];
                extraPrefix = extraPrefix || 'extra';
                for (var i = 0; i < dimSize; i++) {
                    if (!dimensions[i]) {
                        var name = defaultNames[i] || extraPrefix + (i - defaultNames.length);
                        dimensions[i] = guessOrdinal(data, i) ? {
                            type: 'ordinal',
                            name: name
                        } : name;
                    }
                }
                return dimensions;
            }
            function guessOrdinal(data, dimIndex) {
                for (var i = 0, len = data.length; i < len; i++) {
                    var value = retrieveValue(data[i]);
                    if (!zrUtil.isArray(value)) {
                        return false;
                    }
                    var value = value[dimIndex];
                    if (value != null && isFinite(value)) {
                        return false;
                    } else if (zrUtil.isString(value) && value !== '-') {
                        return true;
                    }
                }
                return false;
            }
            function retrieveValue(o) {
                return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value : o;
            }
            module.exports = completeDimensions;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var SymbolDraw = __webpack_require__(98);
            var Symbol = __webpack_require__(99);
            var lineAnimationDiff = __webpack_require__(101);
            var graphic = __webpack_require__(42);
            var polyHelper = __webpack_require__(102);
            var ChartView = __webpack_require__(41);
            function isPointsSame(points1, points2) {
                if (points1.length !== points2.length) {
                    return;
                }
                for (var i = 0; i < points1.length; i++) {
                    var p1 = points1[i];
                    var p2 = points2[i];
                    if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
                        return;
                    }
                }
                return true;
            }
            function getSmooth(smooth) {
                return typeof smooth === 'number' ? smooth : smooth ? 0.3 : 0;
            }
            function getAxisExtentWithGap(axis) {
                var extent = axis.getGlobalExtent();
                if (axis.onBand) {
                    var halfBandWidth = axis.getBandWidth() / 2 - 1;
                    var dir = extent[1] > extent[0] ? 1 : -1;
                    extent[0] += dir * halfBandWidth;
                    extent[1] -= dir * halfBandWidth;
                }
                return extent;
            }
            function sign(val) {
                return val >= 0 ? 1 : -1;
            }
            function getStackedOnPoints(coordSys, data) {
                var baseAxis = coordSys.getBaseAxis();
                var valueAxis = coordSys.getOtherAxis(baseAxis);
                var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0];
                var valueDim = valueAxis.dim;
                var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;
                return data.mapArray([valueDim], function (val, idx) {
                    var stackedOnSameSign;
                    var stackedOn = data.stackedOn;
                    while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {
                        stackedOnSameSign = stackedOn;
                        break;
                    }
                    var stackedData = [];
                    stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
                    stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;
                    return coordSys.dataToPoint(stackedData);
                }, true);
            }
            function queryDataIndex(data, payload) {
                if (payload.dataIndex != null) {
                    return payload.dataIndex;
                } else if (payload.name != null) {
                    return data.indexOfName(payload.name);
                }
            }
            function createGridClipShape(cartesian, hasAnimation, seriesModel) {
                var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));
                var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));
                var isHorizontal = cartesian.getBaseAxis().isHorizontal();
                var x = xExtent[0];
                var y = yExtent[0];
                var width = xExtent[1] - x;
                var height = yExtent[1] - y;
                if (!seriesModel.get('clipOverflow')) {
                    if (isHorizontal) {
                        y -= height;
                        height *= 3;
                    } else {
                        x -= width;
                        width *= 3;
                    }
                }
                var clipPath = new graphic.Rect({
                    shape: {
                        x: x,
                        y: y,
                        width: width,
                        height: height
                    }
                });
                if (hasAnimation) {
                    clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;
                    graphic.initProps(clipPath, {
                        shape: {
                            width: width,
                            height: height
                        }
                    }, seriesModel);
                }
                return clipPath;
            }
            function createPolarClipShape(polar, hasAnimation, seriesModel) {
                var angleAxis = polar.getAngleAxis();
                var radiusAxis = polar.getRadiusAxis();
                var radiusExtent = radiusAxis.getExtent();
                var angleExtent = angleAxis.getExtent();
                var RADIAN = Math.PI / 180;
                var clipPath = new graphic.Sector({
                    shape: {
                        cx: polar.cx,
                        cy: polar.cy,
                        r0: radiusExtent[0],
                        r: radiusExtent[1],
                        startAngle: -angleExtent[0] * RADIAN,
                        endAngle: -angleExtent[1] * RADIAN,
                        clockwise: angleAxis.inverse
                    }
                });
                if (hasAnimation) {
                    clipPath.shape.endAngle = -angleExtent[0] * RADIAN;
                    graphic.initProps(clipPath, { shape: { endAngle: -angleExtent[1] * RADIAN } }, seriesModel);
                }
                return clipPath;
            }
            function createClipShape(coordSys, hasAnimation, seriesModel) {
                return coordSys.type === 'polar' ? createPolarClipShape(coordSys, hasAnimation, seriesModel) : createGridClipShape(coordSys, hasAnimation, seriesModel);
            }
            module.exports = ChartView.extend({
                type: 'line',
                init: function () {
                    var lineGroup = new graphic.Group();
                    var symbolDraw = new SymbolDraw();
                    this.group.add(symbolDraw.group);
                    this._symbolDraw = symbolDraw;
                    this._lineGroup = lineGroup;
                },
                render: function (seriesModel, ecModel, api) {
                    var coordSys = seriesModel.coordinateSystem;
                    var group = this.group;
                    var data = seriesModel.getData();
                    var lineStyleModel = seriesModel.getModel('lineStyle.normal');
                    var areaStyleModel = seriesModel.getModel('areaStyle.normal');
                    var points = data.mapArray(data.getItemLayout, true);
                    var isCoordSysPolar = coordSys.type === 'polar';
                    var prevCoordSys = this._coordSys;
                    var symbolDraw = this._symbolDraw;
                    var polyline = this._polyline;
                    var polygon = this._polygon;
                    var lineGroup = this._lineGroup;
                    var hasAnimation = seriesModel.get('animation');
                    var isAreaChart = !areaStyleModel.isEmpty();
                    var stackedOnPoints = getStackedOnPoints(coordSys, data);
                    var showSymbol = seriesModel.get('showSymbol');
                    var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol') && this._getSymbolIgnoreFunc(data, coordSys);
                    var oldData = this._data;
                    oldData && oldData.eachItemGraphicEl(function (el, idx) {
                        if (el.__temp) {
                            group.remove(el);
                            oldData.setItemGraphicEl(idx, null);
                        }
                    });
                    if (!showSymbol) {
                        symbolDraw.remove();
                    }
                    group.add(lineGroup);
                    if (!(polyline && prevCoordSys.type === coordSys.type)) {
                        showSymbol && symbolDraw.updateData(data, isSymbolIgnore);
                        polyline = this._newPolyline(points, coordSys, hasAnimation);
                        if (isAreaChart) {
                            polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
                        }
                        lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));
                    } else {
                        if (isAreaChart && !polygon) {
                            polygon = this._newPolygon(points, stackedOnPoints, coordSys, hasAnimation);
                        } else if (polygon && !isAreaChart) {
                            lineGroup.remove(polygon);
                            polygon = this._polygon = null;
                        }
                        lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));
                        showSymbol && symbolDraw.updateData(data, isSymbolIgnore);
                        data.eachItemGraphicEl(function (el) {
                            el.stopAnimation(true);
                        });
                        if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
                            if (hasAnimation) {
                                this._updateAnimation(data, stackedOnPoints, coordSys, api);
                            } else {
                                polyline.setShape({ points: points });
                                polygon && polygon.setShape({
                                    points: points,
                                    stackedOnPoints: stackedOnPoints
                                });
                            }
                        }
                    }
                    polyline.setStyle(zrUtil.defaults(lineStyleModel.getLineStyle(), {
                        stroke: data.getVisual('color'),
                        lineJoin: 'bevel'
                    }));
                    var smooth = seriesModel.get('smooth');
                    smooth = getSmooth(seriesModel.get('smooth'));
                    polyline.setShape({
                        smooth: smooth,
                        smoothMonotone: seriesModel.get('smoothMonotone')
                    });
                    if (polygon) {
                        var stackedOn = data.stackedOn;
                        var stackedOnSmooth = 0;
                        polygon.style.opacity = 0.7;
                        polygon.setStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
                            fill: data.getVisual('color'),
                            lineJoin: 'bevel'
                        }));
                        if (stackedOn) {
                            var stackedOnSeries = stackedOn.hostModel;
                            stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
                        }
                        polygon.setShape({
                            smooth: smooth,
                            stackedOnSmooth: stackedOnSmooth,
                            smoothMonotone: seriesModel.get('smoothMonotone')
                        });
                    }
                    this._data = data;
                    this._coordSys = coordSys;
                    this._stackedOnPoints = stackedOnPoints;
                    this._points = points;
                },
                highlight: function (seriesModel, ecModel, api, payload) {
                    var data = seriesModel.getData();
                    var dataIndex = queryDataIndex(data, payload);
                    if (dataIndex != null && dataIndex >= 0) {
                        var symbol = data.getItemGraphicEl(dataIndex);
                        if (!symbol) {
                            var pt = data.getItemLayout(dataIndex);
                            symbol = new Symbol(data, dataIndex, api);
                            symbol.position = pt;
                            symbol.setZ(seriesModel.get('zlevel'), seriesModel.get('z'));
                            symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
                            symbol.__temp = true;
                            data.setItemGraphicEl(dataIndex, symbol);
                            symbol.stopSymbolAnimation(true);
                            this.group.add(symbol);
                        }
                        symbol.highlight();
                    } else {
                        ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload);
                    }
                },
                downplay: function (seriesModel, ecModel, api, payload) {
                    var data = seriesModel.getData();
                    var dataIndex = queryDataIndex(data, payload);
                    if (dataIndex != null && dataIndex >= 0) {
                        var symbol = data.getItemGraphicEl(dataIndex);
                        if (symbol) {
                            if (symbol.__temp) {
                                data.setItemGraphicEl(dataIndex, null);
                                this.group.remove(symbol);
                            } else {
                                symbol.downplay();
                            }
                        }
                    } else {
                        ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload);
                    }
                },
                _newPolyline: function (points) {
                    var polyline = this._polyline;
                    if (polyline) {
                        this._lineGroup.remove(polyline);
                    }
                    polyline = new polyHelper.Polyline({
                        shape: { points: points },
                        silent: true,
                        z2: 10
                    });
                    this._lineGroup.add(polyline);
                    this._polyline = polyline;
                    return polyline;
                },
                _newPolygon: function (points, stackedOnPoints) {
                    var polygon = this._polygon;
                    if (polygon) {
                        this._lineGroup.remove(polygon);
                    }
                    polygon = new polyHelper.Polygon({
                        shape: {
                            points: points,
                            stackedOnPoints: stackedOnPoints
                        },
                        silent: true
                    });
                    this._lineGroup.add(polygon);
                    this._polygon = polygon;
                    return polygon;
                },
                _getSymbolIgnoreFunc: function (data, coordSys) {
                    var categoryAxis = coordSys.getAxesByScale('ordinal')[0];
                    if (categoryAxis && categoryAxis.isLabelIgnored) {
                        return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);
                    }
                },
                _updateAnimation: function (data, stackedOnPoints, coordSys, api) {
                    var polyline = this._polyline;
                    var polygon = this._polygon;
                    var seriesModel = data.hostModel;
                    var diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys);
                    polyline.shape.points = diff.current;
                    graphic.updateProps(polyline, { shape: { points: diff.next } }, seriesModel);
                    if (polygon) {
                        polygon.setShape({
                            points: diff.current,
                            stackedOnPoints: diff.stackedOnCurrent
                        });
                        graphic.updateProps(polygon, {
                            shape: {
                                points: diff.next,
                                stackedOnPoints: diff.stackedOnNext
                            }
                        }, seriesModel);
                    }
                    var updatedDataInfo = [];
                    var diffStatus = diff.status;
                    for (var i = 0; i < diffStatus.length; i++) {
                        var cmd = diffStatus[i].cmd;
                        if (cmd === '=') {
                            var el = data.getItemGraphicEl(diffStatus[i].idx1);
                            if (el) {
                                updatedDataInfo.push({
                                    el: el,
                                    ptIdx: i
                                });
                            }
                        }
                    }
                    if (polyline.animators && polyline.animators.length) {
                        polyline.animators[0].during(function () {
                            for (var i = 0; i < updatedDataInfo.length; i++) {
                                var el = updatedDataInfo[i].el;
                                el.attr('position', polyline.shape.points[updatedDataInfo[i].ptIdx]);
                            }
                        });
                    }
                },
                remove: function (ecModel) {
                    var group = this.group;
                    var oldData = this._data;
                    this._lineGroup.removeAll();
                    this._symbolDraw.remove(true);
                    oldData && oldData.eachItemGraphicEl(function (el, idx) {
                        if (el.__temp) {
                            group.remove(el);
                            oldData.setItemGraphicEl(idx, null);
                        }
                    });
                    this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._data = null;
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var Symbol = __webpack_require__(99);
            function SymbolDraw(symbolCtor) {
                this.group = new graphic.Group();
                this._symbolCtor = symbolCtor || Symbol;
            }
            var symbolDrawProto = SymbolDraw.prototype;
            function symbolNeedsDraw(data, idx, isIgnore) {
                var point = data.getItemLayout(idx);
                return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx)) && data.getItemVisual(idx, 'symbol') !== 'none';
            }
            symbolDrawProto.updateData = function (data, isIgnore) {
                var group = this.group;
                var seriesModel = data.hostModel;
                var oldData = this._data;
                var SymbolCtor = this._symbolCtor;
                data.diff(oldData).add(function (newIdx) {
                    var point = data.getItemLayout(newIdx);
                    if (symbolNeedsDraw(data, newIdx, isIgnore)) {
                        var symbolEl = new SymbolCtor(data, newIdx);
                        symbolEl.attr('position', point);
                        data.setItemGraphicEl(newIdx, symbolEl);
                        group.add(symbolEl);
                    }
                }).update(function (newIdx, oldIdx) {
                    var symbolEl = oldData.getItemGraphicEl(oldIdx);
                    var point = data.getItemLayout(newIdx);
                    if (!symbolNeedsDraw(data, newIdx, isIgnore)) {
                        group.remove(symbolEl);
                        return;
                    }
                    if (!symbolEl) {
                        symbolEl = new SymbolCtor(data, newIdx);
                        symbolEl.attr('position', point);
                    } else {
                        symbolEl.updateData(data, newIdx);
                        graphic.updateProps(symbolEl, { position: point }, seriesModel);
                    }
                    group.add(symbolEl);
                    data.setItemGraphicEl(newIdx, symbolEl);
                }).remove(function (oldIdx) {
                    var el = oldData.getItemGraphicEl(oldIdx);
                    el && el.fadeOut(function () {
                        group.remove(el);
                    });
                }).execute();
                this._data = data;
            };
            symbolDrawProto.updateLayout = function () {
                var data = this._data;
                if (data) {
                    data.eachItemGraphicEl(function (el, idx) {
                        el.attr('position', data.getItemLayout(idx));
                    });
                }
            };
            symbolDrawProto.remove = function (enableAnimation) {
                var group = this.group;
                var data = this._data;
                if (data) {
                    if (enableAnimation) {
                        data.eachItemGraphicEl(function (el) {
                            el.fadeOut(function () {
                                group.remove(el);
                            });
                        });
                    } else {
                        group.removeAll();
                    }
                }
            };
            module.exports = SymbolDraw;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var symbolUtil = __webpack_require__(100);
            var graphic = __webpack_require__(42);
            var numberUtil = __webpack_require__(7);
            function normalizeSymbolSize(symbolSize) {
                if (!zrUtil.isArray(symbolSize)) {
                    symbolSize = [
                        +symbolSize,
                        +symbolSize
                    ];
                }
                return symbolSize;
            }
            function Symbol(data, idx) {
                graphic.Group.call(this);
                this.updateData(data, idx);
            }
            var symbolProto = Symbol.prototype;
            function driftSymbol(dx, dy) {
                this.parent.drift(dx, dy);
            }
            symbolProto._createSymbol = function (symbolType, data, idx) {
                this.removeAll();
                var seriesModel = data.hostModel;
                var color = data.getItemVisual(idx, 'color');
                var symbolPath = symbolUtil.createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
                symbolPath.attr({
                    style: { strokeNoScale: true },
                    z2: 100,
                    culling: true,
                    scale: [
                        0,
                        0
                    ]
                });
                symbolPath.drift = driftSymbol;
                var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
                graphic.initProps(symbolPath, { scale: size }, seriesModel);
                this._symbolType = symbolType;
                this.add(symbolPath);
            };
            symbolProto.stopSymbolAnimation = function (toLastFrame) {
                this.childAt(0).stopAnimation(toLastFrame);
            };
            symbolProto.getScale = function () {
                return this.childAt(0).scale;
            };
            symbolProto.highlight = function () {
                this.childAt(0).trigger('emphasis');
            };
            symbolProto.downplay = function () {
                this.childAt(0).trigger('normal');
            };
            symbolProto.setZ = function (zlevel, z) {
                var symbolPath = this.childAt(0);
                symbolPath.zlevel = zlevel;
                symbolPath.z = z;
            };
            symbolProto.setDraggable = function (draggable) {
                var symbolPath = this.childAt(0);
                symbolPath.draggable = draggable;
                symbolPath.cursor = draggable ? 'move' : 'pointer';
            };
            symbolProto.updateData = function (data, idx) {
                var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
                var seriesModel = data.hostModel;
                var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
                if (symbolType !== this._symbolType) {
                    this._createSymbol(symbolType, data, idx);
                } else {
                    var symbolPath = this.childAt(0);
                    graphic.updateProps(symbolPath, { scale: symbolSize }, seriesModel);
                }
                this._updateCommon(data, idx, symbolSize);
                this._seriesModel = seriesModel;
            };
            var normalStyleAccessPath = [
                'itemStyle',
                'normal'
            ];
            var emphasisStyleAccessPath = [
                'itemStyle',
                'emphasis'
            ];
            var normalLabelAccessPath = [
                'label',
                'normal'
            ];
            var emphasisLabelAccessPath = [
                'label',
                'emphasis'
            ];
            symbolProto._updateCommon = function (data, idx, symbolSize) {
                var symbolPath = this.childAt(0);
                var seriesModel = data.hostModel;
                var itemModel = data.getItemModel(idx);
                var normalItemStyleModel = itemModel.getModel(normalStyleAccessPath);
                var color = data.getItemVisual(idx, 'color');
                var elStyle = symbolPath.style;
                var hoverStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
                symbolPath.rotation = itemModel.getShallow('symbolRotate') * Math.PI / 180 || 0;
                var symbolOffset = itemModel.getShallow('symbolOffset');
                if (symbolOffset) {
                    var pos = symbolPath.position;
                    pos[0] = numberUtil.parsePercent(symbolOffset[0], symbolSize[0]);
                    pos[1] = numberUtil.parsePercent(symbolOffset[1], symbolSize[1]);
                }
                symbolPath.setColor(color);
                zrUtil.extend(elStyle, normalItemStyleModel.getItemStyle(['color']));
                var opacity = data.getItemVisual(idx, 'opacity');
                if (opacity != null) {
                    elStyle.opacity = opacity;
                }
                var labelModel = itemModel.getModel(normalLabelAccessPath);
                var hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
                var dimensions = data.dimensions.slice();
                var valueDim = dimensions.pop();
                var dataType;
                while ((dataType = data.getDimensionInfo(valueDim).type) === 'ordinal' || dataType === 'time') {
                    valueDim = dimensions.pop();
                }
                if (labelModel.get('show')) {
                    graphic.setText(elStyle, labelModel, color);
                    elStyle.text = zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), data.get(valueDim, idx));
                } else {
                    elStyle.text = '';
                }
                if (hoverLabelModel.getShallow('show')) {
                    graphic.setText(hoverStyle, hoverLabelModel, color);
                    hoverStyle.text = zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), data.get(valueDim, idx));
                } else {
                    hoverStyle.text = '';
                }
                var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
                symbolPath.off('mouseover').off('mouseout').off('emphasis').off('normal');
                graphic.setHoverStyle(symbolPath, hoverStyle);
                if (itemModel.getShallow('hoverAnimation')) {
                    var onEmphasis = function () {
                        var ratio = size[1] / size[0];
                        this.animateTo({
                            scale: [
                                Math.max(size[0] * 1.1, size[0] + 3),
                                Math.max(size[1] * 1.1, size[1] + 3 * ratio)
                            ]
                        }, 400, 'elasticOut');
                    };
                    var onNormal = function () {
                        this.animateTo({ scale: size }, 400, 'elasticOut');
                    };
                    symbolPath.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);
                }
            };
            symbolProto.fadeOut = function (cb) {
                var symbolPath = this.childAt(0);
                symbolPath.style.text = '';
                graphic.updateProps(symbolPath, {
                    scale: [
                        0,
                        0
                    ]
                }, this._seriesModel, cb);
            };
            zrUtil.inherits(Symbol, graphic.Group);
            module.exports = Symbol;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var graphic = __webpack_require__(42);
            var BoundingRect = __webpack_require__(15);
            var Triangle = graphic.extendShape({
                type: 'triangle',
                shape: {
                    cx: 0,
                    cy: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function (path, shape) {
                    var cx = shape.cx;
                    var cy = shape.cy;
                    var width = shape.width / 2;
                    var height = shape.height / 2;
                    path.moveTo(cx, cy - height);
                    path.lineTo(cx + width, cy + height);
                    path.lineTo(cx - width, cy + height);
                    path.closePath();
                }
            });
            var Diamond = graphic.extendShape({
                type: 'diamond',
                shape: {
                    cx: 0,
                    cy: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function (path, shape) {
                    var cx = shape.cx;
                    var cy = shape.cy;
                    var width = shape.width / 2;
                    var height = shape.height / 2;
                    path.moveTo(cx, cy - height);
                    path.lineTo(cx + width, cy);
                    path.lineTo(cx, cy + height);
                    path.lineTo(cx - width, cy);
                    path.closePath();
                }
            });
            var Pin = graphic.extendShape({
                type: 'pin',
                shape: {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function (path, shape) {
                    var x = shape.x;
                    var y = shape.y;
                    var w = shape.width / 5 * 3;
                    var h = Math.max(w, shape.height);
                    var r = w / 2;
                    var dy = r * r / (h - r);
                    var cy = y - h + r + dy;
                    var angle = Math.asin(dy / r);
                    var dx = Math.cos(angle) * r;
                    var tanX = Math.sin(angle);
                    var tanY = Math.cos(angle);
                    path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle);
                    var cpLen = r * 0.6;
                    var cpLen2 = r * 0.7;
                    path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y);
                    path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy);
                    path.closePath();
                }
            });
            var Arrow = graphic.extendShape({
                type: 'arrow',
                shape: {
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                buildPath: function (ctx, shape) {
                    var height = shape.height;
                    var width = shape.width;
                    var x = shape.x;
                    var y = shape.y;
                    var dx = width / 3 * 2;
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + dx, y + height);
                    ctx.lineTo(x, y + height / 4 * 3);
                    ctx.lineTo(x - dx, y + height);
                    ctx.lineTo(x, y);
                    ctx.closePath();
                }
            });
            var symbolCtors = {
                line: graphic.Line,
                rect: graphic.Rect,
                roundRect: graphic.Rect,
                square: graphic.Rect,
                circle: graphic.Circle,
                diamond: Diamond,
                pin: Pin,
                arrow: Arrow,
                triangle: Triangle
            };
            var symbolShapeMakers = {
                line: function (x, y, w, h, shape) {
                    shape.x1 = x;
                    shape.y1 = y + h / 2;
                    shape.x2 = x + w;
                    shape.y2 = y + h / 2;
                },
                rect: function (x, y, w, h, shape) {
                    shape.x = x;
                    shape.y = y;
                    shape.width = w;
                    shape.height = h;
                },
                roundRect: function (x, y, w, h, shape) {
                    shape.x = x;
                    shape.y = y;
                    shape.width = w;
                    shape.height = h;
                    shape.r = Math.min(w, h) / 4;
                },
                square: function (x, y, w, h, shape) {
                    var size = Math.min(w, h);
                    shape.x = x;
                    shape.y = y;
                    shape.width = size;
                    shape.height = size;
                },
                circle: function (x, y, w, h, shape) {
                    shape.cx = x + w / 2;
                    shape.cy = y + h / 2;
                    shape.r = Math.min(w, h) / 2;
                },
                diamond: function (x, y, w, h, shape) {
                    shape.cx = x + w / 2;
                    shape.cy = y + h / 2;
                    shape.width = w;
                    shape.height = h;
                },
                pin: function (x, y, w, h, shape) {
                    shape.x = x + w / 2;
                    shape.y = y + h / 2;
                    shape.width = w;
                    shape.height = h;
                },
                arrow: function (x, y, w, h, shape) {
                    shape.x = x + w / 2;
                    shape.y = y + h / 2;
                    shape.width = w;
                    shape.height = h;
                },
                triangle: function (x, y, w, h, shape) {
                    shape.cx = x + w / 2;
                    shape.cy = y + h / 2;
                    shape.width = w;
                    shape.height = h;
                }
            };
            var symbolBuildProxies = {};
            for (var name in symbolCtors) {
                symbolBuildProxies[name] = new symbolCtors[name]();
            }
            var Symbol = graphic.extendShape({
                type: 'symbol',
                shape: {
                    symbolType: '',
                    x: 0,
                    y: 0,
                    width: 0,
                    height: 0
                },
                beforeBrush: function () {
                    var style = this.style;
                    var shape = this.shape;
                    if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
                        style.textPosition = [
                            '50%',
                            '40%'
                        ];
                        style.textAlign = 'center';
                        style.textVerticalAlign = 'middle';
                    }
                },
                buildPath: function (ctx, shape) {
                    var symbolType = shape.symbolType;
                    var proxySymbol = symbolBuildProxies[symbolType];
                    if (shape.symbolType !== 'none') {
                        if (!proxySymbol) {
                            symbolType = 'rect';
                            proxySymbol = symbolBuildProxies[symbolType];
                        }
                        symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape);
                        proxySymbol.buildPath(ctx, proxySymbol.shape);
                    }
                }
            });
            var symbolPathSetColor = function (color) {
                if (this.type !== 'image') {
                    var symbolStyle = this.style;
                    var symbolShape = this.shape;
                    if (symbolShape && symbolShape.symbolType === 'line') {
                        symbolStyle.stroke = color;
                    } else if (this.__isEmptyBrush) {
                        symbolStyle.stroke = color;
                        symbolStyle.fill = '#fff';
                    } else {
                        symbolStyle.fill && (symbolStyle.fill = color);
                        symbolStyle.stroke && (symbolStyle.stroke = color);
                    }
                    this.dirty();
                }
            };
            var symbolUtil = {
                createSymbol: function (symbolType, x, y, w, h, color) {
                    var isEmpty = symbolType.indexOf('empty') === 0;
                    if (isEmpty) {
                        symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
                    }
                    var symbolPath;
                    if (symbolType.indexOf('image://') === 0) {
                        symbolPath = new graphic.Image({
                            style: {
                                image: symbolType.slice(8),
                                x: x,
                                y: y,
                                width: w,
                                height: h
                            }
                        });
                    } else if (symbolType.indexOf('path://') === 0) {
                        symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));
                    } else {
                        symbolPath = new Symbol({
                            shape: {
                                symbolType: symbolType,
                                x: x,
                                y: y,
                                width: w,
                                height: h
                            }
                        });
                    }
                    symbolPath.__isEmptyBrush = isEmpty;
                    symbolPath.setColor = symbolPathSetColor;
                    symbolPath.setColor(color);
                    return symbolPath;
                }
            };
            module.exports = symbolUtil;
        },
        function (module, exports) {
            function sign(val) {
                return val >= 0 ? 1 : -1;
            }
            function getStackedOnPoint(coordSys, data, idx) {
                var baseAxis = coordSys.getBaseAxis();
                var valueAxis = coordSys.getOtherAxis(baseAxis);
                var valueStart = baseAxis.onZero ? 0 : valueAxis.scale.getExtent()[0];
                var valueDim = valueAxis.dim;
                var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;
                var stackedOnSameSign;
                var stackedOn = data.stackedOn;
                var val = data.get(valueDim, idx);
                while (stackedOn && sign(stackedOn.get(valueDim, idx)) === sign(val)) {
                    stackedOnSameSign = stackedOn;
                    break;
                }
                var stackedData = [];
                stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
                stackedData[1 - baseDataOffset] = stackedOnSameSign ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;
                return coordSys.dataToPoint(stackedData);
            }
            function diffData(oldData, newData) {
                var diffResult = [];
                newData.diff(oldData).add(function (idx) {
                    diffResult.push({
                        cmd: '+',
                        idx: idx
                    });
                }).update(function (newIdx, oldIdx) {
                    diffResult.push({
                        cmd: '=',
                        idx: oldIdx,
                        idx1: newIdx
                    });
                }).remove(function (idx) {
                    diffResult.push({
                        cmd: '-',
                        idx: idx
                    });
                }).execute();
                return diffResult;
            }
            module.exports = function (oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys) {
                var diff = diffData(oldData, newData);
                var currPoints = [];
                var nextPoints = [];
                var currStackedPoints = [];
                var nextStackedPoints = [];
                var status = [];
                var sortedIndices = [];
                var rawIndices = [];
                var dims = newCoordSys.dimensions;
                for (var i = 0; i < diff.length; i++) {
                    var diffItem = diff[i];
                    var pointAdded = true;
                    switch (diffItem.cmd) {
                    case '=':
                        var currentPt = oldData.getItemLayout(diffItem.idx);
                        var nextPt = newData.getItemLayout(diffItem.idx1);
                        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
                            currentPt = nextPt.slice();
                        }
                        currPoints.push(currentPt);
                        nextPoints.push(nextPt);
                        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
                        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);
                        rawIndices.push(newData.getRawIndex(diffItem.idx1));
                        break;
                    case '+':
                        var idx = diffItem.idx;
                        currPoints.push(oldCoordSys.dataToPoint([
                            newData.get(dims[0], idx, true),
                            newData.get(dims[1], idx, true)
                        ]));
                        nextPoints.push(newData.getItemLayout(idx).slice());
                        currStackedPoints.push(getStackedOnPoint(oldCoordSys, newData, idx));
                        nextStackedPoints.push(newStackedOnPoints[idx]);
                        rawIndices.push(newData.getRawIndex(idx));
                        break;
                    case '-':
                        var idx = diffItem.idx;
                        var rawIndex = oldData.getRawIndex(idx);
                        if (rawIndex !== idx) {
                            currPoints.push(oldData.getItemLayout(idx));
                            nextPoints.push(newCoordSys.dataToPoint([
                                oldData.get(dims[0], idx, true),
                                oldData.get(dims[1], idx, true)
                            ]));
                            currStackedPoints.push(oldStackedOnPoints[idx]);
                            nextStackedPoints.push(getStackedOnPoint(newCoordSys, oldData, idx));
                            rawIndices.push(rawIndex);
                        } else {
                            pointAdded = false;
                        }
                    }
                    if (pointAdded) {
                        status.push(diffItem);
                        sortedIndices.push(sortedIndices.length);
                    }
                }
                sortedIndices.sort(function (a, b) {
                    return rawIndices[a] - rawIndices[b];
                });
                var sortedCurrPoints = [];
                var sortedNextPoints = [];
                var sortedCurrStackedPoints = [];
                var sortedNextStackedPoints = [];
                var sortedStatus = [];
                for (var i = 0; i < sortedIndices.length; i++) {
                    var idx = sortedIndices[i];
                    sortedCurrPoints[i] = currPoints[idx];
                    sortedNextPoints[i] = nextPoints[idx];
                    sortedCurrStackedPoints[i] = currStackedPoints[idx];
                    sortedNextStackedPoints[i] = nextStackedPoints[idx];
                    sortedStatus[i] = status[idx];
                }
                return {
                    current: sortedCurrPoints,
                    next: sortedNextPoints,
                    stackedOnCurrent: sortedCurrStackedPoints,
                    stackedOnNext: sortedNextStackedPoints,
                    status: sortedStatus
                };
            };
        },
        function (module, exports, __webpack_require__) {
            var Path = __webpack_require__(44);
            var vec2 = __webpack_require__(16);
            var vec2Min = vec2.min;
            var vec2Max = vec2.max;
            var scaleAndAdd = vec2.scaleAndAdd;
            var v2Copy = vec2.copy;
            var v = [];
            var cp0 = [];
            var cp1 = [];
            function drawSegment(ctx, points, start, stop, len, dir, smoothMin, smoothMax, smooth, smoothMonotone) {
                var idx = start;
                for (var k = 0; k < len; k++) {
                    var p = points[idx];
                    if (idx >= stop || idx < 0 || isNaN(p[0]) || isNaN(p[1])) {
                        break;
                    }
                    if (idx === start) {
                        ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
                        v2Copy(cp0, p);
                    } else {
                        if (smooth > 0) {
                            var prevIdx = idx - dir;
                            var nextIdx = idx + dir;
                            var ratioNextSeg = 0.5;
                            var prevP = points[prevIdx];
                            var nextP = points[nextIdx];
                            if (dir > 0 && (idx === len - 1 || isNaN(nextP[0]) || isNaN(nextP[1])) || dir <= 0 && (idx === 0 || isNaN(nextP[0]) || isNaN(nextP[1]))) {
                                v2Copy(cp1, p);
                            } else {
                                if (isNaN(nextP[0]) || isNaN(nextP[1])) {
                                    nextP = p;
                                }
                                vec2.sub(v, nextP, prevP);
                                var lenPrevSeg;
                                var lenNextSeg;
                                if (smoothMonotone === 'x' || smoothMonotone === 'y') {
                                    var dim = smoothMonotone === 'x' ? 0 : 1;
                                    lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
                                    lenNextSeg = Math.abs(p[dim] - nextP[dim]);
                                } else {
                                    lenPrevSeg = vec2.dist(p, prevP);
                                    lenNextSeg = vec2.dist(p, nextP);
                                }
                                ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);
                                scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));
                            }
                            vec2Min(cp0, cp0, smoothMax);
                            vec2Max(cp0, cp0, smoothMin);
                            vec2Min(cp1, cp1, smoothMax);
                            vec2Max(cp1, cp1, smoothMin);
                            ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);
                            scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);
                        } else {
                            ctx.lineTo(p[0], p[1]);
                        }
                    }
                    idx += dir;
                }
                return k;
            }
            function getBoundingBox(points, smoothConstraint) {
                var ptMin = [
                    Infinity,
                    Infinity
                ];
                var ptMax = [
                    -Infinity,
                    -Infinity
                ];
                if (smoothConstraint) {
                    for (var i = 0; i < points.length; i++) {
                        var pt = points[i];
                        if (pt[0] < ptMin[0]) {
                            ptMin[0] = pt[0];
                        }
                        if (pt[1] < ptMin[1]) {
                            ptMin[1] = pt[1];
                        }
                        if (pt[0] > ptMax[0]) {
                            ptMax[0] = pt[0];
                        }
                        if (pt[1] > ptMax[1]) {
                            ptMax[1] = pt[1];
                        }
                    }
                }
                return {
                    min: smoothConstraint ? ptMin : ptMax,
                    max: smoothConstraint ? ptMax : ptMin
                };
            }
            module.exports = {
                Polyline: Path.extend({
                    type: 'ec-polyline',
                    shape: {
                        points: [],
                        smooth: 0,
                        smoothConstraint: true,
                        smoothMonotone: null
                    },
                    style: {
                        fill: null,
                        stroke: '#000'
                    },
                    buildPath: function (ctx, shape) {
                        var points = shape.points;
                        var i = 0;
                        var len = points.length;
                        var result = getBoundingBox(points, shape.smoothConstraint);
                        while (i < len) {
                            i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone) + 1;
                        }
                    }
                }),
                Polygon: Path.extend({
                    type: 'ec-polygon',
                    shape: {
                        points: [],
                        stackedOnPoints: [],
                        smooth: 0,
                        stackedOnSmooth: 0,
                        smoothConstraint: true,
                        smoothMonotone: null
                    },
                    buildPath: function (ctx, shape) {
                        var points = shape.points;
                        var stackedOnPoints = shape.stackedOnPoints;
                        var i = 0;
                        var len = points.length;
                        var smoothMonotone = shape.smoothMonotone;
                        var bbox = getBoundingBox(points, shape.smoothConstraint);
                        var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);
                        while (i < len) {
                            var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone);
                            drawSegment(ctx, stackedOnPoints, i + k - 1, len, k, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone);
                            i += k + 1;
                            ctx.closePath();
                        }
                    }
                })
            };
        },
        function (module, exports) {
            module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {
                ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {
                    var data = seriesModel.getData();
                    var symbolType = seriesModel.get('symbol') || defaultSymbolType;
                    var symbolSize = seriesModel.get('symbolSize');
                    data.setVisual({
                        legendSymbol: legendSymbol || symbolType,
                        symbol: symbolType,
                        symbolSize: symbolSize
                    });
                    if (!ecModel.isSeriesFiltered(seriesModel)) {
                        if (typeof symbolSize === 'function') {
                            data.each(function (idx) {
                                var rawValue = seriesModel.getRawValue(idx);
                                var params = seriesModel.getDataParams(idx);
                                data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));
                            });
                        }
                        data.each(function (idx) {
                            var itemModel = data.getItemModel(idx);
                            var itemSymbolType = itemModel.get('symbol', true);
                            var itemSymbolSize = itemModel.get('symbolSize', true);
                            if (itemSymbolType != null) {
                                data.setItemVisual(idx, 'symbol', itemSymbolType);
                            }
                            if (itemSymbolSize != null) {
                                data.setItemVisual(idx, 'symbolSize', itemSymbolSize);
                            }
                        });
                    }
                });
            };
        },
        function (module, exports) {
            module.exports = function (seriesType, ecModel, api) {
                ecModel.eachSeriesByType(seriesType, function (seriesModel) {
                    var data = seriesModel.getData();
                    var coordSys = seriesModel.coordinateSystem;
                    var dims = coordSys.dimensions;
                    data.each(dims, function (x, y, idx) {
                        var point;
                        if (!isNaN(x) && !isNaN(y)) {
                            point = coordSys.dataToPoint([
                                x,
                                y
                            ]);
                        } else {
                            point = [
                                NaN,
                                NaN
                            ];
                        }
                        data.setItemLayout(idx, point);
                    }, true);
                });
            };
        },
        function (module, exports) {
            var samplers = {
                average: function (frame) {
                    var sum = 0;
                    var count = 0;
                    for (var i = 0; i < frame.length; i++) {
                        if (!isNaN(frame[i])) {
                            sum += frame[i];
                            count++;
                        }
                    }
                    return count === 0 ? NaN : sum / count;
                },
                sum: function (frame) {
                    var sum = 0;
                    for (var i = 0; i < frame.length; i++) {
                        sum += frame[i] || 0;
                    }
                    return sum;
                },
                max: function (frame) {
                    var max = -Infinity;
                    for (var i = 0; i < frame.length; i++) {
                        frame[i] > max && (max = frame[i]);
                    }
                    return max;
                },
                min: function (frame) {
                    var min = Infinity;
                    for (var i = 0; i < frame.length; i++) {
                        frame[i] < min && (min = frame[i]);
                    }
                    return min;
                },
                nearest: function (frame) {
                    return frame[0];
                }
            };
            var indexSampler = function (frame, value) {
                return Math.round(frame.length / 2);
            };
            module.exports = function (seriesType, ecModel, api) {
                ecModel.eachSeriesByType(seriesType, function (seriesModel) {
                    var data = seriesModel.getData();
                    var sampling = seriesModel.get('sampling');
                    var coordSys = seriesModel.coordinateSystem;
                    if (coordSys.type === 'cartesian2d' && sampling) {
                        var baseAxis = coordSys.getBaseAxis();
                        var valueAxis = coordSys.getOtherAxis(baseAxis);
                        var extent = baseAxis.getExtent();
                        var size = extent[1] - extent[0];
                        var rate = Math.round(data.count() / size);
                        if (rate > 1) {
                            var sampler;
                            if (typeof sampling === 'string') {
                                sampler = samplers[sampling];
                            } else if (typeof sampling === 'function') {
                                sampler = sampling;
                            }
                            if (sampler) {
                                data = data.downSample(valueAxis.dim, 1 / rate, sampler, indexSampler);
                                seriesModel.setData(data);
                            }
                        }
                    }
                }, this);
            };
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var graphic = __webpack_require__(42);
            var zrUtil = __webpack_require__(3);
            __webpack_require__(107);
            __webpack_require__(124);
            __webpack_require__(1).extendComponentView({
                type: 'grid',
                render: function (gridModel, ecModel) {
                    this.group.removeAll();
                    if (gridModel.get('show')) {
                        this.group.add(new graphic.Rect({
                            shape: gridModel.coordinateSystem.getRect(),
                            style: zrUtil.defaults({ fill: gridModel.get('backgroundColor') }, gridModel.getItemStyle()),
                            silent: true
                        }));
                    }
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var factory = exports;
            var layout = __webpack_require__(21);
            var axisHelper = __webpack_require__(108);
            var zrUtil = __webpack_require__(3);
            var Cartesian2D = __webpack_require__(114);
            var Axis2D = __webpack_require__(116);
            var each = zrUtil.each;
            var ifAxisCrossZero = axisHelper.ifAxisCrossZero;
            var niceScaleExtent = axisHelper.niceScaleExtent;
            __webpack_require__(119);
            function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
                return ecModel.getComponent('grid', axisModel.get('gridIndex')) === gridModel;
            }
            function getLabelUnionRect(axis) {
                var axisModel = axis.model;
                var labels = axisModel.getFormattedLabels();
                var rect;
                var step = 1;
                var labelCount = labels.length;
                if (labelCount > 40) {
                    step = Math.ceil(labelCount / 40);
                }
                for (var i = 0; i < labelCount; i += step) {
                    if (!axis.isLabelIgnored(i)) {
                        var singleRect = axisModel.getTextRect(labels[i]);
                        rect ? rect.union(singleRect) : rect = singleRect;
                    }
                }
                return rect;
            }
            function Grid(gridModel, ecModel, api) {
                this._coordsMap = {};
                this._coordsList = [];
                this._axesMap = {};
                this._axesList = [];
                this._initCartesian(gridModel, ecModel, api);
                this._model = gridModel;
            }
            var gridProto = Grid.prototype;
            gridProto.type = 'grid';
            gridProto.getRect = function () {
                return this._rect;
            };
            gridProto.update = function (ecModel, api) {
                var axesMap = this._axesMap;
                this._updateScale(ecModel, this._model);
                function ifAxisCanNotOnZero(otherAxisDim) {
                    var axes = axesMap[otherAxisDim];
                    for (var idx in axes) {
                        var axis = axes[idx];
                        if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {
                            return true;
                        }
                    }
                    return false;
                }
                each(axesMap.x, function (xAxis) {
                    niceScaleExtent(xAxis, xAxis.model);
                });
                each(axesMap.y, function (yAxis) {
                    niceScaleExtent(yAxis, yAxis.model);
                });
                each(axesMap.x, function (xAxis) {
                    if (ifAxisCanNotOnZero('y')) {
                        xAxis.onZero = false;
                    }
                });
                each(axesMap.y, function (yAxis) {
                    if (ifAxisCanNotOnZero('x')) {
                        yAxis.onZero = false;
                    }
                });
                this.resize(this._model, api);
            };
            gridProto.resize = function (gridModel, api) {
                var gridRect = layout.getLayoutRect(gridModel.getBoxLayoutParams(), {
                    width: api.getWidth(),
                    height: api.getHeight()
                });
                this._rect = gridRect;
                var axesList = this._axesList;
                adjustAxes();
                if (gridModel.get('containLabel')) {
                    each(axesList, function (axis) {
                        if (!axis.model.get('axisLabel.inside')) {
                            var labelUnionRect = getLabelUnionRect(axis);
                            if (labelUnionRect) {
                                var dim = axis.isHorizontal() ? 'height' : 'width';
                                var margin = axis.model.get('axisLabel.margin');
                                gridRect[dim] -= labelUnionRect[dim] + margin;
                                if (axis.position === 'top') {
                                    gridRect.y += labelUnionRect.height + margin;
                                } else if (axis.position === 'left') {
                                    gridRect.x += labelUnionRect.width + margin;
                                }
                            }
                        }
                    });
                    adjustAxes();
                }
                function adjustAxes() {
                    each(axesList, function (axis) {
                        var isHorizontal = axis.isHorizontal();
                        var extent = isHorizontal ? [
                            0,
                            gridRect.width
                        ] : [
                            0,
                            gridRect.height
                        ];
                        var idx = axis.inverse ? 1 : 0;
                        axis.setExtent(extent[idx], extent[1 - idx]);
                        updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);
                    });
                }
            };
            gridProto.getAxis = function (axisType, axisIndex) {
                var axesMapOnDim = this._axesMap[axisType];
                if (axesMapOnDim != null) {
                    if (axisIndex == null) {
                        for (var name in axesMapOnDim) {
                            return axesMapOnDim[name];
                        }
                    }
                    return axesMapOnDim[axisIndex];
                }
            };
            gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {
                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
                return this._coordsMap[key];
            };
            gridProto._initCartesian = function (gridModel, ecModel, api) {
                var axisPositionUsed = {
                    left: false,
                    right: false,
                    top: false,
                    bottom: false
                };
                var axesMap = {
                    x: {},
                    y: {}
                };
                var axesCount = {
                    x: 0,
                    y: 0
                };
                ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
                ecModel.eachComponent('yAxis', createAxisCreator('y'), this);
                if (!axesCount.x || !axesCount.y) {
                    this._axesMap = {};
                    this._axesList = [];
                    return;
                }
                this._axesMap = axesMap;
                each(axesMap.x, function (xAxis, xAxisIndex) {
                    each(axesMap.y, function (yAxis, yAxisIndex) {
                        var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
                        var cartesian = new Cartesian2D(key);
                        cartesian.grid = this;
                        this._coordsMap[key] = cartesian;
                        this._coordsList.push(cartesian);
                        cartesian.addAxis(xAxis);
                        cartesian.addAxis(yAxis);
                    }, this);
                }, this);
                function createAxisCreator(axisType) {
                    return function (axisModel, idx) {
                        if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {
                            return;
                        }
                        var axisPosition = axisModel.get('position');
                        if (axisType === 'x') {
                            if (axisPosition !== 'top' && axisPosition !== 'bottom') {
                                axisPosition = 'bottom';
                            }
                            if (axisPositionUsed[axisPosition]) {
                                axisPosition = axisPosition === 'top' ? 'bottom' : 'top';
                            }
                        } else {
                            if (axisPosition !== 'left' && axisPosition !== 'right') {
                                axisPosition = 'left';
                            }
                            if (axisPositionUsed[axisPosition]) {
                                axisPosition = axisPosition === 'left' ? 'right' : 'left';
                            }
                        }
                        axisPositionUsed[axisPosition] = true;
                        var axis = new Axis2D(axisType, axisHelper.createScaleByModel(axisModel), [
                            0,
                            0
                        ], axisModel.get('type'), axisPosition);
                        var isCategory = axis.type === 'category';
                        axis.onBand = isCategory && axisModel.get('boundaryGap');
                        axis.inverse = axisModel.get('inverse');
                        axis.onZero = axisModel.get('axisLine.onZero');
                        axisModel.axis = axis;
                        axis.model = axisModel;
                        axis.index = idx;
                        this._axesList.push(axis);
                        axesMap[axisType][idx] = axis;
                        axesCount[axisType]++;
                    };
                }
            };
            gridProto._updateScale = function (ecModel, gridModel) {
                zrUtil.each(this._axesList, function (axis) {
                    axis.scale.setExtent(Infinity, -Infinity);
                });
                ecModel.eachSeries(function (seriesModel) {
                    if (seriesModel.get('coordinateSystem') === 'cartesian2d') {
                        var xAxisIndex = seriesModel.get('xAxisIndex');
                        var yAxisIndex = seriesModel.get('yAxisIndex');
                        var xAxisModel = ecModel.getComponent('xAxis', xAxisIndex);
                        var yAxisModel = ecModel.getComponent('yAxis', yAxisIndex);
                        if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)) {
                            return;
                        }
                        var cartesian = this.getCartesian(xAxisIndex, yAxisIndex);
                        var data = seriesModel.getData();
                        var xAxis = cartesian.getAxis('x');
                        var yAxis = cartesian.getAxis('y');
                        if (data.type === 'list') {
                            unionExtent(data, xAxis, seriesModel);
                            unionExtent(data, yAxis, seriesModel);
                        }
                    }
                }, this);
                function unionExtent(data, axis, seriesModel) {
                    each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {
                        axis.scale.unionExtent(data.getDataExtent(dim, axis.scale.type !== 'ordinal'));
                    });
                }
            };
            function updateAxisTransfrom(axis, coordBase) {
                var axisExtent = axis.getExtent();
                var axisExtentSum = axisExtent[0] + axisExtent[1];
                axis.toGlobalCoord = axis.dim === 'x' ? function (coord) {
                    return coord + coordBase;
                } : function (coord) {
                    return axisExtentSum - coord + coordBase;
                };
                axis.toLocalCoord = axis.dim === 'x' ? function (coord) {
                    return coord - coordBase;
                } : function (coord) {
                    return axisExtentSum - coord + coordBase;
                };
            }
            Grid.create = function (ecModel, api) {
                var grids = [];
                ecModel.eachComponent('grid', function (gridModel, idx) {
                    var grid = new Grid(gridModel, ecModel, api);
                    grid.name = 'grid_' + idx;
                    grid.resize(gridModel, api);
                    gridModel.coordinateSystem = grid;
                    grids.push(grid);
                });
                ecModel.eachSeries(function (seriesModel) {
                    if (seriesModel.get('coordinateSystem') !== 'cartesian2d') {
                        return;
                    }
                    var xAxisIndex = seriesModel.get('xAxisIndex');
                    var xAxisModel = ecModel.getComponent('xAxis', xAxisIndex);
                    var grid = grids[xAxisModel.get('gridIndex')];
                    seriesModel.coordinateSystem = grid.getCartesian(xAxisIndex, seriesModel.get('yAxisIndex'));
                });
                return grids;
            };
            Grid.dimensions = Cartesian2D.prototype.dimensions;
            __webpack_require__(25).register('cartesian2d', Grid);
            module.exports = Grid;
        },
        function (module, exports, __webpack_require__) {
            var OrdinalScale = __webpack_require__(109);
            var IntervalScale = __webpack_require__(111);
            __webpack_require__(112);
            __webpack_require__(113);
            var Scale = __webpack_require__(110);
            var numberUtil = __webpack_require__(7);
            var zrUtil = __webpack_require__(3);
            var textContain = __webpack_require__(14);
            var axisHelper = {};
            axisHelper.getScaleExtent = function (axis, model) {
                var scale = axis.scale;
                var originalExtent = scale.getExtent();
                var span = originalExtent[1] - originalExtent[0];
                if (scale.type === 'ordinal') {
                    if (!isFinite(span)) {
                        return [
                            0,
                            0
                        ];
                    } else {
                        return originalExtent;
                    }
                }
                var min = model.getMin ? model.getMin() : model.get('min');
                var max = model.getMax ? model.getMax() : model.get('max');
                var crossZero = model.getNeedCrossZero ? model.getNeedCrossZero() : !model.get('scale');
                var boundaryGap = model.get('boundaryGap');
                if (!zrUtil.isArray(boundaryGap)) {
                    boundaryGap = [
                        boundaryGap || 0,
                        boundaryGap || 0
                    ];
                }
                boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);
                boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);
                var fixMin = true;
                var fixMax = true;
                if (min == null) {
                    min = originalExtent[0] - boundaryGap[0] * span;
                    fixMin = false;
                }
                if (max == null) {
                    max = originalExtent[1] + boundaryGap[1] * span;
                    fixMax = false;
                }
                if (min === 'dataMin') {
                    min = originalExtent[0];
                }
                if (max === 'dataMax') {
                    max = originalExtent[1];
                }
                if (crossZero) {
                    if (min > 0 && max > 0 && !fixMin) {
                        min = 0;
                    }
                    if (min < 0 && max < 0 && !fixMax) {
                        max = 0;
                    }
                }
                return [
                    min,
                    max
                ];
            };
            axisHelper.niceScaleExtent = function (axis, model) {
                var scale = axis.scale;
                var extent = axisHelper.getScaleExtent(axis, model);
                var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;
                var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;
                scale.setExtent(extent[0], extent[1]);
                scale.niceExtent(model.get('splitNumber'), fixMin, fixMax);
                var interval = model.get('interval');
                if (interval != null) {
                    scale.setInterval && scale.setInterval(interval);
                }
            };
            axisHelper.createScaleByModel = function (model, axisType) {
                axisType = axisType || model.get('type');
                if (axisType) {
                    switch (axisType) {
                    case 'category':
                        return new OrdinalScale(model.getCategories(), [
                            Infinity,
                            -Infinity
                        ]);
                    case 'value':
                        return new IntervalScale();
                    default:
                        return (Scale.getClass(axisType) || IntervalScale).create(model);
                    }
                }
            };
            axisHelper.ifAxisCrossZero = function (axis) {
                var dataExtent = axis.scale.getExtent();
                var min = dataExtent[0];
                var max = dataExtent[1];
                return !(min > 0 && max > 0 || min < 0 && max < 0);
            };
            axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {
                var textSpaceTakenRect;
                var autoLabelInterval = 0;
                var accumulatedLabelInterval = 0;
                var step = 1;
                if (labels.length > 40) {
                    step = Math.round(labels.length / 40);
                }
                for (var i = 0; i < tickCoords.length; i += step) {
                    var tickCoord = tickCoords[i];
                    var rect = textContain.getBoundingRect(labels[i], font, 'center', 'top');
                    rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;
                    rect[isAxisHorizontal ? 'width' : 'height'] *= 1.5;
                    if (!textSpaceTakenRect) {
                        textSpaceTakenRect = rect.clone();
                    } else if (textSpaceTakenRect.intersect(rect)) {
                        accumulatedLabelInterval++;
                        autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);
                    } else {
                        textSpaceTakenRect.union(rect);
                        accumulatedLabelInterval = 0;
                    }
                }
                if (autoLabelInterval === 0 && step > 1) {
                    return step;
                }
                return autoLabelInterval * step;
            };
            axisHelper.getFormattedLabels = function (axis, labelFormatter) {
                var scale = axis.scale;
                var labels = scale.getTicksLabels();
                var ticks = scale.getTicks();
                if (typeof labelFormatter === 'string') {
                    labelFormatter = function (tpl) {
                        return function (val) {
                            return tpl.replace('{value}', val);
                        };
                    }(labelFormatter);
                    return zrUtil.map(labels, labelFormatter);
                } else if (typeof labelFormatter === 'function') {
                    return zrUtil.map(ticks, function (tick, idx) {
                        return labelFormatter(axis.type === 'category' ? scale.getLabel(tick) : tick, idx);
                    }, this);
                } else {
                    return labels;
                }
            };
            module.exports = axisHelper;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var Scale = __webpack_require__(110);
            var scaleProto = Scale.prototype;
            var OrdinalScale = Scale.extend({
                type: 'ordinal',
                init: function (data, extent) {
                    this._data = data;
                    this._extent = extent || [
                        0,
                        data.length - 1
                    ];
                },
                parse: function (val) {
                    return typeof val === 'string' ? zrUtil.indexOf(this._data, val) : Math.round(val);
                },
                contain: function (rank) {
                    rank = this.parse(rank);
                    return scaleProto.contain.call(this, rank) && this._data[rank] != null;
                },
                normalize: function (val) {
                    return scaleProto.normalize.call(this, this.parse(val));
                },
                scale: function (val) {
                    return Math.round(scaleProto.scale.call(this, val));
                },
                getTicks: function () {
                    var ticks = [];
                    var extent = this._extent;
                    var rank = extent[0];
                    while (rank <= extent[1]) {
                        ticks.push(rank);
                        rank++;
                    }
                    return ticks;
                },
                getLabel: function (n) {
                    return this._data[n];
                },
                count: function () {
                    return this._extent[1] - this._extent[0] + 1;
                },
                niceTicks: zrUtil.noop,
                niceExtent: zrUtil.noop
            });
            OrdinalScale.create = function () {
                return new OrdinalScale();
            };
            module.exports = OrdinalScale;
        },
        function (module, exports, __webpack_require__) {
            var clazzUtil = __webpack_require__(9);
            function Scale() {
                this._extent = [
                    Infinity,
                    -Infinity
                ];
                this._interval = 0;
                this.init && this.init.apply(this, arguments);
            }
            var scaleProto = Scale.prototype;
            scaleProto.parse = function (val) {
                return val;
            };
            scaleProto.contain = function (val) {
                var extent = this._extent;
                return val >= extent[0] && val <= extent[1];
            };
            scaleProto.normalize = function (val) {
                var extent = this._extent;
                if (extent[1] === extent[0]) {
                    return 0.5;
                }
                return (val - extent[0]) / (extent[1] - extent[0]);
            };
            scaleProto.scale = function (val) {
                var extent = this._extent;
                return val * (extent[1] - extent[0]) + extent[0];
            };
            scaleProto.unionExtent = function (other) {
                var extent = this._extent;
                other[0] < extent[0] && (extent[0] = other[0]);
                other[1] > extent[1] && (extent[1] = other[1]);
            };
            scaleProto.getExtent = function () {
                return this._extent.slice();
            };
            scaleProto.setExtent = function (start, end) {
                var thisExtent = this._extent;
                if (!isNaN(start)) {
                    thisExtent[0] = start;
                }
                if (!isNaN(end)) {
                    thisExtent[1] = end;
                }
            };
            scaleProto.getTicksLabels = function () {
                var labels = [];
                var ticks = this.getTicks();
                for (var i = 0; i < ticks.length; i++) {
                    labels.push(this.getLabel(ticks[i]));
                }
                return labels;
            };
            clazzUtil.enableClassExtend(Scale);
            clazzUtil.enableClassManagement(Scale, { registerWhenExtend: true });
            module.exports = Scale;
        },
        function (module, exports, __webpack_require__) {
            var numberUtil = __webpack_require__(7);
            var formatUtil = __webpack_require__(6);
            var Scale = __webpack_require__(110);
            var mathFloor = Math.floor;
            var mathCeil = Math.ceil;
            var IntervalScale = Scale.extend({
                type: 'interval',
                _interval: 0,
                setExtent: function (start, end) {
                    var thisExtent = this._extent;
                    if (!isNaN(start)) {
                        thisExtent[0] = parseFloat(start);
                    }
                    if (!isNaN(end)) {
                        thisExtent[1] = parseFloat(end);
                    }
                },
                unionExtent: function (other) {
                    var extent = this._extent;
                    other[0] < extent[0] && (extent[0] = other[0]);
                    other[1] > extent[1] && (extent[1] = other[1]);
                    IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
                },
                getInterval: function () {
                    if (!this._interval) {
                        this.niceTicks();
                    }
                    return this._interval;
                },
                setInterval: function (interval) {
                    this._interval = interval;
                    this._niceExtent = this._extent.slice();
                },
                getTicks: function () {
                    if (!this._interval) {
                        this.niceTicks();
                    }
                    var interval = this._interval;
                    var extent = this._extent;
                    var ticks = [];
                    var safeLimit = 10000;
                    if (interval) {
                        var niceExtent = this._niceExtent;
                        if (extent[0] < niceExtent[0]) {
                            ticks.push(extent[0]);
                        }
                        var tick = niceExtent[0];
                        while (tick <= niceExtent[1]) {
                            ticks.push(tick);
                            tick = numberUtil.round(tick + interval);
                            if (ticks.length > safeLimit) {
                                return [];
                            }
                        }
                        if (extent[1] > niceExtent[1]) {
                            ticks.push(extent[1]);
                        }
                    }
                    return ticks;
                },
                getTicksLabels: function () {
                    var labels = [];
                    var ticks = this.getTicks();
                    for (var i = 0; i < ticks.length; i++) {
                        labels.push(this.getLabel(ticks[i]));
                    }
                    return labels;
                },
                getLabel: function (data) {
                    return formatUtil.addCommas(data);
                },
                niceTicks: function (splitNumber) {
                    splitNumber = splitNumber || 5;
                    var extent = this._extent;
                    var span = extent[1] - extent[0];
                    if (!isFinite(span)) {
                        return;
                    }
                    if (span < 0) {
                        span = -span;
                        extent.reverse();
                    }
                    var step = numberUtil.nice(span / splitNumber, true);
                    var niceExtent = [
                        numberUtil.round(mathCeil(extent[0] / step) * step),
                        numberUtil.round(mathFloor(extent[1] / step) * step)
                    ];
                    this._interval = step;
                    this._niceExtent = niceExtent;
                },
                niceExtent: function (splitNumber, fixMin, fixMax) {
                    var extent = this._extent;
                    if (extent[0] === extent[1]) {
                        if (extent[0] !== 0) {
                            var expandSize = extent[0] / 2;
                            extent[0] -= expandSize;
                            extent[1] += expandSize;
                        } else {
                            extent[1] = 1;
                        }
                    }
                    var span = extent[1] - extent[0];
                    if (!isFinite(span)) {
                        extent[0] = 0;
                        extent[1] = 1;
                    }
                    this.niceTicks(splitNumber);
                    var interval = this._interval;
                    if (!fixMin) {
                        extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
                    }
                    if (!fixMax) {
                        extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
                    }
                }
            });
            IntervalScale.create = function () {
                return new IntervalScale();
            };
            module.exports = IntervalScale;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var numberUtil = __webpack_require__(7);
            var formatUtil = __webpack_require__(6);
            var IntervalScale = __webpack_require__(111);
            var intervalScaleProto = IntervalScale.prototype;
            var mathCeil = Math.ceil;
            var mathFloor = Math.floor;
            var ONE_DAY = 3600000 * 24;
            var bisect = function (a, x, lo, hi) {
                while (lo < hi) {
                    var mid = lo + hi >>> 1;
                    if (a[mid][2] < x) {
                        lo = mid + 1;
                    } else {
                        hi = mid;
                    }
                }
                return lo;
            };
            var TimeScale = IntervalScale.extend({
                type: 'time',
                getLabel: function (val) {
                    var stepLvl = this._stepLvl;
                    var date = new Date(val);
                    return formatUtil.formatTime(stepLvl[0], date);
                },
                niceExtent: function (approxTickNum, fixMin, fixMax) {
                    var extent = this._extent;
                    if (extent[0] === extent[1]) {
                        extent[0] -= ONE_DAY;
                        extent[1] += ONE_DAY;
                    }
                    if (extent[1] === -Infinity && extent[0] === Infinity) {
                        var d = new Date();
                        extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());
                        extent[0] = extent[1] - ONE_DAY;
                    }
                    this.niceTicks(approxTickNum, fixMin, fixMax);
                    var interval = this._interval;
                    if (!fixMin) {
                        extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
                    }
                    if (!fixMax) {
                        extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
                    }
                },
                niceTicks: function (approxTickNum) {
                    approxTickNum = approxTickNum || 10;
                    var extent = this._extent;
                    var span = extent[1] - extent[0];
                    var approxInterval = span / approxTickNum;
                    var scaleLevelsLen = scaleLevels.length;
                    var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);
                    var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
                    var interval = level[2];
                    if (level[0] === 'year') {
                        var yearSpan = span / interval;
                        var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);
                        interval *= yearStep;
                    }
                    var niceExtent = [
                        mathCeil(extent[0] / interval) * interval,
                        mathFloor(extent[1] / interval) * interval
                    ];
                    this._stepLvl = level;
                    this._interval = interval;
                    this._niceExtent = niceExtent;
                },
                parse: function (val) {
                    return +numberUtil.parseDate(val);
                }
            });
            zrUtil.each([
                'contain',
                'normalize'
            ], function (methodName) {
                TimeScale.prototype[methodName] = function (val) {
                    return intervalScaleProto[methodName].call(this, this.parse(val));
                };
            });
            var scaleLevels = [
                [
                    'hh:mm:ss',
                    1,
                    1000
                ],
                [
                    'hh:mm:ss',
                    5,
                    1000 * 5
                ],
                [
                    'hh:mm:ss',
                    10,
                    1000 * 10
                ],
                [
                    'hh:mm:ss',
                    15,
                    1000 * 15
                ],
                [
                    'hh:mm:ss',
                    30,
                    1000 * 30
                ],
                [
                    'hh:mm\nMM-dd',
                    1,
                    60000
                ],
                [
                    'hh:mm\nMM-dd',
                    5,
                    60000 * 5
                ],
                [
                    'hh:mm\nMM-dd',
                    10,
                    60000 * 10
                ],
                [
                    'hh:mm\nMM-dd',
                    15,
                    60000 * 15
                ],
                [
                    'hh:mm\nMM-dd',
                    30,
                    60000 * 30
                ],
                [
                    'hh:mm\nMM-dd',
                    1,
                    3600000
                ],
                [
                    'hh:mm\nMM-dd',
                    2,
                    3600000 * 2
                ],
                [
                    'hh:mm\nMM-dd',
                    6,
                    3600000 * 6
                ],
                [
                    'hh:mm\nMM-dd',
                    12,
                    3600000 * 12
                ],
                [
                    'MM-dd\nyyyy',
                    1,
                    ONE_DAY
                ],
                [
                    'week',
                    7,
                    ONE_DAY * 7
                ],
                [
                    'month',
                    1,
                    ONE_DAY * 31
                ],
                [
                    'quarter',
                    3,
                    ONE_DAY * 380 / 4
                ],
                [
                    'half-year',
                    6,
                    ONE_DAY * 380 / 2
                ],
                [
                    'year',
                    1,
                    ONE_DAY * 380
                ]
            ];
            TimeScale.create = function () {
                return new TimeScale();
            };
            module.exports = TimeScale;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var Scale = __webpack_require__(110);
            var numberUtil = __webpack_require__(7);
            var IntervalScale = __webpack_require__(111);
            var scaleProto = Scale.prototype;
            var intervalScaleProto = IntervalScale.prototype;
            var mathFloor = Math.floor;
            var mathCeil = Math.ceil;
            var mathPow = Math.pow;
            var LOG_BASE = 10;
            var mathLog = Math.log;
            var LogScale = Scale.extend({
                type: 'log',
                getTicks: function () {
                    return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {
                        return numberUtil.round(mathPow(LOG_BASE, val));
                    });
                },
                getLabel: intervalScaleProto.getLabel,
                scale: function (val) {
                    val = scaleProto.scale.call(this, val);
                    return mathPow(LOG_BASE, val);
                },
                setExtent: function (start, end) {
                    start = mathLog(start) / mathLog(LOG_BASE);
                    end = mathLog(end) / mathLog(LOG_BASE);
                    intervalScaleProto.setExtent.call(this, start, end);
                },
                getExtent: function () {
                    var extent = scaleProto.getExtent.call(this);
                    extent[0] = mathPow(LOG_BASE, extent[0]);
                    extent[1] = mathPow(LOG_BASE, extent[1]);
                    return extent;
                },
                unionExtent: function (extent) {
                    extent[0] = mathLog(extent[0]) / mathLog(LOG_BASE);
                    extent[1] = mathLog(extent[1]) / mathLog(LOG_BASE);
                    scaleProto.unionExtent.call(this, extent);
                },
                niceTicks: function (approxTickNum) {
                    approxTickNum = approxTickNum || 10;
                    var extent = this._extent;
                    var span = extent[1] - extent[0];
                    if (span === Infinity || span <= 0) {
                        return;
                    }
                    var interval = mathPow(10, mathFloor(mathLog(span / approxTickNum) / Math.LN10));
                    var err = approxTickNum / span * interval;
                    if (err <= 0.5) {
                        interval *= 10;
                    }
                    var niceExtent = [
                        numberUtil.round(mathCeil(extent[0] / interval) * interval),
                        numberUtil.round(mathFloor(extent[1] / interval) * interval)
                    ];
                    this._interval = interval;
                    this._niceExtent = niceExtent;
                },
                niceExtent: intervalScaleProto.niceExtent
            });
            zrUtil.each([
                'contain',
                'normalize'
            ], function (methodName) {
                LogScale.prototype[methodName] = function (val) {
                    val = mathLog(val) / mathLog(LOG_BASE);
                    return scaleProto[methodName].call(this, val);
                };
            });
            LogScale.create = function () {
                return new LogScale();
            };
            module.exports = LogScale;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var Cartesian = __webpack_require__(115);
            function Cartesian2D(name) {
                Cartesian.call(this, name);
            }
            Cartesian2D.prototype = {
                constructor: Cartesian2D,
                type: 'cartesian2d',
                dimensions: [
                    'x',
                    'y'
                ],
                getBaseAxis: function () {
                    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x');
                },
                containPoint: function (point) {
                    var axisX = this.getAxis('x');
                    var axisY = this.getAxis('y');
                    return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]));
                },
                containData: function (data) {
                    return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1]);
                },
                dataToPoints: function (data, stack) {
                    return data.mapArray([
                        'x',
                        'y'
                    ], function (x, y) {
                        return this.dataToPoint([
                            x,
                            y
                        ]);
                    }, stack, this);
                },
                dataToPoint: function (data, clamp) {
                    var xAxis = this.getAxis('x');
                    var yAxis = this.getAxis('y');
                    return [
                        xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),
                        yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))
                    ];
                },
                pointToData: function (point, clamp) {
                    var xAxis = this.getAxis('x');
                    var yAxis = this.getAxis('y');
                    return [
                        xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),
                        yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)
                    ];
                },
                getOtherAxis: function (axis) {
                    return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
                }
            };
            zrUtil.inherits(Cartesian2D, Cartesian);
            module.exports = Cartesian2D;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            function dimAxisMapper(dim) {
                return this._axes[dim];
            }
            var Cartesian = function (name) {
                this._axes = {};
                this._dimList = [];
                this.name = name || '';
            };
            Cartesian.prototype = {
                constructor: Cartesian,
                type: 'cartesian',
                getAxis: function (dim) {
                    return this._axes[dim];
                },
                getAxes: function () {
                    return zrUtil.map(this._dimList, dimAxisMapper, this);
                },
                getAxesByScale: function (scaleType) {
                    scaleType = scaleType.toLowerCase();
                    return zrUtil.filter(this.getAxes(), function (axis) {
                        return axis.scale.type === scaleType;
                    });
                },
                addAxis: function (axis) {
                    var dim = axis.dim;
                    this._axes[dim] = axis;
                    this._dimList.push(dim);
                },
                dataToCoord: function (val) {
                    return this._dataCoordConvert(val, 'dataToCoord');
                },
                coordToData: function (val) {
                    return this._dataCoordConvert(val, 'coordToData');
                },
                _dataCoordConvert: function (input, method) {
                    var dimList = this._dimList;
                    var output = input instanceof Array ? [] : {};
                    for (var i = 0; i < dimList.length; i++) {
                        var dim = dimList[i];
                        var axis = this._axes[dim];
                        output[dim] = axis[method](input[dim]);
                    }
                    return output;
                }
            };
            module.exports = Cartesian;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var Axis = __webpack_require__(117);
            var axisLabelInterval = __webpack_require__(118);
            var Axis2D = function (dim, scale, coordExtent, axisType, position) {
                Axis.call(this, dim, scale, coordExtent);
                this.type = axisType || 'value';
                this.position = position || 'bottom';
            };
            Axis2D.prototype = {
                constructor: Axis2D,
                index: 0,
                onZero: false,
                model: null,
                isHorizontal: function () {
                    var position = this.position;
                    return position === 'top' || position === 'bottom';
                },
                getGlobalExtent: function () {
                    var ret = this.getExtent();
                    ret[0] = this.toGlobalCoord(ret[0]);
                    ret[1] = this.toGlobalCoord(ret[1]);
                    return ret;
                },
                getLabelInterval: function () {
                    var labelInterval = this._labelInterval;
                    if (!labelInterval) {
                        labelInterval = this._labelInterval = axisLabelInterval(this);
                    }
                    return labelInterval;
                },
                isLabelIgnored: function (idx) {
                    if (this.type === 'category') {
                        var labelInterval = this.getLabelInterval();
                        return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);
                    }
                },
                toLocalCoord: null,
                toGlobalCoord: null
            };
            zrUtil.inherits(Axis2D, Axis);
            module.exports = Axis2D;
        },
        function (module, exports, __webpack_require__) {
            var numberUtil = __webpack_require__(7);
            var linearMap = numberUtil.linearMap;
            var zrUtil = __webpack_require__(3);
            function fixExtentWithBands(extent, nTick) {
                var size = extent[1] - extent[0];
                var len = nTick;
                var margin = size / len / 2;
                extent[0] += margin;
                extent[1] -= margin;
            }
            var normalizedExtent = [
                0,
                1
            ];
            var Axis = function (dim, scale, extent) {
                this.dim = dim;
                this.scale = scale;
                this._extent = extent || [
                    0,
                    0
                ];
                this.inverse = false;
                this.onBand = false;
            };
            Axis.prototype = {
                constructor: Axis,
                contain: function (coord) {
                    var extent = this._extent;
                    var min = Math.min(extent[0], extent[1]);
                    var max = Math.max(extent[0], extent[1]);
                    return coord >= min && coord <= max;
                },
                containData: function (data) {
                    return this.contain(this.dataToCoord(data));
                },
                getExtent: function () {
                    var ret = this._extent.slice();
                    return ret;
                },
                getPixelPrecision: function (dataExtent) {
                    return numberUtil.getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent);
                },
                setExtent: function (start, end) {
                    var extent = this._extent;
                    extent[0] = start;
                    extent[1] = end;
                },
                dataToCoord: function (data, clamp) {
                    var extent = this._extent;
                    var scale = this.scale;
                    data = scale.normalize(data);
                    if (this.onBand && scale.type === 'ordinal') {
                        extent = extent.slice();
                        fixExtentWithBands(extent, scale.count());
                    }
                    return linearMap(data, normalizedExtent, extent, clamp);
                },
                coordToData: function (coord, clamp) {
                    var extent = this._extent;
                    var scale = this.scale;
                    if (this.onBand && scale.type === 'ordinal') {
                        extent = extent.slice();
                        fixExtentWithBands(extent, scale.count());
                    }
                    var t = linearMap(coord, extent, normalizedExtent, clamp);
                    return this.scale.scale(t);
                },
                getTicksCoords: function () {
                    if (this.onBand) {
                        var bands = this.getBands();
                        var coords = [];
                        for (var i = 0; i < bands.length; i++) {
                            coords.push(bands[i][0]);
                        }
                        if (bands[i - 1]) {
                            coords.push(bands[i - 1][1]);
                        }
                        return coords;
                    } else {
                        return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
                    }
                },
                getLabelsCoords: function () {
                    if (this.onBand) {
                        var bands = this.getBands();
                        var coords = [];
                        var band;
                        for (var i = 0; i < bands.length; i++) {
                            band = bands[i];
                            coords.push((band[0] + band[1]) / 2);
                        }
                        return coords;
                    } else {
                        return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
                    }
                },
                getBands: function () {
                    var extent = this.getExtent();
                    var bands = [];
                    var len = this.scale.count();
                    var start = extent[0];
                    var end = extent[1];
                    var span = end - start;
                    for (var i = 0; i < len; i++) {
                        bands.push([
                            span * i / len + start,
                            span * (i + 1) / len + start
                        ]);
                    }
                    return bands;
                },
                getBandWidth: function () {
                    var axisExtent = this._extent;
                    var dataExtent = this.scale.getExtent();
                    var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
                    len === 0 && (len = 1);
                    var size = Math.abs(axisExtent[1] - axisExtent[0]);
                    return Math.abs(size) / len;
                }
            };
            module.exports = Axis;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var axisHelper = __webpack_require__(108);
            module.exports = function (axis) {
                var axisModel = axis.model;
                var labelModel = axisModel.getModel('axisLabel');
                var labelInterval = labelModel.get('interval');
                if (!(axis.type === 'category' && labelInterval === 'auto')) {
                    return labelInterval === 'auto' ? 0 : labelInterval;
                }
                return axisHelper.getAxisLabelInterval(zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis), axisModel.getFormattedLabels(), labelModel.getModel('textStyle').getFont(), axis.isHorizontal());
            };
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            __webpack_require__(120);
            var ComponentModel = __webpack_require__(19);
            module.exports = ComponentModel.extend({
                type: 'grid',
                dependencies: [
                    'xAxis',
                    'yAxis'
                ],
                layoutMode: 'box',
                coordinateSystem: null,
                defaultOption: {
                    show: false,
                    zlevel: 0,
                    z: 0,
                    left: '10%',
                    top: 60,
                    right: '10%',
                    bottom: 60,
                    containLabel: false,
                    backgroundColor: 'rgba(0,0,0,0)',
                    borderWidth: 1,
                    borderColor: '#ccc'
                }
            });
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var ComponentModel = __webpack_require__(19);
            var zrUtil = __webpack_require__(3);
            var axisModelCreator = __webpack_require__(121);
            var AxisModel = ComponentModel.extend({
                type: 'cartesian2dAxis',
                axis: null,
                init: function () {
                    AxisModel.superApply(this, 'init', arguments);
                    this._resetRange();
                },
                mergeOption: function () {
                    AxisModel.superApply(this, 'mergeOption', arguments);
                    this._resetRange();
                },
                restoreData: function () {
                    AxisModel.superApply(this, 'restoreData', arguments);
                    this._resetRange();
                },
                setRange: function (rangeStart, rangeEnd) {
                    this.option.rangeStart = rangeStart;
                    this.option.rangeEnd = rangeEnd;
                },
                getMin: function () {
                    var option = this.option;
                    return option.rangeStart != null ? option.rangeStart : option.min;
                },
                getMax: function () {
                    var option = this.option;
                    return option.rangeEnd != null ? option.rangeEnd : option.max;
                },
                getNeedCrossZero: function () {
                    var option = this.option;
                    return option.rangeStart != null || option.rangeEnd != null ? false : !option.scale;
                },
                _resetRange: function () {
                    this.option.rangeStart = this.option.rangeEnd = null;
                }
            });
            function getAxisType(axisDim, option) {
                return option.type || (option.data ? 'category' : 'value');
            }
            zrUtil.merge(AxisModel.prototype, __webpack_require__(123));
            var extraOption = { gridIndex: 0 };
            axisModelCreator('x', AxisModel, getAxisType, extraOption);
            axisModelCreator('y', AxisModel, getAxisType, extraOption);
            module.exports = AxisModel;
        },
        function (module, exports, __webpack_require__) {
            var axisDefault = __webpack_require__(122);
            var zrUtil = __webpack_require__(3);
            var ComponentModel = __webpack_require__(19);
            var layout = __webpack_require__(21);
            var AXIS_TYPES = [
                'value',
                'category',
                'time',
                'log'
            ];
            module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {
                zrUtil.each(AXIS_TYPES, function (axisType) {
                    BaseAxisModelClass.extend({
                        type: axisName + 'Axis.' + axisType,
                        mergeDefaultAndTheme: function (option, ecModel) {
                            var layoutMode = this.layoutMode;
                            var inputPositionParams = layoutMode ? layout.getLayoutParams(option) : {};
                            var themeModel = ecModel.getTheme();
                            zrUtil.merge(option, themeModel.get(axisType + 'Axis'));
                            zrUtil.merge(option, this.getDefaultOption());
                            option.type = axisTypeDefaulter(axisName, option);
                            if (layoutMode) {
                                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
                            }
                        },
                        defaultOption: zrUtil.mergeAll([
                            {},
                            axisDefault[axisType + 'Axis'],
                            extraDefaultOption
                        ], true)
                    });
                });
                ComponentModel.registerSubTypeDefaulter(axisName + 'Axis', zrUtil.curry(axisTypeDefaulter, axisName));
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var defaultOption = {
                show: true,
                zlevel: 0,
                z: 0,
                inverse: false,
                name: '',
                nameLocation: 'end',
                nameTextStyle: {},
                nameGap: 15,
                silent: true,
                axisLine: {
                    show: true,
                    onZero: true,
                    lineStyle: {
                        color: '#333',
                        width: 1,
                        type: 'solid'
                    }
                },
                axisTick: {
                    show: true,
                    inside: false,
                    length: 5,
                    lineStyle: {
                        color: '#333',
                        width: 1
                    }
                },
                axisLabel: {
                    show: true,
                    inside: false,
                    rotate: 0,
                    margin: 8,
                    textStyle: {
                        color: '#333',
                        fontSize: 12
                    }
                },
                splitLine: {
                    show: true,
                    lineStyle: {
                        color: ['#ccc'],
                        width: 1,
                        type: 'solid'
                    }
                },
                splitArea: {
                    show: false,
                    areaStyle: {
                        color: [
                            'rgba(250,250,250,0.3)',
                            'rgba(200,200,200,0.3)'
                        ]
                    }
                }
            };
            var categoryAxis = zrUtil.merge({
                boundaryGap: true,
                axisTick: { interval: 'auto' },
                axisLabel: { interval: 'auto' }
            }, defaultOption);
            var valueAxis = zrUtil.defaults({
                boundaryGap: [
                    0,
                    0
                ],
                splitNumber: 5
            }, defaultOption);
            var timeAxis = zrUtil.defaults({
                scale: true,
                min: 'dataMin',
                max: 'dataMax'
            }, valueAxis);
            var logAxis = zrUtil.defaults({}, valueAxis);
            logAxis.scale = true;
            module.exports = {
                categoryAxis: categoryAxis,
                valueAxis: valueAxis,
                timeAxis: timeAxis,
                logAxis: logAxis
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var axisHelper = __webpack_require__(108);
            function getName(obj) {
                if (zrUtil.isObject(obj) && obj.value != null) {
                    return obj.value;
                } else {
                    return obj;
                }
            }
            function getCategories() {
                return this.get('type') === 'category' && zrUtil.map(this.get('data'), getName);
            }
            function getFormattedLabels() {
                return axisHelper.getFormattedLabels(this.axis, this.get('axisLabel.formatter'));
            }
            module.exports = {
                getFormattedLabels: getFormattedLabels,
                getCategories: getCategories
            };
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            __webpack_require__(120);
            __webpack_require__(125);
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var AxisBuilder = __webpack_require__(126);
            var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;
            var getInterval = AxisBuilder.getInterval;
            var axisBuilderAttrs = [
                'axisLine',
                'axisLabel',
                'axisTick',
                'axisName'
            ];
            var selfBuilderAttrs = [
                'splitLine',
                'splitArea'
            ];
            var AxisView = __webpack_require__(1).extendComponentView({
                type: 'axis',
                render: function (axisModel, ecModel) {
                    this.group.removeAll();
                    if (!axisModel.get('show')) {
                        return;
                    }
                    var gridModel = ecModel.getComponent('grid', axisModel.get('gridIndex'));
                    var layout = layoutAxis(gridModel, axisModel);
                    var axisBuilder = new AxisBuilder(axisModel, layout);
                    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
                    this.group.add(axisBuilder.getGroup());
                    zrUtil.each(selfBuilderAttrs, function (name) {
                        if (axisModel.get(name + '.show')) {
                            this['_' + name](axisModel, gridModel, layout.labelInterval);
                        }
                    }, this);
                },
                _splitLine: function (axisModel, gridModel, labelInterval) {
                    var axis = axisModel.axis;
                    var splitLineModel = axisModel.getModel('splitLine');
                    var lineStyleModel = splitLineModel.getModel('lineStyle');
                    var lineWidth = lineStyleModel.get('width');
                    var lineColors = lineStyleModel.get('color');
                    var lineInterval = getInterval(splitLineModel, labelInterval);
                    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];
                    var gridRect = gridModel.coordinateSystem.getRect();
                    var isHorizontal = axis.isHorizontal();
                    var splitLines = [];
                    var lineCount = 0;
                    var ticksCoords = axis.getTicksCoords();
                    var p1 = [];
                    var p2 = [];
                    for (var i = 0; i < ticksCoords.length; i++) {
                        if (ifIgnoreOnTick(axis, i, lineInterval)) {
                            continue;
                        }
                        var tickCoord = axis.toGlobalCoord(ticksCoords[i]);
                        if (isHorizontal) {
                            p1[0] = tickCoord;
                            p1[1] = gridRect.y;
                            p2[0] = tickCoord;
                            p2[1] = gridRect.y + gridRect.height;
                        } else {
                            p1[0] = gridRect.x;
                            p1[1] = tickCoord;
                            p2[0] = gridRect.x + gridRect.width;
                            p2[1] = tickCoord;
                        }
                        var colorIndex = lineCount++ % lineColors.length;
                        splitLines[colorIndex] = splitLines[colorIndex] || [];
                        splitLines[colorIndex].push(new graphic.Line(graphic.subPixelOptimizeLine({
                            shape: {
                                x1: p1[0],
                                y1: p1[1],
                                x2: p2[0],
                                y2: p2[1]
                            },
                            style: { lineWidth: lineWidth },
                            silent: true
                        })));
                    }
                    var lineStyle = lineStyleModel.getLineStyle();
                    for (var i = 0; i < splitLines.length; i++) {
                        this.group.add(graphic.mergePath(splitLines[i], {
                            style: zrUtil.defaults({ stroke: lineColors[i % lineColors.length] }, lineStyle),
                            silent: true
                        }));
                    }
                },
                _splitArea: function (axisModel, gridModel, labelInterval) {
                    var axis = axisModel.axis;
                    var splitAreaModel = axisModel.getModel('splitArea');
                    var areaStyleModel = splitAreaModel.getModel('areaStyle');
                    var areaColors = areaStyleModel.get('color');
                    var gridRect = gridModel.coordinateSystem.getRect();
                    var ticksCoords = axis.getTicksCoords();
                    var prevX = axis.toGlobalCoord(ticksCoords[0]);
                    var prevY = axis.toGlobalCoord(ticksCoords[0]);
                    var splitAreaRects = [];
                    var count = 0;
                    var areaInterval = getInterval(splitAreaModel, labelInterval);
                    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];
                    for (var i = 1; i < ticksCoords.length; i++) {
                        if (ifIgnoreOnTick(axis, i, areaInterval)) {
                            continue;
                        }
                        var tickCoord = axis.toGlobalCoord(ticksCoords[i]);
                        var x;
                        var y;
                        var width;
                        var height;
                        if (axis.isHorizontal()) {
                            x = prevX;
                            y = gridRect.y;
                            width = tickCoord - x;
                            height = gridRect.height;
                        } else {
                            x = gridRect.x;
                            y = prevY;
                            width = gridRect.width;
                            height = tickCoord - y;
                        }
                        var colorIndex = count++ % areaColors.length;
                        splitAreaRects[colorIndex] = splitAreaRects[colorIndex] || [];
                        splitAreaRects[colorIndex].push(new graphic.Rect({
                            shape: {
                                x: x,
                                y: y,
                                width: width,
                                height: height
                            },
                            silent: true
                        }));
                        prevX = x + width;
                        prevY = y + height;
                    }
                    var areaStyle = areaStyleModel.getAreaStyle();
                    for (var i = 0; i < splitAreaRects.length; i++) {
                        this.group.add(graphic.mergePath(splitAreaRects[i], {
                            style: zrUtil.defaults({ fill: areaColors[i % areaColors.length] }, areaStyle),
                            silent: true
                        }));
                    }
                }
            });
            AxisView.extend({ type: 'xAxis' });
            AxisView.extend({ type: 'yAxis' });
            function layoutAxis(gridModel, axisModel) {
                var grid = gridModel.coordinateSystem;
                var axis = axisModel.axis;
                var layout = {};
                var rawAxisPosition = axis.position;
                var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;
                var axisDim = axis.dim;
                var rect = grid.getRect();
                var rectBound = [
                    rect.x,
                    rect.x + rect.width,
                    rect.y,
                    rect.y + rect.height
                ];
                var posMap = {
                    x: {
                        top: rectBound[2],
                        bottom: rectBound[3]
                    },
                    y: {
                        left: rectBound[0],
                        right: rectBound[1]
                    }
                };
                posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);
                posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);
                function getZero(dim, val) {
                    var theAxis = grid.getAxis(dim);
                    return theAxis.toGlobalCoord(theAxis.dataToCoord(0));
                }
                layout.position = [
                    axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],
                    axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]
                ];
                var r = {
                    x: 0,
                    y: 1
                };
                layout.rotation = Math.PI / 2 * r[axisDim];
                var dirMap = {
                    top: -1,
                    bottom: 1,
                    left: -1,
                    right: 1
                };
                layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
                if (axis.onZero) {
                    layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;
                }
                if (axisModel.getModel('axisTick').get('inside')) {
                    layout.tickDirection = -layout.tickDirection;
                }
                if (axisModel.getModel('axisLabel').get('inside')) {
                    layout.labelDirection = -layout.labelDirection;
                }
                var labelRotation = axisModel.getModel('axisLabel').get('rotate');
                layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;
                layout.labelInterval = axis.getLabelInterval();
                layout.z2 = 1;
                return layout;
            }
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var Model = __webpack_require__(8);
            var numberUtil = __webpack_require__(7);
            var remRadian = numberUtil.remRadian;
            var isRadianAroundZero = numberUtil.isRadianAroundZero;
            var PI = Math.PI;
            function makeAxisEventDataBase(axisModel) {
                var eventData = { componentType: axisModel.mainType };
                eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
                return eventData;
            }
            var AxisBuilder = function (axisModel, opt) {
                this.opt = opt;
                this.axisModel = axisModel;
                zrUtil.defaults(opt, {
                    labelOffset: 0,
                    nameDirection: 1,
                    tickDirection: 1,
                    labelDirection: 1,
                    silent: true
                });
                this.group = new graphic.Group({
                    position: opt.position.slice(),
                    rotation: opt.rotation
                });
            };
            AxisBuilder.prototype = {
                constructor: AxisBuilder,
                hasBuilder: function (name) {
                    return !!builders[name];
                },
                add: function (name) {
                    builders[name].call(this);
                },
                getGroup: function () {
                    return this.group;
                }
            };
            var builders = {
                axisLine: function () {
                    var opt = this.opt;
                    var axisModel = this.axisModel;
                    if (!axisModel.get('axisLine.show')) {
                        return;
                    }
                    var extent = this.axisModel.axis.getExtent();
                    this.group.add(new graphic.Line({
                        shape: {
                            x1: extent[0],
                            y1: 0,
                            x2: extent[1],
                            y2: 0
                        },
                        style: zrUtil.extend({ lineCap: 'round' }, axisModel.getModel('axisLine.lineStyle').getLineStyle()),
                        strokeContainThreshold: opt.strokeContainThreshold,
                        silent: !!opt.axisLineSilent,
                        z2: 1
                    }));
                },
                axisTick: function () {
                    var axisModel = this.axisModel;
                    if (!axisModel.get('axisTick.show')) {
                        return;
                    }
                    var axis = axisModel.axis;
                    var tickModel = axisModel.getModel('axisTick');
                    var opt = this.opt;
                    var lineStyleModel = tickModel.getModel('lineStyle');
                    var tickLen = tickModel.get('length');
                    var tickInterval = getInterval(tickModel, opt.labelInterval);
                    var ticksCoords = axis.getTicksCoords();
                    var tickLines = [];
                    for (var i = 0; i < ticksCoords.length; i++) {
                        if (ifIgnoreOnTick(axis, i, tickInterval)) {
                            continue;
                        }
                        var tickCoord = ticksCoords[i];
                        tickLines.push(new graphic.Line(graphic.subPixelOptimizeLine({
                            shape: {
                                x1: tickCoord,
                                y1: 0,
                                x2: tickCoord,
                                y2: opt.tickDirection * tickLen
                            },
                            style: { lineWidth: lineStyleModel.get('width') },
                            silent: true
                        })));
                    }
                    this.group.add(graphic.mergePath(tickLines, {
                        style: lineStyleModel.getLineStyle(),
                        z2: 2,
                        silent: true
                    }));
                },
                axisLabel: function () {
                    var axisModel = this.axisModel;
                    if (!axisModel.get('axisLabel.show')) {
                        return;
                    }
                    var opt = this.opt;
                    var axis = axisModel.axis;
                    var labelModel = axisModel.getModel('axisLabel');
                    var textStyleModel = labelModel.getModel('textStyle');
                    var labelMargin = labelModel.get('margin');
                    var ticks = axis.scale.getTicks();
                    var labels = axisModel.getFormattedLabels();
                    var labelRotation = opt.labelRotation;
                    if (labelRotation == null) {
                        labelRotation = labelModel.get('rotate') || 0;
                    }
                    labelRotation = labelRotation * PI / 180;
                    var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);
                    var categoryData = axisModel.get('data');
                    var textEls = [];
                    var isSilent = axisModel.get('silent');
                    for (var i = 0; i < ticks.length; i++) {
                        if (ifIgnoreOnTick(axis, i, opt.labelInterval)) {
                            continue;
                        }
                        var itemTextStyleModel = textStyleModel;
                        if (categoryData && categoryData[i] && categoryData[i].textStyle) {
                            itemTextStyleModel = new Model(categoryData[i].textStyle, textStyleModel, axisModel.ecModel);
                        }
                        var textColor = itemTextStyleModel.getTextColor();
                        var tickCoord = axis.dataToCoord(ticks[i]);
                        var pos = [
                            tickCoord,
                            opt.labelOffset + opt.labelDirection * labelMargin
                        ];
                        var labelBeforeFormat = axis.scale.getLabel(ticks[i]);
                        var textEl = new graphic.Text({
                            style: {
                                text: labels[i],
                                textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,
                                textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,
                                textFont: itemTextStyleModel.getFont(),
                                fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor
                            },
                            position: pos,
                            rotation: labelLayout.rotation,
                            silent: isSilent,
                            z2: 10
                        });
                        textEl.eventData = makeAxisEventDataBase(axisModel);
                        textEl.eventData.targetType = 'axisLabel';
                        textEl.eventData.value = labelBeforeFormat;
                        textEls.push(textEl);
                        this.group.add(textEl);
                    }
                    function isTwoLabelOverlapped(current, next) {
                        var firstRect = current && current.getBoundingRect().clone();
                        var nextRect = next && next.getBoundingRect().clone();
                        if (firstRect && nextRect) {
                            firstRect.applyTransform(current.getLocalTransform());
                            nextRect.applyTransform(next.getLocalTransform());
                            return firstRect.intersect(nextRect);
                        }
                    }
                    if (axis.type !== 'category') {
                        if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {
                            var firstLabel = textEls[0];
                            var nextLabel = textEls[1];
                            if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
                                firstLabel.ignore = true;
                            }
                        }
                        if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {
                            var lastLabel = textEls[textEls.length - 1];
                            var prevLabel = textEls[textEls.length - 2];
                            if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
                                lastLabel.ignore = true;
                            }
                        }
                    }
                },
                axisName: function () {
                    var opt = this.opt;
                    var axisModel = this.axisModel;
                    var name = this.opt.axisName;
                    if (name == null) {
                        name = axisModel.get('name');
                    }
                    if (!name) {
                        return;
                    }
                    var nameLocation = axisModel.get('nameLocation');
                    var nameDirection = opt.nameDirection;
                    var textStyleModel = axisModel.getModel('nameTextStyle');
                    var gap = axisModel.get('nameGap') || 0;
                    var extent = this.axisModel.axis.getExtent();
                    var gapSignal = extent[0] > extent[1] ? -1 : 1;
                    var pos = [
                        nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,
                        nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0
                    ];
                    var labelLayout;
                    if (nameLocation === 'middle') {
                        labelLayout = innerTextLayout(opt, opt.rotation, nameDirection);
                    } else {
                        labelLayout = endTextLayout(opt, nameLocation, extent);
                    }
                    var textEl = new graphic.Text({
                        style: {
                            text: name,
                            textFont: textStyleModel.getFont(),
                            fill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),
                            textAlign: labelLayout.textAlign,
                            textVerticalAlign: labelLayout.verticalAlign
                        },
                        position: pos,
                        rotation: labelLayout.rotation,
                        silent: axisModel.get('silent'),
                        z2: 1
                    });
                    textEl.eventData = makeAxisEventDataBase(axisModel);
                    textEl.eventData.targetType = 'axisName';
                    textEl.eventData.name = name;
                    this.group.add(textEl);
                }
            };
            function innerTextLayout(opt, textRotation, direction) {
                var rotationDiff = remRadian(textRotation - opt.rotation);
                var textAlign;
                var verticalAlign;
                if (isRadianAroundZero(rotationDiff)) {
                    verticalAlign = direction > 0 ? 'top' : 'bottom';
                    textAlign = 'center';
                } else if (isRadianAroundZero(rotationDiff - PI)) {
                    verticalAlign = direction > 0 ? 'bottom' : 'top';
                    textAlign = 'center';
                } else {
                    verticalAlign = 'middle';
                    if (rotationDiff > 0 && rotationDiff < PI) {
                        textAlign = direction > 0 ? 'right' : 'left';
                    } else {
                        textAlign = direction > 0 ? 'left' : 'right';
                    }
                }
                return {
                    rotation: rotationDiff,
                    textAlign: textAlign,
                    verticalAlign: verticalAlign
                };
            }
            function endTextLayout(opt, textPosition, extent) {
                var rotationDiff = remRadian(-opt.rotation);
                var textAlign;
                var verticalAlign;
                var inverse = extent[0] > extent[1];
                var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;
                if (isRadianAroundZero(rotationDiff - PI / 2)) {
                    verticalAlign = onLeft ? 'bottom' : 'top';
                    textAlign = 'center';
                } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
                    verticalAlign = onLeft ? 'top' : 'bottom';
                    textAlign = 'center';
                } else {
                    verticalAlign = 'middle';
                    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
                        textAlign = onLeft ? 'left' : 'right';
                    } else {
                        textAlign = onLeft ? 'right' : 'left';
                    }
                }
                return {
                    rotation: rotationDiff,
                    textAlign: textAlign,
                    verticalAlign: verticalAlign
                };
            }
            var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {
                var rawTick;
                var scale = axis.scale;
                return scale.type === 'ordinal' && (typeof interval === 'function' ? (rawTick = scale.getTicks()[i], !interval(rawTick, scale.getLabel(rawTick))) : i % (interval + 1));
            };
            var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {
                var interval = model.get('interval');
                if (interval == null || interval == 'auto') {
                    interval = labelInterval;
                }
                return interval;
            };
            module.exports = AxisBuilder;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            __webpack_require__(107);
            __webpack_require__(128);
            __webpack_require__(129);
            var barLayoutGrid = __webpack_require__(131);
            var echarts = __webpack_require__(1);
            echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));
            echarts.registerVisualCoding('chart', function (ecModel) {
                ecModel.eachSeriesByType('bar', function (seriesModel) {
                    var data = seriesModel.getData();
                    data.setVisual('legendSymbol', 'roundRect');
                });
            });
            __webpack_require__(106);
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var SeriesModel = __webpack_require__(27);
            var createListFromArray = __webpack_require__(93);
            module.exports = SeriesModel.extend({
                type: 'series.bar',
                dependencies: [
                    'grid',
                    'polar'
                ],
                getInitialData: function (option, ecModel) {
                    return createListFromArray(option.data, this, ecModel);
                },
                getMarkerPosition: function (value) {
                    var coordSys = this.coordinateSystem;
                    if (coordSys) {
                        var pt = coordSys.dataToPoint(value);
                        var data = this.getData();
                        var offset = data.getLayout('offset');
                        var size = data.getLayout('size');
                        var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
                        pt[offsetIndex] += offset + size / 2;
                        return pt;
                    }
                    return [
                        NaN,
                        NaN
                    ];
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: 'cartesian2d',
                    legendHoverLink: true,
                    xAxisIndex: 0,
                    yAxisIndex: 0,
                    barMinHeight: 0,
                    itemStyle: {
                        normal: {
                            barBorderColor: '#fff',
                            barBorderWidth: 0
                        },
                        emphasis: {
                            barBorderColor: '#fff',
                            barBorderWidth: 0
                        }
                    }
                }
            });
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            zrUtil.extend(__webpack_require__(8).prototype, __webpack_require__(130));
            function fixLayoutWithLineWidth(layout, lineWidth) {
                var signX = layout.width > 0 ? 1 : -1;
                var signY = layout.height > 0 ? 1 : -1;
                lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));
                layout.x += signX * lineWidth / 2;
                layout.y += signY * lineWidth / 2;
                layout.width -= signX * lineWidth;
                layout.height -= signY * lineWidth;
            }
            module.exports = __webpack_require__(1).extendChartView({
                type: 'bar',
                render: function (seriesModel, ecModel, api) {
                    var coordinateSystemType = seriesModel.get('coordinateSystem');
                    if (coordinateSystemType === 'cartesian2d') {
                        this._renderOnCartesian(seriesModel, ecModel, api);
                    }
                    return this.group;
                },
                _renderOnCartesian: function (seriesModel, ecModel, api) {
                    var group = this.group;
                    var data = seriesModel.getData();
                    var oldData = this._data;
                    var cartesian = seriesModel.coordinateSystem;
                    var baseAxis = cartesian.getBaseAxis();
                    var isHorizontal = baseAxis.isHorizontal();
                    var enableAnimation = seriesModel.get('animation');
                    var barBorderWidthQuery = [
                        'itemStyle',
                        'normal',
                        'barBorderWidth'
                    ];
                    function createRect(dataIndex, isUpdate) {
                        var layout = data.getItemLayout(dataIndex);
                        var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;
                        fixLayoutWithLineWidth(layout, lineWidth);
                        var rect = new graphic.Rect({ shape: zrUtil.extend({}, layout) });
                        if (enableAnimation) {
                            var rectShape = rect.shape;
                            var animateProperty = isHorizontal ? 'height' : 'width';
                            var animateTarget = {};
                            rectShape[animateProperty] = 0;
                            animateTarget[animateProperty] = layout[animateProperty];
                            graphic[isUpdate ? 'updateProps' : 'initProps'](rect, { shape: animateTarget }, seriesModel);
                        }
                        return rect;
                    }
                    data.diff(oldData).add(function (dataIndex) {
                        if (!data.hasValue(dataIndex)) {
                            return;
                        }
                        var rect = createRect(dataIndex);
                        data.setItemGraphicEl(dataIndex, rect);
                        group.add(rect);
                    }).update(function (newIndex, oldIndex) {
                        var rect = oldData.getItemGraphicEl(oldIndex);
                        if (!data.hasValue(newIndex)) {
                            group.remove(rect);
                            return;
                        }
                        if (!rect) {
                            rect = createRect(newIndex, true);
                        }
                        var layout = data.getItemLayout(newIndex);
                        var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;
                        fixLayoutWithLineWidth(layout, lineWidth);
                        graphic.updateProps(rect, { shape: layout }, seriesModel);
                        data.setItemGraphicEl(newIndex, rect);
                        group.add(rect);
                    }).remove(function (idx) {
                        var rect = oldData.getItemGraphicEl(idx);
                        if (rect) {
                            rect.style.text = '';
                            graphic.updateProps(rect, { shape: { width: 0 } }, seriesModel, function () {
                                group.remove(rect);
                            });
                        }
                    }).execute();
                    this._updateStyle(seriesModel, data, isHorizontal);
                    this._data = data;
                },
                _updateStyle: function (seriesModel, data, isHorizontal) {
                    function setLabel(style, model, color, labelText, labelPositionOutside) {
                        graphic.setText(style, model, color);
                        style.text = labelText;
                        if (style.textPosition === 'outside') {
                            style.textPosition = labelPositionOutside;
                        }
                    }
                    data.eachItemGraphicEl(function (rect, idx) {
                        var itemModel = data.getItemModel(idx);
                        var color = data.getItemVisual(idx, 'color');
                        var opacity = data.getItemVisual(idx, 'opacity');
                        var layout = data.getItemLayout(idx);
                        var itemStyleModel = itemModel.getModel('itemStyle.normal');
                        var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();
                        rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);
                        rect.setStyle(zrUtil.defaults({
                            fill: color,
                            opacity: opacity
                        }, itemStyleModel.getBarItemStyle()));
                        var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';
                        var labelModel = itemModel.getModel('label.normal');
                        var hoverLabelModel = itemModel.getModel('label.emphasis');
                        var rectStyle = rect.style;
                        if (labelModel.get('show')) {
                            setLabel(rectStyle, labelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), seriesModel.getRawValue(idx)), labelPositionOutside);
                        } else {
                            rectStyle.text = '';
                        }
                        if (hoverLabelModel.get('show')) {
                            setLabel(hoverStyle, hoverLabelModel, color, zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), seriesModel.getRawValue(idx)), labelPositionOutside);
                        } else {
                            hoverStyle.text = '';
                        }
                        graphic.setHoverStyle(rect, hoverStyle);
                    });
                },
                remove: function (ecModel, api) {
                    var group = this.group;
                    if (ecModel.get('animation')) {
                        if (this._data) {
                            this._data.eachItemGraphicEl(function (el) {
                                el.style.text = '';
                                graphic.updateProps(el, { shape: { width: 0 } }, ecModel, function () {
                                    group.remove(el);
                                });
                            });
                        }
                    } else {
                        group.removeAll();
                    }
                }
            });
        },
        function (module, exports, __webpack_require__) {
            module.exports = {
                getBarItemStyle: __webpack_require__(11)([
                    [
                        'fill',
                        'color'
                    ],
                    [
                        'stroke',
                        'borderColor'
                    ],
                    [
                        'lineWidth',
                        'borderWidth'
                    ],
                    [
                        'stroke',
                        'barBorderColor'
                    ],
                    [
                        'lineWidth',
                        'barBorderWidth'
                    ],
                    ['opacity'],
                    ['shadowBlur'],
                    ['shadowOffsetX'],
                    ['shadowOffsetY'],
                    ['shadowColor']
                ])
            };
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var numberUtil = __webpack_require__(7);
            var parsePercent = numberUtil.parsePercent;
            function getSeriesStackId(seriesModel) {
                return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;
            }
            function calBarWidthAndOffset(barSeries, api) {
                var columnsMap = {};
                zrUtil.each(barSeries, function (seriesModel, idx) {
                    var cartesian = seriesModel.coordinateSystem;
                    var baseAxis = cartesian.getBaseAxis();
                    var columnsOnAxis = columnsMap[baseAxis.index] || {
                        remainedWidth: baseAxis.getBandWidth(),
                        autoWidthCount: 0,
                        categoryGap: '20%',
                        gap: '30%',
                        axis: baseAxis,
                        stacks: {}
                    };
                    var stacks = columnsOnAxis.stacks;
                    columnsMap[baseAxis.index] = columnsOnAxis;
                    var stackId = getSeriesStackId(seriesModel);
                    if (!stacks[stackId]) {
                        columnsOnAxis.autoWidthCount++;
                    }
                    stacks[stackId] = stacks[stackId] || {
                        width: 0,
                        maxWidth: 0
                    };
                    var barWidth = seriesModel.get('barWidth');
                    var barMaxWidth = seriesModel.get('barMaxWidth');
                    var barGap = seriesModel.get('barGap');
                    var barCategoryGap = seriesModel.get('barCategoryGap');
                    if (barWidth && !stacks[stackId].width) {
                        barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
                        stacks[stackId].width = barWidth;
                        columnsOnAxis.remainedWidth -= barWidth;
                    }
                    barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
                    barGap != null && (columnsOnAxis.gap = barGap);
                    barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap);
                });
                var result = {};
                zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {
                    result[coordSysName] = {};
                    var stacks = columnsOnAxis.stacks;
                    var baseAxis = columnsOnAxis.axis;
                    var bandWidth = baseAxis.getBandWidth();
                    var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
                    var barGapPercent = parsePercent(columnsOnAxis.gap, 1);
                    var remainedWidth = columnsOnAxis.remainedWidth;
                    var autoWidthCount = columnsOnAxis.autoWidthCount;
                    var autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
                    autoWidth = Math.max(autoWidth, 0);
                    zrUtil.each(stacks, function (column, stack) {
                        var maxWidth = column.maxWidth;
                        if (!column.width && maxWidth && maxWidth < autoWidth) {
                            maxWidth = Math.min(maxWidth, remainedWidth);
                            remainedWidth -= maxWidth;
                            column.width = maxWidth;
                            autoWidthCount--;
                        }
                    });
                    autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
                    autoWidth = Math.max(autoWidth, 0);
                    var widthSum = 0;
                    var lastColumn;
                    zrUtil.each(stacks, function (column, idx) {
                        if (!column.width) {
                            column.width = autoWidth;
                        }
                        lastColumn = column;
                        widthSum += column.width * (1 + barGapPercent);
                    });
                    if (lastColumn) {
                        widthSum -= lastColumn.width * barGapPercent;
                    }
                    var offset = -widthSum / 2;
                    zrUtil.each(stacks, function (column, stackId) {
                        result[coordSysName][stackId] = result[coordSysName][stackId] || {
                            offset: offset,
                            width: column.width
                        };
                        offset += column.width * (1 + barGapPercent);
                    });
                });
                return result;
            }
            function barLayoutGrid(seriesType, ecModel, api) {
                var barWidthAndOffset = calBarWidthAndOffset(zrUtil.filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {
                    return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d';
                }));
                var lastStackCoords = {};
                ecModel.eachSeriesByType(seriesType, function (seriesModel) {
                    var data = seriesModel.getData();
                    var cartesian = seriesModel.coordinateSystem;
                    var baseAxis = cartesian.getBaseAxis();
                    var stackId = getSeriesStackId(seriesModel);
                    var columnLayoutInfo = barWidthAndOffset[baseAxis.index][stackId];
                    var columnOffset = columnLayoutInfo.offset;
                    var columnWidth = columnLayoutInfo.width;
                    var valueAxis = cartesian.getOtherAxis(baseAxis);
                    var barMinHeight = seriesModel.get('barMinHeight') || 0;
                    var valueAxisStart = baseAxis.onZero ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0)) : valueAxis.getGlobalExtent()[0];
                    var coords = cartesian.dataToPoints(data, true);
                    lastStackCoords[stackId] = lastStackCoords[stackId] || [];
                    data.setLayout({
                        offset: columnOffset,
                        size: columnWidth
                    });
                    data.each(valueAxis.dim, function (value, idx) {
                        if (isNaN(value)) {
                            return;
                        }
                        if (!lastStackCoords[stackId][idx]) {
                            lastStackCoords[stackId][idx] = {
                                p: valueAxisStart,
                                n: valueAxisStart
                            };
                        }
                        var sign = value >= 0 ? 'p' : 'n';
                        var coord = coords[idx];
                        var lastCoord = lastStackCoords[stackId][idx][sign];
                        var x, y, width, height;
                        if (valueAxis.isHorizontal()) {
                            x = lastCoord;
                            y = coord[1] + columnOffset;
                            width = coord[0] - lastCoord;
                            height = columnWidth;
                            if (Math.abs(width) < barMinHeight) {
                                width = (width < 0 ? -1 : 1) * barMinHeight;
                            }
                            lastStackCoords[stackId][idx][sign] += width;
                        } else {
                            x = coord[0] + columnOffset;
                            y = lastCoord;
                            width = columnWidth;
                            height = coord[1] - lastCoord;
                            if (Math.abs(height) < barMinHeight) {
                                height = (height <= 0 ? -1 : 1) * barMinHeight;
                            }
                            lastStackCoords[stackId][idx][sign] += height;
                        }
                        data.setItemLayout(idx, {
                            x: x,
                            y: y,
                            width: width,
                            height: height
                        });
                    }, true);
                }, this);
            }
            module.exports = barLayoutGrid;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var echarts = __webpack_require__(1);
            __webpack_require__(133);
            __webpack_require__(135);
            __webpack_require__(136)('pie', [
                {
                    type: 'pieToggleSelect',
                    event: 'pieselectchanged',
                    method: 'toggleSelected'
                },
                {
                    type: 'pieSelect',
                    event: 'pieselected',
                    method: 'select'
                },
                {
                    type: 'pieUnSelect',
                    event: 'pieunselected',
                    method: 'unSelect'
                }
            ]);
            echarts.registerVisualCoding('chart', zrUtil.curry(__webpack_require__(137), 'pie'));
            echarts.registerLayout(zrUtil.curry(__webpack_require__(138), 'pie'));
            echarts.registerProcessor('filter', zrUtil.curry(__webpack_require__(140), 'pie'));
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var List = __webpack_require__(94);
            var zrUtil = __webpack_require__(3);
            var modelUtil = __webpack_require__(5);
            var completeDimensions = __webpack_require__(96);
            var dataSelectableMixin = __webpack_require__(134);
            var PieSeries = __webpack_require__(1).extendSeriesModel({
                type: 'series.pie',
                init: function (option) {
                    PieSeries.superApply(this, 'init', arguments);
                    this.legendDataProvider = function () {
                        return this._dataBeforeProcessed;
                    };
                    this.updateSelectedMap();
                    this._defaultLabelLine(option);
                },
                mergeOption: function (newOption) {
                    PieSeries.superCall(this, 'mergeOption', newOption);
                    this.updateSelectedMap();
                },
                getInitialData: function (option, ecModel) {
                    var dimensions = completeDimensions(['value'], option.data);
                    var list = new List(dimensions, this);
                    list.initData(option.data);
                    return list;
                },
                getDataParams: function (dataIndex) {
                    var data = this._data;
                    var params = PieSeries.superCall(this, 'getDataParams', dataIndex);
                    var sum = data.getSum('value');
                    params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);
                    params.$vars.push('percent');
                    return params;
                },
                _defaultLabelLine: function (option) {
                    modelUtil.defaultEmphasis(option.labelLine, ['show']);
                    var labelLineNormalOpt = option.labelLine.normal;
                    var labelLineEmphasisOpt = option.labelLine.emphasis;
                    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;
                    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    legendHoverLink: true,
                    hoverAnimation: true,
                    center: [
                        '50%',
                        '50%'
                    ],
                    radius: [
                        0,
                        '75%'
                    ],
                    clockwise: true,
                    startAngle: 90,
                    minAngle: 0,
                    selectedOffset: 10,
                    avoidLabelOverlap: true,
                    label: {
                        normal: {
                            rotate: false,
                            show: true,
                            position: 'outer'
                        },
                        emphasis: {}
                    },
                    labelLine: {
                        normal: {
                            show: true,
                            length: 15,
                            length2: 15,
                            smooth: false,
                            lineStyle: {
                                width: 1,
                                type: 'solid'
                            }
                        }
                    },
                    itemStyle: {
                        normal: {
                            borderColor: 'rgba(0,0,0,0)',
                            borderWidth: 1
                        },
                        emphasis: {
                            borderColor: 'rgba(0,0,0,0)',
                            borderWidth: 1
                        }
                    },
                    animationEasing: 'cubicOut',
                    data: []
                }
            });
            zrUtil.mixin(PieSeries, dataSelectableMixin);
            module.exports = PieSeries;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            module.exports = {
                updateSelectedMap: function () {
                    var option = this.option;
                    this._dataOptMap = zrUtil.reduce(option.data, function (dataOptMap, dataOpt) {
                        dataOptMap[dataOpt.name] = dataOpt;
                        return dataOptMap;
                    }, {});
                },
                select: function (name) {
                    var dataOptMap = this._dataOptMap;
                    var dataOpt = dataOptMap[name];
                    var selectedMode = this.get('selectedMode');
                    if (selectedMode === 'single') {
                        zrUtil.each(dataOptMap, function (dataOpt) {
                            dataOpt.selected = false;
                        });
                    }
                    dataOpt && (dataOpt.selected = true);
                },
                unSelect: function (name) {
                    var dataOpt = this._dataOptMap[name];
                    dataOpt && (dataOpt.selected = false);
                },
                toggleSelected: function (name) {
                    var dataOpt = this._dataOptMap[name];
                    if (dataOpt != null) {
                        this[dataOpt.selected ? 'unSelect' : 'select'](name);
                        return dataOpt.selected;
                    }
                },
                isSelected: function (name) {
                    var dataOpt = this._dataOptMap[name];
                    return dataOpt && dataOpt.selected;
                }
            };
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var zrUtil = __webpack_require__(3);
            function updateDataSelected(uid, seriesModel, hasAnimation, api) {
                var data = seriesModel.getData();
                var dataIndex = this.dataIndex;
                var name = data.getName(dataIndex);
                var selectedOffset = seriesModel.get('selectedOffset');
                api.dispatchAction({
                    type: 'pieToggleSelect',
                    from: uid,
                    name: name,
                    seriesId: seriesModel.id
                });
                data.each(function (idx) {
                    toggleItemSelected(data.getItemGraphicEl(idx), data.getItemLayout(idx), seriesModel.isSelected(data.getName(idx)), selectedOffset, hasAnimation);
                });
            }
            function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {
                var midAngle = (layout.startAngle + layout.endAngle) / 2;
                var dx = Math.cos(midAngle);
                var dy = Math.sin(midAngle);
                var offset = isSelected ? selectedOffset : 0;
                var position = [
                    dx * offset,
                    dy * offset
                ];
                hasAnimation ? el.animate().when(200, { position: position }).start('bounceOut') : el.attr('position', position);
            }
            function PiePiece(data, idx) {
                graphic.Group.call(this);
                var sector = new graphic.Sector({ z2: 2 });
                var polyline = new graphic.Polyline();
                var text = new graphic.Text();
                this.add(sector);
                this.add(polyline);
                this.add(text);
                this.updateData(data, idx, true);
                function onEmphasis() {
                    polyline.ignore = polyline.hoverIgnore;
                    text.ignore = text.hoverIgnore;
                }
                function onNormal() {
                    polyline.ignore = polyline.normalIgnore;
                    text.ignore = text.normalIgnore;
                }
                this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);
            }
            var piePieceProto = PiePiece.prototype;
            function getLabelStyle(data, idx, state, labelModel, labelPosition) {
                var textStyleModel = labelModel.getModel('textStyle');
                var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';
                return {
                    fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),
                    textFont: textStyleModel.getFont(),
                    text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))
                };
            }
            piePieceProto.updateData = function (data, idx, firstCreate) {
                var sector = this.childAt(0);
                var seriesModel = data.hostModel;
                var itemModel = data.getItemModel(idx);
                var layout = data.getItemLayout(idx);
                var sectorShape = zrUtil.extend({}, layout);
                sectorShape.label = null;
                if (firstCreate) {
                    sector.setShape(sectorShape);
                    sector.shape.endAngle = layout.startAngle;
                    graphic.updateProps(sector, { shape: { endAngle: layout.endAngle } }, seriesModel);
                } else {
                    graphic.updateProps(sector, { shape: sectorShape }, seriesModel);
                }
                var itemStyleModel = itemModel.getModel('itemStyle');
                var visualColor = data.getItemVisual(idx, 'color');
                sector.setStyle(zrUtil.defaults({ fill: visualColor }, itemStyleModel.getModel('normal').getItemStyle()));
                sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();
                toggleItemSelected(this, data.getItemLayout(idx), itemModel.get('selected'), seriesModel.get('selectedOffset'), seriesModel.get('animation'));
                function onEmphasis() {
                    sector.stopAnimation(true);
                    sector.animateTo({ shape: { r: layout.r + 10 } }, 300, 'elasticOut');
                }
                function onNormal() {
                    sector.stopAnimation(true);
                    sector.animateTo({ shape: { r: layout.r } }, 300, 'elasticOut');
                }
                sector.off('mouseover').off('mouseout').off('emphasis').off('normal');
                if (itemModel.get('hoverAnimation')) {
                    sector.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);
                }
                this._updateLabel(data, idx);
                graphic.setHoverStyle(this);
            };
            piePieceProto._updateLabel = function (data, idx) {
                var labelLine = this.childAt(1);
                var labelText = this.childAt(2);
                var seriesModel = data.hostModel;
                var itemModel = data.getItemModel(idx);
                var layout = data.getItemLayout(idx);
                var labelLayout = layout.label;
                var visualColor = data.getItemVisual(idx, 'color');
                graphic.updateProps(labelLine, {
                    shape: {
                        points: labelLayout.linePoints || [
                            [
                                labelLayout.x,
                                labelLayout.y
                            ],
                            [
                                labelLayout.x,
                                labelLayout.y
                            ],
                            [
                                labelLayout.x,
                                labelLayout.y
                            ]
                        ]
                    }
                }, seriesModel);
                graphic.updateProps(labelText, {
                    style: {
                        x: labelLayout.x,
                        y: labelLayout.y
                    }
                }, seriesModel);
                labelText.attr({
                    style: {
                        textVerticalAlign: labelLayout.verticalAlign,
                        textAlign: labelLayout.textAlign,
                        textFont: labelLayout.font
                    },
                    rotation: labelLayout.rotation,
                    origin: [
                        labelLayout.x,
                        labelLayout.y
                    ],
                    z2: 10
                });
                var labelModel = itemModel.getModel('label.normal');
                var labelHoverModel = itemModel.getModel('label.emphasis');
                var labelLineModel = itemModel.getModel('labelLine.normal');
                var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');
                var labelPosition = labelModel.get('position') || labelHoverModel.get('position');
                labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));
                labelText.ignore = labelText.normalIgnore = !labelModel.get('show');
                labelText.hoverIgnore = !labelHoverModel.get('show');
                labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');
                labelLine.hoverIgnore = !labelLineHoverModel.get('show');
                labelLine.setStyle({ stroke: visualColor });
                labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());
                labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);
                labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();
                var smooth = labelLineModel.get('smooth');
                if (smooth && smooth === true) {
                    smooth = 0.4;
                }
                labelLine.setShape({ smooth: smooth });
            };
            zrUtil.inherits(PiePiece, graphic.Group);
            var Pie = __webpack_require__(41).extend({
                type: 'pie',
                init: function () {
                    var sectorGroup = new graphic.Group();
                    this._sectorGroup = sectorGroup;
                },
                render: function (seriesModel, ecModel, api, payload) {
                    if (payload && payload.from === this.uid) {
                        return;
                    }
                    var data = seriesModel.getData();
                    var oldData = this._data;
                    var group = this.group;
                    var hasAnimation = ecModel.get('animation');
                    var isFirstRender = !oldData;
                    var onSectorClick = zrUtil.curry(updateDataSelected, this.uid, seriesModel, hasAnimation, api);
                    var selectedMode = seriesModel.get('selectedMode');
                    data.diff(oldData).add(function (idx) {
                        var piePiece = new PiePiece(data, idx);
                        if (isFirstRender) {
                            piePiece.eachChild(function (child) {
                                child.stopAnimation(true);
                            });
                        }
                        selectedMode && piePiece.on('click', onSectorClick);
                        data.setItemGraphicEl(idx, piePiece);
                        group.add(piePiece);
                    }).update(function (newIdx, oldIdx) {
                        var piePiece = oldData.getItemGraphicEl(oldIdx);
                        piePiece.updateData(data, newIdx);
                        piePiece.off('click');
                        selectedMode && piePiece.on('click', onSectorClick);
                        group.add(piePiece);
                        data.setItemGraphicEl(newIdx, piePiece);
                    }).remove(function (idx) {
                        var piePiece = oldData.getItemGraphicEl(idx);
                        group.remove(piePiece);
                    }).execute();
                    if (hasAnimation && isFirstRender && data.count() > 0) {
                        var shape = data.getItemLayout(0);
                        var r = Math.max(api.getWidth(), api.getHeight()) / 2;
                        var removeClipPath = zrUtil.bind(group.removeClipPath, group);
                        group.setClipPath(this._createClipPath(shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel));
                    }
                    this._data = data;
                },
                _createClipPath: function (cx, cy, r, startAngle, clockwise, cb, seriesModel) {
                    var clipPath = new graphic.Sector({
                        shape: {
                            cx: cx,
                            cy: cy,
                            r0: 0,
                            r: r,
                            startAngle: startAngle,
                            endAngle: startAngle,
                            clockwise: clockwise
                        }
                    });
                    graphic.initProps(clipPath, { shape: { endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2 } }, seriesModel, cb);
                    return clipPath;
                }
            });
            module.exports = Pie;
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            var zrUtil = __webpack_require__(3);
            module.exports = function (seriesType, actionInfos) {
                zrUtil.each(actionInfos, function (actionInfo) {
                    actionInfo.update = 'updateView';
                    echarts.registerAction(actionInfo, function (payload, ecModel) {
                        var selected = {};
                        ecModel.eachComponent({
                            mainType: 'series',
                            subType: seriesType,
                            query: payload
                        }, function (seriesModel) {
                            if (seriesModel[actionInfo.method]) {
                                seriesModel[actionInfo.method](payload.name);
                            }
                            var data = seriesModel.getData();
                            data.each(function (idx) {
                                var name = data.getName(idx);
                                selected[name] = seriesModel.isSelected(name) || false;
                            });
                        });
                        return {
                            name: payload.name,
                            selected: selected
                        };
                    });
                });
            };
        },
        function (module, exports) {
            module.exports = function (seriesType, ecModel) {
                var globalColorList = ecModel.get('color');
                var offset = 0;
                ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {
                    var colorList = seriesModel.get('color', true);
                    var dataAll = seriesModel.getRawData();
                    if (!ecModel.isSeriesFiltered(seriesModel)) {
                        var data = seriesModel.getData();
                        data.each(function (idx) {
                            var itemModel = data.getItemModel(idx);
                            var rawIdx = data.getRawIndex(idx);
                            var singleDataColor = data.getItemVisual(idx, 'color', true);
                            if (!singleDataColor) {
                                var paletteColor = colorList ? colorList[rawIdx % colorList.length] : globalColorList[(rawIdx + offset) % globalColorList.length];
                                var color = itemModel.get('itemStyle.normal.color') || paletteColor;
                                dataAll.setItemVisual(rawIdx, 'color', color);
                                data.setItemVisual(idx, 'color', color);
                            } else {
                                dataAll.setItemVisual(rawIdx, 'color', singleDataColor);
                            }
                        });
                    }
                    offset += dataAll.count();
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var numberUtil = __webpack_require__(7);
            var parsePercent = numberUtil.parsePercent;
            var labelLayout = __webpack_require__(139);
            var zrUtil = __webpack_require__(3);
            var PI2 = Math.PI * 2;
            var RADIAN = Math.PI / 180;
            module.exports = function (seriesType, ecModel, api) {
                ecModel.eachSeriesByType(seriesType, function (seriesModel) {
                    var center = seriesModel.get('center');
                    var radius = seriesModel.get('radius');
                    if (!zrUtil.isArray(radius)) {
                        radius = [
                            0,
                            radius
                        ];
                    }
                    if (!zrUtil.isArray(center)) {
                        center = [
                            center,
                            center
                        ];
                    }
                    var width = api.getWidth();
                    var height = api.getHeight();
                    var size = Math.min(width, height);
                    var cx = parsePercent(center[0], width);
                    var cy = parsePercent(center[1], height);
                    var r0 = parsePercent(radius[0], size / 2);
                    var r = parsePercent(radius[1], size / 2);
                    var data = seriesModel.getData();
                    var startAngle = -seriesModel.get('startAngle') * RADIAN;
                    var minAngle = seriesModel.get('minAngle') * RADIAN;
                    var sum = data.getSum('value');
                    var unitRadian = Math.PI / (sum || data.count()) * 2;
                    var clockwise = seriesModel.get('clockwise');
                    var roseType = seriesModel.get('roseType');
                    var extent = data.getDataExtent('value');
                    extent[0] = 0;
                    var restAngle = PI2;
                    var valueSumLargerThanMinAngle = 0;
                    var currentAngle = startAngle;
                    var dir = clockwise ? 1 : -1;
                    data.each('value', function (value, idx) {
                        var angle;
                        if (roseType !== 'area') {
                            angle = sum === 0 ? unitRadian : value * unitRadian;
                        } else {
                            angle = PI2 / (data.count() || 1);
                        }
                        if (angle < minAngle) {
                            angle = minAngle;
                            restAngle -= minAngle;
                        } else {
                            valueSumLargerThanMinAngle += value;
                        }
                        var endAngle = currentAngle + dir * angle;
                        data.setItemLayout(idx, {
                            angle: angle,
                            startAngle: currentAngle,
                            endAngle: endAngle,
                            clockwise: clockwise,
                            cx: cx,
                            cy: cy,
                            r0: r0,
                            r: roseType ? numberUtil.linearMap(value, extent, [
                                r0,
                                r
                            ]) : r
                        });
                        currentAngle = endAngle;
                    }, true);
                    if (restAngle < PI2) {
                        if (restAngle <= 0.001) {
                            var angle = PI2 / data.count();
                            data.each(function (idx) {
                                var layout = data.getItemLayout(idx);
                                layout.startAngle = startAngle + dir * idx * angle;
                                layout.endAngle = startAngle + dir * (idx + 1) * angle;
                            });
                        } else {
                            unitRadian = restAngle / valueSumLargerThanMinAngle;
                            currentAngle = startAngle;
                            data.each('value', function (value, idx) {
                                var layout = data.getItemLayout(idx);
                                var angle = layout.angle === minAngle ? minAngle : value * unitRadian;
                                layout.startAngle = currentAngle;
                                layout.endAngle = currentAngle + dir * angle;
                                currentAngle += angle;
                            });
                        }
                    }
                    labelLayout(seriesModel, r, width, height);
                });
            };
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var textContain = __webpack_require__(14);
            function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {
                list.sort(function (a, b) {
                    return a.y - b.y;
                });
                function shiftDown(start, end, delta, dir) {
                    for (var j = start; j < end; j++) {
                        list[j].y += delta;
                        if (j > start && j + 1 < end && list[j + 1].y > list[j].y + list[j].height) {
                            shiftUp(j, delta / 2);
                            return;
                        }
                    }
                    shiftUp(end - 1, delta / 2);
                }
                function shiftUp(end, delta) {
                    for (var j = end; j >= 0; j--) {
                        list[j].y -= delta;
                        if (j > 0 && list[j].y > list[j - 1].y + list[j - 1].height) {
                            break;
                        }
                    }
                }
                function changeX(list, isDownList, cx, cy, r, dir) {
                    var lastDeltaX = dir > 0 ? isDownList ? Number.MAX_VALUE : 0 : isDownList ? Number.MAX_VALUE : 0;
                    for (var i = 0, l = list.length; i < l; i++) {
                        if (list[i].position === 'center') {
                            continue;
                        }
                        var deltaY = Math.abs(list[i].y - cy);
                        var length = list[i].len;
                        var length2 = list[i].len2;
                        var deltaX = deltaY < r + length ? Math.sqrt((r + length + length2) * (r + length + length2) - deltaY * deltaY) : Math.abs(list[i].x - cx);
                        if (isDownList && deltaX >= lastDeltaX) {
                            deltaX = lastDeltaX - 10;
                        }
                        if (!isDownList && deltaX <= lastDeltaX) {
                            deltaX = lastDeltaX + 10;
                        }
                        list[i].x = cx + deltaX * dir;
                        lastDeltaX = deltaX;
                    }
                }
                var lastY = 0;
                var delta;
                var len = list.length;
                var upList = [];
                var downList = [];
                for (var i = 0; i < len; i++) {
                    delta = list[i].y - lastY;
                    if (delta < 0) {
                        shiftDown(i, len, -delta, dir);
                    }
                    lastY = list[i].y + list[i].height;
                }
                if (viewHeight - lastY < 0) {
                    shiftUp(len - 1, lastY - viewHeight);
                }
                for (var i = 0; i < len; i++) {
                    if (list[i].y >= cy) {
                        downList.push(list[i]);
                    } else {
                        upList.push(list[i]);
                    }
                }
                changeX(upList, false, cx, cy, r, dir);
                changeX(downList, true, cx, cy, r, dir);
            }
            function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {
                var leftList = [];
                var rightList = [];
                for (var i = 0; i < labelLayoutList.length; i++) {
                    if (labelLayoutList[i].x < cx) {
                        leftList.push(labelLayoutList[i]);
                    } else {
                        rightList.push(labelLayoutList[i]);
                    }
                }
                adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);
                adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);
                for (var i = 0; i < labelLayoutList.length; i++) {
                    var linePoints = labelLayoutList[i].linePoints;
                    if (linePoints) {
                        var dist = linePoints[1][0] - linePoints[2][0];
                        if (labelLayoutList[i].x < cx) {
                            linePoints[2][0] = labelLayoutList[i].x + 3;
                        } else {
                            linePoints[2][0] = labelLayoutList[i].x - 3;
                        }
                        linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;
                        linePoints[1][0] = linePoints[2][0] + dist;
                    }
                }
            }
            module.exports = function (seriesModel, r, viewWidth, viewHeight) {
                var data = seriesModel.getData();
                var labelLayoutList = [];
                var cx;
                var cy;
                var hasLabelRotate = false;
                data.each(function (idx) {
                    var layout = data.getItemLayout(idx);
                    var itemModel = data.getItemModel(idx);
                    var labelModel = itemModel.getModel('label.normal');
                    var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');
                    var labelLineModel = itemModel.getModel('labelLine.normal');
                    var labelLineLen = labelLineModel.get('length');
                    var labelLineLen2 = labelLineModel.get('length2');
                    var midAngle = (layout.startAngle + layout.endAngle) / 2;
                    var dx = Math.cos(midAngle);
                    var dy = Math.sin(midAngle);
                    var textX;
                    var textY;
                    var linePoints;
                    var textAlign;
                    cx = layout.cx;
                    cy = layout.cy;
                    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';
                    if (labelPosition === 'center') {
                        textX = layout.cx;
                        textY = layout.cy;
                        textAlign = 'center';
                    } else {
                        var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;
                        var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;
                        textX = x1 + dx * 3;
                        textY = y1 + dy * 3;
                        if (!isLabelInside) {
                            var x2 = x1 + dx * (labelLineLen + r - layout.r);
                            var y2 = y1 + dy * (labelLineLen + r - layout.r);
                            var x3 = x2 + (dx < 0 ? -1 : 1) * labelLineLen2;
                            var y3 = y2;
                            textX = x3 + (dx < 0 ? -5 : 5);
                            textY = y3;
                            linePoints = [
                                [
                                    x1,
                                    y1
                                ],
                                [
                                    x2,
                                    y2
                                ],
                                [
                                    x3,
                                    y3
                                ]
                            ];
                        }
                        textAlign = isLabelInside ? 'center' : dx > 0 ? 'left' : 'right';
                    }
                    var font = labelModel.getModel('textStyle').getFont();
                    var labelRotate = labelModel.get('rotate') ? dx < 0 ? -midAngle + Math.PI : -midAngle : 0;
                    var text = seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx);
                    var textRect = textContain.getBoundingRect(text, font, textAlign, 'top');
                    hasLabelRotate = !!labelRotate;
                    layout.label = {
                        x: textX,
                        y: textY,
                        position: labelPosition,
                        height: textRect.height,
                        len: labelLineLen,
                        len2: labelLineLen2,
                        linePoints: linePoints,
                        textAlign: textAlign,
                        verticalAlign: 'middle',
                        font: font,
                        rotation: labelRotate
                    };
                    if (!isLabelInside) {
                        labelLayoutList.push(layout.label);
                    }
                });
                if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {
                    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);
                }
            };
        },
        function (module, exports) {
            module.exports = function (seriesType, ecModel) {
                var legendModels = ecModel.findComponents({ mainType: 'legend' });
                if (!legendModels || !legendModels.length) {
                    return;
                }
                ecModel.eachSeriesByType(seriesType, function (series) {
                    var data = series.getData();
                    data.filterSelf(function (idx) {
                        var name = data.getName(idx);
                        for (var i = 0; i < legendModels.length; i++) {
                            if (!legendModels[i].isSelected(name)) {
                                return false;
                            }
                        }
                        return true;
                    }, this);
                }, this);
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var echarts = __webpack_require__(1);
            __webpack_require__(142);
            __webpack_require__(143);
            echarts.registerVisualCoding('chart', zrUtil.curry(__webpack_require__(103), 'scatter', 'circle', null));
            echarts.registerLayout(zrUtil.curry(__webpack_require__(104), 'scatter'));
            __webpack_require__(106);
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var createListFromArray = __webpack_require__(93);
            var SeriesModel = __webpack_require__(27);
            module.exports = SeriesModel.extend({
                type: 'series.scatter',
                dependencies: [
                    'grid',
                    'polar'
                ],
                getInitialData: function (option, ecModel) {
                    var list = createListFromArray(option.data, this, ecModel);
                    return list;
                },
                defaultOption: {
                    coordinateSystem: 'cartesian2d',
                    zlevel: 0,
                    z: 2,
                    legendHoverLink: true,
                    hoverAnimation: true,
                    xAxisIndex: 0,
                    yAxisIndex: 0,
                    polarIndex: 0,
                    geoIndex: 0,
                    symbolSize: 10,
                    large: false,
                    largeThreshold: 2000,
                    itemStyle: { normal: { opacity: 0.8 } }
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var SymbolDraw = __webpack_require__(98);
            var LargeSymbolDraw = __webpack_require__(144);
            __webpack_require__(1).extendChartView({
                type: 'scatter',
                init: function () {
                    this._normalSymbolDraw = new SymbolDraw();
                    this._largeSymbolDraw = new LargeSymbolDraw();
                },
                render: function (seriesModel, ecModel, api) {
                    var data = seriesModel.getData();
                    var largeSymbolDraw = this._largeSymbolDraw;
                    var normalSymbolDraw = this._normalSymbolDraw;
                    var group = this.group;
                    var symbolDraw = seriesModel.get('large') && data.count() > seriesModel.get('largeThreshold') ? largeSymbolDraw : normalSymbolDraw;
                    this._symbolDraw = symbolDraw;
                    symbolDraw.updateData(data);
                    group.add(symbolDraw.group);
                    group.remove(symbolDraw === largeSymbolDraw ? normalSymbolDraw.group : largeSymbolDraw.group);
                },
                updateLayout: function (seriesModel) {
                    this._symbolDraw.updateLayout(seriesModel);
                },
                remove: function (ecModel, api) {
                    this._symbolDraw && this._symbolDraw.remove(api, true);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var symbolUtil = __webpack_require__(100);
            var zrUtil = __webpack_require__(3);
            var LargeSymbolPath = graphic.extendShape({
                shape: {
                    points: null,
                    sizes: null
                },
                symbolProxy: null,
                buildPath: function (path, shape) {
                    var points = shape.points;
                    var sizes = shape.sizes;
                    var symbolProxy = this.symbolProxy;
                    var symbolProxyShape = symbolProxy.shape;
                    for (var i = 0; i < points.length; i++) {
                        var pt = points[i];
                        var size = sizes[i];
                        if (size[0] < 4) {
                            path.rect(pt[0] - size[0] / 2, pt[1] - size[1] / 2, size[0], size[1]);
                        } else {
                            symbolProxyShape.x = pt[0] - size[0] / 2;
                            symbolProxyShape.y = pt[1] - size[1] / 2;
                            symbolProxyShape.width = size[0];
                            symbolProxyShape.height = size[1];
                            symbolProxy.buildPath(path, symbolProxyShape);
                        }
                    }
                }
            });
            function LargeSymbolDraw() {
                this.group = new graphic.Group();
                this._symbolEl = new LargeSymbolPath({ silent: true });
            }
            var largeSymbolProto = LargeSymbolDraw.prototype;
            largeSymbolProto.updateData = function (data) {
                this.group.removeAll();
                var symbolEl = this._symbolEl;
                var seriesModel = data.hostModel;
                symbolEl.setShape({
                    points: data.mapArray(data.getItemLayout),
                    sizes: data.mapArray(function (idx) {
                        var size = data.getItemVisual(idx, 'symbolSize');
                        if (!zrUtil.isArray(size)) {
                            size = [
                                size,
                                size
                            ];
                        }
                        return size;
                    })
                });
                symbolEl.symbolProxy = symbolUtil.createSymbol(data.getVisual('symbol'), 0, 0, 0, 0);
                symbolEl.setColor = symbolEl.symbolProxy.setColor;
                symbolEl.setStyle(seriesModel.getModel('itemStyle.normal').getItemStyle(['color']));
                var visualColor = data.getVisual('color');
                if (visualColor) {
                    symbolEl.setColor(visualColor);
                }
                this.group.add(this._symbolEl);
            };
            largeSymbolProto.updateLayout = function (seriesModel) {
                var data = seriesModel.getData();
                this._symbolEl.setShape({ points: data.mapArray(data.getItemLayout) });
            };
            largeSymbolProto.remove = function () {
                this.group.removeAll();
            };
            module.exports = LargeSymbolDraw;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var echarts = __webpack_require__(1);
            __webpack_require__(146);
            __webpack_require__(151);
            __webpack_require__(152);
            echarts.registerVisualCoding('chart', zrUtil.curry(__webpack_require__(137), 'radar'));
            echarts.registerVisualCoding('chart', zrUtil.curry(__webpack_require__(103), 'radar', 'circle', null));
            echarts.registerLayout(__webpack_require__(153));
            echarts.registerProcessor('filter', zrUtil.curry(__webpack_require__(140), 'radar'));
            echarts.registerPreprocessor(__webpack_require__(154));
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(147);
            __webpack_require__(149);
            __webpack_require__(150);
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var IndicatorAxis = __webpack_require__(148);
            var IntervalScale = __webpack_require__(111);
            var numberUtil = __webpack_require__(7);
            var axisHelper = __webpack_require__(108);
            function Radar(radarModel, ecModel, api) {
                this._model = radarModel;
                this.dimensions = [];
                this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {
                    var dim = 'indicator_' + idx;
                    var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());
                    indicatorAxis.name = indicatorModel.get('name');
                    indicatorAxis.model = indicatorModel;
                    indicatorModel.axis = indicatorAxis;
                    this.dimensions.push(dim);
                    return indicatorAxis;
                }, this);
                this.resize(radarModel, api);
                this.cx;
                this.cy;
                this.r;
                this.startAngle;
            }
            Radar.prototype.getIndicatorAxes = function () {
                return this._indicatorAxes;
            };
            Radar.prototype.dataToPoint = function (value, indicatorIndex) {
                var indicatorAxis = this._indicatorAxes[indicatorIndex];
                return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
            };
            Radar.prototype.coordToPoint = function (coord, indicatorIndex) {
                var indicatorAxis = this._indicatorAxes[indicatorIndex];
                var angle = indicatorAxis.angle;
                var x = this.cx + coord * Math.cos(angle);
                var y = this.cy - coord * Math.sin(angle);
                return [
                    x,
                    y
                ];
            };
            Radar.prototype.pointToData = function (pt) {
                var dx = pt[0] - this.cx;
                var dy = pt[1] - this.cy;
                var radius = Math.sqrt(dx * dx + dy * dy);
                dx /= radius;
                dy /= radius;
                var radian = Math.atan2(-dy, dx);
                var minRadianDiff = Infinity;
                var closestAxis;
                var closestAxisIdx = -1;
                for (var i = 0; i < this._indicatorAxes.length; i++) {
                    var indicatorAxis = this._indicatorAxes[i];
                    var diff = Math.abs(radian - indicatorAxis.angle);
                    if (diff < minRadianDiff) {
                        closestAxis = indicatorAxis;
                        closestAxisIdx = i;
                        minRadianDiff = diff;
                    }
                }
                return [
                    closestAxisIdx,
                    +(closestAxis && closestAxis.coodToData(radius))
                ];
            };
            Radar.prototype.resize = function (radarModel, api) {
                var center = radarModel.get('center');
                var viewWidth = api.getWidth();
                var viewHeight = api.getHeight();
                var viewSize = Math.min(viewWidth, viewHeight) / 2;
                this.cx = numberUtil.parsePercent(center[0], viewWidth);
                this.cy = numberUtil.parsePercent(center[1], viewHeight);
                this.startAngle = radarModel.get('startAngle') * Math.PI / 180;
                this.r = numberUtil.parsePercent(radarModel.get('radius'), viewSize);
                zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {
                    indicatorAxis.setExtent(0, this.r);
                    var angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length;
                    angle = Math.atan2(Math.sin(angle), Math.cos(angle));
                    indicatorAxis.angle = angle;
                }, this);
            };
            Radar.prototype.update = function (ecModel, api) {
                var indicatorAxes = this._indicatorAxes;
                var radarModel = this._model;
                zrUtil.each(indicatorAxes, function (indicatorAxis) {
                    indicatorAxis.scale.setExtent(Infinity, -Infinity);
                });
                ecModel.eachSeriesByType('radar', function (radarSeries, idx) {
                    if (radarSeries.get('coordinateSystem') !== 'radar' || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {
                        return;
                    }
                    var data = radarSeries.getData();
                    zrUtil.each(indicatorAxes, function (indicatorAxis) {
                        indicatorAxis.scale.unionExtent(data.getDataExtent(indicatorAxis.dim));
                    });
                }, this);
                var splitNumber = radarModel.get('splitNumber');
                function increaseInterval(interval) {
                    var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));
                    var f = interval / exp10;
                    if (f === 2) {
                        f = 5;
                    } else {
                        f *= 2;
                    }
                    return f * exp10;
                }
                zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {
                    var rawExtent = axisHelper.getScaleExtent(indicatorAxis, indicatorAxis.model);
                    axisHelper.niceScaleExtent(indicatorAxis, indicatorAxis.model);
                    var axisModel = indicatorAxis.model;
                    var scale = indicatorAxis.scale;
                    var fixedMin = axisModel.get('min');
                    var fixedMax = axisModel.get('max');
                    var interval = scale.getInterval();
                    if (fixedMin != null && fixedMax != null) {
                        scale.setInterval((fixedMax - fixedMin) / splitNumber);
                    } else if (fixedMin != null) {
                        var max;
                        do {
                            max = fixedMin + interval * splitNumber;
                            scale.setExtent(+fixedMin, max);
                            scale.setInterval(interval);
                            interval = increaseInterval(interval);
                        } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));
                    } else if (fixedMax != null) {
                        var min;
                        do {
                            min = fixedMax - interval * splitNumber;
                            scale.setExtent(min, +fixedMax);
                            scale.setInterval(interval);
                            interval = increaseInterval(interval);
                        } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));
                    } else {
                        var nicedSplitNumber = scale.getTicks().length - 1;
                        if (nicedSplitNumber > splitNumber) {
                            interval = increaseInterval(interval);
                        }
                        var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;
                        var halfSplitNumber = Math.round(splitNumber / 2);
                        scale.setExtent(numberUtil.round(center - halfSplitNumber * interval), numberUtil.round(center + (splitNumber - halfSplitNumber) * interval));
                        scale.setInterval(interval);
                    }
                });
            };
            Radar.dimensions = [];
            Radar.create = function (ecModel, api) {
                var radarList = [];
                ecModel.eachComponent('radar', function (radarModel) {
                    var radar = new Radar(radarModel, ecModel, api);
                    radarList.push(radar);
                    radarModel.coordinateSystem = radar;
                });
                ecModel.eachSeriesByType('radar', function (radarSeries) {
                    if (radarSeries.get('coordinateSystem') === 'radar') {
                        radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];
                    }
                });
                return radarList;
            };
            __webpack_require__(25).register('radar', Radar);
            module.exports = Radar;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var Axis = __webpack_require__(117);
            function IndicatorAxis(dim, scale, radiusExtent) {
                Axis.call(this, dim, scale, radiusExtent);
                this.type = 'value';
                this.angle = 0;
                this.name = '';
                this.model;
            }
            zrUtil.inherits(IndicatorAxis, Axis);
            module.exports = IndicatorAxis;
        },
        function (module, exports, __webpack_require__) {
            var axisDefault = __webpack_require__(122);
            var valueAxisDefault = axisDefault.valueAxis;
            var Model = __webpack_require__(8);
            var zrUtil = __webpack_require__(3);
            var axisModelCommonMixin = __webpack_require__(123);
            function defaultsShow(opt, show) {
                return zrUtil.defaults({ show: show }, opt);
            }
            var RadarModel = __webpack_require__(1).extendComponentModel({
                type: 'radar',
                optionUpdated: function () {
                    var boundaryGap = this.get('boundaryGap');
                    var splitNumber = this.get('splitNumber');
                    var scale = this.get('scale');
                    var axisLine = this.get('axisLine');
                    var axisTick = this.get('axisTick');
                    var axisLabel = this.get('axisLabel');
                    var nameTextStyle = this.get('name.textStyle');
                    var showName = this.get('name.show');
                    var nameFormatter = this.get('name.formatter');
                    var nameGap = this.get('nameGap');
                    var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) {
                        if (indicatorOpt.max != null && indicatorOpt.max > 0) {
                            indicatorOpt.min = 0;
                        } else if (indicatorOpt.min != null && indicatorOpt.min < 0) {
                            indicatorOpt.max = 0;
                        }
                        indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {
                            boundaryGap: boundaryGap,
                            splitNumber: splitNumber,
                            scale: scale,
                            axisLine: axisLine,
                            axisTick: axisTick,
                            axisLabel: axisLabel,
                            name: indicatorOpt.text,
                            nameLocation: 'end',
                            nameGap: nameGap,
                            nameTextStyle: nameTextStyle
                        }, false);
                        if (!showName) {
                            indicatorOpt.name = '';
                        }
                        if (typeof nameFormatter === 'string') {
                            indicatorOpt.name = nameFormatter.replace('{value}', indicatorOpt.name);
                        } else if (typeof nameFormatter === 'function') {
                            indicatorOpt.name = nameFormatter(indicatorOpt.name, indicatorOpt);
                        }
                        return zrUtil.extend(new Model(indicatorOpt, null, this.ecModel), axisModelCommonMixin);
                    }, this);
                    this.getIndicatorModels = function () {
                        return indicatorModels;
                    };
                },
                defaultOption: {
                    zlevel: 0,
                    z: 0,
                    center: [
                        '50%',
                        '50%'
                    ],
                    radius: '75%',
                    startAngle: 90,
                    name: { show: true },
                    boundaryGap: [
                        0,
                        0
                    ],
                    splitNumber: 5,
                    nameGap: 15,
                    scale: false,
                    shape: 'polygon',
                    axisLine: zrUtil.merge({ lineStyle: { color: '#bbb' } }, valueAxisDefault.axisLine),
                    axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
                    axisTick: defaultsShow(valueAxisDefault.axisTick, false),
                    splitLine: defaultsShow(valueAxisDefault.splitLine, true),
                    splitArea: defaultsShow(valueAxisDefault.splitArea, true),
                    indicator: []
                }
            });
            module.exports = RadarModel;
        },
        function (module, exports, __webpack_require__) {
            var AxisBuilder = __webpack_require__(126);
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var axisBuilderAttrs = [
                'axisLine',
                'axisLabel',
                'axisTick',
                'axisName'
            ];
            module.exports = __webpack_require__(1).extendComponentView({
                type: 'radar',
                render: function (radarModel, ecModel, api) {
                    var group = this.group;
                    group.removeAll();
                    this._buildAxes(radarModel);
                    this._buildSplitLineAndArea(radarModel);
                },
                _buildAxes: function (radarModel) {
                    var radar = radarModel.coordinateSystem;
                    var indicatorAxes = radar.getIndicatorAxes();
                    var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) {
                        var axisBuilder = new AxisBuilder(indicatorAxis.model, {
                            position: [
                                radar.cx,
                                radar.cy
                            ],
                            rotation: indicatorAxis.angle,
                            labelDirection: -1,
                            tickDirection: -1,
                            nameDirection: 1
                        });
                        return axisBuilder;
                    });
                    zrUtil.each(axisBuilders, function (axisBuilder) {
                        zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
                        this.group.add(axisBuilder.getGroup());
                    }, this);
                },
                _buildSplitLineAndArea: function (radarModel) {
                    var radar = radarModel.coordinateSystem;
                    var splitNumber = radarModel.get('splitNumber');
                    var indicatorAxes = radar.getIndicatorAxes();
                    if (!indicatorAxes.length) {
                        return;
                    }
                    var shape = radarModel.get('shape');
                    var splitLineModel = radarModel.getModel('splitLine');
                    var splitAreaModel = radarModel.getModel('splitArea');
                    var lineStyleModel = splitLineModel.getModel('lineStyle');
                    var areaStyleModel = splitAreaModel.getModel('areaStyle');
                    var showSplitLine = splitLineModel.get('show');
                    var showSplitArea = splitAreaModel.get('show');
                    var splitLineColors = lineStyleModel.get('color');
                    var splitAreaColors = areaStyleModel.get('color');
                    splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];
                    splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];
                    var splitLines = [];
                    var splitAreas = [];
                    function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
                        var colorIndex = idx % areaOrLineColorList.length;
                        areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];
                        return colorIndex;
                    }
                    if (shape === 'circle') {
                        var ticksRadius = indicatorAxes[0].getTicksCoords();
                        var cx = radar.cx;
                        var cy = radar.cy;
                        for (var i = 0; i < ticksRadius.length; i++) {
                            if (showSplitLine) {
                                var colorIndex = getColorIndex(splitLines, splitLineColors, i);
                                splitLines[colorIndex].push(new graphic.Circle({
                                    shape: {
                                        cx: cx,
                                        cy: cy,
                                        r: ticksRadius[i]
                                    }
                                }));
                            }
                            if (showSplitArea && i < ticksRadius.length - 1) {
                                var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);
                                splitAreas[colorIndex].push(new graphic.Ring({
                                    shape: {
                                        cx: cx,
                                        cy: cy,
                                        r0: ticksRadius[i],
                                        r: ticksRadius[i + 1]
                                    }
                                }));
                            }
                        }
                    } else {
                        var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) {
                            var ticksCoords = indicatorAxis.getTicksCoords();
                            return zrUtil.map(ticksCoords, function (tickCoord) {
                                return radar.coordToPoint(tickCoord, idx);
                            });
                        });
                        var prevPoints = [];
                        for (var i = 0; i <= splitNumber; i++) {
                            var points = [];
                            for (var j = 0; j < indicatorAxes.length; j++) {
                                points.push(axesTicksPoints[j][i]);
                            }
                            points.push(points[0].slice());
                            if (showSplitLine) {
                                var colorIndex = getColorIndex(splitLines, splitLineColors, i);
                                splitLines[colorIndex].push(new graphic.Polyline({ shape: { points: points } }));
                            }
                            if (showSplitArea && prevPoints) {
                                var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);
                                splitAreas[colorIndex].push(new graphic.Polygon({ shape: { points: points.concat(prevPoints) } }));
                            }
                            prevPoints = points.slice().reverse();
                        }
                    }
                    var lineStyle = lineStyleModel.getLineStyle();
                    var areaStyle = areaStyleModel.getAreaStyle();
                    zrUtil.each(splitAreas, function (splitAreas, idx) {
                        this.group.add(graphic.mergePath(splitAreas, {
                            style: zrUtil.defaults({
                                stroke: 'none',
                                fill: splitAreaColors[idx % splitAreaColors.length]
                            }, areaStyle),
                            silent: true
                        }));
                    }, this);
                    zrUtil.each(splitLines, function (splitLines, idx) {
                        this.group.add(graphic.mergePath(splitLines, {
                            style: zrUtil.defaults({
                                fill: 'none',
                                stroke: splitLineColors[idx % splitLineColors.length]
                            }, lineStyle),
                            silent: true
                        }));
                    }, this);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var SeriesModel = __webpack_require__(27);
            var List = __webpack_require__(94);
            var completeDimensions = __webpack_require__(96);
            var zrUtil = __webpack_require__(3);
            var formatUtil = __webpack_require__(6);
            var RadarSeries = SeriesModel.extend({
                type: 'series.radar',
                dependencies: ['radar'],
                init: function (option) {
                    RadarSeries.superApply(this, 'init', arguments);
                    this.legendDataProvider = function () {
                        return this._dataBeforeProcessed;
                    };
                },
                getInitialData: function (option, ecModel) {
                    var data = option.data || [];
                    var dimensions = completeDimensions([], data, [], 'indicator_');
                    var list = new List(dimensions, this);
                    list.initData(data);
                    return list;
                },
                formatTooltip: function (dataIndex) {
                    var value = this.getRawValue(dataIndex);
                    var coordSys = this.coordinateSystem;
                    var indicatorAxes = coordSys.getIndicatorAxes();
                    return this._data.getName(dataIndex) + '<br />' + zrUtil.map(indicatorAxes, function (axis, idx) {
                        return axis.name + ' : ' + value[idx];
                    }).join('<br />');
                },
                getFormattedLabel: function (dataIndex, status, formatter, indicatorIndex) {
                    status = status || 'normal';
                    var data = this.getData();
                    var itemModel = data.getItemModel(dataIndex);
                    var params = this.getDataParams(dataIndex);
                    if (formatter == null) {
                        formatter = itemModel.get([
                            'label',
                            status,
                            'formatter'
                        ]);
                    }
                    params.value = params.value[indicatorIndex || 0];
                    if (typeof formatter === 'function') {
                        params.status = status;
                        return formatter(params);
                    } else if (typeof formatter === 'string') {
                        return formatUtil.formatTpl(formatter, params);
                    }
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: 'radar',
                    legendHoverLink: true,
                    radarIndex: 0,
                    lineStyle: {
                        normal: {
                            width: 2,
                            type: 'solid'
                        }
                    },
                    label: { normal: { position: 'top' } },
                    symbol: 'emptyCircle',
                    symbolSize: 4
                }
            });
            module.exports = RadarSeries;
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var zrUtil = __webpack_require__(3);
            var symbolUtil = __webpack_require__(100);
            function normalizeSymbolSize(symbolSize) {
                if (!zrUtil.isArray(symbolSize)) {
                    symbolSize = [
                        +symbolSize,
                        +symbolSize
                    ];
                }
                return symbolSize;
            }
            module.exports = __webpack_require__(1).extendChartView({
                type: 'radar',
                render: function (seriesModel, ecModel, api) {
                    var polar = seriesModel.coordinateSystem;
                    var group = this.group;
                    var data = seriesModel.getData();
                    var oldData = this._data;
                    function createSymbol(data, idx) {
                        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
                        var color = data.getItemVisual(idx, 'color');
                        if (symbolType === 'none') {
                            return;
                        }
                        var symbolPath = symbolUtil.createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
                        symbolPath.attr({
                            style: { strokeNoScale: true },
                            z2: 100,
                            scale: normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))
                        });
                        return symbolPath;
                    }
                    function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {
                        symbolGroup.removeAll();
                        for (var i = 0; i < newPoints.length - 1; i++) {
                            var symbolPath = createSymbol(data, idx);
                            if (symbolPath) {
                                symbolPath.__dimIdx = i;
                                if (oldPoints[i]) {
                                    symbolPath.attr('position', oldPoints[i]);
                                    graphic[isInit ? 'initProps' : 'updateProps'](symbolPath, { position: newPoints[i] }, seriesModel);
                                } else {
                                    symbolPath.attr('position', newPoints[i]);
                                }
                                symbolGroup.add(symbolPath);
                            }
                        }
                    }
                    function getInitialPoints(points) {
                        return zrUtil.map(points, function (pt) {
                            return [
                                polar.cx,
                                polar.cy
                            ];
                        });
                    }
                    data.diff(oldData).add(function (idx) {
                        var points = data.getItemLayout(idx);
                        if (!points) {
                            return;
                        }
                        var polygon = new graphic.Polygon();
                        var polyline = new graphic.Polyline();
                        var target = { shape: { points: points } };
                        polygon.shape.points = getInitialPoints(points);
                        polyline.shape.points = getInitialPoints(points);
                        graphic.initProps(polygon, target, seriesModel);
                        graphic.initProps(polyline, target, seriesModel);
                        var itemGroup = new graphic.Group();
                        var symbolGroup = new graphic.Group();
                        itemGroup.add(polyline);
                        itemGroup.add(polygon);
                        itemGroup.add(symbolGroup);
                        updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true);
                        data.setItemGraphicEl(idx, itemGroup);
                    }).update(function (newIdx, oldIdx) {
                        var itemGroup = oldData.getItemGraphicEl(oldIdx);
                        var polyline = itemGroup.childAt(0);
                        var polygon = itemGroup.childAt(1);
                        var symbolGroup = itemGroup.childAt(2);
                        var target = { shape: { points: data.getItemLayout(newIdx) } };
                        if (!target.shape.points) {
                            return;
                        }
                        updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false);
                        graphic.updateProps(polyline, target, seriesModel);
                        graphic.updateProps(polygon, target, seriesModel);
                        data.setItemGraphicEl(newIdx, itemGroup);
                    }).remove(function (idx) {
                        group.remove(oldData.getItemGraphicEl(idx));
                    }).execute();
                    data.eachItemGraphicEl(function (itemGroup, idx) {
                        var itemModel = data.getItemModel(idx);
                        var polyline = itemGroup.childAt(0);
                        var polygon = itemGroup.childAt(1);
                        var symbolGroup = itemGroup.childAt(2);
                        var color = data.getItemVisual(idx, 'color');
                        group.add(itemGroup);
                        polyline.setStyle(zrUtil.extend(itemModel.getModel('lineStyle.normal').getLineStyle(), { stroke: color }));
                        polyline.hoverStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();
                        var areaStyleModel = itemModel.getModel('areaStyle.normal');
                        var hoverAreaStyleModel = itemModel.getModel('areaStyle.emphasis');
                        var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
                        var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();
                        hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;
                        polygon.ignore = polygonIgnore;
                        polygon.setStyle(zrUtil.defaults(areaStyleModel.getAreaStyle(), {
                            fill: color,
                            opacity: 0.7
                        }));
                        polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();
                        var itemStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);
                        var itemHoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();
                        var labelModel = itemModel.getModel('label.normal');
                        var labelHoverModel = itemModel.getModel('label.emphasis');
                        symbolGroup.eachChild(function (symbolPath) {
                            symbolPath.setStyle(itemStyle);
                            symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);
                            var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);
                            graphic.setText(symbolPath.style, labelModel, color);
                            symbolPath.setStyle({ text: labelModel.get('show') ? zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal', null, symbolPath.__dimIdx), defaultText) : '' });
                            graphic.setText(symbolPath.hoverStyle, labelHoverModel, color);
                            symbolPath.hoverStyle.text = labelHoverModel.get('show') ? zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis', null, symbolPath.__dimIdx), defaultText) : '';
                        });
                        function onEmphasis() {
                            polygon.attr('ignore', hoverPolygonIgnore);
                        }
                        function onNormal() {
                            polygon.attr('ignore', polygonIgnore);
                        }
                        itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');
                        itemGroup.on('emphasis', onEmphasis).on('mouseover', onEmphasis).on('normal', onNormal).on('mouseout', onNormal);
                        graphic.setHoverStyle(itemGroup);
                    });
                    this._data = data;
                },
                remove: function () {
                    this.group.removeAll();
                    this._data = null;
                }
            });
        },
        function (module, exports) {
            module.exports = function (ecModel, api) {
                ecModel.eachSeriesByType('radar', function (seriesModel) {
                    var data = seriesModel.getData();
                    var points = [];
                    var coordSys = seriesModel.coordinateSystem;
                    if (!coordSys) {
                        return;
                    }
                    function pointsConverter(val, idx) {
                        points[idx] = points[idx] || [];
                        points[idx][i] = coordSys.dataToPoint(val, i);
                    }
                    for (var i = 0; i < coordSys.getIndicatorAxes().length; i++) {
                        var dim = data.dimensions[i];
                        data.each(dim, pointsConverter);
                    }
                    data.each(function (idx) {
                        points[idx][0] && points[idx].push(points[idx][0].slice());
                        data.setItemLayout(idx, points[idx]);
                    });
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            module.exports = function (option) {
                var polarOptArr = option.polar;
                if (polarOptArr) {
                    if (!zrUtil.isArray(polarOptArr)) {
                        polarOptArr = [polarOptArr];
                    }
                    var polarNotRadar = [];
                    zrUtil.each(polarOptArr, function (polarOpt, idx) {
                        if (polarOpt.indicator) {
                            if (polarOpt.type && !polarOpt.shape) {
                                polarOpt.shape = polarOpt.type;
                            }
                            option.radar = option.radar || [];
                            if (!zrUtil.isArray(option.radar)) {
                                option.radar = [option.radar];
                            }
                            option.radar.push(polarOpt);
                        } else {
                            polarNotRadar.push(polarOpt);
                        }
                    });
                    option.polar = polarNotRadar;
                }
                zrUtil.each(option.series, function (seriesOpt) {
                    if (seriesOpt.type === 'radar' && seriesOpt.polarIndex) {
                        seriesOpt.radarIndex = seriesOpt.polarIndex;
                    }
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            __webpack_require__(156);
            __webpack_require__(157);
            __webpack_require__(161);
            __webpack_require__(163);
            echarts.registerLayout(__webpack_require__(173));
            echarts.registerVisualCoding('chart', __webpack_require__(174));
            echarts.registerProcessor('statistic', __webpack_require__(175));
            echarts.registerPreprocessor(__webpack_require__(176));
            __webpack_require__(136)('map', [
                {
                    type: 'mapToggleSelect',
                    event: 'mapselectchanged',
                    method: 'toggleSelected'
                },
                {
                    type: 'mapSelect',
                    event: 'mapselected',
                    method: 'select'
                },
                {
                    type: 'mapUnSelect',
                    event: 'mapunselected',
                    method: 'unSelect'
                }
            ]);
        },
        function (module, exports, __webpack_require__) {
            var List = __webpack_require__(94);
            var echarts = __webpack_require__(1);
            var SeriesModel = __webpack_require__(27);
            var zrUtil = __webpack_require__(3);
            var completeDimensions = __webpack_require__(96);
            var formatUtil = __webpack_require__(6);
            var encodeHTML = formatUtil.encodeHTML;
            var addCommas = formatUtil.addCommas;
            var dataSelectableMixin = __webpack_require__(134);
            function fillData(dataOpt, geoJson) {
                var dataNameMap = {};
                var features = geoJson.features;
                for (var i = 0; i < dataOpt.length; i++) {
                    dataNameMap[dataOpt[i].name] = dataOpt[i];
                }
                for (var i = 0; i < features.length; i++) {
                    var name = features[i].properties.name;
                    if (!dataNameMap[name]) {
                        dataOpt.push({
                            value: NaN,
                            name: name
                        });
                    }
                }
                return dataOpt;
            }
            var MapSeries = SeriesModel.extend({
                type: 'series.map',
                needsDrawMap: false,
                seriesGroup: [],
                init: function (option) {
                    option = this._fillOption(option);
                    this.option = option;
                    MapSeries.superApply(this, 'init', arguments);
                    this.updateSelectedMap();
                },
                getInitialData: function (option) {
                    var dimensions = completeDimensions(['value'], option.data || []);
                    var list = new List(dimensions, this);
                    list.initData(option.data);
                    return list;
                },
                mergeOption: function (newOption) {
                    newOption = this._fillOption(newOption);
                    MapSeries.superCall(this, 'mergeOption', newOption);
                    this.updateSelectedMap();
                },
                _fillOption: function (option) {
                    option = zrUtil.extend({}, option);
                    var map = echarts.getMap(option.map);
                    var geoJson = map && map.geoJson;
                    geoJson && option.data && (option.data = fillData(option.data, geoJson));
                    return option;
                },
                setRoamZoom: function (zoom) {
                    var roamDetail = this.option.roamDetail;
                    roamDetail && (roamDetail.zoom = zoom);
                },
                setRoamPan: function (x, y) {
                    var roamDetail = this.option.roamDetail;
                    if (roamDetail) {
                        roamDetail.x = x;
                        roamDetail.y = y;
                    }
                },
                getRawValue: function (dataIndex) {
                    return this._data.get('value', dataIndex);
                },
                formatTooltip: function (dataIndex) {
                    var data = this._data;
                    var formattedValue = addCommas(this.getRawValue(dataIndex));
                    var name = data.getName(dataIndex);
                    var seriesGroup = this.seriesGroup;
                    var seriesNames = [];
                    for (var i = 0; i < seriesGroup.length; i++) {
                        if (!isNaN(seriesGroup[i].getRawValue(dataIndex))) {
                            seriesNames.push(encodeHTML(seriesGroup[i].name));
                        }
                    }
                    return seriesNames.join(', ') + '<br />' + name + ' : ' + formattedValue;
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: 'geo',
                    map: 'china',
                    left: 'center',
                    top: 'center',
                    showLegendSymbol: true,
                    dataRangeHoverLink: true,
                    roamDetail: {
                        x: 0,
                        y: 0,
                        zoom: 1
                    },
                    scaleLimit: null,
                    label: {
                        normal: {
                            show: false,
                            textStyle: { color: '#000' }
                        },
                        emphasis: {
                            show: false,
                            textStyle: { color: '#000' }
                        }
                    },
                    itemStyle: {
                        normal: {
                            borderWidth: 0.5,
                            borderColor: '#444',
                            areaColor: '#eee'
                        },
                        emphasis: { areaColor: 'rgba(255,215, 0, 0.8)' }
                    }
                }
            });
            zrUtil.mixin(MapSeries, dataSelectableMixin);
            module.exports = MapSeries;
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var MapDraw = __webpack_require__(158);
            __webpack_require__(1).extendChartView({
                type: 'map',
                render: function (mapModel, ecModel, api, payload) {
                    if (payload && payload.type === 'mapToggleSelect' && payload.from === this.uid) {
                        return;
                    }
                    var group = this.group;
                    group.removeAll();
                    if (!(payload && payload.type === 'geoRoam' && payload.component === 'series' && payload.name === mapModel.name)) {
                        if (mapModel.needsDrawMap) {
                            var mapDraw = this._mapDraw || new MapDraw(api, true);
                            group.add(mapDraw.group);
                            mapDraw.draw(mapModel, ecModel, api, this);
                            this._mapDraw = mapDraw;
                        } else {
                            this._mapDraw && this._mapDraw.remove();
                            this._mapDraw = null;
                        }
                    } else {
                        var mapDraw = this._mapDraw;
                        mapDraw && group.add(mapDraw.group);
                    }
                    mapModel.get('showLegendSymbol') && ecModel.getComponent('legend') && this._renderSymbols(mapModel, ecModel, api);
                },
                remove: function () {
                    this._mapDraw && this._mapDraw.remove();
                    this._mapDraw = null;
                    this.group.removeAll();
                },
                _renderSymbols: function (mapModel, ecModel, api) {
                    var data = mapModel.getData();
                    var group = this.group;
                    data.each('value', function (value, idx) {
                        if (isNaN(value)) {
                            return;
                        }
                        var layout = data.getItemLayout(idx);
                        if (!layout || !layout.point) {
                            return;
                        }
                        var point = layout.point;
                        var offset = layout.offset;
                        var circle = new graphic.Circle({
                            style: { fill: data.getVisual('color') },
                            shape: {
                                cx: point[0] + offset * 9,
                                cy: point[1],
                                r: 3
                            },
                            silent: true,
                            z2: 10
                        });
                        if (!offset) {
                            var labelText = data.getName(idx);
                            var itemModel = data.getItemModel(idx);
                            var labelModel = itemModel.getModel('label.normal');
                            var hoverLabelModel = itemModel.getModel('label.emphasis');
                            var textStyleModel = labelModel.getModel('textStyle');
                            var hoverTextStyleModel = hoverLabelModel.getModel('textStyle');
                            var polygonGroups = data.getItemGraphicEl(idx);
                            circle.setStyle({ textPosition: 'bottom' });
                            var onEmphasis = function () {
                                circle.setStyle({
                                    text: hoverLabelModel.get('show') ? labelText : '',
                                    textFill: hoverTextStyleModel.getTextColor(),
                                    textFont: hoverTextStyleModel.getFont()
                                });
                            };
                            var onNormal = function () {
                                circle.setStyle({
                                    text: labelModel.get('show') ? labelText : '',
                                    textFill: textStyleModel.getTextColor(),
                                    textFont: textStyleModel.getFont()
                                });
                            };
                            polygonGroups.on('mouseover', onEmphasis).on('mouseout', onNormal).on('emphasis', onEmphasis).on('normal', onNormal);
                            onNormal();
                        }
                        group.add(circle);
                    });
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var RoamController = __webpack_require__(159);
            var graphic = __webpack_require__(42);
            var zrUtil = __webpack_require__(3);
            function getFixedItemStyle(model, scale) {
                var itemStyle = model.getItemStyle();
                var areaColor = model.get('areaColor');
                if (areaColor) {
                    itemStyle.fill = areaColor;
                }
                return itemStyle;
            }
            function updateMapSelectHandler(mapOrGeoModel, data, group, api, fromView) {
                group.off('click');
                mapOrGeoModel.get('selectedMode') && group.on('click', function (e) {
                    var dataIndex = e.target.dataIndex;
                    if (dataIndex != null) {
                        var name = data.getName(dataIndex);
                        api.dispatchAction({
                            type: 'mapToggleSelect',
                            seriesIndex: mapOrGeoModel.seriesIndex,
                            name: name,
                            from: fromView.uid
                        });
                        updateMapSelected(mapOrGeoModel, data, api);
                    }
                });
            }
            function updateMapSelected(mapOrGeoModel, data) {
                data.eachItemGraphicEl(function (el, idx) {
                    var name = data.getName(idx);
                    el.trigger(mapOrGeoModel.isSelected(name) ? 'emphasis' : 'normal');
                });
            }
            function MapDraw(api, updateGroup) {
                var group = new graphic.Group();
                this._controller = new RoamController(api.getZr(), updateGroup ? group : null, null);
                this.group = group;
                this._updateGroup = updateGroup;
            }
            MapDraw.prototype = {
                constructor: MapDraw,
                draw: function (mapOrGeoModel, ecModel, api, fromView) {
                    var data = mapOrGeoModel.getData && mapOrGeoModel.getData();
                    var geo = mapOrGeoModel.coordinateSystem;
                    var group = this.group;
                    group.removeAll();
                    var scale = geo.scale;
                    group.position = geo.position.slice();
                    group.scale = scale.slice();
                    var itemStyleModel;
                    var hoverItemStyleModel;
                    var itemStyle;
                    var hoverItemStyle;
                    var labelModel;
                    var hoverLabelModel;
                    var itemStyleAccessPath = [
                        'itemStyle',
                        'normal'
                    ];
                    var hoverItemStyleAccessPath = [
                        'itemStyle',
                        'emphasis'
                    ];
                    var labelAccessPath = [
                        'label',
                        'normal'
                    ];
                    var hoverLabelAccessPath = [
                        'label',
                        'emphasis'
                    ];
                    if (!data) {
                        itemStyleModel = mapOrGeoModel.getModel(itemStyleAccessPath);
                        hoverItemStyleModel = mapOrGeoModel.getModel(hoverItemStyleAccessPath);
                        itemStyle = getFixedItemStyle(itemStyleModel, scale);
                        hoverItemStyle = getFixedItemStyle(hoverItemStyleModel, scale);
                        labelModel = mapOrGeoModel.getModel(labelAccessPath);
                        hoverLabelModel = mapOrGeoModel.getModel(hoverLabelAccessPath);
                    }
                    zrUtil.each(geo.regions, function (region) {
                        var regionGroup = new graphic.Group();
                        var dataIdx;
                        if (data) {
                            dataIdx = data.indexOfName(region.name);
                            var itemModel = data.getItemModel(dataIdx);
                            var visualColor = data.getItemVisual(dataIdx, 'color', true);
                            itemStyleModel = itemModel.getModel(itemStyleAccessPath);
                            hoverItemStyleModel = itemModel.getModel(hoverItemStyleAccessPath);
                            itemStyle = getFixedItemStyle(itemStyleModel, scale);
                            hoverItemStyle = getFixedItemStyle(hoverItemStyleModel, scale);
                            labelModel = itemModel.getModel(labelAccessPath);
                            hoverLabelModel = itemModel.getModel(hoverLabelAccessPath);
                            if (visualColor) {
                                itemStyle.fill = visualColor;
                            }
                        }
                        var textStyleModel = labelModel.getModel('textStyle');
                        var hoverTextStyleModel = hoverLabelModel.getModel('textStyle');
                        zrUtil.each(region.contours, function (contour) {
                            var polygon = new graphic.Polygon({
                                shape: { points: contour },
                                style: { strokeNoScale: true },
                                culling: true
                            });
                            polygon.setStyle(itemStyle);
                            regionGroup.add(polygon);
                        });
                        var showLabel = labelModel.get('show');
                        var hoverShowLabel = hoverLabelModel.get('show');
                        var isDataNaN = data && isNaN(data.get('value', dataIdx));
                        var itemLayout = data && data.getItemLayout(dataIdx);
                        if (!data || isDataNaN && (showLabel || hoverShowLabel) || itemLayout && itemLayout.showLabel) {
                            var query = data ? dataIdx : region.name;
                            var formattedStr = mapOrGeoModel.getFormattedLabel(query, 'normal');
                            var hoverFormattedStr = mapOrGeoModel.getFormattedLabel(query, 'emphasis');
                            var text = new graphic.Text({
                                style: {
                                    text: showLabel ? formattedStr || region.name : '',
                                    fill: textStyleModel.getTextColor(),
                                    textFont: textStyleModel.getFont(),
                                    textAlign: 'center',
                                    textVerticalAlign: 'middle'
                                },
                                hoverStyle: {
                                    text: hoverShowLabel ? hoverFormattedStr || region.name : '',
                                    fill: hoverTextStyleModel.getTextColor(),
                                    textFont: hoverTextStyleModel.getFont()
                                },
                                position: region.center.slice(),
                                scale: [
                                    1 / scale[0],
                                    1 / scale[1]
                                ],
                                z2: 10,
                                silent: true
                            });
                            regionGroup.add(text);
                        }
                        data && data.setItemGraphicEl(dataIdx, regionGroup);
                        graphic.setHoverStyle(regionGroup, hoverItemStyle);
                        group.add(regionGroup);
                    });
                    this._updateController(mapOrGeoModel, ecModel, api);
                    data && updateMapSelectHandler(mapOrGeoModel, data, group, api, fromView);
                    data && updateMapSelected(mapOrGeoModel, data);
                },
                remove: function () {
                    this.group.removeAll();
                    this._controller.dispose();
                },
                _updateController: function (mapOrGeoModel, ecModel, api) {
                    var geo = mapOrGeoModel.coordinateSystem;
                    var controller = this._controller;
                    controller.zoomLimit = mapOrGeoModel.get('scaleLimit');
                    controller.zoom = mapOrGeoModel.get('roamDetail.zoom');
                    controller.enable(mapOrGeoModel.get('roam') || false);
                    var mainType = mapOrGeoModel.type.split('.')[0];
                    controller.off('pan').on('pan', function (dx, dy) {
                        api.dispatchAction({
                            type: 'geoRoam',
                            component: mainType,
                            name: mapOrGeoModel.name,
                            dx: dx,
                            dy: dy
                        });
                    });
                    controller.off('zoom').on('zoom', function (zoom, mouseX, mouseY) {
                        api.dispatchAction({
                            type: 'geoRoam',
                            component: mainType,
                            name: mapOrGeoModel.name,
                            zoom: zoom,
                            originX: mouseX,
                            originY: mouseY
                        });
                        if (this._updateGroup) {
                            var group = this.group;
                            var scale = group.scale;
                            group.traverse(function (el) {
                                if (el.type === 'text') {
                                    el.attr('scale', [
                                        1 / scale[0],
                                        1 / scale[1]
                                    ]);
                                }
                            });
                        }
                    }, this);
                    controller.rect = geo.getViewRect();
                }
            };
            module.exports = MapDraw;
        },
        function (module, exports, __webpack_require__) {
            var Eventful = __webpack_require__(32);
            var zrUtil = __webpack_require__(3);
            var eventTool = __webpack_require__(80);
            var interactionMutex = __webpack_require__(160);
            function mousedown(e) {
                if (e.target && e.target.draggable) {
                    return;
                }
                var x = e.offsetX;
                var y = e.offsetY;
                var rect = this.rect;
                if (rect && rect.contain(x, y)) {
                    this._x = x;
                    this._y = y;
                    this._dragging = true;
                }
            }
            function mousemove(e) {
                if (!this._dragging) {
                    return;
                }
                eventTool.stop(e.event);
                if (e.gestureEvent !== 'pinch') {
                    if (interactionMutex.isTaken('globalPan', this._zr)) {
                        return;
                    }
                    var x = e.offsetX;
                    var y = e.offsetY;
                    var dx = x - this._x;
                    var dy = y - this._y;
                    this._x = x;
                    this._y = y;
                    var target = this.target;
                    if (target) {
                        var pos = target.position;
                        pos[0] += dx;
                        pos[1] += dy;
                        target.dirty();
                    }
                    eventTool.stop(e.event);
                    this.trigger('pan', dx, dy);
                }
            }
            function mouseup(e) {
                this._dragging = false;
            }
            function mousewheel(e) {
                eventTool.stop(e.event);
                var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;
                zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);
            }
            function pinch(e) {
                if (interactionMutex.isTaken('globalPan', this._zr)) {
                    return;
                }
                eventTool.stop(e.event);
                var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
                zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);
            }
            function zoom(e, zoomDelta, zoomX, zoomY) {
                var rect = this.rect;
                if (rect && rect.contain(zoomX, zoomY)) {
                    var target = this.target;
                    var zoomLimit = this.zoomLimit;
                    if (target) {
                        var pos = target.position;
                        var scale = target.scale;
                        var newZoom = this.zoom = this.zoom || 1;
                        newZoom *= zoomDelta;
                        if (zoomLimit) {
                            newZoom = Math.max(Math.min(zoomLimit.max, newZoom), zoomLimit.min);
                        }
                        var zoomScale = newZoom / this.zoom;
                        this.zoom = newZoom;
                        pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
                        pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
                        scale[0] *= zoomScale;
                        scale[1] *= zoomScale;
                        target.dirty();
                    }
                    this.trigger('zoom', zoomDelta, zoomX, zoomY);
                }
            }
            function RoamController(zr, target, rect) {
                this.target = target;
                this.rect = rect;
                this.zoomLimit;
                this.zoom;
                this._zr = zr;
                var bind = zrUtil.bind;
                var mousedownHandler = bind(mousedown, this);
                var mousemoveHandler = bind(mousemove, this);
                var mouseupHandler = bind(mouseup, this);
                var mousewheelHandler = bind(mousewheel, this);
                var pinchHandler = bind(pinch, this);
                Eventful.call(this);
                this.enable = function (controlType) {
                    this.disable();
                    if (controlType == null) {
                        controlType = true;
                    }
                    if (controlType === true || (controlType === 'move' || controlType === 'pan')) {
                        zr.on('mousedown', mousedownHandler);
                        zr.on('mousemove', mousemoveHandler);
                        zr.on('mouseup', mouseupHandler);
                    }
                    if (controlType === true || (controlType === 'scale' || controlType === 'zoom')) {
                        zr.on('mousewheel', mousewheelHandler);
                        zr.on('pinch', pinchHandler);
                    }
                };
                this.disable = function () {
                    zr.off('mousedown', mousedownHandler);
                    zr.off('mousemove', mousemoveHandler);
                    zr.off('mouseup', mouseupHandler);
                    zr.off('mousewheel', mousewheelHandler);
                    zr.off('pinch', pinchHandler);
                };
                this.dispose = this.disable;
                this.isDragging = function () {
                    return this._dragging;
                };
                this.isPinching = function () {
                    return this._pinching;
                };
            }
            zrUtil.mixin(RoamController, Eventful);
            module.exports = RoamController;
        },
        function (module, exports) {
            var ATTR = '\0_ec_interaction_mutex';
            var interactionMutex = {
                take: function (key, zr) {
                    getStore(zr)[key] = true;
                },
                release: function (key, zr) {
                    getStore(zr)[key] = false;
                },
                isTaken: function (key, zr) {
                    return !!getStore(zr)[key];
                }
            };
            function getStore(zr) {
                return zr[ATTR] || (zr[ATTR] = {});
            }
            module.exports = interactionMutex;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var roamHelper = __webpack_require__(162);
            var echarts = __webpack_require__(1);
            var actionInfo = {
                type: 'geoRoam',
                event: 'geoRoam',
                update: 'updateLayout'
            };
            echarts.registerAction(actionInfo, function (payload, ecModel) {
                var componentType = payload.component || 'series';
                ecModel.eachComponent(componentType, function (componentModel) {
                    if (componentModel.name === payload.name) {
                        var geo = componentModel.coordinateSystem;
                        if (geo.type !== 'geo') {
                            return;
                        }
                        var roamDetailModel = componentModel.getModel('roamDetail');
                        var res = roamHelper.calcPanAndZoom(roamDetailModel, payload, componentModel.get('scaleLimit'));
                        componentModel.setRoamPan && componentModel.setRoamPan(res.x, res.y);
                        componentModel.setRoamZoom && componentModel.setRoamZoom(res.zoom);
                        geo && geo.setPan(res.x, res.y);
                        geo && geo.setZoom(res.zoom);
                        if (componentType === 'series') {
                            zrUtil.each(componentModel.seriesGroup, function (seriesModel) {
                                seriesModel.setRoamPan(res.x, res.y);
                                seriesModel.setRoamZoom(res.zoom);
                            });
                        }
                    }
                });
            });
        },
        function (module, exports) {
            var roamHelper = {};
            roamHelper.calcPanAndZoom = function (roamDetailModel, payload, zoomLimit) {
                var dx = payload.dx;
                var dy = payload.dy;
                var zoom = payload.zoom;
                var panX = roamDetailModel.get('x') || 0;
                var panY = roamDetailModel.get('y') || 0;
                var previousZoom = roamDetailModel.get('zoom') || 1;
                if (dx != null && dy != null) {
                    panX += dx;
                    panY += dy;
                }
                if (zoom != null) {
                    if (zoomLimit) {
                        zoom = Math.max(Math.min(previousZoom * zoom, zoomLimit.max), zoomLimit.min) / previousZoom;
                    }
                    var fixX = (payload.originX - panX) * (zoom - 1);
                    var fixY = (payload.originY - panY) * (zoom - 1);
                    panX -= fixX;
                    panY -= fixY;
                }
                return {
                    x: panX,
                    y: panY,
                    zoom: (zoom || 1) * previousZoom
                };
            };
            module.exports = roamHelper;
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(164);
            var Geo = __webpack_require__(165);
            var layout = __webpack_require__(21);
            var zrUtil = __webpack_require__(3);
            var mapDataStores = {};
            function resizeGeo(geoModel, api) {
                var rect = this.getBoundingRect();
                var boxLayoutOption = geoModel.getBoxLayoutParams();
                boxLayoutOption.aspect = rect.width / rect.height * 0.75;
                var viewRect = layout.getLayoutRect(boxLayoutOption, {
                    width: api.getWidth(),
                    height: api.getHeight()
                });
                this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);
                var roamDetailModel = geoModel.getModel('roamDetail');
                var panX = roamDetailModel.get('x') || 0;
                var panY = roamDetailModel.get('y') || 0;
                var zoom = roamDetailModel.get('zoom') || 1;
                this.setPan(panX, panY);
                this.setZoom(zoom);
            }
            function setGeoCoords(geo, model) {
                zrUtil.each(model.get('geoCoord'), function (geoCoord, name) {
                    geo.addGeoCoord(name, geoCoord);
                });
            }
            function mapNotExistsError(name) {
                console.error('Map ' + name + ' not exists');
            }
            var geoCreator = {
                dimensions: Geo.prototype.dimensions,
                create: function (ecModel, api) {
                    var geoList = [];
                    ecModel.eachComponent('geo', function (geoModel, idx) {
                        var name = geoModel.get('map');
                        var mapData = mapDataStores[name];
                        if (!mapData) {
                            mapNotExistsError(name);
                        }
                        var geo = new Geo(name + idx, name, mapData && mapData.geoJson, mapData && mapData.specialAreas, geoModel.get('nameMap'));
                        geo.zoomLimit = geoModel.get('scaleLimit');
                        geoList.push(geo);
                        setGeoCoords(geo, geoModel);
                        geoModel.coordinateSystem = geo;
                        geo.model = geoModel;
                        geo.resize = resizeGeo;
                        geo.resize(geoModel, api);
                    });
                    ecModel.eachSeries(function (seriesModel) {
                        var coordSys = seriesModel.get('coordinateSystem');
                        if (coordSys === 'geo') {
                            var geoIndex = seriesModel.get('geoIndex') || 0;
                            seriesModel.coordinateSystem = geoList[geoIndex];
                        }
                    });
                    var mapModelGroupBySeries = {};
                    ecModel.eachSeriesByType('map', function (seriesModel) {
                        var mapType = seriesModel.get('map');
                        mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];
                        mapModelGroupBySeries[mapType].push(seriesModel);
                    });
                    zrUtil.each(mapModelGroupBySeries, function (mapSeries, mapType) {
                        var mapData = mapDataStores[mapType];
                        if (!mapData) {
                            mapNotExistsError(name);
                        }
                        var nameMapList = zrUtil.map(mapSeries, function (singleMapSeries) {
                            return singleMapSeries.get('nameMap');
                        });
                        var geo = new Geo(mapType, mapType, mapData && mapData.geoJson, mapData && mapData.specialAreas, zrUtil.mergeAll(nameMapList));
                        geo.zoomLimit = zrUtil.retrieve.apply(null, zrUtil.map(mapSeries, function (singleMapSeries) {
                            return singleMapSeries.get('scaleLimit');
                        }));
                        geoList.push(geo);
                        geo.resize = resizeGeo;
                        geo.resize(mapSeries[0], api);
                        zrUtil.each(mapSeries, function (singleMapSeries) {
                            singleMapSeries.coordinateSystem = geo;
                            setGeoCoords(geo, singleMapSeries);
                        });
                    });
                    return geoList;
                },
                registerMap: function (mapName, geoJson, specialAreas) {
                    if (geoJson.geoJson && !geoJson.features) {
                        specialAreas = geoJson.specialAreas;
                        geoJson = geoJson.geoJson;
                    }
                    if (typeof geoJson === 'string') {
                        geoJson = typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(geoJson) : new Function('return (' + geoJson + ');')();
                    }
                    mapDataStores[mapName] = {
                        geoJson: geoJson,
                        specialAreas: specialAreas
                    };
                },
                getMap: function (mapName) {
                    return mapDataStores[mapName];
                }
            };
            var echarts = __webpack_require__(1);
            echarts.registerMap = geoCreator.registerMap;
            echarts.getMap = geoCreator.getMap;
            echarts.loadMap = function () {
            };
            echarts.registerCoordinateSystem('geo', geoCreator);
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var modelUtil = __webpack_require__(5);
            var ComponentModel = __webpack_require__(19);
            ComponentModel.extend({
                type: 'geo',
                coordinateSystem: null,
                init: function (option) {
                    ComponentModel.prototype.init.apply(this, arguments);
                    modelUtil.defaultEmphasis(option.label, [
                        'position',
                        'show',
                        'textStyle',
                        'distance',
                        'formatter'
                    ]);
                },
                defaultOption: {
                    zlevel: 0,
                    z: 0,
                    show: true,
                    left: 'center',
                    top: 'center',
                    map: '',
                    roamDetail: {
                        x: 0,
                        y: 0,
                        zoom: 1
                    },
                    scaleLimit: null,
                    label: {
                        normal: {
                            show: false,
                            textStyle: { color: '#000' }
                        },
                        emphasis: {
                            show: true,
                            textStyle: { color: 'rgb(100,0,0)' }
                        }
                    },
                    itemStyle: {
                        normal: {
                            borderWidth: 0.5,
                            borderColor: '#444',
                            color: '#eee'
                        },
                        emphasis: { color: 'rgba(255,215,0,0.8)' }
                    }
                },
                getFormattedLabel: function (name, status) {
                    var formatter = this.get('label.' + status + '.formatter');
                    var params = { name: name };
                    if (typeof formatter === 'function') {
                        params.status = status;
                        return formatter(params);
                    } else if (typeof formatter === 'string') {
                        return formatter.replace('{a}', params.seriesName);
                    }
                },
                setRoamZoom: function (zoom) {
                    var roamDetail = this.option.roamDetail;
                    roamDetail && (roamDetail.zoom = zoom);
                },
                setRoamPan: function (x, y) {
                    var roamDetail = this.option.roamDetail;
                    if (roamDetail) {
                        roamDetail.x = x;
                        roamDetail.y = y;
                    }
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var parseGeoJson = __webpack_require__(166);
            var zrUtil = __webpack_require__(3);
            var BoundingRect = __webpack_require__(15);
            var View = __webpack_require__(169);
            var geoFixFuncs = [
                __webpack_require__(170),
                __webpack_require__(171),
                __webpack_require__(172)
            ];
            function Geo(name, map, geoJson, specialAreas, nameMap) {
                View.call(this, name);
                this.map = map;
                this._nameCoordMap = {};
                this.loadGeoJson(geoJson, specialAreas, nameMap);
            }
            Geo.prototype = {
                constructor: Geo,
                type: 'geo',
                dimensions: [
                    'lng',
                    'lat'
                ],
                loadGeoJson: function (geoJson, specialAreas, nameMap) {
                    try {
                        this.regions = geoJson ? parseGeoJson(geoJson) : [];
                    } catch (e) {
                        throw 'Invalid geoJson format\n' + e;
                    }
                    specialAreas = specialAreas || {};
                    nameMap = nameMap || {};
                    var regions = this.regions;
                    var regionsMap = {};
                    for (var i = 0; i < regions.length; i++) {
                        var regionName = regions[i].name;
                        regionName = nameMap[regionName] || regionName;
                        regions[i].name = regionName;
                        regionsMap[regionName] = regions[i];
                        this.addGeoCoord(regionName, regions[i].center);
                        var specialArea = specialAreas[regionName];
                        if (specialArea) {
                            regions[i].transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height);
                        }
                    }
                    this._regionsMap = regionsMap;
                    this._rect = null;
                    zrUtil.each(geoFixFuncs, function (fixFunc) {
                        fixFunc(this);
                    }, this);
                },
                transformTo: function (x, y, width, height) {
                    var rect = this.getBoundingRect();
                    rect = rect.clone();
                    rect.y = -rect.y - rect.height;
                    var viewTransform = this._viewTransform;
                    viewTransform.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));
                    viewTransform.decomposeTransform();
                    var scale = viewTransform.scale;
                    scale[1] = -scale[1];
                    viewTransform.updateTransform();
                    this._updateTransform();
                },
                getRegion: function (name) {
                    return this._regionsMap[name];
                },
                addGeoCoord: function (name, geoCoord) {
                    this._nameCoordMap[name] = geoCoord;
                },
                getGeoCoord: function (name) {
                    return this._nameCoordMap[name];
                },
                getBoundingRect: function () {
                    if (this._rect) {
                        return this._rect;
                    }
                    var rect;
                    var regions = this.regions;
                    for (var i = 0; i < regions.length; i++) {
                        var regionRect = regions[i].getBoundingRect();
                        rect = rect || regionRect.clone();
                        rect.union(regionRect);
                    }
                    return this._rect = rect || new BoundingRect(0, 0, 0, 0);
                },
                dataToPoints: function (data) {
                    var item = [];
                    return data.mapArray([
                        'lng',
                        'lat'
                    ], function (lon, lat) {
                        item[0] = lon;
                        item[1] = lat;
                        return this.dataToPoint(item);
                    }, this);
                },
                dataToPoint: function (data) {
                    if (typeof data === 'string') {
                        data = this.getGeoCoord(data);
                    }
                    if (data) {
                        return View.prototype.dataToPoint.call(this, data);
                    }
                }
            };
            zrUtil.mixin(Geo, View);
            module.exports = Geo;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var Region = __webpack_require__(167);
            function decode(json) {
                if (!json.UTF8Encoding) {
                    return json;
                }
                var features = json.features;
                for (var f = 0; f < features.length; f++) {
                    var feature = features[f];
                    var geometry = feature.geometry;
                    var coordinates = geometry.coordinates;
                    var encodeOffsets = geometry.encodeOffsets;
                    for (var c = 0; c < coordinates.length; c++) {
                        var coordinate = coordinates[c];
                        if (geometry.type === 'Polygon') {
                            coordinates[c] = decodePolygon(coordinate, encodeOffsets[c]);
                        } else if (geometry.type === 'MultiPolygon') {
                            for (var c2 = 0; c2 < coordinate.length; c2++) {
                                var polygon = coordinate[c2];
                                coordinate[c2] = decodePolygon(polygon, encodeOffsets[c][c2]);
                            }
                        }
                    }
                }
                json.UTF8Encoding = false;
                return json;
            }
            function decodePolygon(coordinate, encodeOffsets) {
                var result = [];
                var prevX = encodeOffsets[0];
                var prevY = encodeOffsets[1];
                for (var i = 0; i < coordinate.length; i += 2) {
                    var x = coordinate.charCodeAt(i) - 64;
                    var y = coordinate.charCodeAt(i + 1) - 64;
                    x = x >> 1 ^ -(x & 1);
                    y = y >> 1 ^ -(y & 1);
                    x += prevX;
                    y += prevY;
                    prevX = x;
                    prevY = y;
                    result.push([
                        x / 1024,
                        y / 1024
                    ]);
                }
                return result;
            }
            function flattern2D(array) {
                var ret = [];
                for (var i = 0; i < array.length; i++) {
                    for (var k = 0; k < array[i].length; k++) {
                        ret.push(array[i][k]);
                    }
                }
                return ret;
            }
            module.exports = function (geoJson) {
                decode(geoJson);
                return zrUtil.map(zrUtil.filter(geoJson.features, function (featureObj) {
                    return featureObj.geometry && featureObj.properties;
                }), function (featureObj) {
                    var properties = featureObj.properties;
                    var geometry = featureObj.geometry;
                    var coordinates = geometry.coordinates;
                    if (geometry.type === 'MultiPolygon') {
                        coordinates = flattern2D(coordinates);
                    }
                    return new Region(properties.name, coordinates, properties.cp);
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var polygonContain = __webpack_require__(168);
            var BoundingRect = __webpack_require__(15);
            var bbox = __webpack_require__(50);
            var vec2 = __webpack_require__(16);
            function Region(name, contours, cp) {
                this.name = name;
                this.contours = contours;
                if (!cp) {
                    var rect = this.getBoundingRect();
                    cp = [
                        rect.x + rect.width / 2,
                        rect.y + rect.height / 2
                    ];
                } else {
                    cp = [
                        cp[0],
                        cp[1]
                    ];
                }
                this.center = cp;
            }
            Region.prototype = {
                constructor: Region,
                getBoundingRect: function () {
                    var rect = this._rect;
                    if (rect) {
                        return rect;
                    }
                    var MAX_NUMBER = Number.MAX_VALUE;
                    var min = [
                        MAX_NUMBER,
                        MAX_NUMBER
                    ];
                    var max = [
                        -MAX_NUMBER,
                        -MAX_NUMBER
                    ];
                    var min2 = [];
                    var max2 = [];
                    var contours = this.contours;
                    for (var i = 0; i < contours.length; i++) {
                        bbox.fromPoints(contours[i], min2, max2);
                        vec2.min(min, min, min2);
                        vec2.max(max, max, max2);
                    }
                    if (i === 0) {
                        min[0] = min[1] = max[0] = max[1] = 0;
                    }
                    return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);
                },
                contain: function (coord) {
                    var rect = this.getBoundingRect();
                    var contours = this.contours;
                    if (rect.contain(coord[0], coord[1])) {
                        for (var i = 0, len = contours.length; i < len; i++) {
                            if (polygonContain.contain(contours[i], coord[0], coord[1])) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                transformTo: function (x, y, width, height) {
                    var rect = this.getBoundingRect();
                    var aspect = rect.width / rect.height;
                    if (!width) {
                        width = aspect * height;
                    } else if (!height) {
                        height = width / aspect;
                    }
                    var target = new BoundingRect(x, y, width, height);
                    var transform = rect.calculateTransform(target);
                    var contours = this.contours;
                    for (var i = 0; i < contours.length; i++) {
                        for (var p = 0; p < contours[i].length; p++) {
                            vec2.applyTransform(contours[i][p], contours[i][p], transform);
                        }
                    }
                    rect = this._rect;
                    rect.copy(target);
                    this.center = [
                        rect.x + rect.width / 2,
                        rect.y + rect.height / 2
                    ];
                }
            };
            module.exports = Region;
        },
        function (module, exports, __webpack_require__) {
            var windingLine = __webpack_require__(57);
            var EPSILON = 1e-8;
            function isAroundEqual(a, b) {
                return Math.abs(a - b) < EPSILON;
            }
            function contain(points, x, y) {
                var w = 0;
                var p = points[0];
                if (!p) {
                    return false;
                }
                for (var i = 1; i < points.length; i++) {
                    var p2 = points[i];
                    w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
                    p = p2;
                }
                var p0 = points[0];
                if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {
                    w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
                }
                return w !== 0;
            }
            module.exports = { contain: contain };
        },
        function (module, exports, __webpack_require__) {
            var vector = __webpack_require__(16);
            var matrix = __webpack_require__(17);
            var Transformable = __webpack_require__(33);
            var zrUtil = __webpack_require__(3);
            var BoundingRect = __webpack_require__(15);
            var v2ApplyTransform = vector.applyTransform;
            function TransformDummy() {
                Transformable.call(this);
            }
            zrUtil.mixin(TransformDummy, Transformable);
            function View(name) {
                this.name = name;
                this.zoomLimit;
                Transformable.call(this);
                this._roamTransform = new TransformDummy();
                this._viewTransform = new TransformDummy();
            }
            View.prototype = {
                constructor: View,
                type: 'view',
                dimensions: [
                    'x',
                    'y'
                ],
                setBoundingRect: function (x, y, width, height) {
                    this._rect = new BoundingRect(x, y, width, height);
                    return this._rect;
                },
                getBoundingRect: function () {
                    return this._rect;
                },
                setViewRect: function (x, y, width, height) {
                    this.transformTo(x, y, width, height);
                    this._viewRect = new BoundingRect(x, y, width, height);
                },
                transformTo: function (x, y, width, height) {
                    var rect = this.getBoundingRect();
                    var viewTransform = this._viewTransform;
                    viewTransform.transform = rect.calculateTransform(new BoundingRect(x, y, width, height));
                    viewTransform.decomposeTransform();
                    this._updateTransform();
                },
                setPan: function (x, y) {
                    this._roamTransform.position = [
                        x,
                        y
                    ];
                    this._updateTransform();
                },
                setZoom: function (zoom) {
                    var zoomLimit = this.zoomLimit;
                    if (zoomLimit) {
                        zoom = Math.max(Math.min(zoom, zoomLimit.max), zoomLimit.min);
                    }
                    this._roamTransform.scale = [
                        zoom,
                        zoom
                    ];
                    this._updateTransform();
                },
                getRoamTransform: function () {
                    return this._roamTransform.transform;
                },
                _updateTransform: function () {
                    var roamTransform = this._roamTransform;
                    var viewTransform = this._viewTransform;
                    viewTransform.parent = roamTransform;
                    roamTransform.updateTransform();
                    viewTransform.updateTransform();
                    viewTransform.transform && matrix.copy(this.transform || (this.transform = []), viewTransform.transform);
                    this.decomposeTransform();
                },
                getViewRect: function () {
                    return this._viewRect;
                },
                dataToPoint: function (data) {
                    var transform = this.transform;
                    return transform ? v2ApplyTransform([], data, transform) : [
                        data[0],
                        data[1]
                    ];
                },
                pointToData: function (point) {
                    var invTransform = this.invTransform;
                    return invTransform ? v2ApplyTransform([], point, invTransform) : [
                        point[0],
                        point[1]
                    ];
                }
            };
            zrUtil.mixin(View, Transformable);
            module.exports = View;
        },
        function (module, exports, __webpack_require__) {
            var Region = __webpack_require__(167);
            var geoCoord = [
                126,
                25
            ];
            var points = [
                [
                    [
                        0,
                        3.5
                    ],
                    [
                        7,
                        11.2
                    ],
                    [
                        15,
                        11.9
                    ],
                    [
                        30,
                        7
                    ],
                    [
                        42,
                        0.7
                    ],
                    [
                        52,
                        0.7
                    ],
                    [
                        56,
                        7.7
                    ],
                    [
                        59,
                        0.7
                    ],
                    [
                        64,
                        0.7
                    ],
                    [
                        64,
                        0
                    ],
                    [
                        5,
                        0
                    ],
                    [
                        0,
                        3.5
                    ]
                ],
                [
                    [
                        13,
                        16.1
                    ],
                    [
                        19,
                        14.7
                    ],
                    [
                        16,
                        21.7
                    ],
                    [
                        11,
                        23.1
                    ],
                    [
                        13,
                        16.1
                    ]
                ],
                [
                    [
                        12,
                        32.2
                    ],
                    [
                        14,
                        38.5
                    ],
                    [
                        15,
                        38.5
                    ],
                    [
                        13,
                        32.2
                    ],
                    [
                        12,
                        32.2
                    ]
                ],
                [
                    [
                        16,
                        47.6
                    ],
                    [
                        12,
                        53.2
                    ],
                    [
                        13,
                        53.2
                    ],
                    [
                        18,
                        47.6
                    ],
                    [
                        16,
                        47.6
                    ]
                ],
                [
                    [
                        6,
                        64.4
                    ],
                    [
                        8,
                        70
                    ],
                    [
                        9,
                        70
                    ],
                    [
                        8,
                        64.4
                    ],
                    [
                        6,
                        64.4
                    ]
                ],
                [
                    [
                        23,
                        82.6
                    ],
                    [
                        29,
                        79.8
                    ],
                    [
                        30,
                        79.8
                    ],
                    [
                        25,
                        82.6
                    ],
                    [
                        23,
                        82.6
                    ]
                ],
                [
                    [
                        37,
                        70.7
                    ],
                    [
                        43,
                        62.3
                    ],
                    [
                        44,
                        62.3
                    ],
                    [
                        39,
                        70.7
                    ],
                    [
                        37,
                        70.7
                    ]
                ],
                [
                    [
                        48,
                        51.1
                    ],
                    [
                        51,
                        45.5
                    ],
                    [
                        53,
                        45.5
                    ],
                    [
                        50,
                        51.1
                    ],
                    [
                        48,
                        51.1
                    ]
                ],
                [
                    [
                        51,
                        35
                    ],
                    [
                        51,
                        28.7
                    ],
                    [
                        53,
                        28.7
                    ],
                    [
                        53,
                        35
                    ],
                    [
                        51,
                        35
                    ]
                ],
                [
                    [
                        52,
                        22.4
                    ],
                    [
                        55,
                        17.5
                    ],
                    [
                        56,
                        17.5
                    ],
                    [
                        53,
                        22.4
                    ],
                    [
                        52,
                        22.4
                    ]
                ],
                [
                    [
                        58,
                        12.6
                    ],
                    [
                        62,
                        7
                    ],
                    [
                        63,
                        7
                    ],
                    [
                        60,
                        12.6
                    ],
                    [
                        58,
                        12.6
                    ]
                ],
                [
                    [
                        0,
                        3.5
                    ],
                    [
                        0,
                        93.1
                    ],
                    [
                        64,
                        93.1
                    ],
                    [
                        64,
                        0
                    ],
                    [
                        63,
                        0
                    ],
                    [
                        63,
                        92.4
                    ],
                    [
                        1,
                        92.4
                    ],
                    [
                        1,
                        3.5
                    ],
                    [
                        0,
                        3.5
                    ]
                ]
            ];
            for (var i = 0; i < points.length; i++) {
                for (var k = 0; k < points[i].length; k++) {
                    points[i][k][0] /= 10.5;
                    points[i][k][1] /= -10.5 / 0.75;
                    points[i][k][0] += geoCoord[0];
                    points[i][k][1] += geoCoord[1];
                }
            }
            module.exports = function (geo) {
                if (geo.map === 'china') {
                    geo.regions.push(new Region('南海诸岛', points, geoCoord));
                }
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var coordsOffsetMap = {
                '南海诸岛': [
                    32,
                    80
                ],
                '广东': [
                    0,
                    -10
                ],
                '香港': [
                    10,
                    5
                ],
                '澳门': [
                    -10,
                    10
                ],
                '天津': [
                    5,
                    5
                ]
            };
            module.exports = function (geo) {
                zrUtil.each(geo.regions, function (region) {
                    var coordFix = coordsOffsetMap[region.name];
                    if (coordFix) {
                        var cp = region.center;
                        cp[0] += coordFix[0] / 10.5;
                        cp[1] += -coordFix[1] / (10.5 / 0.75);
                    }
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var geoCoordMap = {
                'Russia': [
                    100,
                    60
                ],
                'United States of America': [
                    -99,
                    38
                ]
            };
            module.exports = function (geo) {
                zrUtil.each(geo.regions, function (region) {
                    var geoCoord = geoCoordMap[region.name];
                    if (geoCoord) {
                        var cp = region.center;
                        cp[0] = geoCoord[0];
                        cp[1] = geoCoord[1];
                    }
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            module.exports = function (ecModel) {
                var processedMapType = {};
                ecModel.eachSeriesByType('map', function (mapSeries) {
                    var mapType = mapSeries.get('map');
                    if (processedMapType[mapType]) {
                        return;
                    }
                    var mapSymbolOffsets = {};
                    zrUtil.each(mapSeries.seriesGroup, function (subMapSeries) {
                        var geo = subMapSeries.coordinateSystem;
                        var data = subMapSeries.getData();
                        if (subMapSeries.get('showLegendSymbol') && ecModel.getComponent('legend')) {
                            data.each('value', function (value, idx) {
                                var name = data.getName(idx);
                                var region = geo.getRegion(name);
                                if (!region || isNaN(value)) {
                                    return;
                                }
                                var offset = mapSymbolOffsets[name] || 0;
                                var point = geo.dataToPoint(region.center);
                                mapSymbolOffsets[name] = offset + 1;
                                data.setItemLayout(idx, {
                                    point: point,
                                    offset: offset
                                });
                            });
                        }
                    });
                    var data = mapSeries.getData();
                    data.each(function (idx) {
                        var name = data.getName(idx);
                        var layout = data.getItemLayout(idx) || {};
                        layout.showLabel = !mapSymbolOffsets[name];
                        data.setItemLayout(idx, layout);
                    });
                    processedMapType[mapType] = true;
                });
            };
        },
        function (module, exports) {
            module.exports = function (ecModel) {
                ecModel.eachSeriesByType('map', function (seriesModel) {
                    var colorList = seriesModel.get('color');
                    var itemStyleModel = seriesModel.getModel('itemStyle.normal');
                    var areaColor = itemStyleModel.get('areaColor');
                    var color = itemStyleModel.get('color') || colorList[seriesModel.seriesIndex % colorList.length];
                    seriesModel.getData().setVisual({
                        'areaColor': areaColor,
                        'color': color
                    });
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            function dataStatistics(datas, statisticsType) {
                var dataNameMap = {};
                var dims = ['value'];
                for (var i = 0; i < datas.length; i++) {
                    datas[i].each(dims, function (value, idx) {
                        var name = datas[i].getName(idx);
                        dataNameMap[name] = dataNameMap[name] || [];
                        if (!isNaN(value)) {
                            dataNameMap[name].push(value);
                        }
                    });
                }
                return datas[0].map(dims, function (value, idx) {
                    var name = datas[0].getName(idx);
                    var sum = 0;
                    var min = Infinity;
                    var max = -Infinity;
                    var len = dataNameMap[name].length;
                    for (var i = 0; i < len; i++) {
                        min = Math.min(min, dataNameMap[name][i]);
                        max = Math.max(max, dataNameMap[name][i]);
                        sum += dataNameMap[name][i];
                    }
                    var result;
                    if (statisticsType === 'min') {
                        result = min;
                    } else if (statisticsType === 'max') {
                        result = max;
                    } else if (statisticsType === 'average') {
                        result = sum / len;
                    } else {
                        result = sum;
                    }
                    return len === 0 ? NaN : result;
                });
            }
            module.exports = function (ecModel) {
                var seriesGroupByMapType = {};
                ecModel.eachSeriesByType('map', function (seriesModel) {
                    var mapType = seriesModel.get('map');
                    seriesGroupByMapType[mapType] = seriesGroupByMapType[mapType] || [];
                    seriesGroupByMapType[mapType].push(seriesModel);
                });
                zrUtil.each(seriesGroupByMapType, function (seriesList, mapType) {
                    var data = dataStatistics(zrUtil.map(seriesList, function (seriesModel) {
                        return seriesModel.getData();
                    }), seriesList[0].get('mapValueCalculation'));
                    seriesList[0].seriesGroup = [];
                    seriesList[0].setData(data);
                    for (var i = 0; i < seriesList.length; i++) {
                        seriesList[i].seriesGroup = seriesList;
                        seriesList[i].needsDrawMap = i === 0;
                    }
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var geoProps = [
                'x',
                'y',
                'x2',
                'y2',
                'width',
                'height',
                'map',
                'roam',
                'roamDetail',
                'label',
                'itemStyle'
            ];
            var geoCoordsMap = {};
            function createGeoFromMap(mapSeriesOpt) {
                var geoOpt = {};
                zrUtil.each(geoProps, function (propName) {
                    if (mapSeriesOpt[propName] != null) {
                        geoOpt[propName] = mapSeriesOpt[propName];
                    }
                });
                return geoOpt;
            }
            module.exports = function (option) {
                var mapSeries = [];
                zrUtil.each(option.series, function (seriesOpt) {
                    if (seriesOpt.type === 'map') {
                        mapSeries.push(seriesOpt);
                    }
                    zrUtil.extend(geoCoordsMap, seriesOpt.geoCoord);
                });
                var newCreatedGeoOptMap = {};
                zrUtil.each(mapSeries, function (seriesOpt) {
                    seriesOpt.map = seriesOpt.map || seriesOpt.mapType;
                    zrUtil.defaults(seriesOpt, seriesOpt.mapLocation);
                    if (seriesOpt.markPoint) {
                        var markPoint = seriesOpt.markPoint;
                        markPoint.data = zrUtil.map(markPoint.data, function (dataOpt) {
                            if (!zrUtil.isArray(dataOpt.value)) {
                                var geoCoord;
                                if (dataOpt.geoCoord) {
                                    geoCoord = dataOpt.geoCoord;
                                } else if (dataOpt.name) {
                                    geoCoord = geoCoordsMap[dataOpt.name];
                                }
                                var newValue = geoCoord ? [
                                    geoCoord[0],
                                    geoCoord[1]
                                ] : [
                                    NaN,
                                    NaN
                                ];
                                if (dataOpt.value != null) {
                                    newValue.push(dataOpt.value);
                                }
                                dataOpt.value = newValue;
                            }
                            return dataOpt;
                        });
                        if (!(seriesOpt.data && seriesOpt.data.length)) {
                            if (!option.geo) {
                                option.geo = [];
                            }
                            var geoOpt = newCreatedGeoOptMap[seriesOpt.map];
                            if (!geoOpt) {
                                geoOpt = newCreatedGeoOptMap[seriesOpt.map] = createGeoFromMap(seriesOpt);
                                option.geo.push(geoOpt);
                            }
                            var scatterSeries = seriesOpt.markPoint;
                            scatterSeries.type = option.effect && option.effect.show ? 'effectScatter' : 'scatter';
                            scatterSeries.coordinateSystem = 'geo';
                            scatterSeries.geoIndex = zrUtil.indexOf(option.geo, geoOpt);
                            scatterSeries.name = seriesOpt.name;
                            option.series.splice(zrUtil.indexOf(option.series, seriesOpt), 1, scatterSeries);
                        }
                    }
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            __webpack_require__(178);
            __webpack_require__(182);
            __webpack_require__(185);
            echarts.registerVisualCoding('chart', __webpack_require__(186));
            echarts.registerLayout(__webpack_require__(188));
        },
        function (module, exports, __webpack_require__) {
            var SeriesModel = __webpack_require__(27);
            var Tree = __webpack_require__(179);
            var zrUtil = __webpack_require__(3);
            var Model = __webpack_require__(8);
            var formatUtil = __webpack_require__(6);
            var helper = __webpack_require__(181);
            var encodeHTML = formatUtil.encodeHTML;
            var addCommas = formatUtil.addCommas;
            module.exports = SeriesModel.extend({
                type: 'series.treemap',
                dependencies: [
                    'grid',
                    'polar'
                ],
                _viewRoot: null,
                defaultOption: {
                    left: 'center',
                    top: 'middle',
                    right: null,
                    bottom: null,
                    width: '80%',
                    height: '80%',
                    sort: true,
                    clipWindow: 'origin',
                    squareRatio: 0.5 * (1 + Math.sqrt(5)),
                    leafDepth: null,
                    visualDimension: 0,
                    zoomToNodeRatio: 0.32 * 0.32,
                    roam: true,
                    nodeClick: 'zoomToNode',
                    animation: true,
                    animationDurationUpdate: 900,
                    animationEasing: 'quinticInOut',
                    breadcrumb: {
                        show: true,
                        height: 22,
                        left: 'center',
                        top: 'bottom',
                        emptyItemWidth: 25,
                        itemStyle: {
                            normal: {
                                color: 'rgba(0,0,0,0.7)',
                                borderColor: 'rgba(255,255,255,0.7)',
                                borderWidth: 1,
                                shadowColor: 'rgba(150,150,150,1)',
                                shadowBlur: 3,
                                shadowOffsetX: 0,
                                shadowOffsetY: 0,
                                textStyle: { color: '#fff' }
                            },
                            emphasis: { textStyle: {} }
                        }
                    },
                    label: {
                        normal: {
                            show: true,
                            position: [
                                '50%',
                                '50%'
                            ],
                            textStyle: {
                                align: 'center',
                                baseline: 'middle',
                                color: '#fff',
                                ellipsis: true
                            }
                        }
                    },
                    itemStyle: {
                        normal: {
                            color: null,
                            colorAlpha: null,
                            colorSaturation: null,
                            borderWidth: 0,
                            gapWidth: 0,
                            borderColor: '#fff',
                            borderColorSaturation: null
                        },
                        emphasis: {}
                    },
                    color: 'none',
                    colorAlpha: null,
                    colorSaturation: null,
                    colorMappingBy: 'index',
                    visibleMin: 10,
                    childrenVisibleMin: null,
                    levels: []
                },
                getInitialData: function (option, ecModel) {
                    var data = option.data || [];
                    var rootName = option.name;
                    rootName == null && (rootName = option.name);
                    var root = {
                        name: rootName,
                        children: option.data
                    };
                    var value0 = (data[0] || {}).value;
                    completeTreeValue(root, zrUtil.isArray(value0) ? value0.length : -1);
                    var levels = option.levels || [];
                    levels = option.levels = setDefault(levels, ecModel);
                    return Tree.createTree(root, this, levels).data;
                },
                optionUpdated: function () {
                    this.resetViewRoot();
                },
                formatTooltip: function (dataIndex) {
                    var data = this.getData();
                    var value = this.getRawValue(dataIndex);
                    var formattedValue = zrUtil.isArray(value) ? addCommas(value[0]) : addCommas(value);
                    var name = data.getName(dataIndex);
                    return encodeHTML(name) + ': ' + formattedValue;
                },
                getDataParams: function (dataIndex) {
                    var params = SeriesModel.prototype.getDataParams.apply(this, arguments);
                    var data = this.getData();
                    var node = data.tree.getNodeByDataIndex(dataIndex);
                    var treePathInfo = params.treePathInfo = [];
                    while (node) {
                        var nodeDataIndex = node.dataIndex;
                        treePathInfo.push({
                            name: node.name,
                            dataIndex: nodeDataIndex,
                            value: this.getRawValue(nodeDataIndex)
                        });
                        node = node.parentNode;
                    }
                    treePathInfo.reverse();
                    return params;
                },
                setLayoutInfo: function (layoutInfo) {
                    this.layoutInfo = this.layoutInfo || {};
                    zrUtil.extend(this.layoutInfo, layoutInfo);
                },
                mapIdToIndex: function (id) {
                    var idIndexMap = this._idIndexMap;
                    if (!idIndexMap) {
                        idIndexMap = this._idIndexMap = {};
                        this._idIndexMapCount = 0;
                    }
                    var index = idIndexMap[id];
                    if (index == null) {
                        idIndexMap[id] = index = this._idIndexMapCount++;
                    }
                    return index;
                },
                getViewRoot: function () {
                    return this._viewRoot;
                },
                resetViewRoot: function (viewRoot) {
                    viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot;
                    var root = this.getData().tree.root;
                    if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
                        this._viewRoot = root;
                    }
                }
            });
            function completeTreeValue(dataNode, arrValueLength) {
                var sum = 0;
                zrUtil.each(dataNode.children, function (child) {
                    completeTreeValue(child, arrValueLength);
                    var childValue = child.value;
                    zrUtil.isArray(childValue) && (childValue = childValue[0]);
                    sum += childValue;
                });
                var thisValue = dataNode.value;
                if (arrValueLength >= 0) {
                    if (!zrUtil.isArray(thisValue)) {
                        dataNode.value = new Array(arrValueLength);
                    } else {
                        thisValue = thisValue[0];
                    }
                }
                if (thisValue == null || isNaN(thisValue)) {
                    thisValue = sum;
                }
                if (thisValue < 0) {
                    thisValue = 0;
                }
                arrValueLength >= 0 ? dataNode.value[0] = thisValue : dataNode.value = thisValue;
            }
            function setDefault(levels, ecModel) {
                var globalColorList = ecModel.get('color');
                if (!globalColorList) {
                    return;
                }
                levels = levels || [];
                var hasColorDefine;
                zrUtil.each(levels, function (levelDefine) {
                    var model = new Model(levelDefine);
                    var modelColor = model.get('color');
                    if (model.get('itemStyle.normal.color') || modelColor && modelColor !== 'none') {
                        hasColorDefine = true;
                    }
                });
                if (!hasColorDefine) {
                    var level0 = levels[0] || (levels[0] = {});
                    level0.color = globalColorList.slice();
                }
                return levels;
            }
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var Model = __webpack_require__(8);
            var List = __webpack_require__(94);
            var linkListHelper = __webpack_require__(180);
            var completeDimensions = __webpack_require__(96);
            var TreeNode = function (name, dataIndex, hostTree) {
                this.name = name || '';
                this.depth = 0;
                this.height = 0;
                this.parentNode = null;
                this.dataIndex = dataIndex == null ? -1 : dataIndex;
                this.children = [];
                this.viewChildren = [];
                this.hostTree = hostTree;
            };
            TreeNode.prototype = {
                constructor: TreeNode,
                isRemoved: function () {
                    return this.dataIndex < 0;
                },
                eachNode: function (options, cb, context) {
                    if (typeof options === 'function') {
                        context = cb;
                        cb = options;
                        options = null;
                    }
                    options = options || {};
                    if (zrUtil.isString(options)) {
                        options = { order: options };
                    }
                    var order = options.order || 'preorder';
                    var children = this[options.attr || 'children'];
                    var suppressVisitSub;
                    order === 'preorder' && (suppressVisitSub = cb.call(context, this));
                    for (var i = 0; !suppressVisitSub && i < children.length; i++) {
                        children[i].eachNode(options, cb, context);
                    }
                    order === 'postorder' && cb.call(context, this);
                },
                updateDepthAndHeight: function (depth) {
                    var height = 0;
                    this.depth = depth;
                    for (var i = 0; i < this.children.length; i++) {
                        var child = this.children[i];
                        child.updateDepthAndHeight(depth + 1);
                        if (child.height > height) {
                            height = child.height;
                        }
                    }
                    this.height = height + 1;
                },
                getNodeById: function (id) {
                    if (this.getId() === id) {
                        return this;
                    }
                    for (var i = 0, children = this.children, len = children.length; i < len; i++) {
                        var res = children[i].getNodeById(id);
                        if (res) {
                            return res;
                        }
                    }
                },
                contains: function (node) {
                    if (node === this) {
                        return true;
                    }
                    for (var i = 0, children = this.children, len = children.length; i < len; i++) {
                        var res = children[i].contains(node);
                        if (res) {
                            return res;
                        }
                    }
                },
                getAncestors: function (includeSelf) {
                    var ancestors = [];
                    var node = includeSelf ? this : this.parentNode;
                    while (node) {
                        ancestors.push(node);
                        node = node.parentNode;
                    }
                    ancestors.reverse();
                    return ancestors;
                },
                getValue: function (dimension) {
                    var data = this.hostTree.data;
                    return data.get(data.getDimension(dimension || 'value'), this.dataIndex);
                },
                setLayout: function (layout, merge) {
                    this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);
                },
                getLayout: function () {
                    return this.hostTree.data.getItemLayout(this.dataIndex);
                },
                getModel: function (path) {
                    if (this.dataIndex < 0) {
                        return;
                    }
                    var hostTree = this.hostTree;
                    var itemModel = hostTree.data.getItemModel(this.dataIndex);
                    var levelModel = this.getLevelModel();
                    return itemModel.getModel(path, (levelModel || hostTree.hostModel).getModel(path));
                },
                getLevelModel: function () {
                    return (this.hostTree.levelModels || [])[this.depth];
                },
                setVisual: function (key, value) {
                    this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
                },
                getVisual: function (key, ignoreParent) {
                    return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent);
                },
                getRawIndex: function () {
                    return this.hostTree.data.getRawIndex(this.dataIndex);
                },
                getId: function () {
                    return this.hostTree.data.getId(this.dataIndex);
                }
            };
            function Tree(hostModel, levelOptions) {
                this.root;
                this.data;
                this._nodes = [];
                this.hostModel = hostModel;
                this.levelModels = zrUtil.map(levelOptions || [], function (levelDefine) {
                    return new Model(levelDefine, hostModel, hostModel.ecModel);
                });
            }
            Tree.prototype = {
                constructor: Tree,
                type: 'tree',
                eachNode: function (options, cb, context) {
                    this.root.eachNode(options, cb, context);
                },
                getNodeByDataIndex: function (dataIndex) {
                    var rawIndex = this.data.getRawIndex(dataIndex);
                    return this._nodes[rawIndex];
                },
                getNodeByName: function (name) {
                    return this.root.getNodeByName(name);
                },
                update: function () {
                    var data = this.data;
                    var nodes = this._nodes;
                    for (var i = 0, len = nodes.length; i < len; i++) {
                        nodes[i].dataIndex = -1;
                    }
                    for (var i = 0, len = data.count(); i < len; i++) {
                        nodes[data.getRawIndex(i)].dataIndex = i;
                    }
                }
            };
            Tree.createTree = function (dataRoot, hostModel, levelOptions) {
                var tree = new Tree(hostModel, levelOptions);
                var listData = [];
                buildHierarchy(dataRoot);
                function buildHierarchy(dataNode, parentNode) {
                    listData.push(dataNode);
                    var node = new TreeNode(dataNode.name, listData.length - 1, tree);
                    parentNode ? addChild(node, parentNode) : tree.root = node;
                    var children = dataNode.children;
                    if (children) {
                        for (var i = 0; i < children.length; i++) {
                            buildHierarchy(children[i], node);
                        }
                    }
                }
                tree.root.updateDepthAndHeight(0);
                var dimensions = completeDimensions([{ name: 'value' }], listData);
                var list = new List(dimensions, hostModel);
                list.initData(listData);
                linkListHelper.linkToTree(list, tree);
                return tree;
            };
            function addChild(child, node) {
                var children = node.children;
                if (child.parentNode === node) {
                    return;
                }
                children.push(child);
                child.parentNode = node;
                node.hostTree._nodes.push(child);
            }
            module.exports = Tree;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var arraySlice = Array.prototype.slice;
            function linkList(list, target, targetType) {
                zrUtil.each(listProxyMethods, function (method, methodName) {
                    var originMethod = list[methodName];
                    list[methodName] = zrUtil.curry(method, originMethod, target, targetType);
                });
                list[targetType] = target;
                target.data = list;
                return list;
            }
            var listProxyMethods = {
                cloneShallow: function (originMethod, target, targetType) {
                    var newList = originMethod.apply(this, arraySlice.call(arguments, 3));
                    return linkList(newList, target, targetType);
                },
                map: function (originMethod, target, targetType) {
                    var newList = originMethod.apply(this, arraySlice.call(arguments, 3));
                    return linkList(newList, target, targetType);
                },
                filterSelf: function (originMethod, target, targetType) {
                    var result = originMethod.apply(this, arraySlice.call(arguments, 3));
                    target.update();
                    return result;
                }
            };
            module.exports = {
                linkToGraph: function (list, graph) {
                    linkList(list, graph, 'graph');
                },
                linkToTree: function (list, tree) {
                    linkList(list, tree, 'tree');
                }
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var helper = {
                retrieveTargetInfo: function (payload, seriesModel) {
                    if (payload && (payload.type === 'treemapZoomToNode' || payload.type === 'treemapRootToNode')) {
                        var root = seriesModel.getData().tree.root;
                        var targetNode = payload.targetNode;
                        if (targetNode && root.contains(targetNode)) {
                            return { node: targetNode };
                        }
                        var targetNodeId = payload.targetNodeId;
                        if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
                            return { node: targetNode };
                        }
                    }
                },
                getPathToRoot: function (node) {
                    var path = [];
                    while (node) {
                        path.push(node);
                        node = node.parentNode;
                    }
                    return path.reverse();
                },
                aboveViewRoot: function (viewRoot, node) {
                    var viewPath = helper.getPathToRoot(viewRoot);
                    return helper.aboveViewRootByViewPath(viewPath, node);
                },
                aboveViewRootByViewPath: function (viewPath, node) {
                    var index = zrUtil.indexOf(viewPath, node);
                    return index >= 0 && index !== viewPath.length - 1;
                }
            };
            module.exports = helper;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var DataDiffer = __webpack_require__(95);
            var helper = __webpack_require__(181);
            var Breadcrumb = __webpack_require__(183);
            var RoamController = __webpack_require__(159);
            var BoundingRect = __webpack_require__(15);
            var matrix = __webpack_require__(17);
            var animationUtil = __webpack_require__(184);
            var bind = zrUtil.bind;
            var Group = graphic.Group;
            var Rect = graphic.Rect;
            var each = zrUtil.each;
            var DRAG_THRESHOLD = 3;
            module.exports = __webpack_require__(1).extendChartView({
                type: 'treemap',
                init: function (o, api) {
                    this._containerGroup;
                    this._storage = createStorage();
                    this._oldTree;
                    this._breadcrumb;
                    this._controller;
                    this._state = 'ready';
                    this._mayClick;
                },
                render: function (seriesModel, ecModel, api, payload) {
                    var models = ecModel.findComponents({
                        mainType: 'series',
                        subType: 'treemap',
                        query: payload
                    });
                    if (zrUtil.indexOf(models, seriesModel) < 0) {
                        return;
                    }
                    this.seriesModel = seriesModel;
                    this.api = api;
                    this.ecModel = ecModel;
                    var targetInfo = helper.retrieveTargetInfo(payload, seriesModel);
                    var payloadType = payload && payload.type;
                    var layoutInfo = seriesModel.layoutInfo;
                    var isInit = !this._oldTree;
                    var thisStorage = this._storage;
                    var reRoot = payloadType === 'treemapRootToNode' && targetInfo && thisStorage ? {
                        rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
                        direction: payload.direction
                    } : null;
                    var containerGroup = this._giveContainerGroup(layoutInfo);
                    var renderResult = this._doRender(containerGroup, seriesModel, reRoot);
                    !isInit && (!payloadType || payloadType === 'treemapZoomToNode' || payloadType === 'treemapRootToNode') ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally();
                    this._resetController(api);
                    this._renderBreadcrumb(seriesModel, api, targetInfo);
                },
                _giveContainerGroup: function (layoutInfo) {
                    var containerGroup = this._containerGroup;
                    if (!containerGroup) {
                        containerGroup = this._containerGroup = new Group();
                        this._initEvents(containerGroup);
                        this.group.add(containerGroup);
                    }
                    containerGroup.position = [
                        layoutInfo.x,
                        layoutInfo.y
                    ];
                    return containerGroup;
                },
                _doRender: function (containerGroup, seriesModel, reRoot) {
                    var thisTree = seriesModel.getData().tree;
                    var oldTree = this._oldTree;
                    var lastsForAnimation = createStorage();
                    var thisStorage = createStorage();
                    var oldStorage = this._storage;
                    var willInvisibleEls = [];
                    var willVisibleEls = [];
                    var willDeleteEls = [];
                    var renderNode = bind(this._renderNode, this, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, willVisibleEls);
                    var viewRoot = seriesModel.getViewRoot();
                    var viewPath = helper.getPathToRoot(viewRoot);
                    dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0);
                    var willDeleteEls = clearStorage(oldStorage);
                    this._oldTree = thisTree;
                    this._storage = thisStorage;
                    return {
                        lastsForAnimation: lastsForAnimation,
                        willDeleteEls: willDeleteEls,
                        renderFinally: renderFinally
                    };
                    function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, viewPathIndex) {
                        if (sameTree) {
                            oldViewChildren = thisViewChildren;
                            each(thisViewChildren, function (child, index) {
                                !child.isRemoved() && processNode(index, index);
                            });
                        } else {
                            new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove(zrUtil.curry(processNode, null)).execute();
                        }
                        function getKey(node) {
                            return node.getId();
                        }
                        function processNode(newIndex, oldIndex) {
                            var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
                            var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;
                            if (!thisNode || isNaN(viewPathIndex) || viewPathIndex < viewPath.length && viewPath[viewPathIndex] !== thisNode) {
                                return;
                            }
                            var group = renderNode(thisNode, oldNode, parentGroup);
                            group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, viewPathIndex + 1);
                        }
                    }
                    function clearStorage(storage) {
                        var willDeleteEls = createStorage();
                        storage && each(storage, function (store, storageName) {
                            var delEls = willDeleteEls[storageName];
                            each(store, function (el) {
                                el && (delEls.push(el), el.__tmWillDelete = storageName);
                            });
                        });
                        return willDeleteEls;
                    }
                    function renderFinally() {
                        each(willDeleteEls, function (els) {
                            each(els, function (el) {
                                el.parent && el.parent.remove(el);
                            });
                        });
                        each(willInvisibleEls, function (el) {
                            el.invisible = true;
                            el.dirty();
                        });
                        each(willVisibleEls, function (el) {
                            el.invisible = false;
                            el.__tmWillVisible = false;
                            el.dirty();
                        });
                    }
                },
                _renderNode: function (thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, willVisibleEls, thisNode, oldNode, parentGroup) {
                    var thisRawIndex = thisNode && thisNode.getRawIndex();
                    var oldRawIndex = oldNode && oldNode.getRawIndex();
                    var layout = thisNode.getLayout();
                    var thisWidth = layout.width;
                    var thisHeight = layout.height;
                    var invisible = layout.invisible;
                    var group = giveGraphic('nodeGroup', Group);
                    if (!group) {
                        return;
                    }
                    parentGroup.add(group);
                    group.position = [
                        layout.x,
                        layout.y
                    ];
                    group.__tmNodeWidth = thisWidth;
                    group.__tmNodeHeight = thisHeight;
                    var bg = giveGraphic('background', Rect, 0);
                    if (bg) {
                        bg.setShape({
                            x: 0,
                            y: 0,
                            width: thisWidth,
                            height: thisHeight
                        });
                        updateStyle(bg, { fill: thisNode.getVisual('borderColor', true) });
                        group.add(bg);
                    }
                    var thisViewChildren = thisNode.viewChildren;
                    if (!thisViewChildren || !thisViewChildren.length) {
                        var borderWidth = layout.borderWidth;
                        var content = giveGraphic('content', Rect, 3);
                        if (content) {
                            var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
                            var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);
                            var labelModel = thisNode.getModel('label.normal');
                            var textStyleModel = thisNode.getModel('label.normal.textStyle');
                            var hoverStyle = thisNode.getModel('itemStyle.emphasis').getItemStyle();
                            var text = thisNode.getModel().get('name');
                            var textRect = textStyleModel.getTextRect(text);
                            var showLabel = labelModel.get('show');
                            if (!showLabel || textRect.height > contentHeight) {
                                text = '';
                            } else if (textRect.width > contentWidth) {
                                text = textStyleModel.get('ellipsis') ? textStyleModel.ellipsis(text, contentWidth) : '';
                            }
                            graphic.setHoverStyle(content, hoverStyle);
                            content.dataIndex = thisNode.dataIndex;
                            content.seriesIndex = this.seriesModel.seriesIndex;
                            content.culling = true;
                            content.setShape({
                                x: borderWidth,
                                y: borderWidth,
                                width: contentWidth,
                                height: contentHeight
                            });
                            updateStyle(content, {
                                fill: thisNode.getVisual('color', true),
                                text: text,
                                textPosition: labelModel.get('position'),
                                textFill: textStyleModel.getTextColor(),
                                textAlign: textStyleModel.get('align'),
                                textVerticalAlign: textStyleModel.get('baseline'),
                                textFont: textStyleModel.getFont()
                            });
                            group.add(content);
                        }
                    }
                    return group;
                    function giveGraphic(storageName, Ctor, z) {
                        var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
                        var lasts = lastsForAnimation[storageName];
                        if (element) {
                            oldStorage[storageName][oldRawIndex] = null;
                            prepareAnimationWhenHasOld(lasts, element, storageName);
                        } else if (!invisible) {
                            element = new Ctor({ z: z });
                            prepareAnimationWhenNoOld(lasts, element, storageName);
                        }
                        return thisStorage[storageName][thisRawIndex] = element;
                    }
                    function prepareAnimationWhenHasOld(lasts, element, storageName) {
                        var lastCfg = lasts[thisRawIndex] = {};
                        lastCfg.old = storageName === 'nodeGroup' ? element.position.slice() : zrUtil.extend({}, element.shape);
                    }
                    function prepareAnimationWhenNoOld(lasts, element, storageName) {
                        if (storageName === 'background') {
                            element.invisible = true;
                            element.__tmWillVisible = true;
                            willVisibleEls.push(element);
                        } else {
                            var lastCfg = lasts[thisRawIndex] = {};
                            var parentNode = thisNode.parentNode;
                            if (parentNode && (!reRoot || reRoot.direction === 'drilldown')) {
                                var parentOldX = 0;
                                var parentOldY = 0;
                                var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];
                                if (parentOldBg && parentOldBg.old) {
                                    parentOldX = parentOldBg.old.width / 2;
                                    parentOldY = parentOldBg.old.height / 2;
                                }
                                lastCfg.old = storageName === 'nodeGroup' ? [
                                    parentOldX,
                                    parentOldY
                                ] : {
                                    x: parentOldX,
                                    y: parentOldY,
                                    width: 0,
                                    height: 0
                                };
                            }
                            lastCfg.fadein = storageName !== 'nodeGroup';
                        }
                    }
                    function updateStyle(element, style) {
                        if (!invisible) {
                            element.setStyle(style);
                            if (!element.__tmWillVisible) {
                                element.invisible = false;
                            }
                        } else {
                            !element.invisible && willInvisibleEls.push(element);
                        }
                    }
                },
                _doAnimation: function (containerGroup, renderResult, seriesModel, reRoot) {
                    if (!seriesModel.get('animation')) {
                        return;
                    }
                    var duration = seriesModel.get('animationDurationUpdate');
                    var easing = seriesModel.get('animationEasing');
                    var animationWrap = animationUtil.createWrap();
                    each(renderResult.willDeleteEls, function (store, storageName) {
                        each(store, function (el, rawIndex) {
                            var storageName;
                            if (el.invisible || !(storageName = el.__tmWillDelete)) {
                                return;
                            }
                            var parent = el.parent;
                            var target;
                            if (reRoot && reRoot.direction === 'drilldown') {
                                if (parent === reRoot.rootNodeGroup) {
                                    target = {
                                        shape: {
                                            x: 0,
                                            y: 0,
                                            width: parent.__tmNodeWidth,
                                            height: parent.__tmNodeHeight
                                        }
                                    };
                                    el.z = 2;
                                } else {
                                    target = { style: { opacity: 0 } };
                                    el.z = 1;
                                }
                            } else {
                                var targetX = 0;
                                var targetY = 0;
                                if (!parent.__tmWillDelete) {
                                    targetX = parent.__tmNodeWidth / 2;
                                    targetY = parent.__tmNodeHeight / 2;
                                }
                                target = storageName === 'nodeGroup' ? {
                                    position: [
                                        targetX,
                                        targetY
                                    ],
                                    style: { opacity: 0 }
                                } : {
                                    shape: {
                                        x: targetX,
                                        y: targetY,
                                        width: 0,
                                        height: 0
                                    },
                                    style: { opacity: 0 }
                                };
                            }
                            target && animationWrap.add(el, target, duration, easing);
                        });
                    });
                    each(this._storage, function (store, storageName) {
                        each(store, function (el, rawIndex) {
                            var last = renderResult.lastsForAnimation[storageName][rawIndex];
                            var target = {};
                            if (!last) {
                                return;
                            }
                            if (storageName === 'nodeGroup') {
                                if (last.old) {
                                    target.position = el.position.slice();
                                    el.position = last.old;
                                }
                            } else {
                                if (last.old) {
                                    target.shape = zrUtil.extend({}, el.shape);
                                    el.setShape(last.old);
                                }
                                if (last.fadein) {
                                    el.setStyle('opacity', 0);
                                    target.style = { opacity: 1 };
                                } else if (el.style.opacity !== 1) {
                                    target.style = { opacity: 1 };
                                }
                            }
                            animationWrap.add(el, target, duration, easing);
                        });
                    }, this);
                    this._state = 'animating';
                    animationWrap.done(bind(function () {
                        this._state = 'ready';
                        renderResult.renderFinally();
                    }, this)).start();
                },
                _resetController: function (api) {
                    var controller = this._controller;
                    if (!controller) {
                        controller = this._controller = new RoamController(api.getZr());
                        controller.enable(this.seriesModel.get('roam'));
                        controller.on('pan', bind(this._onPan, this));
                        controller.on('zoom', bind(this._onZoom, this));
                    }
                    controller.rect = new BoundingRect(0, 0, api.getWidth(), api.getHeight());
                },
                _clearController: function () {
                    var controller = this._controller;
                    if (controller) {
                        controller.off('pan').off('zoom');
                        controller = null;
                    }
                },
                _onPan: function (dx, dy) {
                    this._mayClick = false;
                    if (this._state !== 'animating' && (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD)) {
                        var viewRoot = this.seriesModel.getViewRoot();
                        if (!viewRoot) {
                            return;
                        }
                        var rootLayout = viewRoot.getLayout();
                        if (!rootLayout) {
                            return;
                        }
                        this.api.dispatchAction({
                            type: 'treemapMove',
                            from: this.uid,
                            seriesId: this.seriesModel.id,
                            rootRect: {
                                x: rootLayout.x + dx,
                                y: rootLayout.y + dy,
                                width: rootLayout.width,
                                height: rootLayout.height
                            }
                        });
                    }
                },
                _onZoom: function (scale, mouseX, mouseY) {
                    this._mayClick = false;
                    if (this._state !== 'animating') {
                        var viewRoot = this.seriesModel.getViewRoot();
                        if (!viewRoot) {
                            return;
                        }
                        var rootLayout = viewRoot.getLayout();
                        if (!rootLayout) {
                            return;
                        }
                        var rect = new BoundingRect(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height);
                        var layoutInfo = this.seriesModel.layoutInfo;
                        mouseX -= layoutInfo.x;
                        mouseY -= layoutInfo.y;
                        var m = matrix.create();
                        matrix.translate(m, m, [
                            -mouseX,
                            -mouseY
                        ]);
                        matrix.scale(m, m, [
                            scale,
                            scale
                        ]);
                        matrix.translate(m, m, [
                            mouseX,
                            mouseY
                        ]);
                        rect.applyTransform(m);
                        this.api.dispatchAction({
                            type: 'treemapRender',
                            from: this.uid,
                            seriesId: this.seriesModel.id,
                            rootRect: {
                                x: rect.x,
                                y: rect.y,
                                width: rect.width,
                                height: rect.height
                            }
                        });
                    }
                },
                _initEvents: function (containerGroup) {
                    containerGroup.on('mousedown', function (e) {
                        this._state === 'ready' && (this._mayClick = true);
                    }, this);
                    containerGroup.on('mouseup', function (e) {
                        if (this._mayClick) {
                            this._mayClick = false;
                            this._state === 'ready' && onClick.call(this, e);
                        }
                    }, this);
                    function onClick(e) {
                        var nodeClick = this.seriesModel.get('nodeClick', true);
                        if (!nodeClick) {
                            return;
                        }
                        var targetInfo = this.findTarget(e.offsetX, e.offsetY);
                        if (!targetInfo) {
                            return;
                        }
                        var node = targetInfo.node;
                        if (node.getLayout().isLeafRoot) {
                            this._rootToNode(targetInfo);
                        } else {
                            if (nodeClick === 'zoomToNode') {
                                this._zoomToNode(targetInfo);
                            } else if (nodeClick === 'link') {
                                var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
                                var link = itemModel.get('link', true);
                                var linkTarget = itemModel.get('target', true) || 'blank';
                                link && window.open(link, linkTarget);
                            }
                        }
                    }
                },
                _renderBreadcrumb: function (seriesModel, api, targetInfo) {
                    if (!targetInfo) {
                        targetInfo = this.findTarget(api.getWidth() / 2, api.getHeight() / 2);
                        if (!targetInfo) {
                            targetInfo = { node: seriesModel.getData().tree.root };
                        }
                    }
                    (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group, bind(onSelect, this)))).render(seriesModel, api, targetInfo.node);
                    function onSelect(node) {
                        if (this._state !== 'animating') {
                            helper.aboveViewRoot(seriesModel.getViewRoot(), node) ? this._rootToNode({ node: node }) : this._zoomToNode({ node: node });
                        }
                    }
                },
                remove: function () {
                    this._clearController();
                    this._containerGroup && this._containerGroup.removeAll();
                    this._storage = createStorage();
                    this._state = 'ready';
                    this._breadcrumb && this._breadcrumb.remove();
                },
                dispose: function () {
                    this._clearController();
                },
                _zoomToNode: function (targetInfo) {
                    this.api.dispatchAction({
                        type: 'treemapZoomToNode',
                        from: this.uid,
                        seriesId: this.seriesModel.id,
                        targetNode: targetInfo.node
                    });
                },
                _rootToNode: function (targetInfo) {
                    this.api.dispatchAction({
                        type: 'treemapRootToNode',
                        from: this.uid,
                        seriesId: this.seriesModel.id,
                        targetNode: targetInfo.node
                    });
                },
                findTarget: function (x, y) {
                    var targetInfo;
                    var viewRoot = this.seriesModel.getViewRoot();
                    viewRoot.eachNode({
                        attr: 'viewChildren',
                        order: 'preorder'
                    }, function (node) {
                        var bgEl = this._storage.background[node.getRawIndex()];
                        if (bgEl) {
                            var point = bgEl.transformCoordToLocal(x, y);
                            var shape = bgEl.shape;
                            if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
                                targetInfo = {
                                    node: node,
                                    offsetX: point[0],
                                    offsetY: point[1]
                                };
                            } else {
                                return false;
                            }
                        }
                    }, this);
                    return targetInfo;
                }
            });
            function createStorage() {
                return {
                    nodeGroup: [],
                    background: [],
                    content: []
                };
            }
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var layout = __webpack_require__(21);
            var zrUtil = __webpack_require__(3);
            var TEXT_PADDING = 8;
            var ITEM_GAP = 8;
            var ARRAY_LENGTH = 5;
            function Breadcrumb(containerGroup, onSelect) {
                this.group = new graphic.Group();
                containerGroup.add(this.group);
                this._onSelect = onSelect || zrUtil.noop;
            }
            Breadcrumb.prototype = {
                constructor: Breadcrumb,
                render: function (seriesModel, api, targetNode) {
                    var model = seriesModel.getModel('breadcrumb');
                    var thisGroup = this.group;
                    thisGroup.removeAll();
                    if (!model.get('show') || !targetNode) {
                        return;
                    }
                    var normalStyleModel = model.getModel('itemStyle.normal');
                    var textStyleModel = normalStyleModel.getModel('textStyle');
                    var layoutParam = {
                        pos: {
                            left: model.get('left'),
                            right: model.get('right'),
                            top: model.get('top'),
                            bottom: model.get('bottom')
                        },
                        box: {
                            width: api.getWidth(),
                            height: api.getHeight()
                        },
                        emptyItemWidth: model.get('emptyItemWidth'),
                        totalWidth: 0,
                        renderList: []
                    };
                    this._prepare(model, targetNode, layoutParam, textStyleModel);
                    this._renderContent(model, targetNode, layoutParam, normalStyleModel, textStyleModel);
                    layout.positionGroup(thisGroup, layoutParam.pos, layoutParam.box);
                },
                _prepare: function (model, targetNode, layoutParam, textStyleModel) {
                    for (var node = targetNode; node; node = node.parentNode) {
                        var text = node.getModel().get('name');
                        var textRect = textStyleModel.getTextRect(text);
                        var itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth);
                        layoutParam.totalWidth += itemWidth + ITEM_GAP;
                        layoutParam.renderList.push({
                            node: node,
                            text: text,
                            width: itemWidth
                        });
                    }
                },
                _renderContent: function (model, targetNode, layoutParam, normalStyleModel, textStyleModel) {
                    var lastX = 0;
                    var emptyItemWidth = layoutParam.emptyItemWidth;
                    var height = model.get('height');
                    var availableSize = layout.getAvailableSize(layoutParam.pos, layoutParam.box);
                    var totalWidth = layoutParam.totalWidth;
                    var renderList = layoutParam.renderList;
                    for (var i = renderList.length - 1; i >= 0; i--) {
                        var item = renderList[i];
                        var itemWidth = item.width;
                        var text = item.text;
                        if (totalWidth > availableSize.width) {
                            totalWidth -= itemWidth - emptyItemWidth;
                            itemWidth = emptyItemWidth;
                            text = '';
                        }
                        this.group.add(new graphic.Polygon({
                            shape: { points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0) },
                            style: zrUtil.defaults(normalStyleModel.getItemStyle(), {
                                lineJoin: 'bevel',
                                text: text,
                                textFill: textStyleModel.getTextColor(),
                                textFont: textStyleModel.getFont()
                            }),
                            z: 10,
                            onclick: zrUtil.bind(this._onSelect, this, item.node)
                        }));
                        lastX += itemWidth + ITEM_GAP;
                    }
                },
                remove: function () {
                    this.group.removeAll();
                }
            };
            function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
                var points = [
                    [
                        head ? x : x - ARRAY_LENGTH,
                        y
                    ],
                    [
                        x + itemWidth,
                        y
                    ],
                    [
                        x + itemWidth,
                        y + itemHeight
                    ],
                    [
                        head ? x : x - ARRAY_LENGTH,
                        y + itemHeight
                    ]
                ];
                !tail && points.splice(2, 0, [
                    x + itemWidth + ARRAY_LENGTH,
                    y + itemHeight / 2
                ]);
                !head && points.push([
                    x,
                    y + itemHeight / 2
                ]);
                return points;
            }
            module.exports = Breadcrumb;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            function createWrap() {
                var storage = [];
                var elExistsMap = {};
                var doneCallback;
                return {
                    add: function (el, target, time, delay, easing) {
                        if (zrUtil.isString(delay)) {
                            easing = delay;
                            delay = 0;
                        }
                        if (elExistsMap[el.id]) {
                            return false;
                        }
                        elExistsMap[el.id] = 1;
                        storage.push({
                            el: el,
                            target: target,
                            time: time,
                            delay: delay,
                            easing: easing
                        });
                        return true;
                    },
                    done: function (callback) {
                        doneCallback = callback;
                        return this;
                    },
                    start: function () {
                        var count = storage.length;
                        for (var i = 0, len = storage.length; i < len; i++) {
                            var item = storage[i];
                            item.el.animateTo(item.target, item.time, item.delay, item.easing, done);
                        }
                        return this;
                        function done() {
                            count--;
                            if (!count) {
                                storage.length = 0;
                                elExistsMap = {};
                                doneCallback && doneCallback();
                            }
                        }
                    }
                };
            }
            module.exports = { createWrap: createWrap };
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            var helper = __webpack_require__(181);
            var noop = function () {
            };
            var actionTypes = [
                'treemapZoomToNode',
                'treemapRender',
                'treemapMove'
            ];
            for (var i = 0; i < actionTypes.length; i++) {
                echarts.registerAction({
                    type: actionTypes[i],
                    update: 'updateView'
                }, noop);
            }
            echarts.registerAction({
                type: 'treemapRootToNode',
                update: 'updateView'
            }, function (payload, ecModel) {
                ecModel.eachComponent({
                    mainType: 'series',
                    subType: 'treemap',
                    query: payload
                }, function (model, index) {
                    var targetInfo = helper.retrieveTargetInfo(payload, model);
                    if (targetInfo) {
                        var originViewRoot = model.getViewRoot();
                        if (originViewRoot) {
                            payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollup' : 'drilldown';
                        }
                        model.resetViewRoot(targetInfo.node);
                    }
                });
            });
        },
        function (module, exports, __webpack_require__) {
            var VisualMapping = __webpack_require__(187);
            var zrColor = __webpack_require__(38);
            var zrUtil = __webpack_require__(3);
            var isArray = zrUtil.isArray;
            var ITEM_STYLE_NORMAL = 'itemStyle.normal';
            module.exports = function (ecModel, payload) {
                var condition = {
                    mainType: 'series',
                    subType: 'treemap',
                    query: payload
                };
                ecModel.eachComponent(condition, function (seriesModel) {
                    var tree = seriesModel.getData().tree;
                    var root = tree.root;
                    var seriesItemStyleModel = seriesModel.getModel(ITEM_STYLE_NORMAL);
                    if (root.isRemoved()) {
                        return;
                    }
                    var levelItemStyles = zrUtil.map(tree.levelModels, function (levelModel) {
                        return levelModel ? levelModel.get(ITEM_STYLE_NORMAL) : null;
                    });
                    travelTree(root, {}, levelItemStyles, seriesItemStyleModel, seriesModel.getViewRoot().getAncestors(), seriesModel);
                });
            };
            function travelTree(node, designatedVisual, levelItemStyles, seriesItemStyleModel, viewRootAncestors, seriesModel) {
                var nodeModel = node.getModel();
                var nodeLayout = node.getLayout();
                if (nodeLayout.invisible) {
                    return;
                }
                var nodeItemStyleModel = node.getModel(ITEM_STYLE_NORMAL);
                var levelItemStyle = levelItemStyles[node.depth];
                var visuals = buildVisuals(nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel);
                var borderColor = nodeItemStyleModel.get('borderColor');
                var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');
                var thisNodeColor;
                if (borderColorSaturation != null) {
                    thisNodeColor = calculateColor(visuals, node);
                    borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
                }
                node.setVisual('borderColor', borderColor);
                var viewChildren = node.viewChildren;
                if (!viewChildren || !viewChildren.length) {
                    thisNodeColor = calculateColor(visuals, node);
                    node.setVisual('color', thisNodeColor);
                } else {
                    var mapping = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren);
                    zrUtil.each(viewChildren, function (child, index) {
                        if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
                            var childVisual = mapVisual(nodeModel, visuals, child, index, mapping, seriesModel);
                            travelTree(child, childVisual, levelItemStyles, seriesItemStyleModel, viewRootAncestors, seriesModel);
                        }
                    });
                }
            }
            function buildVisuals(nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel) {
                var visuals = zrUtil.extend({}, designatedVisual);
                zrUtil.each([
                    'color',
                    'colorAlpha',
                    'colorSaturation'
                ], function (visualName) {
                    var val = nodeItemStyleModel.get(visualName, true);
                    val == null && levelItemStyle && (val = levelItemStyle[visualName]);
                    val == null && (val = designatedVisual[visualName]);
                    val == null && (val = seriesItemStyleModel.get(visualName));
                    val != null && (visuals[visualName] = val);
                });
                return visuals;
            }
            function calculateColor(visuals) {
                var color = getValueVisualDefine(visuals, 'color');
                if (color) {
                    var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');
                    var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');
                    if (colorSaturation) {
                        color = zrColor.modifyHSL(color, null, null, colorSaturation);
                    }
                    if (colorAlpha) {
                        color = zrColor.modifyAlpha(color, colorAlpha);
                    }
                    return color;
                }
            }
            function calculateBorderColor(borderColorSaturation, thisNodeColor) {
                return thisNodeColor != null ? zrColor.modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null;
            }
            function getValueVisualDefine(visuals, name) {
                var value = visuals[name];
                if (value != null && value !== 'none') {
                    return value;
                }
            }
            function buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
                if (!viewChildren || !viewChildren.length) {
                    return;
                }
                var rangeVisual = getRangeVisual(nodeModel, 'color') || visuals.color != null && visuals.color !== 'none' && (getRangeVisual(nodeModel, 'colorAlpha') || getRangeVisual(nodeModel, 'colorSaturation'));
                if (!rangeVisual) {
                    return;
                }
                var colorMappingBy = nodeModel.get('colorMappingBy');
                var opt = {
                    type: rangeVisual.name,
                    dataExtent: nodeLayout.dataExtent,
                    visual: rangeVisual.range
                };
                if (opt.type === 'color' && (colorMappingBy === 'index' || colorMappingBy === 'id')) {
                    opt.mappingMethod = 'category';
                    opt.loop = true;
                } else {
                    opt.mappingMethod = 'linear';
                }
                var mapping = new VisualMapping(opt);
                mapping.__drColorMappingBy = colorMappingBy;
                return mapping;
            }
            function getRangeVisual(nodeModel, name) {
                var range = nodeModel.get(name);
                return isArray(range) && range.length ? {
                    name: name,
                    range: range
                } : null;
            }
            function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {
                var childVisuals = zrUtil.extend({}, visuals);
                if (mapping) {
                    var mappingType = mapping.type;
                    var colorMappingBy = mappingType === 'color' && mapping.__drColorMappingBy;
                    var value = colorMappingBy === 'index' ? index : colorMappingBy === 'id' ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get('visualDimension'));
                    childVisuals[mappingType] = mapping.mapValueToVisual(value);
                }
                return childVisuals;
            }
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var zrColor = __webpack_require__(38);
            var linearMap = __webpack_require__(7).linearMap;
            var each = zrUtil.each;
            var isObject = zrUtil.isObject;
            var CATEGORY_DEFAULT_VISUAL_INDEX = -1;
            function linearMapArray(val, domain, range, clamp) {
                if (zrUtil.isArray(val)) {
                    return zrUtil.map(val, function (v) {
                        return linearMap(v, domain, range, clamp);
                    });
                }
                return linearMap(val, domain, range, clamp);
            }
            var VisualMapping = function (option) {
                var mappingMethod = option.mappingMethod;
                var visualType = option.type;
                this.type = visualType;
                this.mappingMethod = mappingMethod;
                var thisOption = this.option = zrUtil.clone(option);
                this._normalizeData = normalizers[mappingMethod];
                this._getSpecifiedVisual = zrUtil.bind(specifiedVisualGetters[mappingMethod], this, visualType);
                zrUtil.extend(this, visualHandlers[visualType]);
                if (mappingMethod === 'piecewise') {
                    preprocessForPiecewise(thisOption);
                }
                if (mappingMethod === 'category') {
                    preprocessForCategory(thisOption);
                }
            };
            VisualMapping.prototype = {
                constructor: VisualMapping,
                applyVisual: null,
                isValueActive: null,
                mapValueToVisual: null,
                getNormalizer: function () {
                    return zrUtil.bind(this._normalizeData, this);
                }
            };
            var visualHandlers = VisualMapping.visualHandlers = {
                color: {
                    applyVisual: defaultApplyColor,
                    getColorMapper: function () {
                        var visual = isCategory(this) ? this.option.visual : zrUtil.map(this.option.visual, zrColor.parse);
                        return zrUtil.bind(isCategory(this) ? function (value, isNormalized) {
                            !isNormalized && (value = this._normalizeData(value));
                            return getVisualForCategory(this, visual, value);
                        } : function (value, isNormalized, out) {
                            var returnRGBArray = !!out;
                            !isNormalized && (value = this._normalizeData(value));
                            out = zrColor.fastMapToColor(value, visual, out);
                            return returnRGBArray ? out : zrUtil.stringify(out, 'rgba');
                        }, this);
                    },
                    mapValueToVisual: function (value) {
                        var visual = this.option.visual;
                        if (zrUtil.isArray(value)) {
                            value = [
                                this._normalizeData(value[0]),
                                this._normalizeData(value[1])
                            ];
                            return zrColor.mapIntervalToColor(value, visual);
                        } else {
                            var normalized = this._normalizeData(value);
                            var result = this._getSpecifiedVisual(value);
                            if (result == null) {
                                result = isCategory(this) ? getVisualForCategory(this, visual, normalized) : zrColor.mapToColor(normalized, visual);
                            }
                            return result;
                        }
                    }
                },
                colorHue: makePartialColorVisualHandler(function (color, value) {
                    return zrColor.modifyHSL(color, value);
                }),
                colorSaturation: makePartialColorVisualHandler(function (color, value) {
                    return zrColor.modifyHSL(color, null, value);
                }),
                colorLightness: makePartialColorVisualHandler(function (color, value) {
                    return zrColor.modifyHSL(color, null, null, value);
                }),
                colorAlpha: makePartialColorVisualHandler(function (color, value) {
                    return zrColor.modifyAlpha(color, value);
                }),
                opacity: {
                    applyVisual: function (value, getter, setter) {
                        setter('opacity', this.mapValueToVisual(value));
                    },
                    mapValueToVisual: function (value) {
                        var normalized = this._normalizeData(value);
                        var result = this._getSpecifiedVisual(value);
                        var visual = this.option.visual;
                        if (result == null) {
                            result = isCategory(this) ? getVisualForCategory(this, visual, normalized) : linearMapArray(normalized, [
                                0,
                                1
                            ], visual, true);
                        }
                        return result;
                    }
                },
                symbol: {
                    applyVisual: function (value, getter, setter) {
                        var symbolCfg = this.mapValueToVisual(value);
                        if (zrUtil.isString(symbolCfg)) {
                            setter('symbol', symbolCfg);
                        } else if (isObject(symbolCfg)) {
                            for (var name in symbolCfg) {
                                if (symbolCfg.hasOwnProperty(name)) {
                                    setter(name, symbolCfg[name]);
                                }
                            }
                        }
                    },
                    mapValueToVisual: function (value) {
                        var normalized = this._normalizeData(value);
                        var result = this._getSpecifiedVisual(value);
                        var visual = this.option.visual;
                        if (result == null) {
                            result = isCategory(this) ? getVisualForCategory(this, visual, normalized) : arrayGetByNormalizedValue(visual, normalized) || {};
                        }
                        return result;
                    }
                },
                symbolSize: {
                    applyVisual: function (value, getter, setter) {
                        setter('symbolSize', this.mapValueToVisual(value));
                    },
                    mapValueToVisual: function (value) {
                        var normalized = this._normalizeData(value);
                        var result = this._getSpecifiedVisual(value);
                        var visual = this.option.visual;
                        if (result == null) {
                            result = isCategory(this) ? getVisualForCategory(this, visual, normalized) : linearMapArray(normalized, [
                                0,
                                1
                            ], visual, true);
                        }
                        return result;
                    }
                }
            };
            function preprocessForPiecewise(thisOption) {
                var pieceList = thisOption.pieceList;
                thisOption.hasSpecialVisual = false;
                zrUtil.each(pieceList, function (piece, index) {
                    piece.originIndex = index;
                    if (piece.visual) {
                        thisOption.hasSpecialVisual = true;
                    }
                });
            }
            function preprocessForCategory(thisOption) {
                var categories = thisOption.categories;
                var visual = thisOption.visual;
                var isVisualArray = zrUtil.isArray(visual);
                if (!categories) {
                    if (!isVisualArray) {
                        throw new Error();
                    } else {
                        return;
                    }
                }
                var categoryMap = thisOption.categoryMap = {};
                each(categories, function (cate, index) {
                    categoryMap[cate] = index;
                });
                if (!isVisualArray) {
                    var visualArr = [];
                    if (zrUtil.isObject(visual)) {
                        each(visual, function (v, cate) {
                            var index = categoryMap[cate];
                            visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
                        });
                    } else {
                        visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
                    }
                    visual = thisOption.visual = visualArr;
                }
                for (var i = categories.length - 1; i >= 0; i--) {
                    if (visual[i] == null) {
                        delete categoryMap[categories[i]];
                        categories.pop();
                    }
                }
            }
            function makePartialColorVisualHandler(applyValue) {
                return {
                    applyVisual: function (value, getter, setter) {
                        var color = getter('color');
                        var isArrayValue = zrUtil.isArray(value);
                        value = isArrayValue ? [
                            this.mapValueToVisual(value[0]),
                            this.mapValueToVisual(value[1])
                        ] : this.mapValueToVisual(value);
                        if (zrUtil.isArray(color)) {
                            for (var i = 0, len = color.length; i < len; i++) {
                                color[i].color = applyValue(color[i].color, isArrayValue ? value[i] : value);
                            }
                        } else {
                            setter('color', applyValue(color, value));
                        }
                    },
                    mapValueToVisual: function (value) {
                        var normalized = this._normalizeData(value);
                        var result = this._getSpecifiedVisual(value);
                        var visual = this.option.visual;
                        if (result == null) {
                            result = isCategory(this) ? getVisualForCategory(this, visual, normalized) : linearMapArray(normalized, [
                                0,
                                1
                            ], visual, true);
                        }
                        return result;
                    }
                };
            }
            function arrayGetByNormalizedValue(arr, normalized) {
                return arr[Math.round(linearMapArray(normalized, [
                    0,
                    1
                ], [
                    0,
                    arr.length - 1
                ], true))];
            }
            function defaultApplyColor(value, getter, setter) {
                setter('color', this.mapValueToVisual(value));
            }
            function getVisualForCategory(me, visual, normalized) {
                return visual[me.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];
            }
            function isCategory(me) {
                return me.option.mappingMethod === 'category';
            }
            var normalizers = {
                linear: function (value) {
                    return linearMapArray(value, this.option.dataExtent, [
                        0,
                        1
                    ], true);
                },
                piecewise: function (value) {
                    var pieceList = this.option.pieceList;
                    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
                    if (pieceIndex != null) {
                        return linearMapArray(pieceIndex, [
                            0,
                            pieceList.length - 1
                        ], [
                            0,
                            1
                        ], true);
                    }
                },
                category: function (value) {
                    var index = this.option.categories ? this.option.categoryMap[value] : value;
                    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
                }
            };
            var specifiedVisualGetters = {
                linear: zrUtil.noop,
                piecewise: function (visualType, value) {
                    var thisOption = this.option;
                    var pieceList = thisOption.pieceList;
                    if (thisOption.hasSpecialVisual) {
                        var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
                        var piece = pieceList[pieceIndex];
                        if (piece && piece.visual) {
                            return piece.visual[visualType];
                        }
                    }
                },
                category: zrUtil.noop
            };
            VisualMapping.addVisualHandler = function (name, handler) {
                visualHandlers[name] = handler;
            };
            VisualMapping.isValidType = function (visualType) {
                return visualHandlers.hasOwnProperty(visualType);
            };
            VisualMapping.eachVisual = function (visual, callback, context) {
                if (zrUtil.isObject(visual)) {
                    zrUtil.each(visual, callback, context);
                } else {
                    callback.call(context, visual);
                }
            };
            VisualMapping.mapVisual = function (visual, callback, context) {
                var isPrimary;
                var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);
                VisualMapping.eachVisual(visual, function (v, key) {
                    var newVal = callback.call(context, v, key);
                    isPrimary ? newVisual = newVal : newVisual[key] = newVal;
                });
                return newVisual;
            };
            VisualMapping.retrieveVisuals = function (obj) {
                var ret = {};
                var hasVisual;
                obj && each(visualHandlers, function (h, visualType) {
                    if (obj.hasOwnProperty(visualType)) {
                        ret[visualType] = obj[visualType];
                        hasVisual = true;
                    }
                });
                return hasVisual ? ret : null;
            };
            VisualMapping.prepareVisualTypes = function (visualTypes) {
                if (isObject(visualTypes)) {
                    var types = [];
                    each(visualTypes, function (item, type) {
                        types.push(type);
                    });
                    visualTypes = types;
                } else if (zrUtil.isArray(visualTypes)) {
                    visualTypes = visualTypes.slice();
                } else {
                    return [];
                }
                visualTypes.sort(function (type1, type2) {
                    return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;
                });
                return visualTypes;
            };
            VisualMapping.dependsOn = function (visualType1, visualType2) {
                return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;
            };
            VisualMapping.cloneOpacityToAlpha = function (opacityMapping) {
                var alphaMapping = new VisualMapping({});
            };
            VisualMapping.findPieceIndex = function (value, pieceList) {
                for (var i = 0, len = pieceList.length; i < len; i++) {
                    var piece = pieceList[i];
                    if (piece.value != null && piece.value === value) {
                        return i;
                    }
                }
                for (var i = 0, len = pieceList.length; i < len; i++) {
                    var piece = pieceList[i];
                    var interval = piece.interval;
                    if (interval) {
                        if (interval[0] === -Infinity) {
                            if (value < interval[1]) {
                                return i;
                            }
                        } else if (interval[1] === Infinity) {
                            if (interval[0] < value) {
                                return i;
                            }
                        } else if (piece.interval[0] <= value && value <= piece.interval[1]) {
                            return i;
                        }
                    }
                }
            };
            module.exports = VisualMapping;
        },
        function (module, exports, __webpack_require__) {
            var mathMax = Math.max;
            var mathMin = Math.min;
            var zrUtil = __webpack_require__(3);
            var numberUtil = __webpack_require__(7);
            var layout = __webpack_require__(21);
            var helper = __webpack_require__(181);
            var parsePercent = numberUtil.parsePercent;
            var retrieveValue = zrUtil.retrieve;
            var BoundingRect = __webpack_require__(15);
            var helper = __webpack_require__(181);
            function update(ecModel, api, payload) {
                var condition = {
                    mainType: 'series',
                    subType: 'treemap',
                    query: payload
                };
                ecModel.eachComponent(condition, function (seriesModel) {
                    var ecWidth = api.getWidth();
                    var ecHeight = api.getHeight();
                    var seriesOption = seriesModel.option;
                    var size = seriesOption.size || [];
                    var containerWidth = parsePercent(retrieveValue(seriesOption.width, size[0]), ecWidth);
                    var containerHeight = parsePercent(retrieveValue(seriesOption.height, size[1]), ecHeight);
                    var layoutInfo = layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
                        width: api.getWidth(),
                        height: api.getHeight()
                    });
                    var payloadType = payload && payload.type;
                    var targetInfo = helper.retrieveTargetInfo(payload, seriesModel);
                    var rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null;
                    var viewRoot = seriesModel.getViewRoot();
                    if (payloadType !== 'treemapMove') {
                        var rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [
                            rootRect.width,
                            rootRect.height
                        ] : [
                            containerWidth,
                            containerHeight
                        ];
                        var sort = seriesOption.sort;
                        if (sort && sort !== 'asc' && sort !== 'desc') {
                            sort = 'desc';
                        }
                        var options = {
                            squareRatio: seriesOption.squareRatio,
                            sort: sort,
                            leafDepth: seriesOption.leafDepth
                        };
                        viewRoot.setLayout({
                            x: 0,
                            y: 0,
                            width: rootSize[0],
                            height: rootSize[1],
                            area: rootSize[0] * rootSize[1]
                        });
                        squarify(viewRoot, options, false, 0);
                    }
                    viewRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true);
                    seriesModel.setLayoutInfo(layoutInfo);
                    prunning(seriesModel.getData().tree.root, new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), helper.getPathToRoot(viewRoot));
                });
            }
            function squarify(node, options, hideChildren, depth) {
                var width;
                var height;
                if (node.isRemoved()) {
                    return;
                }
                var thisLayout = node.getLayout();
                width = thisLayout.width;
                height = thisLayout.height;
                var itemStyleModel = node.getModel('itemStyle.normal');
                var borderWidth = itemStyleModel.get('borderWidth');
                var halfGapWidth = itemStyleModel.get('gapWidth') / 2;
                var layoutOffset = borderWidth - halfGapWidth;
                var nodeModel = node.getModel();
                node.setLayout({ borderWidth: borderWidth }, true);
                width = mathMax(width - 2 * layoutOffset, 0);
                height = mathMax(height - 2 * layoutOffset, 0);
                var totalArea = width * height;
                var viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth);
                if (!viewChildren.length) {
                    return;
                }
                var rect = {
                    x: layoutOffset,
                    y: layoutOffset,
                    width: width,
                    height: height
                };
                var rowFixedLength = mathMin(width, height);
                var best = Infinity;
                var row = [];
                row.area = 0;
                for (var i = 0, len = viewChildren.length; i < len;) {
                    var child = viewChildren[i];
                    row.push(child);
                    row.area += child.getLayout().area;
                    var score = worst(row, rowFixedLength, options.squareRatio);
                    if (score <= best) {
                        i++;
                        best = score;
                    } else {
                        row.area -= row.pop().getLayout().area;
                        position(row, rowFixedLength, rect, halfGapWidth, false);
                        rowFixedLength = mathMin(rect.width, rect.height);
                        row.length = row.area = 0;
                        best = Infinity;
                    }
                }
                if (row.length) {
                    position(row, rowFixedLength, rect, halfGapWidth, true);
                }
                if (!hideChildren) {
                    var childrenVisibleMin = nodeModel.get('childrenVisibleMin');
                    if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
                        hideChildren = true;
                    }
                }
                for (var i = 0, len = viewChildren.length; i < len; i++) {
                    squarify(viewChildren[i], options, hideChildren, depth + 1);
                }
            }
            function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
                var viewChildren = node.children || [];
                var orderBy = options.sort;
                orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);
                var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;
                if (hideChildren && !overLeafDepth) {
                    return node.viewChildren = [];
                }
                viewChildren = zrUtil.filter(viewChildren, function (child) {
                    return !child.isRemoved();
                });
                sort(viewChildren, orderBy);
                var info = statistic(nodeModel, viewChildren, orderBy);
                if (info.sum === 0) {
                    return node.viewChildren = [];
                }
                info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);
                if (info.sum === 0) {
                    return node.viewChildren = [];
                }
                for (var i = 0, len = viewChildren.length; i < len; i++) {
                    var area = viewChildren[i].getValue() / info.sum * totalArea;
                    viewChildren[i].setLayout({ area: area });
                }
                if (overLeafDepth) {
                    viewChildren.length && node.setLayout({ isLeafRoot: true }, true);
                    viewChildren.length = 0;
                }
                node.viewChildren = viewChildren;
                node.setLayout({ dataExtent: info.dataExtent }, true);
                return viewChildren;
            }
            function filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {
                if (!orderBy) {
                    return sum;
                }
                var visibleMin = nodeModel.get('visibleMin');
                var len = orderedChildren.length;
                var deletePoint = len;
                for (var i = len - 1; i >= 0; i--) {
                    var value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue();
                    if (value / sum * totalArea < visibleMin) {
                        deletePoint = i;
                        sum -= value;
                    }
                }
                orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint);
                return sum;
            }
            function sort(viewChildren, orderBy) {
                if (orderBy) {
                    viewChildren.sort(function (a, b) {
                        return orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue();
                    });
                }
                return viewChildren;
            }
            function statistic(nodeModel, children, orderBy) {
                var sum = 0;
                for (var i = 0, len = children.length; i < len; i++) {
                    sum += children[i].getValue();
                }
                var dimension = nodeModel.get('visualDimension');
                var dataExtent;
                if (!children || !children.length) {
                    dataExtent = [
                        NaN,
                        NaN
                    ];
                } else if (dimension === 'value' && orderBy) {
                    dataExtent = [
                        children[children.length - 1].getValue(),
                        children[0].getValue()
                    ];
                    orderBy === 'asc' && dataExtent.reverse();
                } else {
                    var dataExtent = [
                        Infinity,
                        -Infinity
                    ];
                    zrUtil.each(children, function (child) {
                        var value = child.getValue(dimension);
                        value < dataExtent[0] && (dataExtent[0] = value);
                        value > dataExtent[1] && (dataExtent[1] = value);
                    });
                }
                return {
                    sum: sum,
                    dataExtent: dataExtent
                };
            }
            function worst(row, rowFixedLength, ratio) {
                var areaMax = 0;
                var areaMin = Infinity;
                for (var i = 0, area, len = row.length; i < len; i++) {
                    area = row[i].getLayout().area;
                    if (area) {
                        area < areaMin && (areaMin = area);
                        area > areaMax && (areaMax = area);
                    }
                }
                var squareArea = row.area * row.area;
                var f = rowFixedLength * rowFixedLength * ratio;
                return squareArea ? mathMax(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity;
            }
            function position(row, rowFixedLength, rect, halfGapWidth, flush) {
                var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
                var idx1WhenH = 1 - idx0WhenH;
                var xy = [
                    'x',
                    'y'
                ];
                var wh = [
                    'width',
                    'height'
                ];
                var last = rect[xy[idx0WhenH]];
                var rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0;
                if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
                    rowOtherLength = rect[wh[idx1WhenH]];
                }
                for (var i = 0, rowLen = row.length; i < rowLen; i++) {
                    var node = row[i];
                    var nodeLayout = {};
                    var step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0;
                    var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0);
                    var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
                    var modWH = i === rowLen - 1 || remain < step ? remain : step;
                    var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);
                    nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);
                    nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);
                    last += modWH;
                    node.setLayout(nodeLayout, true);
                }
                rect[xy[idx1WhenH]] += rowOtherLength;
                rect[wh[idx1WhenH]] -= rowOtherLength;
            }
            function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
                var currNode = (targetInfo || {}).node;
                var defaultSize = [
                    containerWidth,
                    containerHeight
                ];
                if (!currNode || currNode === viewRoot) {
                    return defaultSize;
                }
                var parent;
                var viewArea = containerWidth * containerHeight;
                var area = viewArea * seriesModel.option.zoomToNodeRatio;
                while (parent = currNode.parentNode) {
                    var sum = 0;
                    var siblings = parent.children;
                    for (var i = 0, len = siblings.length; i < len; i++) {
                        sum += siblings[i].getValue();
                    }
                    var currNodeValue = currNode.getValue();
                    if (currNodeValue === 0) {
                        return defaultSize;
                    }
                    area *= sum / currNodeValue;
                    var borderWidth = parent.getModel('itemStyle.normal').get('borderWidth');
                    if (isFinite(borderWidth)) {
                        area += 4 * borderWidth * borderWidth + 4 * borderWidth * Math.pow(area, 0.5);
                    }
                    area > numberUtil.MAX_SAFE_INTEGER && (area = numberUtil.MAX_SAFE_INTEGER);
                    currNode = parent;
                }
                area < viewArea && (area = viewArea);
                var scale = Math.pow(area / viewArea, 0.5);
                return [
                    containerWidth * scale,
                    containerHeight * scale
                ];
            }
            function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
                if (rootRect) {
                    return {
                        x: rootRect.x,
                        y: rootRect.y
                    };
                }
                var defaultPosition = {
                    x: 0,
                    y: 0
                };
                if (!targetInfo) {
                    return defaultPosition;
                }
                var targetNode = targetInfo.node;
                var layout = targetNode.getLayout();
                if (!layout) {
                    return defaultPosition;
                }
                var targetCenter = [
                    layout.width / 2,
                    layout.height / 2
                ];
                var node = targetNode;
                while (node) {
                    var nodeLayout = node.getLayout();
                    targetCenter[0] += nodeLayout.x;
                    targetCenter[1] += nodeLayout.y;
                    node = node.parentNode;
                }
                return {
                    x: layoutInfo.width / 2 - targetCenter[0],
                    y: layoutInfo.height / 2 - targetCenter[1]
                };
            }
            function prunning(node, clipRect, viewPath) {
                var nodeLayout = node.getLayout();
                node.setLayout({ invisible: nodeLayout ? !clipRect.intersect(nodeLayout) : !helper.aboveViewRootByViewPath(viewPath, node) }, true);
                var viewChildren = node.viewChildren || [];
                for (var i = 0, len = viewChildren.length; i < len; i++) {
                    var childClipRect = new BoundingRect(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height);
                    prunning(viewChildren[i], childClipRect, viewPath);
                }
            }
            module.exports = update;
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            var zrUtil = __webpack_require__(3);
            __webpack_require__(190);
            __webpack_require__(193);
            __webpack_require__(197);
            echarts.registerProcessor('filter', __webpack_require__(198));
            echarts.registerVisualCoding('chart', zrUtil.curry(__webpack_require__(103), 'graph', 'circle', null));
            echarts.registerVisualCoding('chart', __webpack_require__(199));
            echarts.registerLayout(__webpack_require__(200));
            echarts.registerLayout(__webpack_require__(202));
            echarts.registerLayout(__webpack_require__(204));
            echarts.registerCoordinateSystem('graphView', { create: __webpack_require__(206) });
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var List = __webpack_require__(94);
            var zrUtil = __webpack_require__(3);
            var createGraphFromNodeEdge = __webpack_require__(191);
            var GraphSeries = __webpack_require__(1).extendSeriesModel({
                type: 'series.graph',
                init: function (option) {
                    GraphSeries.superApply(this, 'init', arguments);
                    this.legendDataProvider = function () {
                        return this._categoriesData;
                    };
                    this._updateCategoriesData();
                },
                mergeOption: function (option) {
                    GraphSeries.superApply(this, 'mergeOption', arguments);
                    this._updateCategoriesData();
                },
                getInitialData: function (option, ecModel) {
                    var edges = option.edges || option.links;
                    var nodes = option.data || option.nodes;
                    if (nodes && edges) {
                        var graph = createGraphFromNodeEdge(nodes, edges, this, true);
                        var list = graph.data;
                        var self = this;
                        list.wrapMethod('getItemModel', function (model) {
                            var categoriesModels = self._categoriesModels;
                            var categoryIdx = model.getShallow('category');
                            var categoryModel = categoriesModels[categoryIdx];
                            if (categoryModel) {
                                categoryModel.parentModel = model.parentModel;
                                model.parentModel = categoryModel;
                            }
                            return model;
                        });
                        return list;
                    }
                },
                restoreData: function () {
                    GraphSeries.superApply(this, 'restoreData', arguments);
                    this.getGraph().restoreData();
                },
                getGraph: function () {
                    return this.getData().graph;
                },
                getEdgeData: function () {
                    return this.getGraph().edgeData;
                },
                getCategoriesData: function () {
                    return this._categoriesData;
                },
                _updateCategoriesData: function () {
                    var categories = zrUtil.map(this.option.categories || [], function (category) {
                        return category.value != null ? category : zrUtil.extend({ value: 0 }, category);
                    });
                    var categoriesData = new List(['value'], this);
                    categoriesData.initData(categories);
                    this._categoriesData = categoriesData;
                    this._categoriesModels = categoriesData.mapArray(function (idx) {
                        return categoriesData.getItemModel(idx, true);
                    });
                },
                setRoamZoom: function (zoom) {
                    var roamDetail = this.option.roamDetail;
                    roamDetail && (roamDetail.zoom = zoom);
                },
                setRoamPan: function (x, y) {
                    var roamDetail = this.option.roamDetail;
                    if (roamDetail) {
                        roamDetail.x = x;
                        roamDetail.y = y;
                    }
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    color: [
                        '#61a0a8',
                        '#d14a61',
                        '#fd9c35',
                        '#675bba',
                        '#fec42c',
                        '#dd4444',
                        '#fd9c35',
                        '#cd4870'
                    ],
                    coordinateSystem: 'view',
                    legendHoverLink: true,
                    hoverAnimation: true,
                    layout: null,
                    force: {
                        initLayout: null,
                        repulsion: 50,
                        gravity: 0.1,
                        edgeLength: 30,
                        layoutAnimation: true
                    },
                    left: 'center',
                    top: 'center',
                    symbol: 'circle',
                    symbolSize: 10,
                    draggable: false,
                    roam: false,
                    roamDetail: {
                        x: 0,
                        y: 0,
                        zoom: 1
                    },
                    nodeScaleRatio: 0.6,
                    label: {
                        normal: { show: false },
                        emphasis: { show: true }
                    },
                    itemStyle: {
                        normal: {},
                        emphasis: {}
                    },
                    lineStyle: {
                        normal: {
                            color: '#aaa',
                            width: 1,
                            curveness: 0,
                            opacity: 0.5
                        },
                        emphasis: {}
                    }
                }
            });
            module.exports = GraphSeries;
        },
        function (module, exports, __webpack_require__) {
            var List = __webpack_require__(94);
            var Graph = __webpack_require__(192);
            var linkList = __webpack_require__(180);
            var completeDimensions = __webpack_require__(96);
            var zrUtil = __webpack_require__(3);
            module.exports = function (nodes, edges, hostModel, directed) {
                var graph = new Graph(directed);
                for (var i = 0; i < nodes.length; i++) {
                    graph.addNode(zrUtil.retrieve(nodes[i].id, nodes[i].name, i), i);
                }
                var linkNameList = [];
                var validEdges = [];
                for (var i = 0; i < edges.length; i++) {
                    var link = edges[i];
                    if (graph.addEdge(link.source, link.target, i)) {
                        validEdges.push(link);
                        linkNameList.push(zrUtil.retrieve(link.id, link.source + ' - ' + link.target));
                    }
                }
                var dimensionNames = completeDimensions(['value'], nodes);
                var nodeData = new List(dimensionNames, hostModel);
                var edgeData = new List(['value'], hostModel);
                nodeData.initData(nodes);
                edgeData.initData(validEdges, linkNameList);
                graph.setEdgeData(edgeData);
                linkList.linkToGraph(nodeData, graph);
                graph.update();
                return graph;
            };
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var Graph = function (directed) {
                this._directed = directed || false;
                this.nodes = [];
                this.edges = [];
                this._nodesMap = {};
                this._edgesMap = {};
                this.data;
                this.edgeData;
            };
            var graphProto = Graph.prototype;
            graphProto.type = 'graph';
            graphProto.isDirected = function () {
                return this._directed;
            };
            graphProto.addNode = function (id, dataIndex) {
                var nodesMap = this._nodesMap;
                if (nodesMap[id]) {
                    return;
                }
                var node = new Node(id, dataIndex);
                node.hostGraph = this;
                this.nodes.push(node);
                nodesMap[id] = node;
                return node;
            };
            graphProto.getNodeByIndex = function (dataIndex) {
                var rawIdx = this.data.getRawIndex(dataIndex);
                return this.nodes[rawIdx];
            };
            graphProto.getNodeById = function (id) {
                return this._nodesMap[id];
            };
            graphProto.addEdge = function (n1, n2, dataIndex) {
                var nodesMap = this._nodesMap;
                var edgesMap = this._edgesMap;
                if (!(n1 instanceof Node)) {
                    n1 = nodesMap[n1];
                }
                if (!(n2 instanceof Node)) {
                    n2 = nodesMap[n2];
                }
                if (!n1 || !n2) {
                    return;
                }
                var key = n1.id + '-' + n2.id;
                if (edgesMap[key]) {
                    return;
                }
                var edge = new Edge(n1, n2, dataIndex);
                edge.hostGraph = this;
                if (this._directed) {
                    n1.outEdges.push(edge);
                    n2.inEdges.push(edge);
                }
                n1.edges.push(edge);
                if (n1 !== n2) {
                    n2.edges.push(edge);
                }
                this.edges.push(edge);
                edgesMap[key] = edge;
                return edge;
            };
            graphProto.getEdgeByIndex = function (dataIndex) {
                var rawIdx = this.edgeData.getRawIndex(dataIndex);
                return this.edges[rawIdx];
            };
            graphProto.getEdge = function (n1, n2) {
                if (n1 instanceof Node) {
                    n1 = n1.id;
                }
                if (n2 instanceof Node) {
                    n2 = n2.id;
                }
                var edgesMap = this._edgesMap;
                if (this._directed) {
                    return edgesMap[n1 + '-' + n2];
                } else {
                    return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1];
                }
            };
            graphProto.eachNode = function (cb, context) {
                var nodes = this.nodes;
                var len = nodes.length;
                for (var i = 0; i < len; i++) {
                    if (nodes[i].dataIndex >= 0) {
                        cb.call(context, nodes[i], i);
                    }
                }
            };
            graphProto.eachEdge = function (cb, context) {
                var edges = this.edges;
                var len = edges.length;
                for (var i = 0; i < len; i++) {
                    if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
                        cb.call(context, edges[i], i);
                    }
                }
            };
            graphProto.breadthFirstTraverse = function (cb, startNode, direction, context) {
                if (!(startNode instanceof Node)) {
                    startNode = this._nodesMap[startNode];
                }
                if (!startNode) {
                    return;
                }
                var edgeType = direction === 'out' ? 'outEdges' : direction === 'in' ? 'inEdges' : 'edges';
                for (var i = 0; i < this.nodes.length; i++) {
                    this.nodes[i].__visited = false;
                }
                if (cb.call(context, startNode, null)) {
                    return;
                }
                var queue = [startNode];
                while (queue.length) {
                    var currentNode = queue.shift();
                    var edges = currentNode[edgeType];
                    for (var i = 0; i < edges.length; i++) {
                        var e = edges[i];
                        var otherNode = e.node1 === currentNode ? e.node2 : e.node1;
                        if (!otherNode.__visited) {
                            if (cb.call(otherNode, otherNode, currentNode)) {
                                return;
                            }
                            queue.push(otherNode);
                            otherNode.__visited = true;
                        }
                    }
                }
            };
            graphProto.update = function () {
                var data = this.data;
                var edgeData = this.edgeData;
                var nodes = this.nodes;
                var edges = this.edges;
                for (var i = 0, len = nodes.length; i < len; i++) {
                    nodes[i].dataIndex = -1;
                }
                for (var i = 0, len = data.count(); i < len; i++) {
                    nodes[data.getRawIndex(i)].dataIndex = i;
                }
                edgeData.filterSelf(function (idx) {
                    var edge = edges[edgeData.getRawIndex(idx)];
                    return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
                });
                for (var i = 0, len = edges.length; i < len; i++) {
                    edges[i].dataIndex = -1;
                }
                for (var i = 0, len = edgeData.count(); i < len; i++) {
                    edges[edgeData.getRawIndex(i)].dataIndex = i;
                }
            };
            graphProto.setEdgeData = function (edgeData) {
                this.edgeData = edgeData;
                this._edgeDataSaved = edgeData.cloneShallow();
            };
            graphProto.restoreData = function () {
                this.edgeData = this._edgeDataSaved.cloneShallow();
            };
            graphProto.clone = function () {
                var graph = new Graph(this._directed);
                var nodes = this.nodes;
                var edges = this.edges;
                for (var i = 0; i < nodes.length; i++) {
                    graph.addNode(nodes[i].id, nodes[i].dataIndex);
                }
                for (var i = 0; i < edges.length; i++) {
                    var e = edges[i];
                    graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);
                }
                return graph;
            };
            function Node(id, dataIndex) {
                this.id = id == null ? '' : id;
                this.inEdges = [];
                this.outEdges = [];
                this.edges = [];
                this.hostGraph;
                this.dataIndex = dataIndex == null ? -1 : dataIndex;
            }
            Node.prototype = {
                constructor: Node,
                degree: function () {
                    return this.edges.length;
                },
                inDegree: function () {
                    return this.inEdges.length;
                },
                outDegree: function () {
                    return this.outEdges.length;
                },
                getModel: function (path) {
                    if (this.dataIndex < 0) {
                        return;
                    }
                    var graph = this.hostGraph;
                    var itemModel = graph.data.getItemModel(this.dataIndex);
                    return itemModel.getModel(path);
                }
            };
            function Edge(n1, n2, dataIndex) {
                this.node1 = n1;
                this.node2 = n2;
                this.dataIndex = dataIndex == null ? -1 : dataIndex;
            }
            Edge.prototype.getModel = function (path) {
                if (this.dataIndex < 0) {
                    return;
                }
                var graph = this.hostGraph;
                var itemModel = graph.edgeData.getItemModel(this.dataIndex);
                return itemModel.getModel(path);
            };
            var createGraphDataProxyMixin = function (hostName, dataName) {
                return {
                    getValue: function (dimension) {
                        var data = this[hostName][dataName];
                        return data.get(data.getDimension(dimension || 'value'), this.dataIndex);
                    },
                    setVisual: function (key, value) {
                        this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
                    },
                    getVisual: function (key, ignoreParent) {
                        return this[hostName][dataName].getItemVisual(this.dataIndex, key, ignoreParent);
                    },
                    setLayout: function (layout, merge) {
                        this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);
                    },
                    getLayout: function () {
                        return this[hostName][dataName].getItemLayout(this.dataIndex);
                    },
                    getGraphicEl: function () {
                        return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
                    },
                    getRawIndex: function () {
                        return this[hostName][dataName].getRawIndex(this.dataIndex);
                    }
                };
            };
            zrUtil.mixin(Node, createGraphDataProxyMixin('hostGraph', 'data'));
            zrUtil.mixin(Edge, createGraphDataProxyMixin('hostGraph', 'edgeData'));
            Graph.Node = Node;
            Graph.Edge = Edge;
            module.exports = Graph;
        },
        function (module, exports, __webpack_require__) {
            var SymbolDraw = __webpack_require__(98);
            var LineDraw = __webpack_require__(194);
            var RoamController = __webpack_require__(159);
            var modelUtil = __webpack_require__(5);
            var graphic = __webpack_require__(42);
            __webpack_require__(1).extendChartView({
                type: 'graph',
                init: function (ecModel, api) {
                    var symbolDraw = new SymbolDraw();
                    var lineDraw = new LineDraw();
                    var group = this.group;
                    var controller = new RoamController(api.getZr(), group);
                    group.add(symbolDraw.group);
                    group.add(lineDraw.group);
                    this._symbolDraw = symbolDraw;
                    this._lineDraw = lineDraw;
                    this._controller = controller;
                    this._firstRender = true;
                },
                render: function (seriesModel, ecModel, api) {
                    var coordSys = seriesModel.coordinateSystem;
                    if (coordSys.type !== 'geo' && coordSys.type !== 'view') {
                        return;
                    }
                    var data = seriesModel.getData();
                    this._model = seriesModel;
                    var symbolDraw = this._symbolDraw;
                    var lineDraw = this._lineDraw;
                    symbolDraw.updateData(data);
                    var edgeData = data.graph.edgeData;
                    var rawOption = seriesModel.option;
                    var formatModel = modelUtil.createDataFormatModel(seriesModel, edgeData, rawOption.edges || rawOption.links);
                    formatModel.formatTooltip = function (dataIndex) {
                        var params = this.getDataParams(dataIndex);
                        var edge = data.graph.getEdgeByIndex(dataIndex);
                        var sourceName = data.getName(edge.node1.dataIndex);
                        var targetName = data.getName(edge.node2.dataIndex);
                        var html = sourceName + ' > ' + targetName;
                        if (params.value) {
                            html += ' : ' + params.value;
                        }
                        return html;
                    };
                    lineDraw.updateData(edgeData, null, null);
                    edgeData.eachItemGraphicEl(function (el) {
                        el.traverse(function (child) {
                            child.dataModel = formatModel;
                        });
                    });
                    var group = this.group;
                    var groupNewProp = {
                        position: coordSys.position,
                        scale: coordSys.scale
                    };
                    if (this._firstRender) {
                        group.attr(groupNewProp);
                    } else {
                        graphic.updateProps(group, groupNewProp, seriesModel);
                    }
                    this._nodeScaleRatio = seriesModel.get('nodeScaleRatio');
                    this._updateNodeAndLinkScale();
                    this._updateController(seriesModel, coordSys, api);
                    clearTimeout(this._layoutTimeout);
                    var forceLayout = seriesModel.forceLayout;
                    var layoutAnimation = seriesModel.get('force.layoutAnimation');
                    if (forceLayout) {
                        this._startForceLayoutIteration(forceLayout, layoutAnimation);
                    }
                    data.eachItemGraphicEl(function (el, idx) {
                        var draggable = data.getItemModel(idx).get('draggable');
                        if (draggable && forceLayout) {
                            el.on('drag', function () {
                                forceLayout.warmUp();
                                !this._layouting && this._startForceLayoutIteration(forceLayout, layoutAnimation);
                                forceLayout.setFixed(idx);
                                data.setItemLayout(idx, el.position);
                            }, this).on('dragend', function () {
                                forceLayout.setUnfixed(idx);
                            }, this);
                        } else {
                            el.off('drag');
                        }
                        el.setDraggable(draggable);
                    }, this);
                    this._firstRender = false;
                },
                _startForceLayoutIteration: function (forceLayout, layoutAnimation) {
                    var self = this;
                    (function step() {
                        forceLayout.step(function (stopped) {
                            self.updateLayout();
                            (self._layouting = !stopped) && (layoutAnimation ? self._layoutTimeout = setTimeout(step, 16) : step());
                        });
                    }());
                },
                _updateController: function (seriesModel, coordSys, api) {
                    var controller = this._controller;
                    controller.rect = coordSys.getViewRect();
                    controller.enable(seriesModel.get('roam'));
                    controller.off('pan').off('zoom').on('pan', function (dx, dy) {
                        api.dispatchAction({
                            seriesId: seriesModel.id,
                            type: 'graphRoam',
                            dx: dx,
                            dy: dy
                        });
                    }).on('zoom', function (zoom, mouseX, mouseY) {
                        api.dispatchAction({
                            seriesId: seriesModel.id,
                            type: 'graphRoam',
                            zoom: zoom,
                            originX: mouseX,
                            originY: mouseY
                        });
                    }).on('zoom', this._updateNodeAndLinkScale, this);
                },
                _updateNodeAndLinkScale: function () {
                    var seriesModel = this._model;
                    var data = seriesModel.getData();
                    var group = this.group;
                    var nodeScaleRatio = this._nodeScaleRatio;
                    var groupScale = group.scale[0];
                    var nodeScale = (groupScale - 1) * nodeScaleRatio + 1;
                    var invScale = [
                        nodeScale / groupScale,
                        nodeScale / groupScale
                    ];
                    data.eachItemGraphicEl(function (el, idx) {
                        el.attr('scale', invScale);
                    });
                },
                updateLayout: function (seriesModel, ecModel) {
                    this._symbolDraw.updateLayout();
                    this._lineDraw.updateLayout();
                },
                remove: function (ecModel, api) {
                    this._symbolDraw && this._symbolDraw.remove();
                    this._lineDraw && this._lineDraw.remove();
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var LineGroup = __webpack_require__(195);
            function LineDraw(ctor) {
                this._ctor = ctor || LineGroup;
                this.group = new graphic.Group();
            }
            var lineDrawProto = LineDraw.prototype;
            lineDrawProto.updateData = function (lineData, fromData, toData) {
                var oldLineData = this._lineData;
                var group = this.group;
                var LineCtor = this._ctor;
                lineData.diff(oldLineData).add(function (idx) {
                    var lineGroup = new LineCtor(lineData, fromData, toData, idx);
                    lineData.setItemGraphicEl(idx, lineGroup);
                    group.add(lineGroup);
                }).update(function (newIdx, oldIdx) {
                    var lineGroup = oldLineData.getItemGraphicEl(oldIdx);
                    lineGroup.updateData(lineData, fromData, toData, newIdx);
                    lineData.setItemGraphicEl(newIdx, lineGroup);
                    group.add(lineGroup);
                }).remove(function (idx) {
                    group.remove(oldLineData.getItemGraphicEl(idx));
                }).execute();
                this._lineData = lineData;
                this._fromData = fromData;
                this._toData = toData;
            };
            lineDrawProto.updateLayout = function () {
                var lineData = this._lineData;
                lineData.eachItemGraphicEl(function (el, idx) {
                    el.updateLayout(lineData, this._fromData, this._toData, idx);
                }, this);
            };
            lineDrawProto.remove = function () {
                this.group.removeAll();
            };
            module.exports = LineDraw;
        },
        function (module, exports, __webpack_require__) {
            var symbolUtil = __webpack_require__(100);
            var vector = __webpack_require__(16);
            var LinePath = __webpack_require__(196);
            var graphic = __webpack_require__(42);
            var zrUtil = __webpack_require__(3);
            var numberUtil = __webpack_require__(7);
            function createSymbol(name, data, idx) {
                var color = data.getItemVisual(idx, 'color');
                var symbolType = data.getItemVisual(idx, 'symbol');
                var symbolSize = data.getItemVisual(idx, 'symbolSize');
                if (symbolType === 'none') {
                    return;
                }
                if (!zrUtil.isArray(symbolSize)) {
                    symbolSize = [
                        symbolSize,
                        symbolSize
                    ];
                }
                var symbolPath = symbolUtil.createSymbol(symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2, symbolSize[0], symbolSize[1], color);
                symbolPath.name = name;
                return symbolPath;
            }
            function createLine(points) {
                var line = new LinePath({
                    name: 'line',
                    style: { strokeNoScale: true }
                });
                setLinePoints(line.shape, points);
                return line;
            }
            function setLinePoints(targetShape, points) {
                var p1 = points[0];
                var p2 = points[1];
                var cp1 = points[2];
                targetShape.x1 = p1[0];
                targetShape.y1 = p1[1];
                targetShape.x2 = p2[0];
                targetShape.y2 = p2[1];
                targetShape.percent = 1;
                if (cp1) {
                    targetShape.cpx1 = cp1[0];
                    targetShape.cpy1 = cp1[1];
                }
            }
            function isSymbolArrow(symbol) {
                return symbol.type === 'symbol' && symbol.shape.symbolType === 'arrow';
            }
            function updateSymbolBeforeLineUpdate() {
                var lineGroup = this;
                var line = lineGroup.childOfName('line');
                if (!this.__dirty && !line.__dirty) {
                    return;
                }
                var symbolFrom = lineGroup.childOfName('fromSymbol');
                var symbolTo = lineGroup.childOfName('toSymbol');
                var label = lineGroup.childOfName('label');
                var fromPos = line.pointAt(0);
                var toPos = line.pointAt(line.shape.percent);
                var d = vector.sub([], toPos, fromPos);
                vector.normalize(d, d);
                if (symbolFrom) {
                    symbolFrom.attr('position', fromPos);
                    if (isSymbolArrow(symbolFrom)) {
                        symbolFrom.attr('rotation', tangentRotation(toPos, fromPos));
                    }
                }
                if (symbolTo) {
                    symbolTo.attr('position', toPos);
                    if (isSymbolArrow(symbolTo)) {
                        symbolTo.attr('rotation', tangentRotation(fromPos, toPos));
                    }
                }
                label.attr('position', toPos);
                var textPosition;
                var textAlign;
                var textVerticalAlign;
                if (label.__position === 'end') {
                    textPosition = [
                        d[0] * 5 + toPos[0],
                        d[1] * 5 + toPos[1]
                    ];
                    textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center';
                    textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle';
                } else {
                    textPosition = [
                        -d[0] * 5 + fromPos[0],
                        -d[1] * 5 + fromPos[1]
                    ];
                    textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center';
                    textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle';
                }
                label.attr({
                    style: {
                        textVerticalAlign: label.__verticalAlign || textVerticalAlign,
                        textAlign: label.__textAlign || textAlign
                    },
                    position: textPosition
                });
            }
            function tangentRotation(p1, p2) {
                return -Math.PI / 2 - Math.atan2(p2[1] - p1[1], p2[0] - p1[0]);
            }
            function Line(lineData, fromData, toData, idx) {
                graphic.Group.call(this);
                this._createLine(lineData, fromData, toData, idx);
            }
            var lineProto = Line.prototype;
            lineProto.beforeUpdate = updateSymbolBeforeLineUpdate;
            lineProto._createLine = function (lineData, fromData, toData, idx) {
                var seriesModel = lineData.hostModel;
                var linePoints = lineData.getItemLayout(idx);
                var line = createLine(linePoints);
                line.shape.percent = 0;
                graphic.initProps(line, { shape: { percent: 1 } }, seriesModel);
                this.add(line);
                var label = new graphic.Text({ name: 'label' });
                this.add(label);
                if (fromData) {
                    var symbolFrom = createSymbol('fromSymbol', fromData, idx);
                    this.add(symbolFrom);
                    this._fromSymbolType = fromData.getItemVisual(idx, 'symbol');
                }
                if (toData) {
                    var symbolTo = createSymbol('toSymbol', toData, idx);
                    this.add(symbolTo);
                    this._toSymbolType = toData.getItemVisual(idx, 'symbol');
                }
                this._updateCommonStl(lineData, fromData, toData, idx);
            };
            lineProto.updateData = function (lineData, fromData, toData, idx) {
                var seriesModel = lineData.hostModel;
                var line = this.childOfName('line');
                var linePoints = lineData.getItemLayout(idx);
                var target = { shape: {} };
                setLinePoints(target.shape, linePoints);
                graphic.updateProps(line, target, seriesModel);
                if (fromData) {
                    var fromSymbolType = fromData.getItemVisual(idx, 'symbol');
                    if (this._fromSymbolType !== fromSymbolType) {
                        var symbolFrom = createSymbol('fromSymbol', fromData, idx);
                        this.remove(this.childOfName('fromSymbol'));
                        this.add(symbolFrom);
                    }
                    this._fromSymbolType = fromSymbolType;
                }
                if (toData) {
                    var toSymbolType = toData.getItemVisual(idx, 'symbol');
                    if (toSymbolType !== this._toSymbolType) {
                        var symbolTo = createSymbol('toSymbol', toData, idx);
                        this.remove(this.childOfName('toSymbol'));
                        this.add(symbolTo);
                    }
                    this._toSymbolType = toSymbolType;
                }
                this._updateCommonStl(lineData, fromData, toData, idx);
            };
            lineProto._updateCommonStl = function (lineData, fromData, toData, idx) {
                var seriesModel = lineData.hostModel;
                var line = this.childOfName('line');
                var itemModel = lineData.getItemModel(idx);
                var labelModel = itemModel.getModel('label.normal');
                var textStyleModel = labelModel.getModel('textStyle');
                var labelHoverModel = itemModel.getModel('label.emphasis');
                var textStyleHoverModel = labelHoverModel.getModel('textStyle');
                var defaultText = numberUtil.round(seriesModel.getRawValue(idx));
                if (isNaN(defaultText)) {
                    defaultText = lineData.getName(idx);
                }
                line.setStyle(zrUtil.extend({ stroke: lineData.getItemVisual(idx, 'color') }, itemModel.getModel('lineStyle.normal').getLineStyle()));
                var label = this.childOfName('label');
                label.setStyle({
                    text: labelModel.get('show') ? zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'normal'), defaultText) : '',
                    textFont: textStyleModel.getFont(),
                    fill: textStyleModel.getTextColor() || lineData.getItemVisual(idx, 'color')
                });
                label.hoverStyle = {
                    text: labelHoverModel.get('show') ? zrUtil.retrieve(seriesModel.getFormattedLabel(idx, 'emphasis'), defaultText) : '',
                    textFont: textStyleHoverModel.getFont(),
                    fill: textStyleHoverModel.getTextColor()
                };
                label.__textAlign = textStyleModel.get('align');
                label.__verticalAlign = textStyleModel.get('baseline');
                label.__position = labelModel.get('position');
                graphic.setHoverStyle(this, itemModel.getModel('lineStyle.emphasis').getLineStyle());
            };
            lineProto.updateLayout = function (lineData, fromData, toData, idx) {
                var points = lineData.getItemLayout(idx);
                var linePath = this.childOfName('line');
                setLinePoints(linePath.shape, points);
                linePath.dirty(true);
            };
            zrUtil.inherits(Line, graphic.Group);
            module.exports = Line;
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var straightLineProto = graphic.Line.prototype;
            var bezierCurveProto = graphic.BezierCurve.prototype;
            module.exports = graphic.extendShape({
                type: 'ec-line',
                style: {
                    stroke: '#000',
                    fill: null
                },
                shape: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                    percent: 1,
                    cpx1: null,
                    cpy1: null
                },
                buildPath: function (ctx, shape) {
                    (shape.cpx1 == null || shape.cpy1 == null ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);
                },
                pointAt: function (t) {
                    var shape = this.shape;
                    return shape.cpx1 == null || shape.cpy1 == null ? straightLineProto.pointAt.call(this, t) : bezierCurveProto.pointAt.call(this, t);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            var roamHelper = __webpack_require__(162);
            var actionInfo = {
                type: 'graphRoam',
                event: 'graphRoam',
                update: 'none'
            };
            echarts.registerAction(actionInfo, function (payload, ecModel) {
                ecModel.eachComponent({
                    mainType: 'series',
                    query: payload
                }, function (seriesModel) {
                    var coordSys = seriesModel.coordinateSystem;
                    var roamDetailModel = seriesModel.getModel('roamDetail');
                    var res = roamHelper.calcPanAndZoom(roamDetailModel, payload);
                    seriesModel.setRoamPan && seriesModel.setRoamPan(res.x, res.y);
                    seriesModel.setRoamZoom && seriesModel.setRoamZoom(res.zoom);
                    coordSys && coordSys.setPan(res.x, res.y);
                    coordSys && coordSys.setZoom(res.zoom);
                });
            });
        },
        function (module, exports) {
            module.exports = function (ecModel) {
                var legendModels = ecModel.findComponents({ mainType: 'legend' });
                if (!legendModels || !legendModels.length) {
                    return;
                }
                ecModel.eachSeriesByType('graph', function (graphSeries) {
                    var categoriesData = graphSeries.getCategoriesData();
                    var graph = graphSeries.getGraph();
                    var data = graph.data;
                    var categoryNames = categoriesData.mapArray(categoriesData.getName);
                    data.filterSelf(function (idx) {
                        var model = data.getItemModel(idx);
                        var category = model.getShallow('category');
                        if (category != null) {
                            if (typeof category === 'number') {
                                category = categoryNames[category];
                            }
                            for (var i = 0; i < legendModels.length; i++) {
                                if (!legendModels[i].isSelected(category)) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    });
                }, this);
            };
        },
        function (module, exports) {
            module.exports = function (ecModel) {
                ecModel.eachSeriesByType('graph', function (seriesModel) {
                    var colorList = seriesModel.get('color');
                    var categoriesData = seriesModel.getCategoriesData();
                    var data = seriesModel.getData();
                    var categoryNameIdxMap = {};
                    categoriesData.each(function (idx) {
                        categoryNameIdxMap[categoriesData.getName(idx)] = idx;
                        var itemModel = categoriesData.getItemModel(idx);
                        var rawIdx = categoriesData.getRawIndex(idx);
                        var color = itemModel.get('itemStyle.normal.color') || colorList[rawIdx % colorList.length];
                        categoriesData.setItemVisual(idx, 'color', color);
                    });
                    if (categoriesData.count()) {
                        data.each(function (idx) {
                            var model = data.getItemModel(idx);
                            var category = model.getShallow('category');
                            if (category != null) {
                                if (typeof category === 'string') {
                                    category = categoryNameIdxMap[category];
                                }
                                data.setItemVisual(idx, 'color', categoriesData.getItemVisual(category, 'color'));
                            }
                        });
                    }
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var simpleLayoutHelper = __webpack_require__(201);
            module.exports = function (ecModel, api) {
                ecModel.eachSeriesByType('graph', function (seriesModel) {
                    var layout = seriesModel.get('layout');
                    if (!layout || layout === 'none') {
                        simpleLayoutHelper(seriesModel);
                    }
                });
            };
        },
        function (module, exports) {
            module.exports = function (seriesModel) {
                var coordSys = seriesModel.coordinateSystem;
                if (coordSys && coordSys.type !== 'view') {
                    return;
                }
                var graph = seriesModel.getGraph();
                graph.eachNode(function (node) {
                    var model = node.getModel();
                    node.setLayout([
                        +model.get('x'),
                        +model.get('y')
                    ]);
                });
                graph.eachEdge(function (edge) {
                    var curveness = edge.getModel().get('lineStyle.normal.curveness') || 0;
                    var p1 = edge.node1.getLayout();
                    var p2 = edge.node2.getLayout();
                    var cp1;
                    if (curveness > 0) {
                        cp1 = [
                            (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness,
                            (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness
                        ];
                    }
                    edge.setLayout([
                        p1,
                        p2,
                        cp1
                    ]);
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var circularLayoutHelper = __webpack_require__(203);
            module.exports = function (ecModel, api) {
                ecModel.eachSeriesByType('graph', function (seriesModel) {
                    if (seriesModel.get('layout') === 'circular') {
                        circularLayoutHelper(seriesModel);
                    }
                });
            };
        },
        function (module, exports) {
            module.exports = function (seriesModel) {
                var coordSys = seriesModel.coordinateSystem;
                if (coordSys && coordSys.type !== 'view') {
                    return;
                }
                var rect = coordSys.getBoundingRect();
                var nodeData = seriesModel.getData();
                var graph = nodeData.graph;
                var angle = 0;
                var sum = nodeData.getSum('value');
                var unitAngle = Math.PI * 2 / (sum || nodeData.count());
                var cx = rect.width / 2 + rect.x;
                var cy = rect.height / 2 + rect.y;
                var r = Math.min(rect.width, rect.height) / 2;
                graph.eachNode(function (node) {
                    var value = node.getValue('value');
                    angle += unitAngle * (sum ? value : 2) / 2;
                    node.setLayout([
                        r * Math.cos(angle) + cx,
                        r * Math.sin(angle) + cy
                    ]);
                    angle += unitAngle * (sum ? value : 2) / 2;
                });
                graph.eachEdge(function (edge) {
                    var curveness = edge.getModel().get('lineStyle.normal.curveness') || 0;
                    var p1 = edge.node1.getLayout();
                    var p2 = edge.node2.getLayout();
                    var cp1;
                    if (curveness > 0) {
                        cp1 = [
                            cx,
                            cy
                        ];
                    }
                    edge.setLayout([
                        p1,
                        p2,
                        cp1
                    ]);
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var forceHelper = __webpack_require__(205);
            var numberUtil = __webpack_require__(7);
            var simpleLayoutHelper = __webpack_require__(201);
            var circularLayoutHelper = __webpack_require__(203);
            var vec2 = __webpack_require__(16);
            module.exports = function (ecModel, api) {
                ecModel.eachSeriesByType('graph', function (graphSeries) {
                    if (graphSeries.get('layout') === 'force') {
                        var preservedPoints = graphSeries.preservedPoints || {};
                        var graph = graphSeries.getGraph();
                        var nodeData = graph.data;
                        var edgeData = graph.edgeData;
                        var forceModel = graphSeries.getModel('force');
                        var initLayout = forceModel.get('initLayout');
                        if (graphSeries.preservedPoints) {
                            nodeData.each(function (idx) {
                                var id = nodeData.getId(idx);
                                nodeData.setItemLayout(idx, preservedPoints[id] || [
                                    NaN,
                                    NaN
                                ]);
                            });
                        } else if (!initLayout || initLayout === 'none') {
                            simpleLayoutHelper(graphSeries);
                        } else if (initLayout === 'circular') {
                            circularLayoutHelper(graphSeries);
                        }
                        var nodeDataExtent = nodeData.getDataExtent('value');
                        var repulsion = forceModel.get('repulsion');
                        var edgeLength = forceModel.get('edgeLength');
                        var nodes = nodeData.mapArray('value', function (value, idx) {
                            var point = nodeData.getItemLayout(idx);
                            var rep = numberUtil.linearMap(value, nodeDataExtent, [
                                0,
                                repulsion
                            ]) || repulsion / 2;
                            return {
                                w: rep,
                                rep: rep,
                                p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
                            };
                        });
                        var edges = edgeData.mapArray('value', function (value, idx) {
                            var edge = graph.getEdgeByIndex(idx);
                            return {
                                n1: nodes[edge.node1.dataIndex],
                                n2: nodes[edge.node2.dataIndex],
                                d: edgeLength,
                                curveness: edge.getModel().get('lineStyle.normal.curveness') || 0
                            };
                        });
                        var coordSys = graphSeries.coordinateSystem;
                        var rect = coordSys.getBoundingRect();
                        var forceInstance = forceHelper(nodes, edges, {
                            rect: rect,
                            gravity: forceModel.get('gravity')
                        });
                        var oldStep = forceInstance.step;
                        forceInstance.step = function (cb) {
                            for (var i = 0, l = nodes.length; i < l; i++) {
                                if (nodes[i].fixed) {
                                    vec2.copy(nodes[i].p, graph.getNodeByIndex(i).getLayout());
                                }
                            }
                            oldStep(function (nodes, edges, stopped) {
                                for (var i = 0, l = nodes.length; i < l; i++) {
                                    if (!nodes[i].fixed) {
                                        graph.getNodeByIndex(i).setLayout(nodes[i].p);
                                    }
                                    preservedPoints[nodeData.getId(i)] = nodes[i].p;
                                }
                                for (var i = 0, l = edges.length; i < l; i++) {
                                    var e = edges[i];
                                    var p1 = e.n1.p;
                                    var p2 = e.n2.p;
                                    var points = [
                                        p1,
                                        p2
                                    ];
                                    if (e.curveness > 0) {
                                        points.push([
                                            (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness,
                                            (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness
                                        ]);
                                    }
                                    graph.getEdgeByIndex(i).setLayout(points);
                                }
                                cb && cb(stopped);
                            });
                        };
                        graphSeries.forceLayout = forceInstance;
                        graphSeries.preservedPoints = preservedPoints;
                        forceInstance.step();
                    } else {
                        graphSeries.forceLayout = null;
                    }
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var vec2 = __webpack_require__(16);
            var scaleAndAdd = vec2.scaleAndAdd;
            module.exports = function (nodes, edges, opts) {
                var rect = opts.rect;
                var width = rect.width;
                var height = rect.height;
                var center = [
                    rect.x + width / 2,
                    rect.y + height / 2
                ];
                var gravity = opts.gravity == null ? 0.1 : opts.gravity;
                for (var i = 0; i < nodes.length; i++) {
                    var n = nodes[i];
                    if (!n.p) {
                        n.p = vec2.create(width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1]);
                    }
                    n.pp = vec2.clone(n.p);
                    n.edges = null;
                }
                var friction = 0.6;
                return {
                    warmUp: function () {
                        friction = 0.5;
                    },
                    setFixed: function (idx) {
                        nodes[idx].fixed = true;
                    },
                    setUnfixed: function (idx) {
                        nodes[idx].fixed = false;
                    },
                    step: function (cb) {
                        var v12 = [];
                        var nLen = nodes.length;
                        for (var i = 0; i < edges.length; i++) {
                            var e = edges[i];
                            var n1 = e.n1;
                            var n2 = e.n2;
                            vec2.sub(v12, n2.p, n1.p);
                            var d = vec2.len(v12) - e.d;
                            var w = n2.w / (n1.w + n2.w);
                            vec2.normalize(v12, v12);
                            !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
                            !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
                        }
                        for (var i = 0; i < nLen; i++) {
                            var n = nodes[i];
                            if (!n.fixed) {
                                vec2.sub(v12, center, n.p);
                                vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);
                            }
                        }
                        for (var i = 0; i < nLen; i++) {
                            var n1 = nodes[i];
                            for (var j = i + 1; j < nLen; j++) {
                                var n2 = nodes[j];
                                vec2.sub(v12, n2.p, n1.p);
                                var d = vec2.len(v12);
                                if (d === 0) {
                                    vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);
                                    d = 1;
                                }
                                var repFact = (n1.rep + n2.rep) / d / d;
                                !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
                                !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
                            }
                        }
                        var v = [];
                        for (var i = 0; i < nLen; i++) {
                            var n = nodes[i];
                            if (!n.fixed) {
                                vec2.sub(v, n.p, n.pp);
                                vec2.scaleAndAdd(n.p, n.p, v, friction);
                                vec2.copy(n.pp, n.p);
                            }
                        }
                        friction = friction * 0.992;
                        cb && cb(nodes, edges, friction < 0.01);
                    }
                };
            };
        },
        function (module, exports, __webpack_require__) {
            var View = __webpack_require__(169);
            var layout = __webpack_require__(21);
            var bbox = __webpack_require__(50);
            function getViewRect(seriesModel, api, aspect) {
                var option = seriesModel.getBoxLayoutParams();
                option.aspect = aspect;
                return layout.getLayoutRect(option, {
                    width: api.getWidth(),
                    height: api.getHeight()
                });
            }
            module.exports = function (ecModel, api) {
                var viewList = [];
                ecModel.eachSeriesByType('graph', function (seriesModel) {
                    var coordSysType = seriesModel.get('coordinateSystem');
                    if (!coordSysType || coordSysType === 'view') {
                        var viewCoordSys = new View();
                        viewList.push(viewCoordSys);
                        var data = seriesModel.getData();
                        var positions = data.mapArray(function (idx) {
                            var itemModel = data.getItemModel(idx);
                            return [
                                +itemModel.get('x'),
                                +itemModel.get('y')
                            ];
                        });
                        var min = [];
                        var max = [];
                        bbox.fromPoints(positions, min, max);
                        var viewRect = getViewRect(seriesModel, api, (max[0] - min[0]) / (max[1] - min[1]) || 1);
                        if (isNaN(min[0]) || isNaN(min[1])) {
                            min = [
                                viewRect.x,
                                viewRect.y
                            ];
                            max = [
                                viewRect.x + viewRect.width,
                                viewRect.y + viewRect.height
                            ];
                        }
                        var bbWidth = max[0] - min[0];
                        var bbHeight = max[1] - min[1];
                        var viewWidth = viewRect.width;
                        var viewHeight = viewRect.height;
                        viewCoordSys = seriesModel.coordinateSystem = new View();
                        viewCoordSys.setBoundingRect(min[0], min[1], bbWidth, bbHeight);
                        viewCoordSys.setViewRect(viewRect.x, viewRect.y, viewWidth, viewHeight);
                        var roamDetailModel = seriesModel.getModel('roamDetail');
                        viewCoordSys.setPan(roamDetailModel.get('x') || 0, roamDetailModel.get('y') || 0);
                        viewCoordSys.setZoom(roamDetailModel.get('zoom') || 1);
                    }
                });
                return viewList;
            };
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(208);
            __webpack_require__(209);
        },
        function (module, exports, __webpack_require__) {
            var List = __webpack_require__(94);
            var SeriesModel = __webpack_require__(27);
            var zrUtil = __webpack_require__(3);
            var GaugeSeries = SeriesModel.extend({
                type: 'series.gauge',
                getInitialData: function (option, ecModel) {
                    var list = new List(['value'], this);
                    var dataOpt = option.data || [];
                    if (!zrUtil.isArray(dataOpt)) {
                        dataOpt = [dataOpt];
                    }
                    list.initData(dataOpt);
                    return list;
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    center: [
                        '50%',
                        '50%'
                    ],
                    legendHoverLink: true,
                    radius: '75%',
                    startAngle: 225,
                    endAngle: -45,
                    clockwise: true,
                    min: 0,
                    max: 100,
                    splitNumber: 10,
                    axisLine: {
                        show: true,
                        lineStyle: {
                            color: [
                                [
                                    0.2,
                                    '#91c7ae'
                                ],
                                [
                                    0.8,
                                    '#63869e'
                                ],
                                [
                                    1,
                                    '#c23531'
                                ]
                            ],
                            width: 30
                        }
                    },
                    splitLine: {
                        show: true,
                        length: 30,
                        lineStyle: {
                            color: '#eee',
                            width: 2,
                            type: 'solid'
                        }
                    },
                    axisTick: {
                        show: true,
                        splitNumber: 5,
                        length: 8,
                        lineStyle: {
                            color: '#eee',
                            width: 1,
                            type: 'solid'
                        }
                    },
                    axisLabel: {
                        show: true,
                        textStyle: { color: 'auto' }
                    },
                    pointer: {
                        show: true,
                        length: '80%',
                        width: 8
                    },
                    itemStyle: { normal: { color: 'auto' } },
                    title: {
                        show: true,
                        offsetCenter: [
                            0,
                            '-40%'
                        ],
                        textStyle: {
                            color: '#333',
                            fontSize: 15
                        }
                    },
                    detail: {
                        show: true,
                        backgroundColor: 'rgba(0,0,0,0)',
                        borderWidth: 0,
                        borderColor: '#ccc',
                        width: 100,
                        height: 40,
                        offsetCenter: [
                            0,
                            '40%'
                        ],
                        textStyle: {
                            color: 'auto',
                            fontSize: 30
                        }
                    }
                }
            });
            module.exports = GaugeSeries;
        },
        function (module, exports, __webpack_require__) {
            var PointerPath = __webpack_require__(210);
            var graphic = __webpack_require__(42);
            var numberUtil = __webpack_require__(7);
            var parsePercent = numberUtil.parsePercent;
            function parsePosition(seriesModel, api) {
                var center = seriesModel.get('center');
                var width = api.getWidth();
                var height = api.getHeight();
                var size = Math.min(width, height);
                var cx = parsePercent(center[0], api.getWidth());
                var cy = parsePercent(center[1], api.getHeight());
                var r = parsePercent(seriesModel.get('radius'), size / 2);
                return {
                    cx: cx,
                    cy: cy,
                    r: r
                };
            }
            function formatLabel(label, labelFormatter) {
                if (labelFormatter) {
                    if (typeof labelFormatter === 'string') {
                        label = labelFormatter.replace('{value}', label);
                    } else if (typeof labelFormatter === 'function') {
                        label = labelFormatter(label);
                    }
                }
                return label;
            }
            var PI2 = Math.PI * 2;
            var GaugeView = __webpack_require__(41).extend({
                type: 'gauge',
                render: function (seriesModel, ecModel, api) {
                    this.group.removeAll();
                    var colorList = seriesModel.get('axisLine.lineStyle.color');
                    var posInfo = parsePosition(seriesModel, api);
                    this._renderMain(seriesModel, ecModel, api, colorList, posInfo);
                },
                _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) {
                    var group = this.group;
                    var axisLineModel = seriesModel.getModel('axisLine');
                    var lineStyleModel = axisLineModel.getModel('lineStyle');
                    var clockwise = seriesModel.get('clockwise');
                    var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;
                    var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;
                    var angleRangeSpan = (endAngle - startAngle) % PI2;
                    var prevEndAngle = startAngle;
                    var axisLineWidth = lineStyleModel.get('width');
                    for (var i = 0; i < colorList.length; i++) {
                        var endAngle = startAngle + angleRangeSpan * colorList[i][0];
                        var sector = new graphic.Sector({
                            shape: {
                                startAngle: prevEndAngle,
                                endAngle: endAngle,
                                cx: posInfo.cx,
                                cy: posInfo.cy,
                                clockwise: clockwise,
                                r0: posInfo.r - axisLineWidth,
                                r: posInfo.r
                            },
                            silent: true
                        });
                        sector.setStyle({ fill: colorList[i][1] });
                        sector.setStyle(lineStyleModel.getLineStyle([
                            'color',
                            'borderWidth',
                            'borderColor'
                        ]));
                        group.add(sector);
                        prevEndAngle = endAngle;
                    }
                    var getColor = function (percent) {
                        if (percent <= 0) {
                            return colorList[0][1];
                        }
                        for (var i = 0; i < colorList.length; i++) {
                            if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {
                                return colorList[i][1];
                            }
                        }
                        return colorList[i - 1][1];
                    };
                    if (!clockwise) {
                        var tmp = startAngle;
                        startAngle = endAngle;
                        endAngle = tmp;
                    }
                    this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);
                    this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise);
                    this._renderTitle(seriesModel, ecModel, api, getColor, posInfo);
                    this._renderDetail(seriesModel, ecModel, api, getColor, posInfo);
                },
                _renderTicks: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
                    var group = this.group;
                    var cx = posInfo.cx;
                    var cy = posInfo.cy;
                    var r = posInfo.r;
                    var minVal = seriesModel.get('min');
                    var maxVal = seriesModel.get('max');
                    var splitLineModel = seriesModel.getModel('splitLine');
                    var tickModel = seriesModel.getModel('axisTick');
                    var labelModel = seriesModel.getModel('axisLabel');
                    var splitNumber = seriesModel.get('splitNumber');
                    var subSplitNumber = tickModel.get('splitNumber');
                    var splitLineLen = parsePercent(splitLineModel.get('length'), r);
                    var tickLen = parsePercent(tickModel.get('length'), r);
                    var angle = startAngle;
                    var step = (endAngle - startAngle) / splitNumber;
                    var subStep = step / subSplitNumber;
                    var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();
                    var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();
                    var textStyleModel = labelModel.getModel('textStyle');
                    for (var i = 0; i <= splitNumber; i++) {
                        var unitX = Math.cos(angle);
                        var unitY = Math.sin(angle);
                        if (splitLineModel.get('show')) {
                            var splitLine = new graphic.Line({
                                shape: {
                                    x1: unitX * r + cx,
                                    y1: unitY * r + cy,
                                    x2: unitX * (r - splitLineLen) + cx,
                                    y2: unitY * (r - splitLineLen) + cy
                                },
                                style: splitLineStyle,
                                silent: true
                            });
                            if (splitLineStyle.stroke === 'auto') {
                                splitLine.setStyle({ stroke: getColor(i / splitNumber) });
                            }
                            group.add(splitLine);
                        }
                        if (labelModel.get('show')) {
                            var label = formatLabel(numberUtil.round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'));
                            var text = new graphic.Text({
                                style: {
                                    text: label,
                                    x: unitX * (r - splitLineLen - 5) + cx,
                                    y: unitY * (r - splitLineLen - 5) + cy,
                                    fill: textStyleModel.getTextColor(),
                                    textFont: textStyleModel.getFont(),
                                    textVerticalAlign: unitY < -0.4 ? 'top' : unitY > 0.4 ? 'bottom' : 'middle',
                                    textAlign: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'
                                },
                                silent: true
                            });
                            if (text.style.fill === 'auto') {
                                text.setStyle({ fill: getColor(i / splitNumber) });
                            }
                            group.add(text);
                        }
                        if (tickModel.get('show') && i !== splitNumber) {
                            for (var j = 0; j <= subSplitNumber; j++) {
                                var unitX = Math.cos(angle);
                                var unitY = Math.sin(angle);
                                var tickLine = new graphic.Line({
                                    shape: {
                                        x1: unitX * r + cx,
                                        y1: unitY * r + cy,
                                        x2: unitX * (r - tickLen) + cx,
                                        y2: unitY * (r - tickLen) + cy
                                    },
                                    silent: true,
                                    style: tickLineStyle
                                });
                                if (tickLineStyle.stroke === 'auto') {
                                    tickLine.setStyle({ stroke: getColor((i + j / subSplitNumber) / splitNumber) });
                                }
                                group.add(tickLine);
                                angle += subStep;
                            }
                            angle -= subStep;
                        } else {
                            angle += step;
                        }
                    }
                },
                _renderPointer: function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise) {
                    var linearMap = numberUtil.linearMap;
                    var valueExtent = [
                        +seriesModel.get('min'),
                        +seriesModel.get('max')
                    ];
                    var angleExtent = [
                        startAngle,
                        endAngle
                    ];
                    if (!clockwise) {
                        angleExtent = angleExtent.reverse();
                    }
                    var data = seriesModel.getData();
                    var oldData = this._data;
                    var group = this.group;
                    data.diff(oldData).add(function (idx) {
                        var pointer = new PointerPath({ shape: { angle: startAngle } });
                        graphic.updateProps(pointer, { shape: { angle: linearMap(data.get('value', idx), valueExtent, angleExtent) } }, seriesModel);
                        group.add(pointer);
                        data.setItemGraphicEl(idx, pointer);
                    }).update(function (newIdx, oldIdx) {
                        var pointer = oldData.getItemGraphicEl(oldIdx);
                        graphic.updateProps(pointer, { shape: { angle: linearMap(data.get('value', newIdx), valueExtent, angleExtent) } }, seriesModel);
                        group.add(pointer);
                        data.setItemGraphicEl(newIdx, pointer);
                    }).remove(function (idx) {
                        var pointer = oldData.getItemGraphicEl(idx);
                        group.remove(pointer);
                    }).execute();
                    data.eachItemGraphicEl(function (pointer, idx) {
                        var itemModel = data.getItemModel(idx);
                        var pointerModel = itemModel.getModel('pointer');
                        pointer.attr({
                            shape: {
                                x: posInfo.cx,
                                y: posInfo.cy,
                                width: parsePercent(pointerModel.get('width'), posInfo.r),
                                r: parsePercent(pointerModel.get('length'), posInfo.r)
                            },
                            style: itemModel.getModel('itemStyle.normal').getItemStyle()
                        });
                        if (pointer.style.fill === 'auto') {
                            pointer.setStyle('fill', getColor((data.get('value', idx) - valueExtent[0]) / (valueExtent[1] - valueExtent[0])));
                        }
                        graphic.setHoverStyle(pointer, itemModel.getModel('itemStyle.emphasis').getItemStyle());
                    });
                    this._data = data;
                },
                _renderTitle: function (seriesModel, ecModel, api, getColor, posInfo) {
                    var titleModel = seriesModel.getModel('title');
                    if (titleModel.get('show')) {
                        var textStyleModel = titleModel.getModel('textStyle');
                        var offsetCenter = titleModel.get('offsetCenter');
                        var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
                        var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
                        var text = new graphic.Text({
                            style: {
                                x: x,
                                y: y,
                                text: seriesModel.getData().getName(0),
                                fill: textStyleModel.getTextColor(),
                                textFont: textStyleModel.getFont(),
                                textAlign: 'center',
                                textVerticalAlign: 'middle'
                            }
                        });
                        this.group.add(text);
                    }
                },
                _renderDetail: function (seriesModel, ecModel, api, getColor, posInfo) {
                    var detailModel = seriesModel.getModel('detail');
                    var minVal = seriesModel.get('min');
                    var maxVal = seriesModel.get('max');
                    if (detailModel.get('show')) {
                        var textStyleModel = detailModel.getModel('textStyle');
                        var offsetCenter = detailModel.get('offsetCenter');
                        var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
                        var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
                        var width = parsePercent(detailModel.get('width'), posInfo.r);
                        var height = parsePercent(detailModel.get('height'), posInfo.r);
                        var value = seriesModel.getData().get('value', 0);
                        var rect = new graphic.Rect({
                            shape: {
                                x: x - width / 2,
                                y: y - height / 2,
                                width: width,
                                height: height
                            },
                            style: {
                                text: formatLabel(value, detailModel.get('formatter')),
                                fill: detailModel.get('backgroundColor'),
                                textFill: textStyleModel.getTextColor(),
                                textFont: textStyleModel.getFont()
                            }
                        });
                        if (rect.style.textFill === 'auto') {
                            rect.setStyle('textFill', getColor((value - minVal) / (maxVal - minVal)));
                        }
                        rect.setStyle(detailModel.getItemStyle(['color']));
                        this.group.add(rect);
                    }
                }
            });
            module.exports = GaugeView;
        },
        function (module, exports, __webpack_require__) {
            module.exports = __webpack_require__(44).extend({
                type: 'echartsGaugePointer',
                shape: {
                    angle: 0,
                    width: 10,
                    r: 10,
                    x: 0,
                    y: 0
                },
                buildPath: function (ctx, shape) {
                    var mathCos = Math.cos;
                    var mathSin = Math.sin;
                    var r = shape.r;
                    var width = shape.width;
                    var angle = shape.angle;
                    var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);
                    var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);
                    angle = shape.angle - Math.PI / 2;
                    ctx.moveTo(x, y);
                    ctx.lineTo(shape.x + mathCos(angle) * width, shape.y + mathSin(angle) * width);
                    ctx.lineTo(shape.x + mathCos(shape.angle) * r, shape.y + mathSin(shape.angle) * r);
                    ctx.lineTo(shape.x - mathCos(angle) * width, shape.y - mathSin(angle) * width);
                    ctx.lineTo(x, y);
                    return;
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var echarts = __webpack_require__(1);
            __webpack_require__(212);
            __webpack_require__(213);
            echarts.registerVisualCoding('chart', zrUtil.curry(__webpack_require__(137), 'funnel'));
            echarts.registerLayout(__webpack_require__(214));
            echarts.registerProcessor('filter', zrUtil.curry(__webpack_require__(140), 'funnel'));
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var List = __webpack_require__(94);
            var modelUtil = __webpack_require__(5);
            var completeDimensions = __webpack_require__(96);
            var FunnelSeries = __webpack_require__(1).extendSeriesModel({
                type: 'series.funnel',
                init: function (option) {
                    FunnelSeries.superApply(this, 'init', arguments);
                    this.legendDataProvider = function () {
                        return this._dataBeforeProcessed;
                    };
                    this._defaultLabelLine(option);
                },
                getInitialData: function (option, ecModel) {
                    var dimensions = completeDimensions(['value'], option.data);
                    var list = new List(dimensions, this);
                    list.initData(option.data);
                    return list;
                },
                _defaultLabelLine: function (option) {
                    modelUtil.defaultEmphasis(option.labelLine, ['show']);
                    var labelLineNormalOpt = option.labelLine.normal;
                    var labelLineEmphasisOpt = option.labelLine.emphasis;
                    labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.normal.show;
                    labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.label.emphasis.show;
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    legendHoverLink: true,
                    left: 80,
                    top: 60,
                    right: 80,
                    bottom: 60,
                    minSize: '0%',
                    maxSize: '100%',
                    sort: 'descending',
                    gap: 0,
                    funnelAlign: 'center',
                    label: {
                        normal: {
                            show: true,
                            position: 'outer'
                        },
                        emphasis: { show: true }
                    },
                    labelLine: {
                        normal: {
                            show: true,
                            length: 20,
                            lineStyle: {
                                width: 1,
                                type: 'solid'
                            }
                        },
                        emphasis: {}
                    },
                    itemStyle: {
                        normal: {
                            borderColor: '#fff',
                            borderWidth: 1
                        },
                        emphasis: {}
                    }
                }
            });
            module.exports = FunnelSeries;
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var zrUtil = __webpack_require__(3);
            function FunnelPiece(data, idx) {
                graphic.Group.call(this);
                var polygon = new graphic.Polygon();
                var labelLine = new graphic.Polyline();
                var text = new graphic.Text();
                this.add(polygon);
                this.add(labelLine);
                this.add(text);
                this.updateData(data, idx, true);
                function onEmphasis() {
                    labelLine.ignore = labelLine.hoverIgnore;
                    text.ignore = text.hoverIgnore;
                }
                function onNormal() {
                    labelLine.ignore = labelLine.normalIgnore;
                    text.ignore = text.normalIgnore;
                }
                this.on('emphasis', onEmphasis).on('normal', onNormal).on('mouseover', onEmphasis).on('mouseout', onNormal);
            }
            var funnelPieceProto = FunnelPiece.prototype;
            function getLabelStyle(data, idx, state, labelModel) {
                var textStyleModel = labelModel.getModel('textStyle');
                var position = labelModel.get('position');
                var isLabelInside = position === 'inside' || position === 'inner' || position === 'center';
                return {
                    fill: textStyleModel.getTextColor() || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),
                    textFont: textStyleModel.getFont(),
                    text: zrUtil.retrieve(data.hostModel.getFormattedLabel(idx, state), data.getName(idx))
                };
            }
            var opacityAccessPath = [
                'itemStyle',
                'normal',
                'opacity'
            ];
            funnelPieceProto.updateData = function (data, idx, firstCreate) {
                var polygon = this.childAt(0);
                var seriesModel = data.hostModel;
                var itemModel = data.getItemModel(idx);
                var layout = data.getItemLayout(idx);
                var opacity = data.getItemModel(idx).get(opacityAccessPath);
                opacity = opacity == null ? 1 : opacity;
                if (firstCreate) {
                    polygon.setShape({ points: layout.points });
                    polygon.setStyle({ opacity: 0 });
                    graphic.initProps(polygon, { style: { opacity: opacity } }, seriesModel);
                } else {
                    graphic.updateProps(polygon, {
                        style: { opacity: opacity },
                        shape: { points: layout.points }
                    }, seriesModel);
                }
                var itemStyleModel = itemModel.getModel('itemStyle');
                var visualColor = data.getItemVisual(idx, 'color');
                polygon.setStyle(zrUtil.defaults({ fill: visualColor }, itemStyleModel.getModel('normal').getItemStyle(['opacity'])));
                polygon.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();
                this._updateLabel(data, idx);
                graphic.setHoverStyle(this);
            };
            funnelPieceProto._updateLabel = function (data, idx) {
                var labelLine = this.childAt(1);
                var labelText = this.childAt(2);
                var seriesModel = data.hostModel;
                var itemModel = data.getItemModel(idx);
                var layout = data.getItemLayout(idx);
                var labelLayout = layout.label;
                var visualColor = data.getItemVisual(idx, 'color');
                graphic.updateProps(labelLine, { shape: { points: labelLayout.linePoints || labelLayout.linePoints } }, seriesModel);
                graphic.updateProps(labelText, {
                    style: {
                        x: labelLayout.x,
                        y: labelLayout.y
                    }
                }, seriesModel);
                labelText.attr({
                    style: {
                        textAlign: labelLayout.textAlign,
                        textVerticalAlign: labelLayout.verticalAlign,
                        textFont: labelLayout.font
                    },
                    rotation: labelLayout.rotation,
                    origin: [
                        labelLayout.x,
                        labelLayout.y
                    ],
                    z2: 10
                });
                var labelModel = itemModel.getModel('label.normal');
                var labelHoverModel = itemModel.getModel('label.emphasis');
                var labelLineModel = itemModel.getModel('labelLine.normal');
                var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');
                labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel));
                labelText.ignore = labelText.normalIgnore = !labelModel.get('show');
                labelText.hoverIgnore = !labelHoverModel.get('show');
                labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');
                labelLine.hoverIgnore = !labelLineHoverModel.get('show');
                labelLine.setStyle({ stroke: visualColor });
                labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());
                labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel);
                labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();
            };
            zrUtil.inherits(FunnelPiece, graphic.Group);
            var Funnel = __webpack_require__(41).extend({
                type: 'funnel',
                render: function (seriesModel, ecModel, api) {
                    var data = seriesModel.getData();
                    var oldData = this._data;
                    var group = this.group;
                    data.diff(oldData).add(function (idx) {
                        var funnelPiece = new FunnelPiece(data, idx);
                        data.setItemGraphicEl(idx, funnelPiece);
                        group.add(funnelPiece);
                    }).update(function (newIdx, oldIdx) {
                        var piePiece = oldData.getItemGraphicEl(oldIdx);
                        piePiece.updateData(data, newIdx);
                        group.add(piePiece);
                        data.setItemGraphicEl(newIdx, piePiece);
                    }).remove(function (idx) {
                        var piePiece = oldData.getItemGraphicEl(idx);
                        group.remove(piePiece);
                    }).execute();
                    this._data = data;
                },
                remove: function () {
                    this.group.removeAll();
                    this._data = null;
                }
            });
            module.exports = Funnel;
        },
        function (module, exports, __webpack_require__) {
            var layout = __webpack_require__(21);
            var number = __webpack_require__(7);
            var parsePercent = number.parsePercent;
            function getViewRect(seriesModel, api) {
                return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
                    width: api.getWidth(),
                    height: api.getHeight()
                });
            }
            function getSortedIndices(data, sort) {
                var valueArr = data.mapArray('value', function (val) {
                    return val;
                });
                var indices = [];
                var isAscending = sort === 'ascending';
                for (var i = 0, len = data.count(); i < len; i++) {
                    indices[i] = i;
                }
                indices.sort(function (a, b) {
                    return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
                });
                return indices;
            }
            function labelLayout(data) {
                data.each(function (idx) {
                    var itemModel = data.getItemModel(idx);
                    var labelModel = itemModel.getModel('label.normal');
                    var labelPosition = labelModel.get('position');
                    var labelLineModel = itemModel.getModel('labelLine.normal');
                    var layout = data.getItemLayout(idx);
                    var points = layout.points;
                    var isLabelInside = labelPosition === 'inner' || labelPosition === 'inside' || labelPosition === 'center';
                    var textAlign;
                    var textX;
                    var textY;
                    var linePoints;
                    if (isLabelInside) {
                        textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;
                        textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;
                        textAlign = 'center';
                        linePoints = [
                            [
                                textX,
                                textY
                            ],
                            [
                                textX,
                                textY
                            ]
                        ];
                    } else {
                        var x1;
                        var y1;
                        var x2;
                        var labelLineLen = labelLineModel.get('length');
                        if (labelPosition === 'left') {
                            x1 = (points[3][0] + points[0][0]) / 2;
                            y1 = (points[3][1] + points[0][1]) / 2;
                            x2 = x1 - labelLineLen;
                            textX = x2 - 5;
                            textAlign = 'right';
                        } else {
                            x1 = (points[1][0] + points[2][0]) / 2;
                            y1 = (points[1][1] + points[2][1]) / 2;
                            x2 = x1 + labelLineLen;
                            textX = x2 + 5;
                            textAlign = 'left';
                        }
                        var y2 = y1;
                        linePoints = [
                            [
                                x1,
                                y1
                            ],
                            [
                                x2,
                                y2
                            ]
                        ];
                        textY = y2;
                    }
                    layout.label = {
                        linePoints: linePoints,
                        x: textX,
                        y: textY,
                        verticalAlign: 'middle',
                        textAlign: textAlign,
                        inside: isLabelInside
                    };
                });
            }
            module.exports = function (ecModel, api) {
                ecModel.eachSeriesByType('funnel', function (seriesModel) {
                    var data = seriesModel.getData();
                    var sort = seriesModel.get('sort');
                    var viewRect = getViewRect(seriesModel, api);
                    var indices = getSortedIndices(data, sort);
                    var sizeExtent = [
                        parsePercent(seriesModel.get('minSize'), viewRect.width),
                        parsePercent(seriesModel.get('maxSize'), viewRect.width)
                    ];
                    var dataExtent = data.getDataExtent('value');
                    var min = seriesModel.get('min');
                    var max = seriesModel.get('max');
                    if (min == null) {
                        min = Math.min(dataExtent[0], 0);
                    }
                    if (max == null) {
                        max = dataExtent[1];
                    }
                    var funnelAlign = seriesModel.get('funnelAlign');
                    var gap = seriesModel.get('gap');
                    var itemHeight = (viewRect.height - gap * (data.count() - 1)) / data.count();
                    var y = viewRect.y;
                    var getLinePoints = function (idx, offY) {
                        var val = data.get('value', idx) || 0;
                        var itemWidth = number.linearMap(val, [
                            min,
                            max
                        ], sizeExtent, true);
                        var x0;
                        switch (funnelAlign) {
                        case 'left':
                            x0 = viewRect.x;
                            break;
                        case 'center':
                            x0 = viewRect.x + (viewRect.width - itemWidth) / 2;
                            break;
                        case 'right':
                            x0 = viewRect.x + viewRect.width - itemWidth;
                            break;
                        }
                        return [
                            [
                                x0,
                                offY
                            ],
                            [
                                x0 + itemWidth,
                                offY
                            ]
                        ];
                    };
                    if (sort === 'ascending') {
                        itemHeight = -itemHeight;
                        gap = -gap;
                        y += viewRect.height;
                        indices = indices.reverse();
                    }
                    for (var i = 0; i < indices.length; i++) {
                        var idx = indices[i];
                        var nextIdx = indices[i + 1];
                        var start = getLinePoints(idx, y);
                        var end = getLinePoints(nextIdx, y + itemHeight);
                        y += itemHeight + gap;
                        data.setItemLayout(idx, { points: start.concat(end.slice().reverse()) });
                    }
                    labelLayout(data);
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            __webpack_require__(216);
            __webpack_require__(227);
            __webpack_require__(228);
            echarts.registerVisualCoding('chart', __webpack_require__(229));
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(217);
            __webpack_require__(220);
            __webpack_require__(222);
            var echarts = __webpack_require__(1);
            echarts.extendComponentView({ type: 'parallel' });
            echarts.registerPreprocessor(__webpack_require__(226));
        },
        function (module, exports, __webpack_require__) {
            var Parallel = __webpack_require__(218);
            function create(ecModel, api) {
                var coordSysList = [];
                ecModel.eachComponent('parallel', function (parallelModel, idx) {
                    var coordSys = new Parallel(parallelModel, ecModel, api);
                    coordSys.name = 'parallel_' + idx;
                    coordSys.resize(parallelModel, api);
                    parallelModel.coordinateSystem = coordSys;
                    coordSys.model = parallelModel;
                    coordSysList.push(coordSys);
                });
                ecModel.eachSeries(function (seriesModel) {
                    if (seriesModel.get('coordinateSystem') === 'parallel') {
                        var parallelIndex = seriesModel.get('parallelIndex');
                        seriesModel.coordinateSystem = coordSysList[parallelIndex];
                    }
                });
                return coordSysList;
            }
            __webpack_require__(25).register('parallel', { create: create });
        },
        function (module, exports, __webpack_require__) {
            var layout = __webpack_require__(21);
            var axisHelper = __webpack_require__(108);
            var zrUtil = __webpack_require__(3);
            var ParallelAxis = __webpack_require__(219);
            var matrix = __webpack_require__(17);
            var vector = __webpack_require__(16);
            var each = zrUtil.each;
            var PI = Math.PI;
            function Parallel(parallelModel, ecModel, api) {
                this._axesMap = {};
                this._axesLayout = {};
                this.dimensions = parallelModel.dimensions;
                this._rect;
                this._model = parallelModel;
                this._init(parallelModel, ecModel, api);
            }
            Parallel.prototype = {
                type: 'parallel',
                constructor: Parallel,
                _init: function (parallelModel, ecModel, api) {
                    var dimensions = parallelModel.dimensions;
                    var parallelAxisIndex = parallelModel.parallelAxisIndex;
                    each(dimensions, function (dim, idx) {
                        var axisIndex = parallelAxisIndex[idx];
                        var axisModel = ecModel.getComponent('parallelAxis', axisIndex);
                        var axis = this._axesMap[dim] = new ParallelAxis(dim, axisHelper.createScaleByModel(axisModel), [
                            0,
                            0
                        ], axisModel.get('type'), axisIndex);
                        var isCategory = axis.type === 'category';
                        axis.onBand = isCategory && axisModel.get('boundaryGap');
                        axis.inverse = axisModel.get('inverse');
                        axisModel.axis = axis;
                        axis.model = axisModel;
                    }, this);
                },
                update: function (ecModel, api) {
                    this._updateAxesFromSeries(this._model, ecModel);
                },
                _updateAxesFromSeries: function (parallelModel, ecModel) {
                    ecModel.eachSeries(function (seriesModel) {
                        if (!parallelModel.contains(seriesModel, ecModel)) {
                            return;
                        }
                        var data = seriesModel.getData();
                        each(this.dimensions, function (dim) {
                            var axis = this._axesMap[dim];
                            axis.scale.unionExtent(data.getDataExtent(dim));
                            axisHelper.niceScaleExtent(axis, axis.model);
                        }, this);
                    }, this);
                },
                resize: function (parallelModel, api) {
                    this._rect = layout.getLayoutRect(parallelModel.getBoxLayoutParams(), {
                        width: api.getWidth(),
                        height: api.getHeight()
                    });
                    this._layoutAxes(parallelModel);
                },
                getRect: function () {
                    return this._rect;
                },
                _layoutAxes: function (parallelModel) {
                    var rect = this._rect;
                    var layout = parallelModel.get('layout');
                    var axes = this._axesMap;
                    var dimensions = this.dimensions;
                    var size = [
                        rect.width,
                        rect.height
                    ];
                    var sizeIdx = layout === 'horizontal' ? 0 : 1;
                    var layoutLength = size[sizeIdx];
                    var axisLength = size[1 - sizeIdx];
                    var axisExtent = [
                        0,
                        axisLength
                    ];
                    each(axes, function (axis) {
                        var idx = axis.inverse ? 1 : 0;
                        axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
                    });
                    each(dimensions, function (dim, idx) {
                        var pos = layoutLength * idx / (dimensions.length - 1);
                        var positionTable = {
                            horizontal: {
                                x: pos,
                                y: axisLength
                            },
                            vertical: {
                                x: 0,
                                y: pos
                            }
                        };
                        var rotationTable = {
                            horizontal: PI / 2,
                            vertical: 0
                        };
                        var position = [
                            positionTable[layout].x + rect.x,
                            positionTable[layout].y + rect.y
                        ];
                        var rotation = rotationTable[layout];
                        var transform = matrix.create();
                        matrix.rotate(transform, transform, rotation);
                        matrix.translate(transform, transform, position);
                        this._axesLayout[dim] = {
                            position: position,
                            rotation: rotation,
                            transform: transform,
                            tickDirection: 1,
                            labelDirection: 1
                        };
                    }, this);
                },
                getAxis: function (dim) {
                    return this._axesMap[dim];
                },
                dataToPoint: function (value, dim) {
                    return this.axisCoordToPoint(this._axesMap[dim].dataToCoord(value), dim);
                },
                eachActiveState: function (data, callback, context) {
                    var dimensions = this.dimensions;
                    var axesMap = this._axesMap;
                    var hasActiveSet = false;
                    for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
                        if (axesMap[dimensions[j]].model.getActiveState() !== 'normal') {
                            hasActiveSet = true;
                        }
                    }
                    for (var i = 0, len = data.count(); i < len; i++) {
                        var values = data.getValues(dimensions, i);
                        var activeState;
                        if (!hasActiveSet) {
                            activeState = 'normal';
                        } else {
                            activeState = 'active';
                            for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
                                var dimName = dimensions[j];
                                var state = axesMap[dimName].model.getActiveState(values[j], j);
                                if (state === 'inactive') {
                                    activeState = 'inactive';
                                    break;
                                }
                            }
                        }
                        callback.call(context, activeState, i);
                    }
                },
                axisCoordToPoint: function (coord, dim) {
                    var axisLayout = this._axesLayout[dim];
                    var point = [
                        coord,
                        0
                    ];
                    vector.applyTransform(point, point, axisLayout.transform);
                    return point;
                },
                getAxisLayout: function (dim) {
                    return zrUtil.clone(this._axesLayout[dim]);
                }
            };
            module.exports = Parallel;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var Axis = __webpack_require__(117);
            var ParallelAxis = function (dim, scale, coordExtent, axisType, axisIndex) {
                Axis.call(this, dim, scale, coordExtent);
                this.type = axisType || 'value';
                this.axisIndex = axisIndex;
            };
            ParallelAxis.prototype = {
                constructor: ParallelAxis,
                model: null
            };
            zrUtil.inherits(ParallelAxis, Axis);
            module.exports = ParallelAxis;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var Component = __webpack_require__(19);
            __webpack_require__(221);
            Component.extend({
                type: 'parallel',
                dependencies: ['parallelAxis'],
                coordinateSystem: null,
                dimensions: null,
                parallelAxisIndex: null,
                defaultOption: {
                    zlevel: 0,
                    z: 0,
                    left: 80,
                    top: 60,
                    right: 80,
                    bottom: 60,
                    layout: 'horizontal',
                    parallelAxisDefault: null
                },
                init: function () {
                    Component.prototype.init.apply(this, arguments);
                    this.mergeOption({});
                },
                mergeOption: function (newOption) {
                    var thisOption = this.option;
                    newOption && zrUtil.merge(thisOption, newOption, true);
                    this._initDimensions();
                },
                contains: function (model, ecModel) {
                    var parallelIndex = model.get('parallelIndex');
                    return parallelIndex != null && ecModel.getComponent('parallel', parallelIndex) === this;
                },
                _initDimensions: function () {
                    var dimensions = this.dimensions = [];
                    var parallelAxisIndex = this.parallelAxisIndex = [];
                    var axisModels = zrUtil.filter(this.dependentModels.parallelAxis, function (axisModel) {
                        return axisModel.get('parallelIndex') === this.componentIndex;
                    });
                    zrUtil.each(axisModels, function (axisModel) {
                        dimensions.push('dim' + axisModel.get('dim'));
                        parallelAxisIndex.push(axisModel.componentIndex);
                    });
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var ComponentModel = __webpack_require__(19);
            var zrUtil = __webpack_require__(3);
            var makeStyleMapper = __webpack_require__(11);
            var axisModelCreator = __webpack_require__(121);
            var numberUtil = __webpack_require__(7);
            var AxisModel = ComponentModel.extend({
                type: 'baseParallelAxis',
                axis: null,
                activeIntervals: [],
                getAreaSelectStyle: function () {
                    return makeStyleMapper([
                        [
                            'fill',
                            'color'
                        ],
                        [
                            'lineWidth',
                            'borderWidth'
                        ],
                        [
                            'stroke',
                            'borderColor'
                        ],
                        [
                            'width',
                            'width'
                        ],
                        [
                            'opacity',
                            'opacity'
                        ]
                    ]).call(this.getModel('areaSelectStyle'));
                },
                setActiveIntervals: function (intervals) {
                    var activeIntervals = this.activeIntervals = zrUtil.clone(intervals);
                    if (activeIntervals) {
                        for (var i = activeIntervals.length - 1; i >= 0; i--) {
                            numberUtil.asc(activeIntervals[i]);
                        }
                    }
                },
                getActiveState: function (value) {
                    var activeIntervals = this.activeIntervals;
                    if (!activeIntervals.length) {
                        return 'normal';
                    }
                    if (value == null) {
                        return 'inactive';
                    }
                    for (var i = 0, len = activeIntervals.length; i < len; i++) {
                        if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
                            return 'active';
                        }
                    }
                    return 'inactive';
                }
            });
            var defaultOption = {
                type: 'value',
                dim: null,
                parallelIndex: null,
                areaSelectStyle: {
                    width: 20,
                    borderWidth: 1,
                    borderColor: 'rgba(160,197,232)',
                    color: 'rgba(160,197,232)',
                    opacity: 0.3
                },
                z: 10
            };
            zrUtil.merge(AxisModel.prototype, __webpack_require__(123));
            function getAxisType(axisName, option) {
                return option.type || (option.data ? 'category' : 'value');
            }
            axisModelCreator('parallel', AxisModel, getAxisType, defaultOption);
            module.exports = AxisModel;
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(217);
            __webpack_require__(223);
            __webpack_require__(224);
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            var actionInfo = {
                type: 'axisAreaSelect',
                event: 'axisAreaSelected',
                update: 'updateVisual'
            };
            echarts.registerAction(actionInfo, function (payload, ecModel) {
                ecModel.eachComponent({
                    mainType: 'parallelAxis',
                    query: payload
                }, function (parallelAxisModel) {
                    parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
                });
            });
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var AxisBuilder = __webpack_require__(126);
            var SelectController = __webpack_require__(225);
            var elementList = [
                'axisLine',
                'axisLabel',
                'axisTick',
                'axisName'
            ];
            var AxisView = __webpack_require__(1).extendComponentView({
                type: 'parallelAxis',
                _selectController: null,
                render: function (axisModel, ecModel, api, payload) {
                    if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
                        return;
                    }
                    this.axisModel = axisModel;
                    this.api = api;
                    this.group.removeAll();
                    if (!axisModel.get('show')) {
                        return;
                    }
                    var coordSys = ecModel.getComponent('parallel', axisModel.get('parallelIndex')).coordinateSystem;
                    var areaSelectStyle = axisModel.getAreaSelectStyle();
                    var areaWidth = areaSelectStyle.width;
                    var axisLayout = coordSys.getAxisLayout(axisModel.axis.dim);
                    var builderOpt = zrUtil.extend({
                        strokeContainThreshold: areaWidth,
                        axisLineSilent: !(areaWidth > 0)
                    }, axisLayout);
                    var axisBuilder = new AxisBuilder(axisModel, builderOpt);
                    zrUtil.each(elementList, axisBuilder.add, axisBuilder);
                    var axisGroup = axisBuilder.getGroup();
                    this.group.add(axisGroup);
                    this._buildSelectController(axisGroup, areaSelectStyle, axisModel, api);
                },
                _buildSelectController: function (axisGroup, areaSelectStyle, axisModel, api) {
                    var axis = axisModel.axis;
                    var selectController = this._selectController;
                    if (!selectController) {
                        selectController = this._selectController = new SelectController('line', api.getZr(), areaSelectStyle);
                        selectController.on('selected', zrUtil.bind(this._onSelected, this));
                    }
                    selectController.enable(axisGroup);
                    var ranges = zrUtil.map(axisModel.activeIntervals, function (interval) {
                        return [
                            axis.dataToCoord(interval[0], true),
                            axis.dataToCoord(interval[1], true)
                        ];
                    });
                    selectController.update(ranges);
                },
                _onSelected: function (ranges) {
                    var axisModel = this.axisModel;
                    var axis = axisModel.axis;
                    var intervals = zrUtil.map(ranges, function (range) {
                        return [
                            axis.coordToData(range[0], true),
                            axis.coordToData(range[1], true)
                        ];
                    });
                    this.api.dispatchAction({
                        type: 'axisAreaSelect',
                        parallelAxisId: axisModel.id,
                        intervals: intervals
                    });
                },
                remove: function () {
                    this._selectController && this._selectController.disable();
                },
                dispose: function () {
                    if (this._selectController) {
                        this._selectController.dispose();
                        this._selectController = null;
                    }
                }
            });
            function fromAxisAreaSelect(axisModel, ecModel, payload) {
                return payload && payload.type === 'axisAreaSelect' && ecModel.findComponents({
                    mainType: 'parallelAxis',
                    query: payload
                })[0] === axisModel;
            }
            module.exports = AxisView;
        },
        function (module, exports, __webpack_require__) {
            var Eventful = __webpack_require__(32);
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var bind = zrUtil.bind;
            var each = zrUtil.each;
            var mathMin = Math.min;
            var mathMax = Math.max;
            var mathPow = Math.pow;
            var COVER_Z = 10000;
            var UNSELECT_THRESHOLD = 2;
            var EVENTS = [
                'mousedown',
                'mousemove',
                'mouseup'
            ];
            function SelectController(type, zr, opt) {
                Eventful.call(this);
                this.type = type;
                this.zr = zr;
                this.opt = zrUtil.clone(opt);
                this.group = new graphic.Group();
                this._containerRect = null;
                this._track = [];
                this._dragging;
                this._cover;
                this._disabled = true;
                this._handlers = {
                    mousedown: bind(mousedown, this),
                    mousemove: bind(mousemove, this),
                    mouseup: bind(mouseup, this)
                };
                each(EVENTS, function (eventName) {
                    this.zr.on(eventName, this._handlers[eventName]);
                }, this);
            }
            SelectController.prototype = {
                constructor: SelectController,
                enable: function (container, rect) {
                    this._disabled = false;
                    removeGroup.call(this);
                    this._containerRect = rect !== false ? rect || container.getBoundingRect() : null;
                    container.add(this.group);
                },
                update: function (ranges) {
                    renderCover.call(this, ranges && zrUtil.clone(ranges));
                },
                disable: function () {
                    this._disabled = true;
                    removeGroup.call(this);
                },
                dispose: function () {
                    this.disable();
                    each(EVENTS, function (eventName) {
                        this.zr.off(eventName, this._handlers[eventName]);
                    }, this);
                }
            };
            zrUtil.mixin(SelectController, Eventful);
            function updateZ(group) {
                group.traverse(function (el) {
                    el.z = COVER_Z;
                });
            }
            function isInContainer(x, y) {
                var localPos = this.group.transformCoordToLocal(x, y);
                return !this._containerRect || this._containerRect.contain(localPos[0], localPos[1]);
            }
            function preventDefault(e) {
                var rawE = e.event;
                rawE.preventDefault && rawE.preventDefault();
            }
            function mousedown(e) {
                if (this._disabled || e.target && e.target.draggable) {
                    return;
                }
                preventDefault(e);
                var x = e.offsetX;
                var y = e.offsetY;
                if (isInContainer.call(this, x, y)) {
                    this._dragging = true;
                    this._track = [[
                            x,
                            y
                        ]];
                }
            }
            function mousemove(e) {
                if (!this._dragging || this._disabled) {
                    return;
                }
                preventDefault(e);
                updateViewByCursor.call(this, e);
            }
            function mouseup(e) {
                if (!this._dragging || this._disabled) {
                    return;
                }
                preventDefault(e);
                updateViewByCursor.call(this, e, true);
                this._dragging = false;
                this._track = [];
            }
            function updateViewByCursor(e, isEnd) {
                var x = e.offsetX;
                var y = e.offsetY;
                if (isInContainer.call(this, x, y)) {
                    this._track.push([
                        x,
                        y
                    ]);
                    var ranges = shouldShowCover.call(this) ? coverRenderers[this.type].getRanges.call(this) : [];
                    renderCover.call(this, ranges);
                    this.trigger('selected', zrUtil.clone(ranges));
                    if (isEnd) {
                        this.trigger('selectEnd', zrUtil.clone(ranges));
                    }
                }
            }
            function shouldShowCover() {
                var track = this._track;
                if (!track.length) {
                    return false;
                }
                var p2 = track[track.length - 1];
                var p1 = track[0];
                var dx = p2[0] - p1[0];
                var dy = p2[1] - p1[1];
                var dist = mathPow(dx * dx + dy * dy, 0.5);
                return dist > UNSELECT_THRESHOLD;
            }
            function renderCover(ranges) {
                var coverRenderer = coverRenderers[this.type];
                if (ranges && ranges.length) {
                    if (!this._cover) {
                        this._cover = coverRenderer.create.call(this);
                        this.group.add(this._cover);
                    }
                    coverRenderer.update.call(this, ranges);
                } else {
                    this.group.remove(this._cover);
                    this._cover = null;
                }
                updateZ(this.group);
            }
            function removeGroup() {
                var group = this.group;
                var container = group.parent;
                if (container) {
                    container.remove(group);
                }
            }
            function createRectCover() {
                var opt = this.opt;
                return new graphic.Rect({
                    style: {
                        stroke: opt.stroke,
                        fill: opt.fill,
                        lineWidth: opt.lineWidth,
                        opacity: opt.opacity
                    }
                });
            }
            function getLocalTrack() {
                return zrUtil.map(this._track, function (point) {
                    return this.group.transformCoordToLocal(point[0], point[1]);
                }, this);
            }
            function getLocalTrackEnds() {
                var localTrack = getLocalTrack.call(this);
                var tail = localTrack.length - 1;
                tail < 0 && (tail = 0);
                return [
                    localTrack[0],
                    localTrack[tail]
                ];
            }
            var coverRenderers = {
                line: {
                    create: createRectCover,
                    getRanges: function () {
                        var ends = getLocalTrackEnds.call(this);
                        var min = mathMin(ends[0][0], ends[1][0]);
                        var max = mathMax(ends[0][0], ends[1][0]);
                        return [[
                                min,
                                max
                            ]];
                    },
                    update: function (ranges) {
                        var range = ranges[0];
                        var width = this.opt.width;
                        this._cover.setShape({
                            x: range[0],
                            y: -width / 2,
                            width: range[1] - range[0],
                            height: width
                        });
                    }
                },
                rect: {
                    create: createRectCover,
                    getRanges: function () {
                        var ends = getLocalTrackEnds.call(this);
                        var min = [
                            mathMin(ends[1][0], ends[0][0]),
                            mathMin(ends[1][1], ends[0][1])
                        ];
                        var max = [
                            mathMax(ends[1][0], ends[0][0]),
                            mathMax(ends[1][1], ends[0][1])
                        ];
                        return [[
                                [
                                    min[0],
                                    max[0]
                                ],
                                [
                                    min[1],
                                    max[1]
                                ]
                            ]];
                    },
                    update: function (ranges) {
                        var range = ranges[0];
                        this._cover.setShape({
                            x: range[0][0],
                            y: range[1][0],
                            width: range[0][1] - range[0][0],
                            height: range[1][1] - range[1][0]
                        });
                    }
                }
            };
            module.exports = SelectController;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var modelUtil = __webpack_require__(5);
            module.exports = function (option) {
                createParallelIfNeeded(option);
                mergeAxisOptionFromParallel(option);
            };
            function createParallelIfNeeded(option) {
                if (option.parallel) {
                    return;
                }
                var hasParallelSeries = false;
                zrUtil.each(option.series, function (seriesOpt) {
                    if (seriesOpt && seriesOpt.type === 'parallel') {
                        hasParallelSeries = true;
                    }
                });
                if (hasParallelSeries) {
                    option.parallel = [{}];
                }
            }
            function mergeAxisOptionFromParallel(option) {
                var axes = modelUtil.normalizeToArray(option.parallelAxis);
                zrUtil.each(axes, function (axisOption) {
                    if (!zrUtil.isObject(axisOption)) {
                        return;
                    }
                    var parallelIndex = axisOption.parallelIndex || 0;
                    var parallelOption = modelUtil.normalizeToArray(option.parallel)[parallelIndex];
                    if (parallelOption && parallelOption.parallelAxisDefault) {
                        zrUtil.merge(axisOption, parallelOption.parallelAxisDefault, false);
                    }
                });
            }
        },
        function (module, exports, __webpack_require__) {
            var List = __webpack_require__(94);
            var zrUtil = __webpack_require__(3);
            var SeriesModel = __webpack_require__(27);
            module.exports = SeriesModel.extend({
                type: 'series.parallel',
                dependencies: ['parallel'],
                getInitialData: function (option, ecModel) {
                    var parallelModel = ecModel.getComponent('parallel', this.get('parallelIndex'));
                    var dimensions = parallelModel.dimensions;
                    var parallelAxisIndices = parallelModel.parallelAxisIndex;
                    var rawData = option.data;
                    var dimensionsInfo = zrUtil.map(dimensions, function (dim, index) {
                        var axisModel = ecModel.getComponent('parallelAxis', parallelAxisIndices[index]);
                        if (axisModel.get('type') === 'category') {
                            translateCategoryValue(axisModel, dim, rawData);
                            return {
                                name: dim,
                                type: 'ordinal'
                            };
                        } else {
                            return dim;
                        }
                    });
                    var list = new List(dimensionsInfo, this);
                    list.initData(rawData);
                    return list;
                },
                getRawIndicesByActiveState: function (activeState) {
                    var coordSys = this.coordinateSystem;
                    var data = this.getData();
                    var indices = [];
                    coordSys.eachActiveState(data, function (theActiveState, dataIndex) {
                        if (activeState === theActiveState) {
                            indices.push(data.getRawIndex(dataIndex));
                        }
                    });
                    return indices;
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: 'parallel',
                    parallelIndex: 0,
                    label: {
                        normal: { show: false },
                        emphasis: { show: false }
                    },
                    inactiveOpacity: 0.05,
                    activeOpacity: 1,
                    lineStyle: {
                        normal: {
                            width: 2,
                            opacity: 0.45,
                            type: 'solid'
                        }
                    },
                    animationEasing: 'linear'
                }
            });
            function translateCategoryValue(axisModel, dim, rawData) {
                var axisData = axisModel.get('data');
                var numberDim = +dim.replace('dim', '');
                if (axisData && axisData.length) {
                    zrUtil.each(rawData, function (dataItem) {
                        if (!dataItem) {
                            return;
                        }
                        var index = zrUtil.indexOf(axisData, dataItem[numberDim]);
                        dataItem[numberDim] = index >= 0 ? index : NaN;
                    });
                }
            }
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var zrUtil = __webpack_require__(3);
            var ParallelView = __webpack_require__(41).extend({
                type: 'parallel',
                init: function () {
                    this._dataGroup = new graphic.Group();
                    this.group.add(this._dataGroup);
                    this._data;
                },
                render: function (seriesModel, ecModel, api, payload) {
                    var dataGroup = this._dataGroup;
                    var data = seriesModel.getData();
                    var oldData = this._data;
                    var coordSys = seriesModel.coordinateSystem;
                    var dimensions = coordSys.dimensions;
                    data.diff(oldData).add(add).update(update).remove(remove).execute();
                    data.eachItemGraphicEl(function (elGroup, idx) {
                        var itemModel = data.getItemModel(idx);
                        var lineStyleModel = itemModel.getModel('lineStyle.normal');
                        elGroup.eachChild(function (child) {
                            child.setStyle(zrUtil.extend(lineStyleModel.getLineStyle(), {
                                stroke: data.getItemVisual(idx, 'color'),
                                opacity: data.getItemVisual(idx, 'opacity')
                            }));
                        });
                    });
                    if (!this._data) {
                        dataGroup.setClipPath(createGridClipShape(coordSys, seriesModel, function () {
                            dataGroup.removeClipPath();
                        }));
                    }
                    this._data = data;
                    function add(newDataIndex) {
                        var values = data.getValues(dimensions, newDataIndex);
                        var elGroup = new graphic.Group();
                        dataGroup.add(elGroup);
                        eachAxisPair(values, dimensions, coordSys, function (pointPair, pairIndex) {
                            if (pointPair) {
                                elGroup.add(createEl(pointPair));
                            }
                        });
                        data.setItemGraphicEl(newDataIndex, elGroup);
                    }
                    function update(newDataIndex, oldDataIndex) {
                        var values = data.getValues(dimensions, newDataIndex);
                        var elGroup = oldData.getItemGraphicEl(oldDataIndex);
                        var newEls = [];
                        var elGroupIndex = 0;
                        eachAxisPair(values, dimensions, coordSys, function (pointPair, pairIndex) {
                            var el = elGroup.childAt(elGroupIndex++);
                            if (pointPair && !el) {
                                newEls.push(createEl(pointPair));
                            } else if (pointPair) {
                                graphic.updateProps(el, { shape: { points: pointPair } }, seriesModel);
                            }
                        });
                        for (var i = elGroup.childCount() - 1; i >= elGroupIndex; i--) {
                            elGroup.remove(elGroup.childAt(i));
                        }
                        for (var i = 0, len = newEls.length; i < len; i++) {
                            elGroup.add(newEls[i]);
                        }
                        data.setItemGraphicEl(newDataIndex, elGroup);
                    }
                    function remove(oldDataIndex) {
                        var elGroup = oldData.getItemGraphicEl(oldDataIndex);
                        dataGroup.remove(elGroup);
                    }
                },
                remove: function () {
                    this._dataGroup && this._dataGroup.removeAll();
                    this._data = null;
                }
            });
            function createGridClipShape(coordSys, seriesModel, cb) {
                var parallelModel = coordSys.model;
                var rect = coordSys.getRect();
                var rectEl = new graphic.Rect({
                    shape: {
                        x: rect.x,
                        y: rect.y,
                        width: rect.width,
                        height: rect.height
                    }
                });
                var dim = parallelModel.get('layout') === 'horizontal' ? 'width' : 'height';
                rectEl.setShape(dim, 0);
                graphic.initProps(rectEl, {
                    shape: {
                        width: rect.width,
                        height: rect.height
                    }
                }, seriesModel, cb);
                return rectEl;
            }
            function eachAxisPair(values, dimensions, coordSys, cb) {
                for (var i = 0, len = dimensions.length - 1; i < len; i++) {
                    var dimA = dimensions[i];
                    var dimB = dimensions[i + 1];
                    var valueA = values[i];
                    var valueB = values[i + 1];
                    cb(isEmptyValue(valueA, coordSys.getAxis(dimA).type) || isEmptyValue(valueB, coordSys.getAxis(dimB).type) ? null : [
                        coordSys.dataToPoint(valueA, dimA),
                        coordSys.dataToPoint(valueB, dimB)
                    ], i);
                }
            }
            function createEl(pointPair) {
                return new graphic.Polyline({
                    shape: { points: pointPair },
                    silent: true
                });
            }
            function isEmptyValue(val, axisType) {
                return axisType === 'category' ? val == null : val == null || isNaN(val);
            }
            module.exports = ParallelView;
        },
        function (module, exports) {
            module.exports = function (ecModel, payload) {
                ecModel.eachSeriesByType('parallel', function (seriesModel) {
                    var itemStyleModel = seriesModel.getModel('itemStyle.normal');
                    var globalColors = ecModel.get('color');
                    var color = itemStyleModel.get('color') || globalColors[seriesModel.seriesIndex % globalColors.length];
                    var inactiveOpacity = seriesModel.get('inactiveOpacity');
                    var activeOpacity = seriesModel.get('activeOpacity');
                    var lineStyle = seriesModel.getModel('lineStyle.normal').getLineStyle();
                    var coordSys = seriesModel.coordinateSystem;
                    var data = seriesModel.getData();
                    var opacityMap = {
                        normal: lineStyle.opacity,
                        active: activeOpacity,
                        inactive: inactiveOpacity
                    };
                    coordSys.eachActiveState(data, function (activeState, dataIndex) {
                        data.setItemVisual(dataIndex, 'opacity', opacityMap[activeState]);
                    });
                    data.setVisual('color', color);
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            __webpack_require__(231);
            __webpack_require__(232);
            echarts.registerLayout(__webpack_require__(233));
            echarts.registerVisualCoding('chart', __webpack_require__(235));
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var SeriesModel = __webpack_require__(27);
            var createGraphFromNodeEdge = __webpack_require__(191);
            module.exports = SeriesModel.extend({
                type: 'series.sankey',
                layoutInfo: null,
                getInitialData: function (option, ecModel) {
                    var links = option.edges || option.links;
                    var nodes = option.data || option.nodes;
                    if (nodes && links) {
                        var graph = createGraphFromNodeEdge(nodes, links, this, true);
                        return graph.data;
                    }
                },
                getGraph: function () {
                    return this.getData().graph;
                },
                getEdgeData: function () {
                    return this.getGraph().edgeData;
                },
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: 'view',
                    layout: null,
                    left: '5%',
                    top: '5%',
                    right: '20%',
                    bottom: '5%',
                    nodeWidth: 20,
                    nodeGap: 8,
                    layoutIterations: 32,
                    label: {
                        normal: {
                            show: true,
                            position: 'right',
                            textStyle: {
                                color: '#000',
                                fontSize: 12
                            }
                        },
                        emphasis: { show: true }
                    },
                    itemStyle: {
                        normal: {
                            borderWidth: 1,
                            borderColor: '#aaa'
                        }
                    },
                    lineStyle: {
                        normal: {
                            color: '#314656',
                            opacity: 0.2,
                            curveness: 0.5
                        },
                        emphasis: { opacity: 0.6 }
                    },
                    color: [
                        '#9e0142',
                        '#d53e4f',
                        '#f46d43',
                        '#fdae61',
                        '#fee08b',
                        '#ffffbf',
                        '#e6f598',
                        '#abdda4',
                        '#66c2a5',
                        '#3288bd',
                        '#5e4fa2'
                    ],
                    animationEasing: 'linear',
                    animationDuration: 1000
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var modelUtil = __webpack_require__(5);
            var zrUtil = __webpack_require__(3);
            var SankeyShape = graphic.extendShape({
                shape: {
                    x1: 0,
                    y1: 0,
                    x2: 0,
                    y2: 0,
                    cpx1: 0,
                    cpy1: 0,
                    cpx2: 0,
                    cpy2: 0,
                    extent: 0
                },
                buildPath: function (ctx, shape) {
                    var halfExtent = shape.extent / 2;
                    ctx.moveTo(shape.x1, shape.y1 - halfExtent);
                    ctx.bezierCurveTo(shape.cpx1, shape.cpy1 - halfExtent, shape.cpx2, shape.cpy2 - halfExtent, shape.x2, shape.y2 - halfExtent);
                    ctx.lineTo(shape.x2, shape.y2 + halfExtent);
                    ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + halfExtent, shape.cpx1, shape.cpy1 + halfExtent, shape.x1, shape.y1 + halfExtent);
                    ctx.closePath();
                }
            });
            module.exports = __webpack_require__(1).extendChartView({
                type: 'sankey',
                _model: null,
                render: function (seriesModel, ecModel, api) {
                    var graph = seriesModel.getGraph();
                    var group = this.group;
                    var layoutInfo = seriesModel.layoutInfo;
                    this._model = seriesModel;
                    group.removeAll();
                    group.position = [
                        layoutInfo.x,
                        layoutInfo.y
                    ];
                    var edgeData = graph.edgeData;
                    var rawOption = seriesModel.option;
                    var formatModel = modelUtil.createDataFormatModel(seriesModel, edgeData, rawOption.edges || rawOption.links);
                    formatModel.formatTooltip = function (dataIndex) {
                        var params = this.getDataParams(dataIndex);
                        var rawDataOpt = params.data;
                        var html = rawDataOpt.source + ' -- ' + rawDataOpt.target;
                        if (params.value) {
                            html += ':' + params.value;
                        }
                        return html;
                    };
                    graph.eachNode(function (node) {
                        var layout = node.getLayout();
                        var itemModel = node.getModel();
                        var labelModel = itemModel.getModel('label.normal');
                        var textStyleModel = labelModel.getModel('textStyle');
                        var labelHoverModel = itemModel.getModel('label.emphasis');
                        var textStyleHoverModel = labelHoverModel.getModel('textStyle');
                        var rect = new graphic.Rect({
                            shape: {
                                x: layout.x,
                                y: layout.y,
                                width: node.getLayout().dx,
                                height: node.getLayout().dy
                            },
                            style: {
                                text: labelModel.get('show') ? seriesModel.getFormattedLabel(node.dataIndex, 'normal') || node.id : '',
                                textFont: textStyleModel.getFont(),
                                textFill: textStyleModel.getTextColor(),
                                textPosition: labelModel.get('position')
                            }
                        });
                        rect.setStyle(zrUtil.defaults({ fill: node.getVisual('color') }, itemModel.getModel('itemStyle.normal').getItemStyle()));
                        graphic.setHoverStyle(rect, zrUtil.extend(node.getModel('itemStyle.emphasis'), {
                            text: labelHoverModel.get('show') ? seriesModel.getFormattedLabel(node.dataIndex, 'emphasis') || node.id : '',
                            textFont: textStyleHoverModel.getFont(),
                            textFill: textStyleHoverModel.getTextColor(),
                            textPosition: labelHoverModel.get('position')
                        }));
                        group.add(rect);
                    });
                    graph.eachEdge(function (edge) {
                        var curve = new SankeyShape();
                        curve.dataIndex = edge.dataIndex;
                        curve.dataModel = formatModel;
                        var lineStyleModel = edge.getModel('lineStyle.normal');
                        var curvature = lineStyleModel.get('curveness');
                        var n1Layout = edge.node1.getLayout();
                        var n2Layout = edge.node2.getLayout();
                        var edgeLayout = edge.getLayout();
                        curve.shape.extent = Math.max(1, edgeLayout.dy);
                        var x1 = n1Layout.x + n1Layout.dx;
                        var y1 = n1Layout.y + edgeLayout.sy + edgeLayout.dy / 2;
                        var x2 = n2Layout.x;
                        var y2 = n2Layout.y + edgeLayout.ty + edgeLayout.dy / 2;
                        var cpx1 = x1 * (1 - curvature) + x2 * curvature;
                        var cpy1 = y1;
                        var cpx2 = x1 * curvature + x2 * (1 - curvature);
                        var cpy2 = y2;
                        curve.setShape({
                            x1: x1,
                            y1: y1,
                            x2: x2,
                            y2: y2,
                            cpx1: cpx1,
                            cpy1: cpy1,
                            cpx2: cpx2,
                            cpy2: cpy2
                        });
                        curve.setStyle(lineStyleModel.getItemStyle());
                        graphic.setHoverStyle(curve, edge.getModel('lineStyle.emphasis').getItemStyle());
                        group.add(curve);
                    });
                    if (!this._data) {
                        group.setClipPath(createGridClipShape(group.getBoundingRect(), seriesModel, function () {
                            group.removeClipPath();
                        }));
                    }
                    this._data = seriesModel.getData();
                }
            });
            function createGridClipShape(rect, seriesModel, cb) {
                var rectEl = new graphic.Rect({
                    shape: {
                        x: rect.x - 10,
                        y: rect.y - 10,
                        width: 0,
                        height: rect.height + 20
                    }
                });
                graphic.initProps(rectEl, {
                    shape: {
                        width: rect.width + 20,
                        height: rect.height + 20
                    }
                }, seriesModel, cb);
                return rectEl;
            }
        },
        function (module, exports, __webpack_require__) {
            var layout = __webpack_require__(21);
            var nest = __webpack_require__(234);
            var zrUtil = __webpack_require__(3);
            module.exports = function (ecModel, api) {
                ecModel.eachSeriesByType('sankey', function (seriesModel) {
                    var nodeWidth = seriesModel.get('nodeWidth');
                    var nodeGap = seriesModel.get('nodeGap');
                    var layoutInfo = getViewRect(seriesModel, api);
                    seriesModel.layoutInfo = layoutInfo;
                    var width = layoutInfo.width;
                    var height = layoutInfo.height;
                    var graph = seriesModel.getGraph();
                    var nodes = graph.nodes;
                    var edges = graph.edges;
                    computeNodeValues(nodes);
                    var filteredNodes = nodes.filter(function (node) {
                        return node.getLayout().value === 0;
                    });
                    var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');
                    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations);
                });
            };
            function getViewRect(seriesModel, api) {
                return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {
                    width: api.getWidth(),
                    height: api.getHeight()
                });
            }
            function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations) {
                computeNodeBreadths(nodes, nodeWidth, width);
                computeNodeDepths(nodes, edges, height, nodeGap, iterations);
                computeEdgeDepths(nodes);
            }
            function computeNodeValues(nodes) {
                zrUtil.each(nodes, function (node) {
                    var value1 = sum(node.outEdges, getEdgeValue);
                    var value2 = sum(node.inEdges, getEdgeValue);
                    var value = Math.max(value1, value2);
                    node.setLayout({ value: value }, true);
                });
            }
            function computeNodeBreadths(nodes, nodeWidth, width) {
                var remainNodes = nodes;
                var nextNode = null;
                var x = 0;
                var kx = 0;
                while (remainNodes.length) {
                    nextNode = [];
                    for (var i = 0, len = remainNodes.length; i < len; i++) {
                        var node = remainNodes[i];
                        node.setLayout({ x: x }, true);
                        node.setLayout({ dx: nodeWidth }, true);
                        for (var j = 0, lenj = node.outEdges.length; j < lenj; j++) {
                            nextNode.push(node.outEdges[j].node2);
                        }
                    }
                    remainNodes = nextNode;
                    ++x;
                }
                moveSinksRight(nodes, x);
                kx = (width - nodeWidth) / (x - 1);
                scaleNodeBreadths(nodes, kx);
            }
            function moveSinksRight(nodes, x) {
                zrUtil.each(nodes, function (node) {
                    if (!node.outEdges.length) {
                        node.setLayout({ x: x - 1 }, true);
                    }
                });
            }
            function scaleNodeBreadths(nodes, kx) {
                zrUtil.each(nodes, function (node) {
                    var nodeX = node.getLayout().x * kx;
                    node.setLayout({ x: nodeX }, true);
                });
            }
            function computeNodeDepths(nodes, edges, height, nodeGap, iterations) {
                var nodesByBreadth = nest().key(function (d) {
                    return d.getLayout().x;
                }).sortKeys(ascending).entries(nodes).map(function (d) {
                    return d.values;
                });
                initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap);
                resolveCollisions(nodesByBreadth, nodeGap, height);
                for (var alpha = 1; iterations > 0; iterations--) {
                    alpha *= 0.99;
                    relaxRightToLeft(nodesByBreadth, alpha);
                    resolveCollisions(nodesByBreadth, nodeGap, height);
                    relaxLeftToRight(nodesByBreadth, alpha);
                    resolveCollisions(nodesByBreadth, nodeGap, height);
                }
            }
            function initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap) {
                var kyArray = [];
                zrUtil.each(nodesByBreadth, function (nodes) {
                    var n = nodes.length;
                    var sum = 0;
                    zrUtil.each(nodes, function (node) {
                        sum += node.getLayout().value;
                    });
                    var ky = (height - (n - 1) * nodeGap) / sum;
                    kyArray.push(ky);
                });
                kyArray.sort(function (a, b) {
                    return a - b;
                });
                var ky0 = kyArray[0];
                zrUtil.each(nodesByBreadth, function (nodes) {
                    zrUtil.each(nodes, function (node, i) {
                        node.setLayout({ y: i }, true);
                        var nodeDy = node.getLayout().value * ky0;
                        node.setLayout({ dy: nodeDy }, true);
                    });
                });
                zrUtil.each(edges, function (edge) {
                    var edgeDy = +edge.getValue() * ky0;
                    edge.setLayout({ dy: edgeDy }, true);
                });
            }
            function resolveCollisions(nodesByBreadth, nodeGap, height) {
                zrUtil.each(nodesByBreadth, function (nodes) {
                    var node;
                    var dy;
                    var y0 = 0;
                    var n = nodes.length;
                    var i;
                    nodes.sort(ascendingDepth);
                    for (i = 0; i < n; i++) {
                        node = nodes[i];
                        dy = y0 - node.getLayout().y;
                        if (dy > 0) {
                            var nodeY = node.getLayout().y + dy;
                            node.setLayout({ y: nodeY }, true);
                        }
                        y0 = node.getLayout().y + node.getLayout().dy + nodeGap;
                    }
                    dy = y0 - nodeGap - height;
                    if (dy > 0) {
                        var nodeY = node.getLayout().y - dy;
                        node.setLayout({ y: nodeY }, true);
                        y0 = node.getLayout().y;
                        for (i = n - 2; i >= 0; --i) {
                            node = nodes[i];
                            dy = node.getLayout().y + node.getLayout().dy + nodeGap - y0;
                            if (dy > 0) {
                                nodeY = node.getLayout().y - dy;
                                node.setLayout({ y: nodeY }, true);
                            }
                            y0 = node.getLayout().y;
                        }
                    }
                });
            }
            function relaxRightToLeft(nodesByBreadth, alpha) {
                zrUtil.each(nodesByBreadth.slice().reverse(), function (nodes) {
                    zrUtil.each(nodes, function (node) {
                        if (node.outEdges.length) {
                            var y = sum(node.outEdges, weightedTarget) / sum(node.outEdges, getEdgeValue);
                            var nodeY = node.getLayout().y + (y - center(node)) * alpha;
                            node.setLayout({ y: nodeY }, true);
                        }
                    });
                });
            }
            function weightedTarget(edge) {
                return center(edge.node2) * edge.getValue();
            }
            function relaxLeftToRight(nodesByBreadth, alpha) {
                zrUtil.each(nodesByBreadth, function (nodes) {
                    zrUtil.each(nodes, function (node) {
                        if (node.inEdges.length) {
                            var y = sum(node.inEdges, weightedSource) / sum(node.inEdges, getEdgeValue);
                            var nodeY = node.getLayout().y + (y - center(node)) * alpha;
                            node.setLayout({ y: nodeY }, true);
                        }
                    });
                });
            }
            function weightedSource(edge) {
                return center(edge.node1) * edge.getValue();
            }
            function computeEdgeDepths(nodes) {
                zrUtil.each(nodes, function (node) {
                    node.outEdges.sort(ascendingTargetDepth);
                    node.inEdges.sort(ascendingSourceDepth);
                });
                zrUtil.each(nodes, function (node) {
                    var sy = 0;
                    var ty = 0;
                    zrUtil.each(node.outEdges, function (edge) {
                        edge.setLayout({ sy: sy }, true);
                        sy += edge.getLayout().dy;
                    });
                    zrUtil.each(node.inEdges, function (edge) {
                        edge.setLayout({ ty: ty }, true);
                        ty += edge.getLayout().dy;
                    });
                });
            }
            function ascendingTargetDepth(a, b) {
                return a.node2.getLayout().y - b.node2.getLayout().y;
            }
            function ascendingSourceDepth(a, b) {
                return a.node1.getLayout().y - b.node1.getLayout().y;
            }
            function sum(array, f) {
                var s = 0;
                var n = array.length;
                var a;
                var i = -1;
                if (arguments.length === 1) {
                    while (++i < n) {
                        a = +array[i];
                        if (!isNaN(a)) {
                            s += a;
                        }
                    }
                } else {
                    while (++i < n) {
                        a = +f.call(array, array[i], i);
                        if (!isNaN(a)) {
                            s += a;
                        }
                    }
                }
                return s;
            }
            function center(node) {
                return node.getLayout().y + node.getLayout().dy / 2;
            }
            function ascendingDepth(a, b) {
                return a.getLayout().y - b.getLayout().y;
            }
            function ascending(a, b) {
                return a < b ? -1 : a > b ? 1 : a == b ? 0 : NaN;
            }
            function getEdgeValue(edge) {
                return edge.getValue();
            }
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            function nest() {
                var keysFunction = [];
                var sortKeysFunction = [];
                function map(array, depth) {
                    if (depth >= keysFunction.length) {
                        return array;
                    }
                    var i = -1;
                    var n = array.length;
                    var keyFunction = keysFunction[depth++];
                    var mapObject = {};
                    var valuesByKey = {};
                    while (++i < n) {
                        var keyValue = keyFunction(array[i]);
                        var values = valuesByKey[keyValue];
                        if (values) {
                            values.push(array[i]);
                        } else {
                            valuesByKey[keyValue] = [array[i]];
                        }
                    }
                    zrUtil.each(valuesByKey, function (value, key) {
                        mapObject[key] = map(value, depth);
                    });
                    return mapObject;
                }
                function entriesMap(mapObject, depth) {
                    if (depth >= keysFunction.length) {
                        return mapObject;
                    }
                    var array = [];
                    var sortKeyFunction = sortKeysFunction[depth++];
                    zrUtil.each(mapObject, function (value, key) {
                        array.push({
                            key: key,
                            values: entriesMap(value, depth)
                        });
                    });
                    if (sortKeyFunction) {
                        return array.sort(function (a, b) {
                            return sortKeyFunction(a.key, b.key);
                        });
                    } else {
                        return array;
                    }
                }
                return {
                    key: function (d) {
                        keysFunction.push(d);
                        return this;
                    },
                    sortKeys: function (order) {
                        sortKeysFunction[keysFunction.length - 1] = order;
                        return this;
                    },
                    entries: function (array) {
                        return entriesMap(map(array, 0), 0);
                    }
                };
            }
            module.exports = nest;
        },
        function (module, exports, __webpack_require__) {
            var VisualMapping = __webpack_require__(187);
            module.exports = function (ecModel, payload) {
                ecModel.eachSeriesByType('sankey', function (seriesModel) {
                    var graph = seriesModel.getGraph();
                    var nodes = graph.nodes;
                    nodes.sort(function (a, b) {
                        return a.getLayout().value - b.getLayout().value;
                    });
                    var minValue = nodes[0].getLayout().value;
                    var maxValue = nodes[nodes.length - 1].getLayout().value;
                    nodes.forEach(function (node) {
                        var mapping = new VisualMapping({
                            type: 'color',
                            mappingMethod: 'linear',
                            dataExtent: [
                                minValue,
                                maxValue
                            ],
                            visual: seriesModel.get('color')
                        });
                        var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
                        node.setVisual('color', mapValueToColor);
                    });
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            __webpack_require__(237);
            __webpack_require__(240);
            echarts.registerVisualCoding('chart', __webpack_require__(241));
            echarts.registerLayout(__webpack_require__(242));
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var SeriesModel = __webpack_require__(27);
            var whiskerBoxCommon = __webpack_require__(238);
            var BoxplotSeries = SeriesModel.extend({
                type: 'series.boxplot',
                dependencies: [
                    'xAxis',
                    'yAxis',
                    'grid'
                ],
                valueDimensions: [
                    'min',
                    'Q1',
                    'median',
                    'Q3',
                    'max'
                ],
                dimensions: null,
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: 'cartesian2d',
                    legendHoverLink: true,
                    hoverAnimation: true,
                    xAxisIndex: 0,
                    yAxisIndex: 0,
                    layout: null,
                    boxWidth: [
                        7,
                        50
                    ],
                    itemStyle: {
                        normal: {
                            color: '#fff',
                            borderWidth: 1
                        },
                        emphasis: {
                            borderWidth: 2,
                            shadowBlur: 5,
                            shadowOffsetX: 2,
                            shadowOffsetY: 2,
                            shadowColor: 'rgba(0,0,0,0.4)'
                        }
                    },
                    animationEasing: 'elasticOut',
                    animationDuration: 800
                }
            });
            zrUtil.mixin(BoxplotSeries, whiskerBoxCommon.seriesModelMixin, true);
            module.exports = BoxplotSeries;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var List = __webpack_require__(94);
            var completeDimensions = __webpack_require__(96);
            var WhiskerBoxDraw = __webpack_require__(239);
            var zrUtil = __webpack_require__(3);
            function getItemValue(item) {
                return item.value == null ? item : item.value;
            }
            var seriesModelMixin = {
                _baseAxisDim: null,
                getInitialData: function (option, ecModel) {
                    var categories;
                    var xAxisModel = ecModel.getComponent('xAxis', this.get('xAxisIndex'));
                    var yAxisModel = ecModel.getComponent('yAxis', this.get('yAxisIndex'));
                    var xAxisType = xAxisModel.get('type');
                    var yAxisType = yAxisModel.get('type');
                    var addOrdinal;
                    if (xAxisType === 'category') {
                        option.layout = 'horizontal';
                        categories = xAxisModel.getCategories();
                        addOrdinal = true;
                    } else if (yAxisType === 'category') {
                        option.layout = 'vertical';
                        categories = yAxisModel.getCategories();
                        addOrdinal = true;
                    } else {
                        option.layout = option.layout || 'horizontal';
                    }
                    this._baseAxisDim = option.layout === 'horizontal' ? 'x' : 'y';
                    var data = option.data;
                    var dimensions = this.dimensions = ['base'].concat(this.valueDimensions);
                    completeDimensions(dimensions, data);
                    var list = new List(dimensions, this);
                    list.initData(data, categories ? categories.slice() : null, function (dataItem, dimName, idx, dimIdx) {
                        var value = getItemValue(dataItem);
                        return addOrdinal ? dimName === 'base' ? idx : value[dimIdx - 1] : value[dimIdx];
                    });
                    return list;
                },
                coordDimToDataDim: function (axisDim) {
                    var dims = this.valueDimensions.slice();
                    var baseDim = ['base'];
                    var map = {
                        horizontal: {
                            x: baseDim,
                            y: dims
                        },
                        vertical: {
                            x: dims,
                            y: baseDim
                        }
                    };
                    return map[this.get('layout')][axisDim];
                },
                dataDimToCoordDim: function (dataDim) {
                    var dim;
                    zrUtil.each([
                        'x',
                        'y'
                    ], function (coordDim, index) {
                        var dataDims = this.coordDimToDataDim(coordDim);
                        if (zrUtil.indexOf(dataDims, dataDim) >= 0) {
                            dim = coordDim;
                        }
                    }, this);
                    return dim;
                },
                getBaseAxis: function () {
                    var dim = this._baseAxisDim;
                    return this.ecModel.getComponent(dim + 'Axis', this.get(dim + 'AxisIndex')).axis;
                }
            };
            var viewMixin = {
                init: function () {
                    var whiskerBoxDraw = this._whiskerBoxDraw = new WhiskerBoxDraw(this.getStyleUpdater());
                    this.group.add(whiskerBoxDraw.group);
                },
                render: function (seriesModel, ecModel, api) {
                    this._whiskerBoxDraw.updateData(seriesModel.getData());
                },
                remove: function (ecModel) {
                    this._whiskerBoxDraw.remove();
                }
            };
            module.exports = {
                seriesModelMixin: seriesModelMixin,
                viewMixin: viewMixin
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var Path = __webpack_require__(44);
            var WhiskerPath = Path.extend({
                type: 'whiskerInBox',
                shape: {},
                buildPath: function (ctx, shape) {
                    for (var i in shape) {
                        if (i.indexOf('ends') === 0) {
                            var pts = shape[i];
                            ctx.moveTo(pts[0][0], pts[0][1]);
                            ctx.lineTo(pts[1][0], pts[1][1]);
                        }
                    }
                }
            });
            function WhiskerBox(data, idx, styleUpdater, isInit) {
                graphic.Group.call(this);
                this.bodyIndex;
                this.whiskerIndex;
                this.styleUpdater = styleUpdater;
                this._createContent(data, idx, isInit);
                this.updateData(data, idx, isInit);
                this._seriesModel;
            }
            var whiskerBoxProto = WhiskerBox.prototype;
            whiskerBoxProto._createContent = function (data, idx, isInit) {
                var itemLayout = data.getItemLayout(idx);
                var constDim = itemLayout.chartLayout === 'horizontal' ? 1 : 0;
                var count = 0;
                this.add(new graphic.Polygon({
                    shape: { points: isInit ? transInit(itemLayout.bodyEnds, constDim, itemLayout) : itemLayout.bodyEnds },
                    style: { strokeNoScale: true },
                    z2: 100
                }));
                this.bodyIndex = count++;
                var whiskerEnds = zrUtil.map(itemLayout.whiskerEnds, function (ends) {
                    return isInit ? transInit(ends, constDim, itemLayout) : ends;
                });
                this.add(new WhiskerPath({
                    shape: makeWhiskerEndsShape(whiskerEnds),
                    style: { strokeNoScale: true },
                    z2: 100
                }));
                this.whiskerIndex = count++;
            };
            function transInit(points, dim, itemLayout) {
                return zrUtil.map(points, function (point) {
                    point = point.slice();
                    point[dim] = itemLayout.initBaseline;
                    return point;
                });
            }
            function makeWhiskerEndsShape(whiskerEnds) {
                var shape = {};
                zrUtil.each(whiskerEnds, function (ends, i) {
                    shape['ends' + i] = ends;
                });
                return shape;
            }
            whiskerBoxProto.updateData = function (data, idx, isInit) {
                var seriesModel = this._seriesModel = data.hostModel;
                var itemLayout = data.getItemLayout(idx);
                var updateMethod = graphic[isInit ? 'initProps' : 'updateProps'];
                updateMethod(this.childAt(this.bodyIndex), { shape: { points: itemLayout.bodyEnds } }, seriesModel);
                updateMethod(this.childAt(this.whiskerIndex), { shape: makeWhiskerEndsShape(itemLayout.whiskerEnds) }, seriesModel);
                this.styleUpdater.call(null, this, data, idx);
            };
            zrUtil.inherits(WhiskerBox, graphic.Group);
            function WhiskerBoxDraw(styleUpdater) {
                this.group = new graphic.Group();
                this.styleUpdater = styleUpdater;
            }
            var whiskerBoxDrawProto = WhiskerBoxDraw.prototype;
            whiskerBoxDrawProto.updateData = function (data) {
                var group = this.group;
                var oldData = this._data;
                var styleUpdater = this.styleUpdater;
                data.diff(oldData).add(function (newIdx) {
                    if (data.hasValue(newIdx)) {
                        var symbolEl = new WhiskerBox(data, newIdx, styleUpdater, true);
                        data.setItemGraphicEl(newIdx, symbolEl);
                        group.add(symbolEl);
                    }
                }).update(function (newIdx, oldIdx) {
                    var symbolEl = oldData.getItemGraphicEl(oldIdx);
                    if (!data.hasValue(newIdx)) {
                        group.remove(symbolEl);
                        return;
                    }
                    if (!symbolEl) {
                        symbolEl = new WhiskerBox(data, newIdx, styleUpdater);
                    } else {
                        symbolEl.updateData(data, newIdx);
                    }
                    group.add(symbolEl);
                    data.setItemGraphicEl(newIdx, symbolEl);
                }).remove(function (oldIdx) {
                    var el = oldData.getItemGraphicEl(oldIdx);
                    el && group.remove(el);
                }).execute();
                this._data = data;
            };
            whiskerBoxDrawProto.remove = function () {
                var group = this.group;
                var data = this._data;
                this._data = null;
                data && data.eachItemGraphicEl(function (el) {
                    el && group.remove(el);
                });
            };
            module.exports = WhiskerBoxDraw;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var ChartView = __webpack_require__(41);
            var graphic = __webpack_require__(42);
            var whiskerBoxCommon = __webpack_require__(238);
            var BoxplotView = ChartView.extend({
                type: 'boxplot',
                getStyleUpdater: function () {
                    return updateStyle;
                }
            });
            zrUtil.mixin(BoxplotView, whiskerBoxCommon.viewMixin, true);
            var normalStyleAccessPath = [
                'itemStyle',
                'normal'
            ];
            var emphasisStyleAccessPath = [
                'itemStyle',
                'emphasis'
            ];
            function updateStyle(itemGroup, data, idx) {
                var itemModel = data.getItemModel(idx);
                var normalItemStyleModel = itemModel.getModel(normalStyleAccessPath);
                var borderColor = data.getItemVisual(idx, 'color');
                var itemStyle = normalItemStyleModel.getItemStyle(['borderColor']);
                var whiskerEl = itemGroup.childAt(itemGroup.whiskerIndex);
                whiskerEl.style.set(itemStyle);
                whiskerEl.style.stroke = borderColor;
                whiskerEl.dirty();
                var bodyEl = itemGroup.childAt(itemGroup.bodyIndex);
                bodyEl.style.set(itemStyle);
                bodyEl.style.stroke = borderColor;
                bodyEl.dirty();
                var hoverStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
                graphic.setHoverStyle(itemGroup, hoverStyle);
            }
            module.exports = BoxplotView;
        },
        function (module, exports) {
            var borderColorQuery = [
                'itemStyle',
                'normal',
                'borderColor'
            ];
            module.exports = function (ecModel, api) {
                var globalColors = ecModel.get('color');
                ecModel.eachRawSeriesByType('boxplot', function (seriesModel) {
                    var defaulColor = globalColors[seriesModel.seriesIndex % globalColors.length];
                    var data = seriesModel.getData();
                    data.setVisual({
                        legendSymbol: 'roundRect',
                        color: seriesModel.get(borderColorQuery) || defaulColor
                    });
                    if (!ecModel.isSeriesFiltered(seriesModel)) {
                        data.each(function (idx) {
                            var itemModel = data.getItemModel(idx);
                            data.setItemVisual(idx, { color: itemModel.get(borderColorQuery, true) });
                        });
                    }
                });
            };
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var numberUtil = __webpack_require__(7);
            var parsePercent = numberUtil.parsePercent;
            var each = zrUtil.each;
            module.exports = function (ecModel, api) {
                var groupResult = groupSeriesByAxis(ecModel);
                each(groupResult, function (groupItem) {
                    var seriesModels = groupItem.seriesModels;
                    if (!seriesModels.length) {
                        return;
                    }
                    calculateBase(groupItem);
                    each(seriesModels, function (seriesModel, idx) {
                        layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx]);
                    });
                });
            };
            function groupSeriesByAxis(ecModel) {
                var result = [];
                var axisList = [];
                ecModel.eachSeriesByType('boxplot', function (seriesModel) {
                    var baseAxis = seriesModel.getBaseAxis();
                    var idx = zrUtil.indexOf(axisList, baseAxis);
                    if (idx < 0) {
                        idx = axisList.length;
                        axisList[idx] = baseAxis;
                        result[idx] = {
                            axis: baseAxis,
                            seriesModels: []
                        };
                    }
                    result[idx].seriesModels.push(seriesModel);
                });
                return result;
            }
            function calculateBase(groupItem) {
                var extent;
                var baseAxis = groupItem.axis;
                var seriesModels = groupItem.seriesModels;
                var seriesCount = seriesModels.length;
                var boxWidthList = groupItem.boxWidthList = [];
                var boxOffsetList = groupItem.boxOffsetList = [];
                var boundList = [];
                var bandWidth;
                if (baseAxis.type === 'category') {
                    bandWidth = baseAxis.getBandWidth();
                } else {
                    var maxDataCount = 0;
                    each(seriesModels, function (seriesModel) {
                        maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());
                    });
                    extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / maxDataCount;
                }
                each(seriesModels, function (seriesModel) {
                    var boxWidthBound = seriesModel.get('boxWidth');
                    if (!zrUtil.isArray(boxWidthBound)) {
                        boxWidthBound = [
                            boxWidthBound,
                            boxWidthBound
                        ];
                    }
                    boundList.push([
                        parsePercent(boxWidthBound[0], bandWidth) || 0,
                        parsePercent(boxWidthBound[1], bandWidth) || 0
                    ]);
                });
                var availableWidth = bandWidth * 0.8 - 2;
                var boxGap = availableWidth / seriesCount * 0.3;
                var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
                var base = boxWidth / 2 - availableWidth / 2;
                each(seriesModels, function (seriesModel, idx) {
                    boxOffsetList.push(base);
                    base += boxGap + boxWidth;
                    boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]));
                });
            }
            function layoutSingleSeries(seriesModel, offset, boxWidth) {
                var coordSys = seriesModel.coordinateSystem;
                var data = seriesModel.getData();
                var dimensions = seriesModel.dimensions;
                var chartLayout = seriesModel.get('layout');
                var halfWidth = boxWidth / 2;
                data.each(dimensions, function () {
                    var args = arguments;
                    var dimLen = dimensions.length;
                    var axisDimVal = args[0];
                    var idx = args[dimLen];
                    var variableDim = chartLayout === 'horizontal' ? 0 : 1;
                    var constDim = 1 - variableDim;
                    var median = getPoint(args[3]);
                    var end1 = getPoint(args[1]);
                    var end5 = getPoint(args[5]);
                    var whiskerEnds = [
                        [
                            end1,
                            getPoint(args[2])
                        ],
                        [
                            end5,
                            getPoint(args[4])
                        ]
                    ];
                    layEndLine(end1);
                    layEndLine(end5);
                    layEndLine(median);
                    var bodyEnds = [];
                    addBodyEnd(whiskerEnds[0][1], 0);
                    addBodyEnd(whiskerEnds[1][1], 1);
                    data.setItemLayout(idx, {
                        chartLayout: chartLayout,
                        initBaseline: median[constDim],
                        median: median,
                        bodyEnds: bodyEnds,
                        whiskerEnds: whiskerEnds
                    });
                    function getPoint(val) {
                        var p = [];
                        p[variableDim] = axisDimVal;
                        p[constDim] = val;
                        var point;
                        if (isNaN(axisDimVal) || isNaN(val)) {
                            point = [
                                NaN,
                                NaN
                            ];
                        } else {
                            point = coordSys.dataToPoint(p);
                            point[variableDim] += offset;
                        }
                        return point;
                    }
                    function addBodyEnd(point, start) {
                        var point1 = point.slice();
                        var point2 = point.slice();
                        point1[variableDim] += halfWidth;
                        point2[variableDim] -= halfWidth;
                        start ? bodyEnds.push(point1, point2) : bodyEnds.push(point2, point1);
                    }
                    function layEndLine(endCenter) {
                        var line = [
                            endCenter.slice(),
                            endCenter.slice()
                        ];
                        line[0][variableDim] -= halfWidth;
                        line[1][variableDim] += halfWidth;
                        whiskerEnds.push(line);
                    }
                });
            }
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            __webpack_require__(244);
            __webpack_require__(245);
            echarts.registerPreprocessor(__webpack_require__(246));
            echarts.registerVisualCoding('chart', __webpack_require__(247));
            echarts.registerLayout(__webpack_require__(248));
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var SeriesModel = __webpack_require__(27);
            var whiskerBoxCommon = __webpack_require__(238);
            var formatUtil = __webpack_require__(6);
            var encodeHTML = formatUtil.encodeHTML;
            var addCommas = formatUtil.addCommas;
            var CandlestickSeries = SeriesModel.extend({
                type: 'series.candlestick',
                dependencies: [
                    'xAxis',
                    'yAxis',
                    'grid'
                ],
                valueDimensions: [
                    'open',
                    'close',
                    'lowest',
                    'highest'
                ],
                dimensions: null,
                defaultOption: {
                    zlevel: 0,
                    z: 2,
                    coordinateSystem: 'cartesian2d',
                    legendHoverLink: true,
                    hoverAnimation: true,
                    xAxisIndex: 0,
                    yAxisIndex: 0,
                    layout: null,
                    itemStyle: {
                        normal: {
                            color: '#c23531',
                            color0: '#314656',
                            borderWidth: 1,
                            borderColor: '#c23531',
                            borderColor0: '#314656'
                        },
                        emphasis: { borderWidth: 2 }
                    },
                    animationUpdate: false,
                    animationEasing: 'linear',
                    animationDuration: 300
                },
                getShadowDim: function () {
                    return 'open';
                },
                formatTooltip: function (dataIndex, mutipleSeries) {
                    var valueHTMLArr = zrUtil.map(this.valueDimensions, function (dim) {
                        return dim + ': ' + addCommas(this._data.get(dim, dataIndex));
                    }, this);
                    return encodeHTML(this.name) + '<br />' + valueHTMLArr.join('<br />');
                }
            });
            zrUtil.mixin(CandlestickSeries, whiskerBoxCommon.seriesModelMixin, true);
            module.exports = CandlestickSeries;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var ChartView = __webpack_require__(41);
            var graphic = __webpack_require__(42);
            var whiskerBoxCommon = __webpack_require__(238);
            var CandlestickView = ChartView.extend({
                type: 'candlestick',
                getStyleUpdater: function () {
                    return updateStyle;
                }
            });
            zrUtil.mixin(CandlestickView, whiskerBoxCommon.viewMixin, true);
            var normalStyleAccessPath = [
                'itemStyle',
                'normal'
            ];
            var emphasisStyleAccessPath = [
                'itemStyle',
                'emphasis'
            ];
            function updateStyle(itemGroup, data, idx) {
                var itemModel = data.getItemModel(idx);
                var normalItemStyleModel = itemModel.getModel(normalStyleAccessPath);
                var color = data.getItemVisual(idx, 'color');
                var borderColor = data.getItemVisual(idx, 'borderColor');
                var itemStyle = normalItemStyleModel.getItemStyle([
                    'color',
                    'color0',
                    'borderColor',
                    'borderColor0'
                ]);
                var whiskerEl = itemGroup.childAt(itemGroup.whiskerIndex);
                whiskerEl.style.set(itemStyle);
                whiskerEl.style.stroke = borderColor;
                whiskerEl.dirty();
                var bodyEl = itemGroup.childAt(itemGroup.bodyIndex);
                bodyEl.style.set(itemStyle);
                bodyEl.style.fill = color;
                bodyEl.style.stroke = borderColor;
                bodyEl.dirty();
                var hoverStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
                graphic.setHoverStyle(itemGroup, hoverStyle);
            }
            module.exports = CandlestickView;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            module.exports = function (option) {
                if (!option || !zrUtil.isArray(option.series)) {
                    return;
                }
                zrUtil.each(option.series, function (seriesItem) {
                    if (zrUtil.isObject(seriesItem) && seriesItem.type === 'k') {
                        seriesItem.type = 'candlestick';
                    }
                });
            };
        },
        function (module, exports) {
            var positiveBorderColorQuery = [
                'itemStyle',
                'normal',
                'borderColor'
            ];
            var negativeBorderColorQuery = [
                'itemStyle',
                'normal',
                'borderColor0'
            ];
            var positiveColorQuery = [
                'itemStyle',
                'normal',
                'color'
            ];
            var negativeColorQuery = [
                'itemStyle',
                'normal',
                'color0'
            ];
            module.exports = function (ecModel, api) {
                ecModel.eachRawSeriesByType('candlestick', function (seriesModel) {
                    var data = seriesModel.getData();
                    data.setVisual({ legendSymbol: 'roundRect' });
                    if (!ecModel.isSeriesFiltered(seriesModel)) {
                        data.each(function (idx) {
                            var itemModel = data.getItemModel(idx);
                            var sign = data.getItemLayout(idx).sign;
                            data.setItemVisual(idx, {
                                color: itemModel.get(sign > 0 ? positiveColorQuery : negativeColorQuery),
                                borderColor: itemModel.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery)
                            });
                        });
                    }
                });
            };
        },
        function (module, exports) {
            var CANDLE_MIN_WIDTH = 2;
            var CANDLE_MIN_NICE_WIDTH = 5;
            var GPA_MIN = 4;
            module.exports = function (ecModel, api) {
                ecModel.eachSeriesByType('candlestick', function (seriesModel) {
                    var coordSys = seriesModel.coordinateSystem;
                    var data = seriesModel.getData();
                    var dimensions = seriesModel.dimensions;
                    var chartLayout = seriesModel.get('layout');
                    var candleWidth = calculateCandleWidth(seriesModel, data);
                    data.each(dimensions, function () {
                        var args = arguments;
                        var dimLen = dimensions.length;
                        var axisDimVal = args[0];
                        var idx = args[dimLen];
                        var variableDim = chartLayout === 'horizontal' ? 0 : 1;
                        var constDim = 1 - variableDim;
                        var openVal = args[1];
                        var closeVal = args[2];
                        var lowestVal = args[3];
                        var highestVal = args[4];
                        var ocLow = Math.min(openVal, closeVal);
                        var ocHigh = Math.max(openVal, closeVal);
                        var ocLowPoint = getPoint(ocLow);
                        var ocHighPoint = getPoint(ocHigh);
                        var lowestPoint = getPoint(lowestVal);
                        var highestPoint = getPoint(highestVal);
                        var whiskerEnds = [
                            [
                                highestPoint,
                                ocHighPoint
                            ],
                            [
                                lowestPoint,
                                ocLowPoint
                            ]
                        ];
                        var bodyEnds = [];
                        addBodyEnd(ocHighPoint, 0);
                        addBodyEnd(ocLowPoint, 1);
                        data.setItemLayout(idx, {
                            chartLayout: chartLayout,
                            sign: openVal > closeVal ? -1 : openVal < closeVal ? 1 : 0,
                            initBaseline: openVal > closeVal ? ocHighPoint[constDim] : ocLowPoint[constDim],
                            bodyEnds: bodyEnds,
                            whiskerEnds: whiskerEnds
                        });
                        function getPoint(val) {
                            var p = [];
                            p[variableDim] = axisDimVal;
                            p[constDim] = val;
                            return isNaN(axisDimVal) || isNaN(val) ? [
                                NaN,
                                NaN
                            ] : coordSys.dataToPoint(p);
                        }
                        function addBodyEnd(point, start) {
                            var point1 = point.slice();
                            var point2 = point.slice();
                            point1[variableDim] += candleWidth / 2;
                            point2[variableDim] -= candleWidth / 2;
                            start ? bodyEnds.push(point1, point2) : bodyEnds.push(point2, point1);
                        }
                    }, true);
                });
            };
            function calculateCandleWidth(seriesModel, data) {
                var baseAxis = seriesModel.getBaseAxis();
                var extent;
                var bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count());
                return bandWidth / 2 - 2 > CANDLE_MIN_NICE_WIDTH ? bandWidth / 2 - 2 : bandWidth - CANDLE_MIN_NICE_WIDTH > GPA_MIN ? CANDLE_MIN_NICE_WIDTH : Math.max(bandWidth - GPA_MIN, CANDLE_MIN_WIDTH);
            }
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var echarts = __webpack_require__(1);
            __webpack_require__(250);
            __webpack_require__(251);
            echarts.registerVisualCoding('chart', zrUtil.curry(__webpack_require__(103), 'effectScatter', 'circle', null));
            echarts.registerLayout(zrUtil.curry(__webpack_require__(104), 'effectScatter'));
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var createListFromArray = __webpack_require__(93);
            var SeriesModel = __webpack_require__(27);
            module.exports = SeriesModel.extend({
                type: 'series.effectScatter',
                dependencies: [
                    'grid',
                    'polar'
                ],
                getInitialData: function (option, ecModel) {
                    var list = createListFromArray(option.data, this, ecModel);
                    return list;
                },
                defaultOption: {
                    coordinateSystem: 'cartesian2d',
                    zlevel: 0,
                    z: 2,
                    legendHoverLink: true,
                    effectType: 'ripple',
                    showEffectOn: 'render',
                    rippleEffect: {
                        period: 4,
                        scale: 2.5,
                        brushType: 'fill'
                    },
                    xAxisIndex: 0,
                    yAxisIndex: 0,
                    polarIndex: 0,
                    geoIndex: 0,
                    symbolSize: 10
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var SymbolDraw = __webpack_require__(98);
            var EffectSymbol = __webpack_require__(252);
            __webpack_require__(1).extendChartView({
                type: 'effectScatter',
                init: function () {
                    this._symbolDraw = new SymbolDraw(EffectSymbol);
                },
                render: function (seriesModel, ecModel, api) {
                    var data = seriesModel.getData();
                    var effectSymbolDraw = this._symbolDraw;
                    effectSymbolDraw.updateData(data);
                    this.group.add(effectSymbolDraw.group);
                },
                updateLayout: function () {
                    this._symbolDraw.updateLayout();
                },
                remove: function (ecModel, api) {
                    this._symbolDraw && this._symbolDraw.remove(api);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var symbolUtil = __webpack_require__(100);
            var graphic = __webpack_require__(42);
            var numberUtil = __webpack_require__(7);
            var Symbol = __webpack_require__(99);
            var Group = graphic.Group;
            var EFFECT_RIPPLE_NUMBER = 3;
            function normalizeSymbolSize(symbolSize) {
                if (!zrUtil.isArray(symbolSize)) {
                    symbolSize = [
                        +symbolSize,
                        +symbolSize
                    ];
                }
                return symbolSize;
            }
            function EffectSymbol(data, idx) {
                Group.call(this);
                var symbol = new Symbol(data, idx);
                var rippleGroup = new Group();
                this.add(symbol);
                this.add(rippleGroup);
                rippleGroup.beforeUpdate = function () {
                    this.attr(symbol.getScale());
                };
                this.updateData(data, idx);
            }
            var effectSymbolProto = EffectSymbol.prototype;
            effectSymbolProto.stopEffectAnimation = function () {
                this.childAt(1).removeAll();
            };
            effectSymbolProto.startEffectAnimation = function (period, brushType, rippleScale, effectOffset, z, zlevel) {
                var symbolType = this._symbolType;
                var color = this._color;
                var rippleGroup = this.childAt(1);
                for (var i = 0; i < EFFECT_RIPPLE_NUMBER; i++) {
                    var ripplePath = symbolUtil.createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
                    ripplePath.attr({
                        style: {
                            stroke: brushType === 'stroke' ? color : null,
                            fill: brushType === 'fill' ? color : null,
                            strokeNoScale: true
                        },
                        z2: 99,
                        silent: true,
                        scale: [
                            1,
                            1
                        ],
                        z: z,
                        zlevel: zlevel
                    });
                    var delay = -i / EFFECT_RIPPLE_NUMBER * period + effectOffset;
                    ripplePath.animate('', true).when(period, {
                        scale: [
                            rippleScale,
                            rippleScale
                        ]
                    }).delay(delay).start();
                    ripplePath.animateStyle(true).when(period, { opacity: 0 }).delay(delay).start();
                    rippleGroup.add(ripplePath);
                }
            };
            effectSymbolProto.highlight = function () {
                this.trigger('emphasis');
            };
            effectSymbolProto.downplay = function () {
                this.trigger('normal');
            };
            effectSymbolProto.updateData = function (data, idx) {
                var seriesModel = data.hostModel;
                this.childAt(0).updateData(data, idx);
                var rippleGroup = this.childAt(1);
                var itemModel = data.getItemModel(idx);
                var symbolType = data.getItemVisual(idx, 'symbol');
                var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
                var color = data.getItemVisual(idx, 'color');
                rippleGroup.attr('scale', symbolSize);
                rippleGroup.traverse(function (ripplePath) {
                    ripplePath.attr({ fill: color });
                });
                var symbolOffset = itemModel.getShallow('symbolOffset');
                if (symbolOffset) {
                    var pos = rippleGroup.position;
                    pos[0] = numberUtil.parsePercent(symbolOffset[0], symbolSize[0]);
                    pos[1] = numberUtil.parsePercent(symbolOffset[1], symbolSize[1]);
                }
                this._symbolType = symbolType;
                this._color = color;
                var showEffectOn = seriesModel.get('showEffectOn');
                var rippleScale = itemModel.get('rippleEffect.scale');
                var brushType = itemModel.get('rippleEffect.brushType');
                var effectPeriod = itemModel.get('rippleEffect.period') * 1000;
                var effectOffset = idx / data.count();
                var z = itemModel.getShallow('z') || 0;
                var zlevel = itemModel.getShallow('zlevel') || 0;
                this.stopEffectAnimation();
                if (showEffectOn === 'render') {
                    this.startEffectAnimation(effectPeriod, brushType, rippleScale, effectOffset, z, zlevel);
                }
                var symbol = this.childAt(0);
                function onEmphasis() {
                    symbol.trigger('emphasis');
                    if (showEffectOn !== 'render') {
                        this.startEffectAnimation(effectPeriod, brushType, rippleScale, effectOffset, z, zlevel);
                    }
                }
                function onNormal() {
                    symbol.trigger('normal');
                    if (showEffectOn !== 'render') {
                        this.stopEffectAnimation();
                    }
                }
                this.on('mouseover', onEmphasis, this).on('mouseout', onNormal, this).on('emphasis', onEmphasis, this).on('normal', onNormal, this);
            };
            effectSymbolProto.fadeOut = function (cb) {
                cb && cb();
            };
            zrUtil.inherits(EffectSymbol, Group);
            module.exports = EffectSymbol;
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(254);
            __webpack_require__(255);
            var zrUtil = __webpack_require__(3);
            var echarts = __webpack_require__(1);
            echarts.registerLayout(__webpack_require__(257));
            echarts.registerVisualCoding('chart', zrUtil.curry(__webpack_require__(88), 'lines', 'lineStyle'));
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var SeriesModel = __webpack_require__(27);
            var List = __webpack_require__(94);
            var zrUtil = __webpack_require__(3);
            var CoordinateSystem = __webpack_require__(25);
            module.exports = SeriesModel.extend({
                type: 'series.lines',
                dependencies: [
                    'grid',
                    'polar'
                ],
                getInitialData: function (option, ecModel) {
                    var fromDataArr = [];
                    var toDataArr = [];
                    var lineDataArr = [];
                    zrUtil.each(option.data, function (opt) {
                        fromDataArr.push(opt[0]);
                        toDataArr.push(opt[1]);
                        lineDataArr.push(zrUtil.extend(zrUtil.extend({}, zrUtil.isArray(opt[0]) ? null : opt[0]), zrUtil.isArray(opt[1]) ? null : opt[1]));
                    });
                    var coordSys = CoordinateSystem.get(option.coordinateSystem);
                    if (!coordSys) {
                        throw new Error('Invalid coordinate system');
                    }
                    var dimensions = coordSys.dimensions;
                    var fromData = new List(dimensions, this);
                    var toData = new List(dimensions, this);
                    var lineData = new List(['value'], this);
                    function geoCoordGetter(item, dim, dataIndex, dimIndex) {
                        return item.coord && item.coord[dimIndex];
                    }
                    fromData.initData(fromDataArr, null, geoCoordGetter);
                    toData.initData(toDataArr, null, geoCoordGetter);
                    lineData.initData(lineDataArr);
                    this.fromData = fromData;
                    this.toData = toData;
                    return lineData;
                },
                formatTooltip: function (dataIndex) {
                    var fromName = this.fromData.getName(dataIndex);
                    var toName = this.toData.getName(dataIndex);
                    return fromName + ' > ' + toName;
                },
                defaultOption: {
                    coordinateSystem: 'geo',
                    zlevel: 0,
                    z: 2,
                    legendHoverLink: true,
                    hoverAnimation: true,
                    xAxisIndex: 0,
                    yAxisIndex: 0,
                    geoIndex: 0,
                    effect: {
                        show: false,
                        period: 4,
                        symbol: 'circle',
                        symbolSize: 3,
                        trailLength: 0.2
                    },
                    large: false,
                    largeThreshold: 2000,
                    label: {
                        normal: {
                            show: false,
                            position: 'end'
                        }
                    },
                    lineStyle: { normal: { opacity: 0.5 } }
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var LineDraw = __webpack_require__(194);
            var EffectLine = __webpack_require__(256);
            var Line = __webpack_require__(195);
            __webpack_require__(1).extendChartView({
                type: 'lines',
                init: function () {
                },
                render: function (seriesModel, ecModel, api) {
                    var data = seriesModel.getData();
                    var lineDraw = this._lineDraw;
                    var hasEffect = seriesModel.get('effect.show');
                    if (hasEffect !== this._hasEffet) {
                        if (lineDraw) {
                            lineDraw.remove();
                        }
                        lineDraw = this._lineDraw = new LineDraw(hasEffect ? EffectLine : Line);
                        this._hasEffet = hasEffect;
                    }
                    var zlevel = seriesModel.get('zlevel');
                    var trailLength = seriesModel.get('effect.trailLength');
                    var zr = api.getZr();
                    zr.painter.getLayer(zlevel).clear(true);
                    if (this._lastZlevel != null) {
                        zr.configLayer(this._lastZlevel, { motionBlur: false });
                    }
                    if (hasEffect && trailLength) {
                        zr.configLayer(zlevel, {
                            motionBlur: true,
                            lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
                        });
                    }
                    this.group.add(lineDraw.group);
                    lineDraw.updateData(data);
                    this._lastZlevel = zlevel;
                },
                updateLayout: function (seriesModel, ecModel, api) {
                    this._lineDraw.updateLayout();
                    var zr = api.getZr();
                    zr.painter.getLayer(this._lastZlevel).clear(true);
                },
                remove: function (ecModel, api) {
                    this._lineDraw && this._lineDraw.remove(api, true);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var Line = __webpack_require__(195);
            var zrUtil = __webpack_require__(3);
            var symbolUtil = __webpack_require__(100);
            var curveUtil = __webpack_require__(49);
            function EffectLine(lineData, fromData, toData, idx) {
                graphic.Group.call(this);
                var line = new Line(lineData, fromData, toData, idx);
                this.add(line);
                this._updateEffectSymbol(lineData, idx);
            }
            var effectLineProto = EffectLine.prototype;
            function setAnimationPoints(symbol, points) {
                symbol.__p1 = points[0];
                symbol.__p2 = points[1];
                symbol.__cp1 = points[2] || [
                    (points[0][0] + points[1][0]) / 2,
                    (points[0][1] + points[1][1]) / 2
                ];
            }
            function updateSymbolPosition() {
                var p1 = this.__p1;
                var p2 = this.__p2;
                var cp1 = this.__cp1;
                var t = this.__t;
                var pos = this.position;
                var quadraticAt = curveUtil.quadraticAt;
                var quadraticDerivativeAt = curveUtil.quadraticDerivativeAt;
                pos[0] = quadraticAt(p1[0], cp1[0], p2[0], t);
                pos[1] = quadraticAt(p1[1], cp1[1], p2[1], t);
                var tx = quadraticDerivativeAt(p1[0], cp1[0], p2[0], t);
                var ty = quadraticDerivativeAt(p1[1], cp1[1], p2[1], t);
                this.rotation = -Math.atan2(ty, tx) - Math.PI / 2;
                this.ignore = false;
            }
            effectLineProto._updateEffectSymbol = function (lineData, idx) {
                var itemModel = lineData.getItemModel(idx);
                var effectModel = itemModel.getModel('effect');
                var size = effectModel.get('symbolSize');
                var symbolType = effectModel.get('symbol');
                if (!zrUtil.isArray(size)) {
                    size = [
                        size,
                        size
                    ];
                }
                var color = effectModel.get('color') || lineData.getItemVisual(idx, 'color');
                var symbol = this.childAt(1);
                var period = effectModel.get('period') * 1000;
                if (this._symbolType !== symbolType || period !== this._period) {
                    symbol = symbolUtil.createSymbol(symbolType, -0.5, -0.5, 1, 1, color);
                    symbol.ignore = true;
                    symbol.z2 = 100;
                    this._symbolType = symbolType;
                    this._period = period;
                    this.add(symbol);
                    symbol.__t = 0;
                    symbol.animate('', true).when(period, { __t: 1 }).delay(idx / lineData.count() * period / 2).during(zrUtil.bind(updateSymbolPosition, symbol)).start();
                }
                symbol.setStyle('shadowColor', color);
                symbol.setStyle(effectModel.getItemStyle(['color']));
                symbol.attr('scale', size);
                var points = lineData.getItemLayout(idx);
                setAnimationPoints(symbol, points);
                symbol.setColor(color);
                symbol.attr('scale', size);
            };
            effectLineProto.updateData = function (lineData, fromData, toData, idx) {
                this.childAt(0).updateData(lineData, fromData, toData, idx);
                this._updateEffectSymbol(lineData, idx);
            };
            effectLineProto.updateLayout = function (lineData, fromData, toData, idx) {
                this.childAt(0).updateLayout(lineData, fromData, toData, idx);
                var symbol = this.childAt(1);
                var points = lineData.getItemLayout(idx);
                setAnimationPoints(symbol, points);
            };
            zrUtil.inherits(EffectLine, graphic.Group);
            module.exports = EffectLine;
        },
        function (module, exports) {
            module.exports = function (ecModel) {
                ecModel.eachSeriesByType('lines', function (seriesModel) {
                    var coordSys = seriesModel.coordinateSystem;
                    var fromData = seriesModel.fromData;
                    var toData = seriesModel.toData;
                    var lineData = seriesModel.getData();
                    var dims = coordSys.dimensions;
                    fromData.each(dims, function (x, y, idx) {
                        fromData.setItemLayout(idx, coordSys.dataToPoint([
                            x,
                            y
                        ]));
                    });
                    toData.each(dims, function (x, y, idx) {
                        toData.setItemLayout(idx, coordSys.dataToPoint([
                            x,
                            y
                        ]));
                    });
                    lineData.each(function (idx) {
                        var p1 = fromData.getItemLayout(idx);
                        var p2 = toData.getItemLayout(idx);
                        var curveness = lineData.getItemModel(idx).get('lineStyle.normal.curveness');
                        var cp1;
                        if (curveness > 0) {
                            cp1 = [
                                (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness,
                                (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness
                            ];
                        }
                        lineData.setItemLayout(idx, [
                            p1,
                            p2,
                            cp1
                        ]);
                    });
                });
            };
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(259);
            __webpack_require__(260);
        },
        function (module, exports, __webpack_require__) {
            var SeriesModel = __webpack_require__(27);
            var createListFromArray = __webpack_require__(93);
            module.exports = SeriesModel.extend({
                type: 'series.heatmap',
                getInitialData: function (option, ecModel) {
                    return createListFromArray(option.data, this, ecModel);
                },
                defaultOption: {
                    coordinateSystem: 'cartesian2d',
                    zlevel: 0,
                    z: 2,
                    xAxisIndex: 0,
                    yAxisIndex: 0,
                    geoIndex: 0,
                    blurSize: 30,
                    pointSize: 20,
                    maxOpacity: 1,
                    minOpacity: 0
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var graphic = __webpack_require__(42);
            var HeatmapLayer = __webpack_require__(261);
            var zrUtil = __webpack_require__(3);
            function getIsInPiecewiseRange(dataExtent, pieceList, selected) {
                var dataSpan = dataExtent[1] - dataExtent[0];
                pieceList = zrUtil.map(pieceList, function (piece) {
                    return {
                        interval: [
                            (piece.interval[0] - dataExtent[0]) / dataSpan,
                            (piece.interval[1] - dataExtent[0]) / dataSpan
                        ]
                    };
                });
                var len = pieceList.length;
                var lastIndex = 0;
                return function (val) {
                    for (var i = lastIndex; i < len; i++) {
                        var interval = pieceList[i].interval;
                        if (interval[0] <= val && val <= interval[1]) {
                            lastIndex = i;
                            break;
                        }
                    }
                    if (i === len) {
                        for (var i = lastIndex - 1; i >= 0; i--) {
                            var interval = pieceList[i].interval;
                            if (interval[0] <= val && val <= interval[1]) {
                                lastIndex = i;
                                break;
                            }
                        }
                    }
                    return i >= 0 && i < len && selected[i];
                };
            }
            function getIsInContinuousRange(dataExtent, range) {
                var dataSpan = dataExtent[1] - dataExtent[0];
                range = [
                    (range[0] - dataExtent[0]) / dataSpan,
                    (range[1] - dataExtent[0]) / dataSpan
                ];
                return function (val) {
                    return val >= range[0] && val <= range[1];
                };
            }
            function isGeoCoordSys(coordSys) {
                var dimensions = coordSys.dimensions;
                return dimensions[0] === 'lng' && dimensions[1] === 'lat';
            }
            module.exports = __webpack_require__(1).extendChartView({
                type: 'heatmap',
                render: function (seriesModel, ecModel, api) {
                    var visualMapOfThisSeries;
                    ecModel.eachComponent('visualMap', function (visualMap) {
                        visualMap.eachTargetSeries(function (targetSeries) {
                            if (targetSeries === seriesModel) {
                                visualMapOfThisSeries = visualMap;
                            }
                        });
                    });
                    if (!visualMapOfThisSeries) {
                        throw new Error('Heatmap must use with visualMap');
                    }
                    this.group.removeAll();
                    var coordSys = seriesModel.coordinateSystem;
                    if (coordSys.type === 'cartesian2d') {
                        this._renderOnCartesian(coordSys, seriesModel, api);
                    } else if (isGeoCoordSys(coordSys)) {
                        this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api);
                    }
                },
                _renderOnCartesian: function (cartesian, seriesModel, api) {
                    var xAxis = cartesian.getAxis('x');
                    var yAxis = cartesian.getAxis('y');
                    var group = this.group;
                    if (!(xAxis.type === 'category' && yAxis.type === 'category')) {
                        throw new Error('Heatmap on cartesian must have two category axes');
                    }
                    if (!(xAxis.onBand && yAxis.onBand)) {
                        throw new Error('Heatmap on cartesian must have two axes with boundaryGap true');
                    }
                    var width = xAxis.getBandWidth();
                    var height = yAxis.getBandWidth();
                    var data = seriesModel.getData();
                    data.each([
                        'x',
                        'y',
                        'z'
                    ], function (x, y, z, idx) {
                        var itemModel = data.getItemModel(idx);
                        var point = cartesian.dataToPoint([
                            x,
                            y
                        ]);
                        if (isNaN(z)) {
                            return;
                        }
                        var rect = new graphic.Rect({
                            shape: {
                                x: point[0] - width / 2,
                                y: point[1] - height / 2,
                                width: width,
                                height: height
                            },
                            style: { fill: data.getItemVisual(idx, 'color') }
                        });
                        var style = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);
                        var hoverStl = itemModel.getModel('itemStyle.emphasis').getItemStyle();
                        var labelModel = itemModel.getModel('label.normal');
                        var hoverLabelModel = itemModel.getModel('label.emphasis');
                        var rawValue = seriesModel.getRawValue(idx);
                        var defaultText = '-';
                        if (rawValue && rawValue[2] != null) {
                            defaultText = rawValue[2];
                        }
                        if (labelModel.get('show')) {
                            graphic.setText(style, labelModel);
                            style.text = seriesModel.getFormattedLabel(idx, 'normal') || defaultText;
                        }
                        if (hoverLabelModel.get('show')) {
                            graphic.setText(hoverStl, hoverLabelModel);
                            hoverStl.text = seriesModel.getFormattedLabel(idx, 'emphasis') || defaultText;
                        }
                        rect.setStyle(style);
                        graphic.setHoverStyle(rect, hoverStl);
                        group.add(rect);
                        data.setItemGraphicEl(idx, rect);
                    });
                },
                _renderOnGeo: function (geo, seriesModel, visualMapModel, api) {
                    var inRangeVisuals = visualMapModel.targetVisuals.inRange;
                    var outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange;
                    var data = seriesModel.getData();
                    var hmLayer = this._hmLayer || (this._hmLayer || new HeatmapLayer());
                    hmLayer.blurSize = seriesModel.get('blurSize');
                    hmLayer.pointSize = seriesModel.get('pointSize');
                    hmLayer.minOpacity = seriesModel.get('minOpacity');
                    hmLayer.maxOpacity = seriesModel.get('maxOpacity');
                    var rect = geo.getViewRect().clone();
                    var roamTransform = geo.getRoamTransform();
                    rect.applyTransform(roamTransform);
                    var x = Math.max(rect.x, 0);
                    var y = Math.max(rect.y, 0);
                    var x2 = Math.min(rect.width + rect.x, api.getWidth());
                    var y2 = Math.min(rect.height + rect.y, api.getHeight());
                    var width = x2 - x;
                    var height = y2 - y;
                    var points = data.mapArray([
                        'lng',
                        'lat',
                        'value'
                    ], function (lng, lat, value) {
                        var pt = geo.dataToPoint([
                            lng,
                            lat
                        ]);
                        pt[0] -= x;
                        pt[1] -= y;
                        pt.push(value);
                        return pt;
                    });
                    var dataExtent = visualMapModel.getExtent();
                    var isInRange = visualMapModel.type === 'visualMap.continuous' ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected);
                    hmLayer.update(points, width, height, inRangeVisuals.color.getNormalizer(), {
                        inRange: inRangeVisuals.color.getColorMapper(),
                        outOfRange: outOfRangeVisuals.color.getColorMapper()
                    }, isInRange);
                    var img = new graphic.Image({
                        style: {
                            width: width,
                            height: height,
                            x: x,
                            y: y,
                            image: hmLayer.canvas
                        },
                        silent: true
                    });
                    this.group.add(img);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var GRADIENT_LEVELS = 256;
            var zrUtil = __webpack_require__(3);
            function Heatmap() {
                var canvas = zrUtil.createCanvas();
                this.canvas = canvas;
                this.blurSize = 30;
                this.pointSize = 20;
                this.maxOpacity = 1;
                this.minOpacity = 0;
                this._gradientPixels = {};
            }
            Heatmap.prototype = {
                update: function (data, width, height, normalize, colorFunc, isInRange) {
                    var brush = this._getBrush();
                    var gradientInRange = this._getGradient(data, colorFunc, 'inRange');
                    var gradientOutOfRange = this._getGradient(data, colorFunc, 'outOfRange');
                    var r = this.pointSize + this.blurSize;
                    var canvas = this.canvas;
                    var ctx = canvas.getContext('2d');
                    var len = data.length;
                    canvas.width = width;
                    canvas.height = height;
                    for (var i = 0; i < len; ++i) {
                        var p = data[i];
                        var x = p[0];
                        var y = p[1];
                        var value = p[2];
                        var alpha = normalize(value);
                        ctx.globalAlpha = alpha;
                        ctx.drawImage(brush, x - r, y - r);
                    }
                    var imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                    var pixels = imageData.data;
                    var offset = 0;
                    var pixelLen = pixels.length;
                    var minOpacity = this.minOpacity;
                    var maxOpacity = this.maxOpacity;
                    var diffOpacity = maxOpacity - minOpacity;
                    while (offset < pixelLen) {
                        var alpha = pixels[offset + 3] / 256;
                        var gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4;
                        if (alpha > 0) {
                            var gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange;
                            alpha > 0 && (alpha = alpha * diffOpacity + minOpacity);
                            pixels[offset++] = gradient[gradientOffset];
                            pixels[offset++] = gradient[gradientOffset + 1];
                            pixels[offset++] = gradient[gradientOffset + 2];
                            pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256;
                        } else {
                            offset += 4;
                        }
                    }
                    ctx.putImageData(imageData, 0, 0);
                    return canvas;
                },
                _getBrush: function () {
                    var brushCanvas = this._brushCanvas || (this._brushCanvas = zrUtil.createCanvas());
                    var r = this.pointSize + this.blurSize;
                    var d = r * 2;
                    brushCanvas.width = d;
                    brushCanvas.height = d;
                    var ctx = brushCanvas.getContext('2d');
                    ctx.clearRect(0, 0, d, d);
                    ctx.shadowOffsetX = d;
                    ctx.shadowBlur = this.blurSize;
                    ctx.shadowColor = '#000';
                    ctx.beginPath();
                    ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true);
                    ctx.closePath();
                    ctx.fill();
                    return brushCanvas;
                },
                _getGradient: function (data, colorFunc, state) {
                    var gradientPixels = this._gradientPixels;
                    var pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4));
                    var color = [];
                    var off = 0;
                    for (var i = 0; i < 256; i++) {
                        colorFunc[state](i / 255, true, color);
                        pixelsSingleState[off++] = color[0];
                        pixelsSingleState[off++] = color[1];
                        pixelsSingleState[off++] = color[2];
                        pixelsSingleState[off++] = color[3];
                    }
                    return pixelsSingleState;
                }
            };
            module.exports = Heatmap;
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(263);
            __webpack_require__(264);
            __webpack_require__(265);
            var echarts = __webpack_require__(1);
            echarts.registerProcessor('filter', __webpack_require__(267));
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var Model = __webpack_require__(8);
            var LegendModel = __webpack_require__(1).extendComponentModel({
                type: 'legend',
                dependencies: ['series'],
                layoutMode: {
                    type: 'box',
                    ignoreSize: true
                },
                init: function (option, parentModel, ecModel) {
                    this.mergeDefaultAndTheme(option, ecModel);
                    option.selected = option.selected || {};
                    this._updateData(ecModel);
                    var legendData = this._data;
                    var selectedMap = this.option.selected;
                    if (legendData[0] && this.get('selectedMode') === 'single') {
                        var hasSelected = false;
                        for (var name in selectedMap) {
                            if (selectedMap[name]) {
                                this.select(name);
                                hasSelected = true;
                            }
                        }
                        !hasSelected && this.select(legendData[0].get('name'));
                    }
                },
                mergeOption: function (option) {
                    LegendModel.superCall(this, 'mergeOption', option);
                    this._updateData(this.ecModel);
                },
                _updateData: function (ecModel) {
                    var legendData = zrUtil.map(this.get('data') || [], function (dataItem) {
                        if (typeof dataItem === 'string') {
                            dataItem = { name: dataItem };
                        }
                        return new Model(dataItem, this, this.ecModel);
                    }, this);
                    this._data = legendData;
                    var availableNames = zrUtil.map(ecModel.getSeries(), function (series) {
                        return series.name;
                    });
                    ecModel.eachSeries(function (seriesModel) {
                        if (seriesModel.legendDataProvider) {
                            var data = seriesModel.legendDataProvider();
                            availableNames = availableNames.concat(data.mapArray(data.getName));
                        }
                    });
                    this._availableNames = availableNames;
                },
                getData: function () {
                    return this._data;
                },
                select: function (name) {
                    var selected = this.option.selected;
                    var selectedMode = this.get('selectedMode');
                    if (selectedMode === 'single') {
                        var data = this._data;
                        zrUtil.each(data, function (dataItem) {
                            selected[dataItem.get('name')] = false;
                        });
                    }
                    selected[name] = true;
                },
                unSelect: function (name) {
                    if (this.get('selectedMode') !== 'single') {
                        this.option.selected[name] = false;
                    }
                },
                toggleSelected: function (name) {
                    var selected = this.option.selected;
                    if (!(name in selected)) {
                        selected[name] = true;
                    }
                    this[selected[name] ? 'unSelect' : 'select'](name);
                },
                isSelected: function (name) {
                    var selected = this.option.selected;
                    return !(name in selected && !selected[name]) && zrUtil.indexOf(this._availableNames, name) >= 0;
                },
                defaultOption: {
                    zlevel: 0,
                    z: 4,
                    show: true,
                    orient: 'horizontal',
                    left: 'center',
                    top: 'top',
                    align: 'auto',
                    backgroundColor: 'rgba(0,0,0,0)',
                    borderColor: '#ccc',
                    borderWidth: 0,
                    padding: 5,
                    itemGap: 10,
                    itemWidth: 25,
                    itemHeight: 14,
                    textStyle: { color: '#333' },
                    selectedMode: true
                }
            });
            module.exports = LegendModel;
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            var zrUtil = __webpack_require__(3);
            function legendSelectActionHandler(methodName, payload, ecModel) {
                var selectedMap = {};
                var isToggleSelect = methodName === 'toggleSelected';
                var isSelected;
                ecModel.eachComponent('legend', function (legendModel) {
                    if (isToggleSelect && isSelected != null) {
                        legendModel[isSelected ? 'select' : 'unSelect'](payload.name);
                    } else {
                        legendModel[methodName](payload.name);
                        isSelected = legendModel.isSelected(payload.name);
                    }
                    var legendData = legendModel.getData();
                    zrUtil.each(legendData, function (model) {
                        var name = model.get('name');
                        if (name === '\n' || name === '') {
                            return;
                        }
                        var isItemSelected = legendModel.isSelected(name);
                        if (name in selectedMap) {
                            selectedMap[name] = selectedMap[name] && isItemSelected;
                        } else {
                            selectedMap[name] = isItemSelected;
                        }
                    });
                });
                return {
                    name: payload.name,
                    selected: selectedMap
                };
            }
            echarts.registerAction('legendToggleSelect', 'legendselectchanged', zrUtil.curry(legendSelectActionHandler, 'toggleSelected'));
            echarts.registerAction('legendSelect', 'legendselected', zrUtil.curry(legendSelectActionHandler, 'select'));
            echarts.registerAction('legendUnSelect', 'legendunselected', zrUtil.curry(legendSelectActionHandler, 'unSelect'));
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var symbolCreator = __webpack_require__(100);
            var graphic = __webpack_require__(42);
            var listComponentHelper = __webpack_require__(266);
            var curry = zrUtil.curry;
            var LEGEND_DISABLE_COLOR = '#ccc';
            function dispatchSelectAction(name, api) {
                api.dispatchAction({
                    type: 'legendToggleSelect',
                    name: name
                });
            }
            function dispatchHighlightAction(seriesModel, dataName, api) {
                seriesModel.get('legendHoverLink') && api.dispatchAction({
                    type: 'highlight',
                    seriesName: seriesModel.name,
                    name: dataName
                });
            }
            function dispatchDownplayAction(seriesModel, dataName, api) {
                seriesModel.get('legendHoverLink') && api.dispatchAction({
                    type: 'downplay',
                    seriesName: seriesModel.name,
                    name: dataName
                });
            }
            module.exports = __webpack_require__(1).extendComponentView({
                type: 'legend',
                init: function () {
                    this._symbolTypeStore = {};
                },
                render: function (legendModel, ecModel, api) {
                    var group = this.group;
                    group.removeAll();
                    if (!legendModel.get('show')) {
                        return;
                    }
                    var selectMode = legendModel.get('selectedMode');
                    var itemAlign = legendModel.get('align');
                    if (itemAlign === 'auto') {
                        itemAlign = legendModel.get('left') === 'right' && legendModel.get('orient') === 'vertical' ? 'right' : 'left';
                    }
                    var legendDrawedMap = {};
                    zrUtil.each(legendModel.getData(), function (itemModel) {
                        var name = itemModel.get('name');
                        if (name === '' || name === '\n') {
                            group.add(new graphic.Group({ newline: true }));
                            return;
                        }
                        var seriesModel = ecModel.getSeriesByName(name)[0];
                        if (legendDrawedMap[name]) {
                            return;
                        }
                        if (seriesModel) {
                            var data = seriesModel.getData();
                            var color = data.getVisual('color');
                            if (typeof color === 'function') {
                                color = color(seriesModel.getDataParams(0));
                            }
                            var legendSymbolType = data.getVisual('legendSymbol') || 'roundRect';
                            var symbolType = data.getVisual('symbol');
                            var itemGroup = this._createItem(name, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode);
                            itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, '', api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, '', api));
                            legendDrawedMap[name] = true;
                        } else {
                            ecModel.eachRawSeries(function (seriesModel) {
                                if (legendDrawedMap[name]) {
                                    return;
                                }
                                if (seriesModel.legendDataProvider) {
                                    var data = seriesModel.legendDataProvider();
                                    var idx = data.indexOfName(name);
                                    var color = data.getItemVisual(idx, 'color');
                                    var legendSymbolType = 'roundRect';
                                    var itemGroup = this._createItem(name, itemModel, legendModel, legendSymbolType, null, itemAlign, color, selectMode);
                                    itemGroup.on('click', curry(dispatchSelectAction, name, api)).on('mouseover', curry(dispatchHighlightAction, seriesModel, name, api)).on('mouseout', curry(dispatchDownplayAction, seriesModel, name, api));
                                    legendDrawedMap[name] = true;
                                }
                            }, this);
                        }
                    }, this);
                    listComponentHelper.layout(group, legendModel, api);
                    listComponentHelper.addBackground(group, legendModel);
                },
                _createItem: function (name, itemModel, legendModel, legendSymbolType, symbolType, itemAlign, color, selectMode) {
                    var itemWidth = legendModel.get('itemWidth');
                    var itemHeight = legendModel.get('itemHeight');
                    var isSelected = legendModel.isSelected(name);
                    var itemGroup = new graphic.Group();
                    var textStyleModel = itemModel.getModel('textStyle');
                    var itemIcon = itemModel.get('icon');
                    legendSymbolType = itemIcon || legendSymbolType;
                    itemGroup.add(symbolCreator.createSymbol(legendSymbolType, 0, 0, itemWidth, itemHeight, isSelected ? color : LEGEND_DISABLE_COLOR));
                    if (!itemIcon && symbolType && (symbolType !== legendSymbolType || symbolType == 'none')) {
                        var size = itemHeight * 0.8;
                        if (symbolType === 'none') {
                            symbolType = 'circle';
                        }
                        itemGroup.add(symbolCreator.createSymbol(symbolType, (itemWidth - size) / 2, (itemHeight - size) / 2, size, size, isSelected ? color : LEGEND_DISABLE_COLOR));
                    }
                    var textX = itemAlign === 'left' ? itemWidth + 5 : -5;
                    var textAlign = itemAlign;
                    var formatter = legendModel.get('formatter');
                    if (typeof formatter === 'string' && formatter) {
                        name = formatter.replace('{name}', name);
                    } else if (typeof formatter === 'function') {
                        name = formatter(name);
                    }
                    var text = new graphic.Text({
                        style: {
                            text: name,
                            x: textX,
                            y: itemHeight / 2,
                            fill: isSelected ? textStyleModel.getTextColor() : LEGEND_DISABLE_COLOR,
                            textFont: textStyleModel.getFont(),
                            textAlign: textAlign,
                            textVerticalAlign: 'middle'
                        }
                    });
                    itemGroup.add(text);
                    itemGroup.add(new graphic.Rect({
                        shape: itemGroup.getBoundingRect(),
                        invisible: true
                    }));
                    itemGroup.eachChild(function (child) {
                        child.silent = !selectMode;
                    });
                    this.group.add(itemGroup);
                    graphic.setHoverStyle(itemGroup);
                    return itemGroup;
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var layout = __webpack_require__(21);
            var formatUtil = __webpack_require__(6);
            var graphic = __webpack_require__(42);
            function positionGroup(group, model, api) {
                layout.positionGroup(group, model.getBoxLayoutParams(), {
                    width: api.getWidth(),
                    height: api.getHeight()
                }, model.get('padding'));
            }
            module.exports = {
                layout: function (group, componentModel, api) {
                    var rect = layout.getLayoutRect(componentModel.getBoxLayoutParams(), {
                        width: api.getWidth(),
                        height: api.getHeight()
                    }, componentModel.get('padding'));
                    layout.box(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height);
                    positionGroup(group, componentModel, api);
                },
                addBackground: function (group, componentModel) {
                    var padding = formatUtil.normalizeCssArray(componentModel.get('padding'));
                    var boundingRect = group.getBoundingRect();
                    var style = componentModel.getItemStyle([
                        'color',
                        'opacity'
                    ]);
                    style.fill = componentModel.get('backgroundColor');
                    var rect = new graphic.Rect({
                        shape: {
                            x: boundingRect.x - padding[3],
                            y: boundingRect.y - padding[0],
                            width: boundingRect.width + padding[1] + padding[3],
                            height: boundingRect.height + padding[0] + padding[2]
                        },
                        style: style,
                        silent: true,
                        z2: -1
                    });
                    graphic.subPixelOptimizeRect(rect);
                    group.add(rect);
                }
            };
        },
        function (module, exports) {
            module.exports = function (ecModel) {
                var legendModels = ecModel.findComponents({ mainType: 'legend' });
                if (legendModels && legendModels.length) {
                    ecModel.filterSeries(function (series) {
                        for (var i = 0; i < legendModels.length; i++) {
                            if (!legendModels[i].isSelected(series.name)) {
                                return false;
                            }
                        }
                        return true;
                    });
                }
            };
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(269);
            __webpack_require__(270);
            __webpack_require__(1).registerAction({
                type: 'showTip',
                event: 'showTip',
                update: 'none'
            }, function () {
            });
            __webpack_require__(1).registerAction({
                type: 'hideTip',
                event: 'hideTip',
                update: 'none'
            }, function () {
            });
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(1).extendComponentModel({
                type: 'tooltip',
                defaultOption: {
                    zlevel: 0,
                    z: 8,
                    show: true,
                    showContent: true,
                    trigger: 'item',
                    triggerOn: 'mousemove',
                    alwaysShowContent: false,
                    showDelay: 0,
                    hideDelay: 100,
                    transitionDuration: 0.4,
                    enterable: false,
                    backgroundColor: 'rgba(50,50,50,0.7)',
                    borderColor: '#333',
                    borderRadius: 4,
                    borderWidth: 0,
                    padding: 5,
                    extraCssText: '',
                    axisPointer: {
                        type: 'line',
                        axis: 'auto',
                        animation: true,
                        animationDurationUpdate: 200,
                        animationEasingUpdate: 'exponentialOut',
                        lineStyle: {
                            color: '#555',
                            width: 1,
                            type: 'solid'
                        },
                        crossStyle: {
                            color: '#555',
                            width: 1,
                            type: 'dashed',
                            textStyle: {}
                        },
                        shadowStyle: { color: 'rgba(150,150,150,0.3)' }
                    },
                    textStyle: {
                        color: '#fff',
                        fontSize: 14
                    }
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var TooltipContent = __webpack_require__(271);
            var graphic = __webpack_require__(42);
            var zrUtil = __webpack_require__(3);
            var formatUtil = __webpack_require__(6);
            var numberUtil = __webpack_require__(7);
            var parsePercent = numberUtil.parsePercent;
            var env = __webpack_require__(78);
            function dataEqual(a, b) {
                if (!a || !b) {
                    return false;
                }
                var round = numberUtil.round;
                return round(a[0]) === round(b[0]) && round(a[1]) === round(b[1]);
            }
            function makeLineShape(x1, y1, x2, y2) {
                return {
                    x1: x1,
                    y1: y1,
                    x2: x2,
                    y2: y2
                };
            }
            function makeRectShape(x, y, width, height) {
                return {
                    x: x,
                    y: y,
                    width: width,
                    height: height
                };
            }
            function makeSectorShape(cx, cy, r0, r, startAngle, endAngle) {
                return {
                    cx: cx,
                    cy: cy,
                    r0: r0,
                    r: r,
                    startAngle: startAngle,
                    endAngle: endAngle,
                    clockwise: true
                };
            }
            function refixTooltipPosition(x, y, el, viewWidth, viewHeight) {
                var width = el.clientWidth;
                var height = el.clientHeight;
                var gap = 20;
                if (x + width + gap > viewWidth) {
                    x -= width + gap;
                } else {
                    x += gap;
                }
                if (y + height + gap > viewHeight) {
                    y -= height + gap;
                } else {
                    y += gap;
                }
                return [
                    x,
                    y
                ];
            }
            function calcTooltipPosition(position, rect, dom) {
                var domWidth = dom.clientWidth;
                var domHeight = dom.clientHeight;
                var gap = 5;
                var x = 0;
                var y = 0;
                var rectWidth = rect.width;
                var rectHeight = rect.height;
                switch (position) {
                case 'inside':
                    x = rect.x + rectWidth / 2 - domWidth / 2;
                    y = rect.y + rectHeight / 2 - domHeight / 2;
                    break;
                case 'top':
                    x = rect.x + rectWidth / 2 - domWidth / 2;
                    y = rect.y - domHeight - gap;
                    break;
                case 'bottom':
                    x = rect.x + rectWidth / 2 - domWidth / 2;
                    y = rect.y + rectHeight + gap;
                    break;
                case 'left':
                    x = rect.x - domWidth - gap;
                    y = rect.y + rectHeight / 2 - domHeight / 2;
                    break;
                case 'right':
                    x = rect.x + rectWidth + gap;
                    y = rect.y + rectHeight / 2 - domHeight / 2;
                }
                return [
                    x,
                    y
                ];
            }
            function updatePosition(positionExpr, x, y, content, params, el, api) {
                var viewWidth = api.getWidth();
                var viewHeight = api.getHeight();
                var rect = el && el.getBoundingRect().clone();
                el && rect.applyTransform(el.transform);
                if (typeof positionExpr === 'function') {
                    positionExpr = positionExpr([
                        x,
                        y
                    ], params, rect);
                }
                if (zrUtil.isArray(positionExpr)) {
                    x = parsePercent(positionExpr[0], viewWidth);
                    y = parsePercent(positionExpr[1], viewHeight);
                } else if (typeof positionExpr === 'string' && el) {
                    var pos = calcTooltipPosition(positionExpr, rect, content.el);
                    x = pos[0];
                    y = pos[1];
                } else {
                    var pos = refixTooltipPosition(x, y, content.el, viewWidth, viewHeight);
                    x = pos[0];
                    y = pos[1];
                }
                content.moveTo(x, y);
            }
            function ifSeriesSupportAxisTrigger(seriesModel) {
                var coordSys = seriesModel.coordinateSystem;
                var trigger = seriesModel.get('tooltip.trigger', true);
                return !(!coordSys || coordSys.type !== 'cartesian2d' && coordSys.type !== 'polar' && coordSys.type !== 'single' || trigger === 'item');
            }
            __webpack_require__(1).extendComponentView({
                type: 'tooltip',
                _axisPointers: {},
                init: function (ecModel, api) {
                    if (env.node) {
                        return;
                    }
                    var tooltipContent = new TooltipContent(api.getDom(), api);
                    this._tooltipContent = tooltipContent;
                    api.on('showTip', this._manuallyShowTip, this);
                    api.on('hideTip', this._manuallyHideTip, this);
                },
                render: function (tooltipModel, ecModel, api) {
                    if (env.node) {
                        return;
                    }
                    this.group.removeAll();
                    this._axisPointers = {};
                    this._tooltipModel = tooltipModel;
                    this._ecModel = ecModel;
                    this._api = api;
                    this._lastHover = {};
                    var tooltipContent = this._tooltipContent;
                    tooltipContent.update();
                    tooltipContent.enterable = tooltipModel.get('enterable');
                    this._alwaysShowContent = tooltipModel.get('alwaysShowContent');
                    this._seriesGroupByAxis = this._prepareAxisTriggerData(tooltipModel, ecModel);
                    var crossText = this._crossText;
                    if (crossText) {
                        this.group.add(crossText);
                    }
                    if (this._lastX != null && this._lastY != null) {
                        var self = this;
                        clearTimeout(this._refreshUpdateTimeout);
                        this._refreshUpdateTimeout = setTimeout(function () {
                            self._manuallyShowTip({
                                x: self._lastX,
                                y: self._lastY
                            });
                        });
                    }
                    var zr = this._api.getZr();
                    zr.off('click', this._tryShow);
                    zr.off('mousemove', this._mousemove);
                    zr.off('mouseout', this._hide);
                    zr.off('globalout', this._hide);
                    if (tooltipModel.get('triggerOn') === 'click') {
                        zr.on('click', this._tryShow, this);
                    } else {
                        zr.on('mousemove', this._mousemove, this);
                        zr.on('mouseout', this._hide, this);
                        zr.on('globalout', this._hide, this);
                    }
                },
                _mousemove: function (e) {
                    var showDelay = this._tooltipModel.get('showDelay');
                    var self = this;
                    clearTimeout(this._showTimeout);
                    if (showDelay > 0) {
                        this._showTimeout = setTimeout(function () {
                            self._tryShow(e);
                        }, showDelay);
                    } else {
                        this._tryShow(e);
                    }
                },
                _manuallyShowTip: function (event) {
                    if (event.from === this.uid) {
                        return;
                    }
                    var ecModel = this._ecModel;
                    var seriesIndex = event.seriesIndex;
                    var dataIndex = event.dataIndex;
                    var seriesModel = ecModel.getSeriesByIndex(seriesIndex);
                    var api = this._api;
                    if (event.x == null || event.y == null) {
                        if (!seriesModel) {
                            ecModel.eachSeries(function (_series) {
                                if (ifSeriesSupportAxisTrigger(_series) && !seriesModel) {
                                    seriesModel = _series;
                                }
                            });
                        }
                        if (seriesModel) {
                            var data = seriesModel.getData();
                            if (dataIndex == null) {
                                dataIndex = data.indexOfName(event.name);
                            }
                            var el = data.getItemGraphicEl(dataIndex);
                            var cx, cy;
                            var coordSys = seriesModel.coordinateSystem;
                            if (coordSys && coordSys.dataToPoint) {
                                var point = coordSys.dataToPoint(data.getValues(zrUtil.map(coordSys.dimensions, function (dim) {
                                    return seriesModel.coordDimToDataDim(dim)[0];
                                }), dataIndex, true));
                                cx = point && point[0];
                                cy = point && point[1];
                            } else if (el) {
                                var rect = el.getBoundingRect().clone();
                                rect.applyTransform(el.transform);
                                cx = rect.x + rect.width / 2;
                                cy = rect.y + rect.height / 2;
                            }
                            if (cx != null && cy != null) {
                                this._tryShow({
                                    offsetX: cx,
                                    offsetY: cy,
                                    target: el,
                                    event: {}
                                });
                            }
                        }
                    } else {
                        var el = api.getZr().handler.findHover(event.x, event.y);
                        this._tryShow({
                            offsetX: event.x,
                            offsetY: event.y,
                            target: el,
                            event: {}
                        });
                    }
                },
                _manuallyHideTip: function (e) {
                    if (e.from === this.uid) {
                        return;
                    }
                    this._hide();
                },
                _prepareAxisTriggerData: function (tooltipModel, ecModel) {
                    var seriesGroupByAxis = {};
                    ecModel.eachSeries(function (seriesModel) {
                        if (ifSeriesSupportAxisTrigger(seriesModel)) {
                            var coordSys = seriesModel.coordinateSystem;
                            var baseAxis;
                            var key;
                            if (coordSys.type === 'cartesian2d') {
                                baseAxis = coordSys.getBaseAxis();
                                key = baseAxis.dim + baseAxis.index;
                            } else if (coordSys.type === 'single') {
                                baseAxis = coordSys.getAxis();
                                key = baseAxis.dim + baseAxis.type;
                            } else {
                                baseAxis = coordSys.getBaseAxis();
                                key = baseAxis.dim + coordSys.name;
                            }
                            seriesGroupByAxis[key] = seriesGroupByAxis[key] || {
                                coordSys: [],
                                series: []
                            };
                            seriesGroupByAxis[key].coordSys.push(coordSys);
                            seriesGroupByAxis[key].series.push(seriesModel);
                        }
                    }, this);
                    return seriesGroupByAxis;
                },
                _tryShow: function (e) {
                    var el = e.target;
                    var tooltipModel = this._tooltipModel;
                    var globalTrigger = tooltipModel.get('trigger');
                    var ecModel = this._ecModel;
                    var api = this._api;
                    if (!tooltipModel) {
                        return;
                    }
                    this._lastX = e.offsetX;
                    this._lastY = e.offsetY;
                    if (el && el.dataIndex != null) {
                        var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
                        var dataIndex = el.dataIndex;
                        var itemModel = dataModel.getData().getItemModel(dataIndex);
                        if ((itemModel.get('tooltip.trigger') || globalTrigger) === 'axis') {
                            this._showAxisTooltip(tooltipModel, ecModel, e);
                        } else {
                            this._ticket = '';
                            this._hideAxisPointer();
                            this._resetLastHover();
                            this._showItemTooltipContent(dataModel, dataIndex, e);
                        }
                        api.dispatchAction({
                            type: 'showTip',
                            from: this.uid,
                            dataIndex: el.dataIndex,
                            seriesIndex: el.seriesIndex
                        });
                    } else {
                        if (globalTrigger === 'item') {
                            this._hide();
                        } else {
                            this._showAxisTooltip(tooltipModel, ecModel, e);
                        }
                        if (tooltipModel.get('axisPointer.type') === 'cross') {
                            api.dispatchAction({
                                type: 'showTip',
                                from: this.uid,
                                x: e.offsetX,
                                y: e.offsetY
                            });
                        }
                    }
                },
                _showAxisTooltip: function (tooltipModel, ecModel, e) {
                    var axisPointerModel = tooltipModel.getModel('axisPointer');
                    var axisPointerType = axisPointerModel.get('type');
                    if (axisPointerType === 'cross') {
                        var el = e.target;
                        if (el && el.dataIndex != null) {
                            var seriesModel = ecModel.getSeriesByIndex(el.seriesIndex);
                            var dataIndex = el.dataIndex;
                            this._showItemTooltipContent(seriesModel, dataIndex, e);
                        }
                    }
                    this._showAxisPointer();
                    var allNotShow = true;
                    zrUtil.each(this._seriesGroupByAxis, function (seriesCoordSysSameAxis) {
                        var allCoordSys = seriesCoordSysSameAxis.coordSys;
                        var coordSys = allCoordSys[0];
                        var point = [
                            e.offsetX,
                            e.offsetY
                        ];
                        if (!coordSys.containPoint(point)) {
                            this._hideAxisPointer(coordSys.name);
                            return;
                        }
                        allNotShow = false;
                        var dimensions = coordSys.dimensions;
                        var value = coordSys.pointToData(point, true);
                        point = coordSys.dataToPoint(value);
                        var baseAxis = coordSys.getBaseAxis();
                        var axisType = axisPointerModel.get('axis');
                        if (axisType === 'auto') {
                            axisType = baseAxis.dim;
                        }
                        var contentNotChange = false;
                        var lastHover = this._lastHover;
                        if (axisPointerType === 'cross') {
                            if (dataEqual(lastHover.data, value)) {
                                contentNotChange = true;
                            }
                            lastHover.data = value;
                        } else {
                            var valIndex = zrUtil.indexOf(dimensions, axisType);
                            if (lastHover.data === value[valIndex]) {
                                contentNotChange = true;
                            }
                            lastHover.data = value[valIndex];
                        }
                        if (coordSys.type === 'cartesian2d' && !contentNotChange) {
                            this._showCartesianPointer(axisPointerModel, coordSys, axisType, point);
                        } else if (coordSys.type === 'polar' && !contentNotChange) {
                            this._showPolarPointer(axisPointerModel, coordSys, axisType, point);
                        } else if (coordSys.type === 'single' && !contentNotChange) {
                            this._showSinglePointer(axisPointerModel, coordSys, axisType, point);
                        }
                        if (axisPointerType !== 'cross') {
                            this._dispatchAndShowSeriesTooltipContent(coordSys, seriesCoordSysSameAxis.series, point, value, contentNotChange);
                        }
                    }, this);
                    if (allNotShow) {
                        this._hide();
                    }
                },
                _showCartesianPointer: function (axisPointerModel, cartesian, axisType, point) {
                    var self = this;
                    var axisPointerType = axisPointerModel.get('type');
                    var moveAnimation = axisPointerType !== 'cross';
                    if (axisPointerType === 'cross') {
                        moveGridLine('x', point, cartesian.getAxis('y').getGlobalExtent());
                        moveGridLine('y', point, cartesian.getAxis('x').getGlobalExtent());
                        this._updateCrossText(cartesian, point, axisPointerModel);
                    } else {
                        var otherAxis = cartesian.getAxis(axisType === 'x' ? 'y' : 'x');
                        var otherExtent = otherAxis.getGlobalExtent();
                        if (cartesian.type === 'cartesian2d') {
                            (axisPointerType === 'line' ? moveGridLine : moveGridShadow)(axisType, point, otherExtent);
                        }
                    }
                    function moveGridLine(axisType, point, otherExtent) {
                        var targetShape = axisType === 'x' ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1]) : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);
                        var pointerEl = self._getPointerElement(cartesian, axisPointerModel, axisType, targetShape);
                        moveAnimation ? graphic.updateProps(pointerEl, { shape: targetShape }, axisPointerModel) : pointerEl.attr({ shape: targetShape });
                    }
                    function moveGridShadow(axisType, point, otherExtent) {
                        var axis = cartesian.getAxis(axisType);
                        var bandWidth = axis.getBandWidth();
                        var span = otherExtent[1] - otherExtent[0];
                        var targetShape = axisType === 'x' ? makeRectShape(point[0] - bandWidth / 2, otherExtent[0], bandWidth, span) : makeRectShape(otherExtent[0], point[1] - bandWidth / 2, span, bandWidth);
                        var pointerEl = self._getPointerElement(cartesian, axisPointerModel, axisType, targetShape);
                        moveAnimation ? graphic.updateProps(pointerEl, { shape: targetShape }, axisPointerModel) : pointerEl.attr({ shape: targetShape });
                    }
                },
                _showSinglePointer: function (axisPointerModel, single, axisType, point) {
                    var self = this;
                    var axisPointerType = axisPointerModel.get('type');
                    var moveAnimation = axisPointerType !== 'cross';
                    var rect = single.getRect();
                    var otherExtent = [
                        rect.y,
                        rect.y + rect.height
                    ];
                    moveSingleLine(axisType, point, otherExtent);
                    function moveSingleLine(axisType, point, otherExtent) {
                        var axis = single.getAxis();
                        var orient = axis.orient;
                        var targetShape = orient === 'horizontal' ? makeLineShape(point[0], otherExtent[0], point[0], otherExtent[1]) : makeLineShape(otherExtent[0], point[1], otherExtent[1], point[1]);
                        var pointerEl = self._getPointerElement(single, axisPointerModel, axisType, targetShape);
                        moveAnimation ? graphic.updateProps(pointerEl, { shape: targetShape }, axisPointerModel) : pointerEl.attr({ shape: targetShape });
                    }
                },
                _showPolarPointer: function (axisPointerModel, polar, axisType, point) {
                    var self = this;
                    var axisPointerType = axisPointerModel.get('type');
                    var angleAxis = polar.getAngleAxis();
                    var radiusAxis = polar.getRadiusAxis();
                    var moveAnimation = axisPointerType !== 'cross';
                    if (axisPointerType === 'cross') {
                        movePolarLine('angle', point, radiusAxis.getExtent());
                        movePolarLine('radius', point, angleAxis.getExtent());
                        this._updateCrossText(polar, point, axisPointerModel);
                    } else {
                        var otherAxis = polar.getAxis(axisType === 'radius' ? 'angle' : 'radius');
                        var otherExtent = otherAxis.getExtent();
                        (axisPointerType === 'line' ? movePolarLine : movePolarShadow)(axisType, point, otherExtent);
                    }
                    function movePolarLine(axisType, point, otherExtent) {
                        var mouseCoord = polar.pointToCoord(point);
                        var targetShape;
                        if (axisType === 'angle') {
                            var p1 = polar.coordToPoint([
                                otherExtent[0],
                                mouseCoord[1]
                            ]);
                            var p2 = polar.coordToPoint([
                                otherExtent[1],
                                mouseCoord[1]
                            ]);
                            targetShape = makeLineShape(p1[0], p1[1], p2[0], p2[1]);
                        } else {
                            targetShape = {
                                cx: polar.cx,
                                cy: polar.cy,
                                r: mouseCoord[0]
                            };
                        }
                        var pointerEl = self._getPointerElement(polar, axisPointerModel, axisType, targetShape);
                        moveAnimation ? graphic.updateProps(pointerEl, { shape: targetShape }, axisPointerModel) : pointerEl.attr({ shape: targetShape });
                    }
                    function movePolarShadow(axisType, point, otherExtent) {
                        var axis = polar.getAxis(axisType);
                        var bandWidth = axis.getBandWidth();
                        var mouseCoord = polar.pointToCoord(point);
                        var targetShape;
                        var radian = Math.PI / 180;
                        if (axisType === 'angle') {
                            targetShape = makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], (-mouseCoord[1] - bandWidth / 2) * radian, (-mouseCoord[1] + bandWidth / 2) * radian);
                        } else {
                            targetShape = makeSectorShape(polar.cx, polar.cy, mouseCoord[0] - bandWidth / 2, mouseCoord[0] + bandWidth / 2, 0, Math.PI * 2);
                        }
                        var pointerEl = self._getPointerElement(polar, axisPointerModel, axisType, targetShape);
                        moveAnimation ? graphic.updateProps(pointerEl, { shape: targetShape }, axisPointerModel) : pointerEl.attr({ shape: targetShape });
                    }
                },
                _updateCrossText: function (coordSys, point, axisPointerModel) {
                    var crossStyleModel = axisPointerModel.getModel('crossStyle');
                    var textStyleModel = crossStyleModel.getModel('textStyle');
                    var tooltipModel = this._tooltipModel;
                    var text = this._crossText;
                    if (!text) {
                        text = this._crossText = new graphic.Text({
                            style: {
                                textAlign: 'left',
                                textVerticalAlign: 'bottom'
                            }
                        });
                        this.group.add(text);
                    }
                    var value = coordSys.pointToData(point);
                    var dims = coordSys.dimensions;
                    value = zrUtil.map(value, function (val, idx) {
                        var axis = coordSys.getAxis(dims[idx]);
                        if (axis.type === 'category' || axis.type === 'time') {
                            val = axis.scale.getLabel(val);
                        } else {
                            val = formatUtil.addCommas(val.toFixed(axis.getPixelPrecision()));
                        }
                        return val;
                    });
                    text.setStyle({
                        fill: textStyleModel.getTextColor() || crossStyleModel.get('color'),
                        textFont: textStyleModel.getFont(),
                        text: value.join(', '),
                        x: point[0] + 5,
                        y: point[1] - 5
                    });
                    text.z = tooltipModel.get('z');
                    text.zlevel = tooltipModel.get('zlevel');
                },
                _getPointerElement: function (coordSys, pointerModel, axisType, initShape) {
                    var tooltipModel = this._tooltipModel;
                    var z = tooltipModel.get('z');
                    var zlevel = tooltipModel.get('zlevel');
                    var axisPointers = this._axisPointers;
                    var coordSysName = coordSys.name;
                    axisPointers[coordSysName] = axisPointers[coordSysName] || {};
                    if (axisPointers[coordSysName][axisType]) {
                        return axisPointers[coordSysName][axisType];
                    }
                    var pointerType = pointerModel.get('type');
                    var styleModel = pointerModel.getModel(pointerType + 'Style');
                    var isShadow = pointerType === 'shadow';
                    var style = styleModel[isShadow ? 'getAreaStyle' : 'getLineStyle']();
                    var elementType = coordSys.type === 'polar' ? isShadow ? 'Sector' : axisType === 'radius' ? 'Circle' : 'Line' : isShadow ? 'Rect' : 'Line';
                    isShadow ? style.stroke = null : style.fill = null;
                    var el = axisPointers[coordSysName][axisType] = new graphic[elementType]({
                        style: style,
                        z: z,
                        zlevel: zlevel,
                        silent: true,
                        shape: initShape
                    });
                    this.group.add(el);
                    return el;
                },
                _dispatchAndShowSeriesTooltipContent: function (coordSys, seriesList, point, value, contentNotChange) {
                    var rootTooltipModel = this._tooltipModel;
                    var tooltipContent = this._tooltipContent;
                    var baseAxis = coordSys.getBaseAxis();
                    var payloadBatch = zrUtil.map(seriesList, function (series) {
                        return {
                            seriesIndex: series.seriesIndex,
                            dataIndex: series.getAxisTooltipDataIndex ? series.getAxisTooltipDataIndex(series.coordDimToDataDim(baseAxis.dim), value, baseAxis) : series.getData().indexOfNearest(series.coordDimToDataDim(baseAxis.dim)[0], value[baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1])
                        };
                    });
                    var lastHover = this._lastHover;
                    var api = this._api;
                    if (lastHover.payloadBatch && !contentNotChange) {
                        api.dispatchAction({
                            type: 'downplay',
                            batch: lastHover.payloadBatch
                        });
                    }
                    if (!contentNotChange) {
                        api.dispatchAction({
                            type: 'highlight',
                            batch: payloadBatch
                        });
                        lastHover.payloadBatch = payloadBatch;
                    }
                    api.dispatchAction({
                        type: 'showTip',
                        dataIndex: payloadBatch[0].dataIndex,
                        seriesIndex: payloadBatch[0].seriesIndex,
                        from: this.uid
                    });
                    if (baseAxis && rootTooltipModel.get('showContent')) {
                        var formatter = rootTooltipModel.get('formatter');
                        var positionExpr = rootTooltipModel.get('position');
                        var html;
                        var paramsList = zrUtil.map(seriesList, function (series, index) {
                            return series.getDataParams(payloadBatch[index].dataIndex);
                        });
                        tooltipContent.show(rootTooltipModel);
                        var firstDataIndex = payloadBatch[0].dataIndex;
                        if (!contentNotChange) {
                            this._ticket = '';
                            if (!formatter) {
                                var firstLine = seriesList[0].getData().getName(firstDataIndex);
                                html = (firstLine ? firstLine + '<br />' : '') + zrUtil.map(seriesList, function (series, index) {
                                    return series.formatTooltip(payloadBatch[index].dataIndex, true);
                                }).join('<br />');
                            } else {
                                if (typeof formatter === 'string') {
                                    html = formatUtil.formatTpl(formatter, paramsList);
                                } else if (typeof formatter === 'function') {
                                    var self = this;
                                    var ticket = 'axis_' + coordSys.name + '_' + firstDataIndex;
                                    var callback = function (cbTicket, html) {
                                        if (cbTicket === self._ticket) {
                                            tooltipContent.setContent(html);
                                            updatePosition(positionExpr, point[0], point[1], tooltipContent, paramsList, null, api);
                                        }
                                    };
                                    self._ticket = ticket;
                                    html = formatter(paramsList, ticket, callback);
                                }
                            }
                            tooltipContent.setContent(html);
                        }
                        updatePosition(positionExpr, point[0], point[1], tooltipContent, paramsList, null, api);
                    }
                },
                _showItemTooltipContent: function (seriesModel, dataIndex, e) {
                    var api = this._api;
                    var data = seriesModel.getData();
                    var itemModel = data.getItemModel(dataIndex);
                    var rootTooltipModel = this._tooltipModel;
                    var tooltipContent = this._tooltipContent;
                    var tooltipModel = itemModel.getModel('tooltip');
                    if (tooltipModel.parentModel) {
                        tooltipModel.parentModel.parentModel = rootTooltipModel;
                    } else {
                        tooltipModel.parentModel = this._tooltipModel;
                    }
                    if (tooltipModel.get('showContent')) {
                        var formatter = tooltipModel.get('formatter');
                        var positionExpr = tooltipModel.get('position');
                        var params = seriesModel.getDataParams(dataIndex);
                        var html;
                        if (!formatter) {
                            html = seriesModel.formatTooltip(dataIndex);
                        } else {
                            if (typeof formatter === 'string') {
                                html = formatUtil.formatTpl(formatter, params);
                            } else if (typeof formatter === 'function') {
                                var self = this;
                                var ticket = 'item_' + seriesModel.name + '_' + dataIndex;
                                var callback = function (cbTicket, html) {
                                    if (cbTicket === self._ticket) {
                                        tooltipContent.setContent(html);
                                        updatePosition(positionExpr, e.offsetX, e.offsetY, tooltipContent, params, e.target, api);
                                    }
                                };
                                self._ticket = ticket;
                                html = formatter(params, ticket, callback);
                            }
                        }
                        tooltipContent.show(tooltipModel);
                        tooltipContent.setContent(html);
                        updatePosition(positionExpr, e.offsetX, e.offsetY, tooltipContent, params, e.target, api);
                    }
                },
                _showAxisPointer: function (coordSysName) {
                    if (coordSysName) {
                        var axisPointers = this._axisPointers[coordSysName];
                        axisPointers && zrUtil.each(axisPointers, function (el) {
                            el.show();
                        });
                    } else {
                        this.group.eachChild(function (child) {
                            child.show();
                        });
                        this.group.show();
                    }
                },
                _resetLastHover: function () {
                    var lastHover = this._lastHover;
                    if (lastHover.payloadBatch) {
                        this._api.dispatchAction({
                            type: 'downplay',
                            batch: lastHover.payloadBatch
                        });
                    }
                    this._lastHover = {};
                },
                _hideAxisPointer: function (coordSysName) {
                    if (coordSysName) {
                        var axisPointers = this._axisPointers[coordSysName];
                        axisPointers && zrUtil.each(axisPointers, function (el) {
                            el.hide();
                        });
                    } else {
                        this.group.hide();
                    }
                },
                _hide: function () {
                    clearTimeout(this._showTimeout);
                    this._hideAxisPointer();
                    this._resetLastHover();
                    if (!this._alwaysShowContent) {
                        this._tooltipContent.hideLater(this._tooltipModel.get('hideDelay'));
                    }
                    this._api.dispatchAction({
                        type: 'hideTip',
                        from: this.uid
                    });
                    this._lastX = this._lastY = null;
                },
                dispose: function (ecModel, api) {
                    if (env.node) {
                        return;
                    }
                    var zr = api.getZr();
                    this._tooltipContent.hide();
                    zr.off('click', this._tryShow);
                    zr.off('mousemove', this._mousemove);
                    zr.off('mouseout', this._hide);
                    zr.off('globalout', this._hide);
                    api.off('showTip', this._manuallyShowTip);
                    api.off('hideTip', this._manuallyHideTip);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var zrColor = __webpack_require__(38);
            var eventUtil = __webpack_require__(80);
            var formatUtil = __webpack_require__(6);
            var each = zrUtil.each;
            var toCamelCase = formatUtil.toCamelCase;
            var vendors = [
                '',
                '-webkit-',
                '-moz-',
                '-o-'
            ];
            var gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;';
            function assembleTransition(duration) {
                var transitionCurve = 'cubic-bezier(0.23, 1, 0.32, 1)';
                var transitionText = 'left ' + duration + 's ' + transitionCurve + ',' + 'top ' + duration + 's ' + transitionCurve;
                return zrUtil.map(vendors, function (vendorPrefix) {
                    return vendorPrefix + 'transition:' + transitionText;
                }).join(';');
            }
            function assembleFont(textStyleModel) {
                var cssText = [];
                var fontSize = textStyleModel.get('fontSize');
                var color = textStyleModel.getTextColor();
                color && cssText.push('color:' + color);
                cssText.push('font:' + textStyleModel.getFont());
                fontSize && cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px');
                each([
                    'decoration',
                    'align'
                ], function (name) {
                    var val = textStyleModel.get(name);
                    val && cssText.push('text-' + name + ':' + val);
                });
                return cssText.join(';');
            }
            function assembleCssText(tooltipModel) {
                tooltipModel = tooltipModel;
                var cssText = [];
                var transitionDuration = tooltipModel.get('transitionDuration');
                var backgroundColor = tooltipModel.get('backgroundColor');
                var textStyleModel = tooltipModel.getModel('textStyle');
                var padding = tooltipModel.get('padding');
                transitionDuration && cssText.push(assembleTransition(transitionDuration));
                if (backgroundColor) {
                    cssText.push('background-Color:' + zrColor.toHex(backgroundColor));
                    cssText.push('filter:alpha(opacity=70)');
                    cssText.push('background-Color:' + backgroundColor);
                }
                each([
                    'width',
                    'color',
                    'radius'
                ], function (name) {
                    var borderName = 'border-' + name;
                    var camelCase = toCamelCase(borderName);
                    var val = tooltipModel.get(camelCase);
                    val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'));
                });
                cssText.push(assembleFont(textStyleModel));
                if (padding != null) {
                    cssText.push('padding:' + formatUtil.normalizeCssArray(padding).join('px ') + 'px');
                }
                return cssText.join(';') + ';';
            }
            function TooltipContent(container, api) {
                var el = document.createElement('div');
                var zr = api.getZr();
                this.el = el;
                this._x = api.getWidth() / 2;
                this._y = api.getHeight() / 2;
                container.appendChild(el);
                this._container = container;
                this._show = false;
                this._hideTimeout;
                var self = this;
                el.onmouseenter = function () {
                    if (self.enterable) {
                        clearTimeout(self._hideTimeout);
                        self._show = true;
                    }
                    self._inContent = true;
                };
                el.onmousemove = function (e) {
                    if (!self.enterable) {
                        var handler = zr.handler;
                        eventUtil.normalizeEvent(container, e);
                        handler.dispatch('mousemove', e);
                    }
                };
                el.onmouseleave = function () {
                    if (self.enterable) {
                        if (self._show) {
                            self.hideLater(self._hideDelay);
                        }
                    }
                    self._inContent = false;
                };
                compromiseMobile(el, container);
            }
            function compromiseMobile(tooltipContentEl, container) {
                eventUtil.addEventListener(container, 'touchstart', preventDefault);
                eventUtil.addEventListener(container, 'touchmove', preventDefault);
                eventUtil.addEventListener(container, 'touchend', preventDefault);
                function preventDefault(e) {
                    if (contains(e.target)) {
                        e.preventDefault();
                    }
                }
                function contains(targetEl) {
                    while (targetEl && targetEl !== container) {
                        if (targetEl === tooltipContentEl) {
                            return true;
                        }
                        targetEl = targetEl.parentNode;
                    }
                }
            }
            TooltipContent.prototype = {
                constructor: TooltipContent,
                enterable: true,
                update: function () {
                    var container = this._container;
                    var stl = container.currentStyle || document.defaultView.getComputedStyle(container);
                    var domStyle = container.style;
                    if (domStyle.position !== 'absolute' && stl.position !== 'absolute') {
                        domStyle.position = 'relative';
                    }
                },
                show: function (tooltipModel) {
                    clearTimeout(this._hideTimeout);
                    this.el.style.cssText = gCssText + assembleCssText(tooltipModel) + ';left:' + this._x + 'px;top:' + this._y + 'px;' + (tooltipModel.get('extraCssText') || '');
                    this._show = true;
                },
                setContent: function (content) {
                    var el = this.el;
                    el.innerHTML = content;
                    el.style.display = content ? 'block' : 'none';
                },
                moveTo: function (x, y) {
                    var style = this.el.style;
                    style.left = x + 'px';
                    style.top = y + 'px';
                    this._x = x;
                    this._y = y;
                },
                hide: function () {
                    this.el.style.display = 'none';
                    this._show = false;
                },
                hideLater: function (time) {
                    if (this._show && !(this._inContent && this.enterable)) {
                        if (time) {
                            this._hideDelay = time;
                            this._show = false;
                            this._hideTimeout = setTimeout(zrUtil.bind(this.hide, this), time);
                        } else {
                            this.hide();
                        }
                    }
                },
                isShow: function () {
                    return this._show;
                }
            };
            module.exports = TooltipContent;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            __webpack_require__(273);
            __webpack_require__(279);
            __webpack_require__(281);
            __webpack_require__(1).extendComponentView({ type: 'polar' });
        },
        function (module, exports, __webpack_require__) {
            var Polar = __webpack_require__(274);
            var numberUtil = __webpack_require__(7);
            var axisHelper = __webpack_require__(108);
            var niceScaleExtent = axisHelper.niceScaleExtent;
            __webpack_require__(277);
            function resizePolar(polarModel, api) {
                var center = polarModel.get('center');
                var radius = polarModel.get('radius');
                var width = api.getWidth();
                var height = api.getHeight();
                var parsePercent = numberUtil.parsePercent;
                this.cx = parsePercent(center[0], width);
                this.cy = parsePercent(center[1], height);
                var radiusAxis = this.getRadiusAxis();
                var size = Math.min(width, height) / 2;
                radiusAxis.setExtent(0, parsePercent(radius, size));
            }
            function updatePolarScale(ecModel, api) {
                var polar = this;
                var angleAxis = polar.getAngleAxis();
                var radiusAxis = polar.getRadiusAxis();
                angleAxis.scale.setExtent(Infinity, -Infinity);
                radiusAxis.scale.setExtent(Infinity, -Infinity);
                ecModel.eachSeries(function (seriesModel) {
                    if (seriesModel.coordinateSystem === polar) {
                        var data = seriesModel.getData();
                        radiusAxis.scale.unionExtent(data.getDataExtent('radius', radiusAxis.type !== 'category'));
                        angleAxis.scale.unionExtent(data.getDataExtent('angle', angleAxis.type !== 'category'));
                    }
                });
                niceScaleExtent(angleAxis, angleAxis.model);
                niceScaleExtent(radiusAxis, radiusAxis.model);
                if (angleAxis.type === 'category' && !angleAxis.onBand) {
                    var extent = angleAxis.getExtent();
                    var diff = 360 / angleAxis.scale.count();
                    angleAxis.inverse ? extent[1] += diff : extent[1] -= diff;
                    angleAxis.setExtent(extent[0], extent[1]);
                }
            }
            function setAxis(axis, axisModel) {
                axis.type = axisModel.get('type');
                axis.scale = axisHelper.createScaleByModel(axisModel);
                axis.onBand = axisModel.get('boundaryGap') && axis.type === 'category';
                if (axisModel.mainType === 'angleAxis') {
                    var startAngle = axisModel.get('startAngle');
                    axis.inverse = axisModel.get('inverse') ^ axisModel.get('clockwise');
                    axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360));
                }
                axisModel.axis = axis;
                axis.model = axisModel;
            }
            var polarCreator = {
                dimensions: Polar.prototype.dimensions,
                create: function (ecModel, api) {
                    var polarList = [];
                    ecModel.eachComponent('polar', function (polarModel, idx) {
                        var polar = new Polar(idx);
                        polar.resize = resizePolar;
                        polar.update = updatePolarScale;
                        var radiusAxis = polar.getRadiusAxis();
                        var angleAxis = polar.getAngleAxis();
                        var radiusAxisModel = polarModel.findAxisModel('radiusAxis');
                        var angleAxisModel = polarModel.findAxisModel('angleAxis');
                        setAxis(radiusAxis, radiusAxisModel);
                        setAxis(angleAxis, angleAxisModel);
                        polar.resize(polarModel, api);
                        polarList.push(polar);
                        polarModel.coordinateSystem = polar;
                    });
                    ecModel.eachSeries(function (seriesModel) {
                        if (seriesModel.get('coordinateSystem') === 'polar') {
                            seriesModel.coordinateSystem = polarList[seriesModel.get('polarIndex')];
                        }
                    });
                    return polarList;
                }
            };
            __webpack_require__(25).register('polar', polarCreator);
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var RadiusAxis = __webpack_require__(275);
            var AngleAxis = __webpack_require__(276);
            var Polar = function (name) {
                this.name = name || '';
                this.cx = 0;
                this.cy = 0;
                this._radiusAxis = new RadiusAxis();
                this._angleAxis = new AngleAxis();
            };
            Polar.prototype = {
                constructor: Polar,
                type: 'polar',
                dimensions: [
                    'radius',
                    'angle'
                ],
                containPoint: function (point) {
                    var coord = this.pointToCoord(point);
                    return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1]);
                },
                containData: function (data) {
                    return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1]);
                },
                getAxis: function (axisType) {
                    return this['_' + axisType + 'Axis'];
                },
                getAxesByScale: function (scaleType) {
                    var axes = [];
                    var angleAxis = this._angleAxis;
                    var radiusAxis = this._radiusAxis;
                    angleAxis.scale.type === scaleType && axes.push(angleAxis);
                    radiusAxis.scale.type === scaleType && axes.push(radiusAxis);
                    return axes;
                },
                getAngleAxis: function () {
                    return this._angleAxis;
                },
                getRadiusAxis: function () {
                    return this._radiusAxis;
                },
                getOtherAxis: function (axis) {
                    var angleAxis = this._angleAxis;
                    return axis === angleAxis ? this._radiusAxis : angleAxis;
                },
                getBaseAxis: function () {
                    return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAngleAxis();
                },
                dataToPoints: function (data) {
                    return data.mapArray(this.dimensions, function (radius, angle) {
                        return this.dataToPoint([
                            radius,
                            angle
                        ]);
                    }, this);
                },
                dataToPoint: function (data, clamp) {
                    return this.coordToPoint([
                        this._radiusAxis.dataToRadius(data[0], clamp),
                        this._angleAxis.dataToAngle(data[1], clamp)
                    ]);
                },
                pointToData: function (point, clamp) {
                    var coord = this.pointToCoord(point);
                    return [
                        this._radiusAxis.radiusToData(coord[0], clamp),
                        this._angleAxis.angleToData(coord[1], clamp)
                    ];
                },
                pointToCoord: function (point) {
                    var dx = point[0] - this.cx;
                    var dy = point[1] - this.cy;
                    var angleAxis = this.getAngleAxis();
                    var extent = angleAxis.getExtent();
                    var minAngle = Math.min(extent[0], extent[1]);
                    var maxAngle = Math.max(extent[0], extent[1]);
                    angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360;
                    var radius = Math.sqrt(dx * dx + dy * dy);
                    dx /= radius;
                    dy /= radius;
                    var radian = Math.atan2(-dy, dx) / Math.PI * 180;
                    var dir = radian < minAngle ? 1 : -1;
                    while (radian < minAngle || radian > maxAngle) {
                        radian += dir * 360;
                    }
                    return [
                        radius,
                        radian
                    ];
                },
                coordToPoint: function (coord) {
                    var radius = coord[0];
                    var radian = coord[1] / 180 * Math.PI;
                    var x = Math.cos(radian) * radius + this.cx;
                    var y = -Math.sin(radian) * radius + this.cy;
                    return [
                        x,
                        y
                    ];
                }
            };
            module.exports = Polar;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var Axis = __webpack_require__(117);
            function RadiusAxis(scale, radiusExtent) {
                Axis.call(this, 'radius', scale, radiusExtent);
                this.type = 'category';
            }
            RadiusAxis.prototype = {
                constructor: RadiusAxis,
                dataToRadius: Axis.prototype.dataToCoord,
                radiusToData: Axis.prototype.coordToData
            };
            zrUtil.inherits(RadiusAxis, Axis);
            module.exports = RadiusAxis;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var Axis = __webpack_require__(117);
            function AngleAxis(scale, angleExtent) {
                angleExtent = angleExtent || [
                    0,
                    360
                ];
                Axis.call(this, 'angle', scale, angleExtent);
                this.type = 'category';
            }
            AngleAxis.prototype = {
                constructor: AngleAxis,
                dataToAngle: Axis.prototype.dataToCoord,
                angleToData: Axis.prototype.coordToData
            };
            zrUtil.inherits(AngleAxis, Axis);
            module.exports = AngleAxis;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            __webpack_require__(278);
            __webpack_require__(1).extendComponentModel({
                type: 'polar',
                dependencies: [
                    'polarAxis',
                    'angleAxis'
                ],
                coordinateSystem: null,
                findAxisModel: function (axisType) {
                    var angleAxisModel;
                    var ecModel = this.ecModel;
                    ecModel.eachComponent(axisType, function (axisModel) {
                        if (ecModel.getComponent('polar', axisModel.getShallow('polarIndex')) === this) {
                            angleAxisModel = axisModel;
                        }
                    }, this);
                    return angleAxisModel;
                },
                defaultOption: {
                    zlevel: 0,
                    z: 0,
                    center: [
                        '50%',
                        '50%'
                    ],
                    radius: '80%'
                }
            });
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var ComponentModel = __webpack_require__(19);
            var axisModelCreator = __webpack_require__(121);
            var PolarAxisModel = ComponentModel.extend({
                type: 'polarAxis',
                axis: null
            });
            zrUtil.merge(PolarAxisModel.prototype, __webpack_require__(123));
            var polarAxisDefaultExtendedOption = {
                angle: {
                    polarIndex: 0,
                    startAngle: 90,
                    clockwise: true,
                    splitNumber: 12,
                    axisLabel: { rotate: false }
                },
                radius: {
                    polarIndex: 0,
                    splitNumber: 5
                }
            };
            function getAxisType(axisDim, option) {
                return option.type || (option.data ? 'category' : 'value');
            }
            axisModelCreator('angle', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.angle);
            axisModelCreator('radius', PolarAxisModel, getAxisType, polarAxisDefaultExtendedOption.radius);
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            __webpack_require__(273);
            __webpack_require__(280);
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var Model = __webpack_require__(8);
            var elementList = [
                'axisLine',
                'axisLabel',
                'axisTick',
                'splitLine',
                'splitArea'
            ];
            function getAxisLineShape(polar, r0, r, angle) {
                var start = polar.coordToPoint([
                    r0,
                    angle
                ]);
                var end = polar.coordToPoint([
                    r,
                    angle
                ]);
                return {
                    x1: start[0],
                    y1: start[1],
                    x2: end[0],
                    y2: end[1]
                };
            }
            __webpack_require__(1).extendComponentView({
                type: 'angleAxis',
                render: function (angleAxisModel, ecModel) {
                    this.group.removeAll();
                    if (!angleAxisModel.get('show')) {
                        return;
                    }
                    var polarModel = ecModel.getComponent('polar', angleAxisModel.get('polarIndex'));
                    var angleAxis = angleAxisModel.axis;
                    var polar = polarModel.coordinateSystem;
                    var radiusExtent = polar.getRadiusAxis().getExtent();
                    var ticksAngles = angleAxis.getTicksCoords();
                    if (angleAxis.type !== 'category') {
                        ticksAngles.pop();
                    }
                    zrUtil.each(elementList, function (name) {
                        if (angleAxisModel.get(name + '.show')) {
                            this['_' + name](angleAxisModel, polar, ticksAngles, radiusExtent);
                        }
                    }, this);
                },
                _axisLine: function (angleAxisModel, polar, ticksAngles, radiusExtent) {
                    var lineStyleModel = angleAxisModel.getModel('axisLine.lineStyle');
                    var circle = new graphic.Circle({
                        shape: {
                            cx: polar.cx,
                            cy: polar.cy,
                            r: radiusExtent[1]
                        },
                        style: lineStyleModel.getLineStyle(),
                        z2: 1,
                        silent: true
                    });
                    circle.style.fill = null;
                    this.group.add(circle);
                },
                _axisTick: function (angleAxisModel, polar, ticksAngles, radiusExtent) {
                    var tickModel = angleAxisModel.getModel('axisTick');
                    var tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length');
                    var lines = zrUtil.map(ticksAngles, function (tickAngle) {
                        return new graphic.Line({ shape: getAxisLineShape(polar, radiusExtent[1], radiusExtent[1] + tickLen, tickAngle) });
                    });
                    this.group.add(graphic.mergePath(lines, { style: tickModel.getModel('lineStyle').getLineStyle() }));
                },
                _axisLabel: function (angleAxisModel, polar, ticksAngles, radiusExtent) {
                    var axis = angleAxisModel.axis;
                    var categoryData = angleAxisModel.get('data');
                    var labelModel = angleAxisModel.getModel('axisLabel');
                    var axisTextStyleModel = labelModel.getModel('textStyle');
                    var labels = angleAxisModel.getFormattedLabels();
                    var labelMargin = labelModel.get('margin');
                    var labelsAngles = axis.getLabelsCoords();
                    for (var i = 0; i < ticksAngles.length; i++) {
                        var r = radiusExtent[1];
                        var p = polar.coordToPoint([
                            r + labelMargin,
                            labelsAngles[i]
                        ]);
                        var cx = polar.cx;
                        var cy = polar.cy;
                        var labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? 'center' : p[0] > cx ? 'left' : 'right';
                        var labelTextBaseline = Math.abs(p[1] - cy) / r < 0.3 ? 'middle' : p[1] > cy ? 'top' : 'bottom';
                        var textStyleModel = axisTextStyleModel;
                        if (categoryData && categoryData[i] && categoryData[i].textStyle) {
                            textStyleModel = new Model(categoryData[i].textStyle, axisTextStyleModel);
                        }
                        this.group.add(new graphic.Text({
                            style: {
                                x: p[0],
                                y: p[1],
                                fill: textStyleModel.getTextColor(),
                                text: labels[i],
                                textAlign: labelTextAlign,
                                textVerticalAlign: labelTextBaseline,
                                textFont: textStyleModel.getFont()
                            },
                            silent: true
                        }));
                    }
                },
                _splitLine: function (angleAxisModel, polar, ticksAngles, radiusExtent) {
                    var splitLineModel = angleAxisModel.getModel('splitLine');
                    var lineStyleModel = splitLineModel.getModel('lineStyle');
                    var lineColors = lineStyleModel.get('color');
                    var lineCount = 0;
                    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
                    var splitLines = [];
                    for (var i = 0; i < ticksAngles.length; i++) {
                        var colorIndex = lineCount++ % lineColors.length;
                        splitLines[colorIndex] = splitLines[colorIndex] || [];
                        splitLines[colorIndex].push(new graphic.Line({ shape: getAxisLineShape(polar, radiusExtent[0], radiusExtent[1], ticksAngles[i]) }));
                    }
                    for (var i = 0; i < splitLines.length; i++) {
                        this.group.add(graphic.mergePath(splitLines[i], {
                            style: zrUtil.defaults({ stroke: lineColors[i % lineColors.length] }, lineStyleModel.getLineStyle()),
                            silent: true,
                            z: angleAxisModel.get('z')
                        }));
                    }
                },
                _splitArea: function (angleAxisModel, polar, ticksAngles, radiusExtent) {
                    var splitAreaModel = angleAxisModel.getModel('splitArea');
                    var areaStyleModel = splitAreaModel.getModel('areaStyle');
                    var areaColors = areaStyleModel.get('color');
                    var lineCount = 0;
                    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
                    var splitAreas = [];
                    var RADIAN = Math.PI / 180;
                    var prevAngle = -ticksAngles[0] * RADIAN;
                    var r0 = Math.min(radiusExtent[0], radiusExtent[1]);
                    var r1 = Math.max(radiusExtent[0], radiusExtent[1]);
                    var clockwise = angleAxisModel.get('clockwise');
                    for (var i = 1; i < ticksAngles.length; i++) {
                        var colorIndex = lineCount++ % areaColors.length;
                        splitAreas[colorIndex] = splitAreas[colorIndex] || [];
                        splitAreas[colorIndex].push(new graphic.Sector({
                            shape: {
                                cx: polar.cx,
                                cy: polar.cy,
                                r0: r0,
                                r: r1,
                                startAngle: prevAngle,
                                endAngle: -ticksAngles[i] * RADIAN,
                                clockwise: clockwise
                            },
                            silent: true
                        }));
                        prevAngle = -ticksAngles[i] * RADIAN;
                    }
                    for (var i = 0; i < splitAreas.length; i++) {
                        this.group.add(graphic.mergePath(splitAreas[i], {
                            style: zrUtil.defaults({ fill: areaColors[i % areaColors.length] }, areaStyleModel.getAreaStyle()),
                            silent: true
                        }));
                    }
                }
            });
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(273);
            __webpack_require__(282);
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var AxisBuilder = __webpack_require__(126);
            var axisBuilderAttrs = [
                'axisLine',
                'axisLabel',
                'axisTick',
                'axisName'
            ];
            var selfBuilderAttrs = [
                'splitLine',
                'splitArea'
            ];
            __webpack_require__(1).extendComponentView({
                type: 'radiusAxis',
                render: function (radiusAxisModel, ecModel) {
                    this.group.removeAll();
                    if (!radiusAxisModel.get('show')) {
                        return;
                    }
                    var polarModel = ecModel.getComponent('polar', radiusAxisModel.get('polarIndex'));
                    var angleAxis = polarModel.coordinateSystem.getAngleAxis();
                    var radiusAxis = radiusAxisModel.axis;
                    var polar = polarModel.coordinateSystem;
                    var ticksCoords = radiusAxis.getTicksCoords();
                    var axisAngle = angleAxis.getExtent()[0];
                    var radiusExtent = radiusAxis.getExtent();
                    var layout = layoutAxis(polar, radiusAxisModel, axisAngle);
                    var axisBuilder = new AxisBuilder(radiusAxisModel, layout);
                    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
                    this.group.add(axisBuilder.getGroup());
                    zrUtil.each(selfBuilderAttrs, function (name) {
                        if (radiusAxisModel.get(name + '.show')) {
                            this['_' + name](radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords);
                        }
                    }, this);
                },
                _splitLine: function (radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
                    var splitLineModel = radiusAxisModel.getModel('splitLine');
                    var lineStyleModel = splitLineModel.getModel('lineStyle');
                    var lineColors = lineStyleModel.get('color');
                    var lineCount = 0;
                    lineColors = lineColors instanceof Array ? lineColors : [lineColors];
                    var splitLines = [];
                    for (var i = 0; i < ticksCoords.length; i++) {
                        var colorIndex = lineCount++ % lineColors.length;
                        splitLines[colorIndex] = splitLines[colorIndex] || [];
                        splitLines[colorIndex].push(new graphic.Circle({
                            shape: {
                                cx: polar.cx,
                                cy: polar.cy,
                                r: ticksCoords[i]
                            },
                            silent: true
                        }));
                    }
                    for (var i = 0; i < splitLines.length; i++) {
                        this.group.add(graphic.mergePath(splitLines[i], {
                            style: zrUtil.defaults({
                                stroke: lineColors[i % lineColors.length],
                                fill: null
                            }, lineStyleModel.getLineStyle()),
                            silent: true
                        }));
                    }
                },
                _splitArea: function (radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
                    var splitAreaModel = radiusAxisModel.getModel('splitArea');
                    var areaStyleModel = splitAreaModel.getModel('areaStyle');
                    var areaColors = areaStyleModel.get('color');
                    var lineCount = 0;
                    areaColors = areaColors instanceof Array ? areaColors : [areaColors];
                    var splitAreas = [];
                    var prevRadius = ticksCoords[0];
                    for (var i = 1; i < ticksCoords.length; i++) {
                        var colorIndex = lineCount++ % areaColors.length;
                        splitAreas[colorIndex] = splitAreas[colorIndex] || [];
                        splitAreas[colorIndex].push(new graphic.Sector({
                            shape: {
                                cx: polar.cx,
                                cy: polar.cy,
                                r0: prevRadius,
                                r: ticksCoords[i],
                                startAngle: 0,
                                endAngle: Math.PI * 2
                            },
                            silent: true
                        }));
                        prevRadius = ticksCoords[i];
                    }
                    for (var i = 0; i < splitAreas.length; i++) {
                        this.group.add(graphic.mergePath(splitAreas[i], {
                            style: zrUtil.defaults({ fill: areaColors[i % areaColors.length] }, areaStyleModel.getAreaStyle()),
                            silent: true
                        }));
                    }
                }
            });
            function layoutAxis(polar, radiusAxisModel, axisAngle) {
                return {
                    position: [
                        polar.cx,
                        polar.cy
                    ],
                    rotation: axisAngle / 180 * Math.PI,
                    labelDirection: -1,
                    tickDirection: -1,
                    nameDirection: 1,
                    labelRotation: radiusAxisModel.getModel('axisLabel').get('rotate'),
                    z2: 1
                };
            }
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(163);
            __webpack_require__(284);
            __webpack_require__(161);
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var MapDraw = __webpack_require__(158);
            module.exports = __webpack_require__(1).extendComponentView({
                type: 'geo',
                init: function (ecModel, api) {
                    var mapDraw = new MapDraw(api, true);
                    this._mapDraw = mapDraw;
                    this.group.add(mapDraw.group);
                },
                render: function (geoModel, ecModel, api) {
                    geoModel.get('show') && this._mapDraw.draw(geoModel, ecModel, api);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var echarts = __webpack_require__(1);
            var graphic = __webpack_require__(42);
            var layout = __webpack_require__(21);
            echarts.extendComponentModel({
                type: 'title',
                layoutMode: {
                    type: 'box',
                    ignoreSize: true
                },
                defaultOption: {
                    zlevel: 0,
                    z: 6,
                    show: true,
                    text: '',
                    target: 'blank',
                    subtext: '',
                    subtarget: 'blank',
                    left: 0,
                    top: 0,
                    backgroundColor: 'rgba(0,0,0,0)',
                    borderColor: '#ccc',
                    borderWidth: 0,
                    padding: 5,
                    itemGap: 10,
                    textStyle: {
                        fontSize: 18,
                        fontWeight: 'bolder',
                        color: '#333'
                    },
                    subtextStyle: { color: '#aaa' }
                }
            });
            echarts.extendComponentView({
                type: 'title',
                render: function (titleModel, ecModel, api) {
                    this.group.removeAll();
                    if (!titleModel.get('show')) {
                        return;
                    }
                    var group = this.group;
                    var textStyleModel = titleModel.getModel('textStyle');
                    var subtextStyleModel = titleModel.getModel('subtextStyle');
                    var textAlign = titleModel.get('textAlign');
                    var textEl = new graphic.Text({
                        style: {
                            text: titleModel.get('text'),
                            textFont: textStyleModel.getFont(),
                            fill: textStyleModel.getTextColor(),
                            textBaseline: 'top'
                        },
                        z2: 10
                    });
                    var textRect = textEl.getBoundingRect();
                    var subText = titleModel.get('subtext');
                    var subTextEl = new graphic.Text({
                        style: {
                            text: subText,
                            textFont: subtextStyleModel.getFont(),
                            fill: subtextStyleModel.getTextColor(),
                            y: textRect.height + titleModel.get('itemGap'),
                            textBaseline: 'top'
                        },
                        z2: 10
                    });
                    var link = titleModel.get('link');
                    var sublink = titleModel.get('sublink');
                    textEl.silent = !link;
                    subTextEl.silent = !sublink;
                    if (link) {
                        textEl.on('click', function () {
                            window.open(link, '_' + titleModel.get('target'));
                        });
                    }
                    if (sublink) {
                        subTextEl.on('click', function () {
                            window.open(sublink, '_' + titleModel.get('subtarget'));
                        });
                    }
                    group.add(textEl);
                    subText && group.add(subTextEl);
                    var groupRect = group.getBoundingRect();
                    var layoutOption = titleModel.getBoxLayoutParams();
                    layoutOption.width = groupRect.width;
                    layoutOption.height = groupRect.height;
                    var layoutRect = layout.getLayoutRect(layoutOption, {
                        width: api.getWidth(),
                        height: api.getHeight()
                    }, titleModel.get('padding'));
                    if (!textAlign) {
                        textAlign = titleModel.get('left') || titleModel.get('right');
                        if (textAlign === 'middle') {
                            textAlign = 'center';
                        }
                        if (textAlign === 'right') {
                            layoutRect.x += layoutRect.width;
                        } else if (textAlign === 'center') {
                            layoutRect.x += layoutRect.width / 2;
                        }
                    }
                    group.position = [
                        layoutRect.x,
                        layoutRect.y
                    ];
                    textEl.setStyle('textAlign', textAlign);
                    subTextEl.setStyle('textAlign', textAlign);
                    groupRect = group.getBoundingRect();
                    var padding = layoutRect.margin;
                    var style = titleModel.getItemStyle([
                        'color',
                        'opacity'
                    ]);
                    style.fill = titleModel.get('backgroundColor');
                    var rect = new graphic.Rect({
                        shape: {
                            x: groupRect.x - padding[3],
                            y: groupRect.y - padding[0],
                            width: groupRect.width + padding[1] + padding[3],
                            height: groupRect.height + padding[0] + padding[2]
                        },
                        style: style,
                        silent: true
                    });
                    graphic.subPixelOptimizeRect(rect);
                    group.add(rect);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(287);
            __webpack_require__(288);
            __webpack_require__(290);
            __webpack_require__(291);
            __webpack_require__(292);
            __webpack_require__(295);
            __webpack_require__(296);
            __webpack_require__(298);
            __webpack_require__(299);
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(19).registerSubTypeDefaulter('dataZoom', function (option) {
                return 'slider';
            });
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var env = __webpack_require__(78);
            var echarts = __webpack_require__(1);
            var modelUtil = __webpack_require__(5);
            var AxisProxy = __webpack_require__(289);
            var each = zrUtil.each;
            var eachAxisDim = modelUtil.eachAxisDim;
            var DataZoomModel = echarts.extendComponentModel({
                type: 'dataZoom',
                dependencies: [
                    'xAxis',
                    'yAxis',
                    'zAxis',
                    'radiusAxis',
                    'angleAxis',
                    'series'
                ],
                defaultOption: {
                    zlevel: 0,
                    z: 4,
                    orient: null,
                    xAxisIndex: null,
                    yAxisIndex: null,
                    angleAxisIndex: null,
                    radiusAxisIndex: null,
                    filterMode: 'filter',
                    throttle: 100,
                    start: 0,
                    end: 100,
                    startValue: null,
                    endValue: null
                },
                init: function (option, parentModel, ecModel) {
                    this._dataIntervalByAxis = {};
                    this._dataInfo = {};
                    this._axisProxies = {};
                    this.textStyleModel;
                    var rawOption = retrieveRaw(option);
                    this.mergeDefaultAndTheme(option, ecModel);
                    this.doInit(rawOption);
                },
                mergeOption: function (newOption) {
                    var rawOption = retrieveRaw(newOption);
                    zrUtil.merge(this.option, newOption, true);
                    this.doInit(rawOption);
                },
                doInit: function (rawOption) {
                    var thisOption = this.option;
                    if (!env.canvasSupported) {
                        thisOption.realtime = false;
                    }
                    processRangeProp('start', 'startValue', rawOption, thisOption);
                    processRangeProp('end', 'endValue', rawOption, thisOption);
                    this.textStyleModel = this.getModel('textStyle');
                    this._resetTarget();
                    this._giveAxisProxies();
                },
                _giveAxisProxies: function () {
                    var axisProxies = this._axisProxies;
                    this.eachTargetAxis(function (dimNames, axisIndex, dataZoomModel, ecModel) {
                        var axisModel = this.dependentModels[dimNames.axis][axisIndex];
                        var axisProxy = axisModel.__dzAxisProxy || (axisModel.__dzAxisProxy = new AxisProxy(dimNames.name, axisIndex, this, ecModel));
                        axisProxies[dimNames.name + '_' + axisIndex] = axisProxy;
                    }, this);
                },
                _resetTarget: function () {
                    var thisOption = this.option;
                    var autoMode = this._judgeAutoMode();
                    eachAxisDim(function (dimNames) {
                        var axisIndexName = dimNames.axisIndex;
                        thisOption[axisIndexName] = modelUtil.normalizeToArray(thisOption[axisIndexName]);
                    }, this);
                    if (autoMode === 'axisIndex') {
                        this._autoSetAxisIndex();
                    } else if (autoMode === 'orient') {
                        this._autoSetOrient();
                    }
                },
                _judgeAutoMode: function () {
                    var thisOption = this.option;
                    var hasIndexSpecified = false;
                    eachAxisDim(function (dimNames) {
                        if (thisOption[dimNames.axisIndex] != null) {
                            hasIndexSpecified = true;
                        }
                    }, this);
                    var orient = thisOption.orient;
                    if (orient == null && hasIndexSpecified) {
                        return 'orient';
                    } else if (!hasIndexSpecified) {
                        if (orient == null) {
                            thisOption.orient = 'horizontal';
                        }
                        return 'axisIndex';
                    }
                },
                _autoSetAxisIndex: function () {
                    var autoAxisIndex = true;
                    var orient = this.get('orient', true);
                    var thisOption = this.option;
                    if (autoAxisIndex) {
                        var dimNames = orient === 'vertical' ? {
                            dim: 'y',
                            axisIndex: 'yAxisIndex',
                            axis: 'yAxis'
                        } : {
                            dim: 'x',
                            axisIndex: 'xAxisIndex',
                            axis: 'xAxis'
                        };
                        if (this.dependentModels[dimNames.axis].length) {
                            thisOption[dimNames.axisIndex] = [0];
                            autoAxisIndex = false;
                        }
                    }
                    if (autoAxisIndex) {
                        eachAxisDim(function (dimNames) {
                            if (!autoAxisIndex) {
                                return;
                            }
                            var axisIndices = [];
                            var axisModels = this.dependentModels[dimNames.axis];
                            if (axisModels.length && !axisIndices.length) {
                                for (var i = 0, len = axisModels.length; i < len; i++) {
                                    if (axisModels[i].get('type') === 'category') {
                                        axisIndices.push(i);
                                    }
                                }
                            }
                            thisOption[dimNames.axisIndex] = axisIndices;
                            if (axisIndices.length) {
                                autoAxisIndex = false;
                            }
                        }, this);
                    }
                    if (autoAxisIndex) {
                        this.ecModel.eachSeries(function (seriesModel) {
                            if (this._isSeriesHasAllAxesTypeOf(seriesModel, 'value')) {
                                eachAxisDim(function (dimNames) {
                                    var axisIndices = thisOption[dimNames.axisIndex];
                                    var axisIndex = seriesModel.get(dimNames.axisIndex);
                                    if (zrUtil.indexOf(axisIndices, axisIndex) < 0) {
                                        axisIndices.push(axisIndex);
                                    }
                                });
                            }
                        }, this);
                    }
                },
                _autoSetOrient: function () {
                    var dim;
                    this.eachTargetAxis(function (dimNames) {
                        !dim && (dim = dimNames.name);
                    }, this);
                    this.option.orient = dim === 'y' ? 'vertical' : 'horizontal';
                },
                _isSeriesHasAllAxesTypeOf: function (seriesModel, axisType) {
                    var is = true;
                    eachAxisDim(function (dimNames) {
                        var seriesAxisIndex = seriesModel.get(dimNames.axisIndex);
                        var axisModel = this.dependentModels[dimNames.axis][seriesAxisIndex];
                        if (!axisModel || axisModel.get('type') !== axisType) {
                            is = false;
                        }
                    }, this);
                    return is;
                },
                getFirstTargetAxisModel: function () {
                    var firstAxisModel;
                    eachAxisDim(function (dimNames) {
                        if (firstAxisModel == null) {
                            var indices = this.get(dimNames.axisIndex);
                            if (indices.length) {
                                firstAxisModel = this.dependentModels[dimNames.axis][indices[0]];
                            }
                        }
                    }, this);
                    return firstAxisModel;
                },
                eachTargetAxis: function (callback, context) {
                    var ecModel = this.ecModel;
                    eachAxisDim(function (dimNames) {
                        each(this.get(dimNames.axisIndex), function (axisIndex) {
                            callback.call(context, dimNames, axisIndex, this, ecModel);
                        }, this);
                    }, this);
                },
                getAxisProxy: function (dimName, axisIndex) {
                    return this._axisProxies[dimName + '_' + axisIndex];
                },
                setRawRange: function (opt) {
                    each([
                        'start',
                        'end',
                        'startValue',
                        'endValue'
                    ], function (name) {
                        this.option[name] = opt[name];
                    }, this);
                },
                getPercentRange: function () {
                    var axisProxy = this.findRepresentativeAxisProxy();
                    if (axisProxy) {
                        return axisProxy.getDataPercentWindow();
                    }
                },
                getValueRange: function (axisDimName, axisIndex) {
                    if (axisDimName == null && axisIndex == null) {
                        var axisProxy = this.findRepresentativeAxisProxy();
                        if (axisProxy) {
                            return axisProxy.getDataValueWindow();
                        }
                    } else {
                        return this.getAxisProxy(axisDimName, axisIndex).getDataValueWindow();
                    }
                },
                findRepresentativeAxisProxy: function () {
                    var axisProxies = this._axisProxies;
                    for (var key in axisProxies) {
                        if (axisProxies.hasOwnProperty(key) && axisProxies[key].hostedBy(this)) {
                            return axisProxies[key];
                        }
                    }
                    for (var key in axisProxies) {
                        if (axisProxies.hasOwnProperty(key) && !axisProxies[key].hostedBy(this)) {
                            return axisProxies[key];
                        }
                    }
                }
            });
            function retrieveRaw(option) {
                var ret = {};
                each([
                    'start',
                    'end',
                    'startValue',
                    'endValue'
                ], function (name) {
                    ret[name] = option[name];
                });
                return ret;
            }
            function processRangeProp(percentProp, valueProp, rawOption, thisOption) {
                if (rawOption[valueProp] != null && rawOption[percentProp] == null) {
                    thisOption[percentProp] = null;
                }
            }
            module.exports = DataZoomModel;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var numberUtil = __webpack_require__(7);
            var each = zrUtil.each;
            var asc = numberUtil.asc;
            var AxisProxy = function (dimName, axisIndex, dataZoomModel, ecModel) {
                this._dimName = dimName;
                this._axisIndex = axisIndex;
                this._valueWindow;
                this._percentWindow;
                this._dataExtent;
                this.ecModel = ecModel;
                this._dataZoomModel = dataZoomModel;
            };
            AxisProxy.prototype = {
                constructor: AxisProxy,
                hostedBy: function (dataZoomModel) {
                    return this._dataZoomModel === dataZoomModel;
                },
                getDataExtent: function () {
                    return this._dataExtent.slice();
                },
                getDataValueWindow: function () {
                    return this._valueWindow.slice();
                },
                getDataPercentWindow: function () {
                    return this._percentWindow.slice();
                },
                getTargetSeriesModels: function () {
                    var seriesModels = [];
                    this.ecModel.eachSeries(function (seriesModel) {
                        if (this._axisIndex === seriesModel.get(this._dimName + 'AxisIndex')) {
                            seriesModels.push(seriesModel);
                        }
                    }, this);
                    return seriesModels;
                },
                getAxisModel: function () {
                    return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex);
                },
                getOtherAxisModel: function () {
                    var axisDim = this._dimName;
                    var ecModel = this.ecModel;
                    var axisModel = this.getAxisModel();
                    var isCartesian = axisDim === 'x' || axisDim === 'y';
                    var otherAxisDim;
                    var coordSysIndexName;
                    if (isCartesian) {
                        coordSysIndexName = 'gridIndex';
                        otherAxisDim = axisDim === 'x' ? 'y' : 'x';
                    } else {
                        coordSysIndexName = 'polarIndex';
                        otherAxisDim = axisDim === 'angle' ? 'radius' : 'angle';
                    }
                    var foundOtherAxisModel;
                    ecModel.eachComponent(otherAxisDim + 'Axis', function (otherAxisModel) {
                        if ((otherAxisModel.get(coordSysIndexName) || 0) === (axisModel.get(coordSysIndexName) || 0)) {
                            foundOtherAxisModel = otherAxisModel;
                        }
                    });
                    return foundOtherAxisModel;
                },
                reset: function (dataZoomModel) {
                    if (dataZoomModel !== this._dataZoomModel) {
                        return;
                    }
                    var dataExtent = this._dataExtent = calculateDataExtent(this._dimName, this.getTargetSeriesModels());
                    var dataWindow = calculateDataWindow(dataZoomModel.option, dataExtent, this);
                    this._valueWindow = dataWindow.valueWindow;
                    this._percentWindow = dataWindow.percentWindow;
                    setAxisModel(this);
                },
                restore: function (dataZoomModel) {
                    if (dataZoomModel !== this._dataZoomModel) {
                        return;
                    }
                    this._valueWindow = this._percentWindow = null;
                    setAxisModel(this, true);
                },
                filterData: function (dataZoomModel) {
                    if (dataZoomModel !== this._dataZoomModel) {
                        return;
                    }
                    var axisDim = this._dimName;
                    var seriesModels = this.getTargetSeriesModels();
                    var filterMode = dataZoomModel.get('filterMode');
                    var valueWindow = this._valueWindow;
                    var otherAxisModel = this.getOtherAxisModel();
                    if (dataZoomModel.get('$fromToolbox') && otherAxisModel && otherAxisModel.get('type') === 'category') {
                        filterMode = 'empty';
                    }
                    each(seriesModels, function (seriesModel) {
                        var seriesData = seriesModel.getData();
                        if (!seriesData) {
                            return;
                        }
                        each(seriesModel.coordDimToDataDim(axisDim), function (dim) {
                            if (filterMode === 'empty') {
                                seriesModel.setData(seriesData.map(dim, function (value) {
                                    return !isInWindow(value) ? NaN : value;
                                }));
                            } else {
                                seriesData.filterSelf(dim, isInWindow);
                            }
                        });
                    });
                    function isInWindow(value) {
                        return value >= valueWindow[0] && value <= valueWindow[1];
                    }
                }
            };
            function calculateDataExtent(axisDim, seriesModels) {
                var dataExtent = [
                    Infinity,
                    -Infinity
                ];
                each(seriesModels, function (seriesModel) {
                    var seriesData = seriesModel.getData();
                    if (seriesData) {
                        each(seriesModel.coordDimToDataDim(axisDim), function (dim) {
                            var seriesExtent = seriesData.getDataExtent(dim);
                            seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0]);
                            seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1]);
                        });
                    }
                }, this);
                return dataExtent;
            }
            function calculateDataWindow(opt, dataExtent, axisProxy) {
                var axisModel = axisProxy.getAxisModel();
                var scale = axisModel.axis.scale;
                var percentExtent = [
                    0,
                    100
                ];
                var percentWindow = [
                    opt.start,
                    opt.end
                ];
                var valueWindow = [];
                dataExtent = dataExtent.slice();
                fixExtendByAxis(dataExtent, axisModel, scale);
                each([
                    'startValue',
                    'endValue'
                ], function (prop) {
                    valueWindow.push(opt[prop] != null ? scale.parse(opt[prop]) : null);
                });
                each([
                    0,
                    1
                ], function (idx) {
                    var boundValue = valueWindow[idx];
                    var boundPercent = percentWindow[idx];
                    if (boundPercent != null || boundValue == null) {
                        if (boundPercent == null) {
                            boundPercent = percentExtent[idx];
                        }
                        boundValue = scale.parse(numberUtil.linearMap(boundPercent, percentExtent, dataExtent, true));
                    } else {
                        boundPercent = numberUtil.linearMap(boundValue, dataExtent, percentExtent, true);
                    }
                    function round(val) {
                        return Math[idx === 0 ? 'floor' : 'ceil'](val * 1000000000000) / 1000000000000;
                    }
                    valueWindow[idx] = round(boundValue);
                    percentWindow[idx] = round(boundPercent);
                });
                return {
                    valueWindow: asc(valueWindow),
                    percentWindow: asc(percentWindow)
                };
            }
            function fixExtendByAxis(dataExtent, axisModel, scale) {
                each([
                    'min',
                    'max'
                ], function (minMax, index) {
                    var axisMax = axisModel.get(minMax, true);
                    if (axisMax != null && (axisMax + '').toLowerCase() !== 'data' + minMax) {
                        dataExtent[index] = scale.parse(axisMax);
                    }
                });
                if (!axisModel.get('scale', true)) {
                    dataExtent[0] > 0 && (dataExtent[0] = 0);
                    dataExtent[1] < 0 && (dataExtent[1] = 0);
                }
                return dataExtent;
            }
            function setAxisModel(axisProxy, isRestore) {
                var axisModel = axisProxy.getAxisModel();
                var percentWindow = axisProxy._percentWindow;
                var valueWindow = axisProxy._valueWindow;
                if (!percentWindow) {
                    return;
                }
                var isFull = isRestore || percentWindow[0] === 0 && percentWindow[1] === 100;
                var precision = !isRestore && numberUtil.getPixelPrecision(valueWindow, [
                    0,
                    500
                ]);
                var invalidPrecision = !isRestore && !(precision < 20 && precision >= 0);
                var useOrigin = isRestore || isFull || invalidPrecision;
                axisModel.setRange && axisModel.setRange(useOrigin ? null : +valueWindow[0].toFixed(precision), useOrigin ? null : +valueWindow[1].toFixed(precision));
            }
            module.exports = AxisProxy;
        },
        function (module, exports, __webpack_require__) {
            var ComponentView = __webpack_require__(28);
            module.exports = ComponentView.extend({
                type: 'dataZoom',
                render: function (dataZoomModel, ecModel, api, payload) {
                    this.dataZoomModel = dataZoomModel;
                    this.ecModel = ecModel;
                    this.api = api;
                },
                getTargetInfo: function () {
                    var dataZoomModel = this.dataZoomModel;
                    var ecModel = this.ecModel;
                    var cartesians = [];
                    var polars = [];
                    var axisModels = [];
                    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
                        var axisModel = ecModel.getComponent(dimNames.axis, axisIndex);
                        if (axisModel) {
                            axisModels.push(axisModel);
                            var gridIndex = axisModel.get('gridIndex');
                            var polarIndex = axisModel.get('polarIndex');
                            if (gridIndex != null) {
                                var coordModel = ecModel.getComponent('grid', gridIndex);
                                save(coordModel, axisModel, cartesians, gridIndex);
                            } else if (polarIndex != null) {
                                var coordModel = ecModel.getComponent('polar', polarIndex);
                                save(coordModel, axisModel, polars, polarIndex);
                            }
                        }
                    }, this);
                    function save(coordModel, axisModel, store, coordIndex) {
                        var item;
                        for (var i = 0; i < store.length; i++) {
                            if (store[i].model === coordModel) {
                                item = store[i];
                                break;
                            }
                        }
                        if (!item) {
                            store.push(item = {
                                model: coordModel,
                                axisModels: [],
                                coordIndex: coordIndex
                            });
                        }
                        item.axisModels.push(axisModel);
                    }
                    return {
                        cartesians: cartesians,
                        polars: polars,
                        axisModels: axisModels
                    };
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var DataZoomModel = __webpack_require__(288);
            var layout = __webpack_require__(21);
            var zrUtil = __webpack_require__(3);
            var SliderZoomModel = DataZoomModel.extend({
                type: 'dataZoom.slider',
                layoutMode: 'box',
                defaultOption: {
                    show: true,
                    right: 'ph',
                    top: 'ph',
                    width: 'ph',
                    height: 'ph',
                    left: null,
                    bottom: null,
                    backgroundColor: 'rgba(47,69,84,0)',
                    dataBackgroundColor: '#ddd',
                    fillerColor: 'rgba(47,69,84,0.15)',
                    handleColor: 'rgba(148,164,165,0.95)',
                    handleSize: 10,
                    labelPrecision: null,
                    labelFormatter: null,
                    showDetail: true,
                    showDataShadow: 'auto',
                    realtime: true,
                    zoomLock: false,
                    textStyle: { color: '#333' }
                },
                mergeOption: function (option) {
                    SliderZoomModel.superApply(this, 'mergeOption', arguments);
                }
            });
            module.exports = SliderZoomModel;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var throttle = __webpack_require__(293);
            var DataZoomView = __webpack_require__(290);
            var Rect = graphic.Rect;
            var numberUtil = __webpack_require__(7);
            var linearMap = numberUtil.linearMap;
            var layout = __webpack_require__(21);
            var sliderMove = __webpack_require__(294);
            var asc = numberUtil.asc;
            var bind = zrUtil.bind;
            var mathRound = Math.round;
            var mathMax = Math.max;
            var each = zrUtil.each;
            var DEFAULT_LOCATION_EDGE_GAP = 7;
            var DEFAULT_FRAME_BORDER_WIDTH = 1;
            var DEFAULT_FILLER_SIZE = 30;
            var HORIZONTAL = 'horizontal';
            var VERTICAL = 'vertical';
            var LABEL_GAP = 5;
            var SHOW_DATA_SHADOW_SERIES_TYPE = [
                'line',
                'bar',
                'candlestick',
                'scatter'
            ];
            var SliderZoomView = DataZoomView.extend({
                type: 'dataZoom.slider',
                init: function (ecModel, api) {
                    this._displayables = {};
                    this._orient;
                    this._range;
                    this._handleEnds;
                    this._size;
                    this._halfHandleSize;
                    this._location;
                    this._dragging;
                    this._dataShadowInfo;
                    this.api = api;
                },
                render: function (dataZoomModel, ecModel, api, payload) {
                    SliderZoomView.superApply(this, 'render', arguments);
                    throttle.createOrUpdate(this, '_dispatchZoomAction', this.dataZoomModel.get('throttle'), 'fixRate');
                    this._orient = dataZoomModel.get('orient');
                    this._halfHandleSize = mathRound(dataZoomModel.get('handleSize') / 2);
                    if (this.dataZoomModel.get('show') === false) {
                        this.group.removeAll();
                        return;
                    }
                    if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {
                        this._buildView();
                    }
                    this._updateView();
                },
                remove: function () {
                    SliderZoomView.superApply(this, 'remove', arguments);
                    throttle.clear(this, '_dispatchZoomAction');
                },
                dispose: function () {
                    SliderZoomView.superApply(this, 'dispose', arguments);
                    throttle.clear(this, '_dispatchZoomAction');
                },
                _buildView: function () {
                    var thisGroup = this.group;
                    thisGroup.removeAll();
                    this._resetLocation();
                    this._resetInterval();
                    var barGroup = this._displayables.barGroup = new graphic.Group();
                    this._renderBackground();
                    this._renderDataShadow();
                    this._renderHandle();
                    thisGroup.add(barGroup);
                    this._positionGroup();
                },
                _resetLocation: function () {
                    var dataZoomModel = this.dataZoomModel;
                    var api = this.api;
                    var coordRect = this._findCoordRect();
                    var ecSize = {
                        width: api.getWidth(),
                        height: api.getHeight()
                    };
                    var positionInfo = this._orient === HORIZONTAL ? {
                        right: ecSize.width - coordRect.x - coordRect.width,
                        top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP,
                        width: coordRect.width,
                        height: DEFAULT_FILLER_SIZE
                    } : {
                        right: DEFAULT_LOCATION_EDGE_GAP,
                        top: coordRect.y,
                        width: DEFAULT_FILLER_SIZE,
                        height: coordRect.height
                    };
                    var layoutParams = layout.getLayoutParams(dataZoomModel.option);
                    zrUtil.each([
                        'right',
                        'top',
                        'width',
                        'height'
                    ], function (name) {
                        if (layoutParams[name] === 'ph') {
                            layoutParams[name] = positionInfo[name];
                        }
                    });
                    var layoutRect = layout.getLayoutRect(layoutParams, ecSize, dataZoomModel.padding);
                    this._location = {
                        x: layoutRect.x,
                        y: layoutRect.y
                    };
                    this._size = [
                        layoutRect.width,
                        layoutRect.height
                    ];
                    this._orient === VERTICAL && this._size.reverse();
                },
                _positionGroup: function () {
                    var thisGroup = this.group;
                    var location = this._location;
                    var orient = this._orient;
                    var targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel();
                    var inverse = targetAxisModel && targetAxisModel.get('inverse');
                    var barGroup = this._displayables.barGroup;
                    var otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse;
                    barGroup.attr(orient === HORIZONTAL && !inverse ? {
                        scale: otherAxisInverse ? [
                            1,
                            1
                        ] : [
                            1,
                            -1
                        ]
                    } : orient === HORIZONTAL && inverse ? {
                        scale: otherAxisInverse ? [
                            -1,
                            1
                        ] : [
                            -1,
                            -1
                        ]
                    } : orient === VERTICAL && !inverse ? {
                        scale: otherAxisInverse ? [
                            1,
                            -1
                        ] : [
                            1,
                            1
                        ],
                        rotation: Math.PI / 2
                    } : {
                        scale: otherAxisInverse ? [
                            -1,
                            -1
                        ] : [
                            -1,
                            1
                        ],
                        rotation: Math.PI / 2
                    });
                    var rect = thisGroup.getBoundingRect([barGroup]);
                    thisGroup.position[0] = location.x - rect.x;
                    thisGroup.position[1] = location.y - rect.y;
                },
                _getViewExtent: function () {
                    var halfHandleSize = this._halfHandleSize;
                    var totalLength = mathMax(this._size[0], halfHandleSize * 4);
                    var extent = [
                        halfHandleSize,
                        totalLength - halfHandleSize
                    ];
                    return extent;
                },
                _renderBackground: function () {
                    var dataZoomModel = this.dataZoomModel;
                    var size = this._size;
                    this._displayables.barGroup.add(new Rect({
                        silent: true,
                        shape: {
                            x: 0,
                            y: 0,
                            width: size[0],
                            height: size[1]
                        },
                        style: { fill: dataZoomModel.get('backgroundColor') }
                    }));
                },
                _renderDataShadow: function () {
                    var info = this._dataShadowInfo = this._prepareDataShadowInfo();
                    if (!info) {
                        return;
                    }
                    var size = this._size;
                    var seriesModel = info.series;
                    var data = seriesModel.getRawData();
                    var otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() : info.otherDim;
                    var otherDataExtent = data.getDataExtent(otherDim);
                    var otherOffset = (otherDataExtent[1] - otherDataExtent[0]) * 0.3;
                    otherDataExtent = [
                        otherDataExtent[0] - otherOffset,
                        otherDataExtent[1] + otherOffset
                    ];
                    var otherShadowExtent = [
                        0,
                        size[1]
                    ];
                    var thisShadowExtent = [
                        0,
                        size[0]
                    ];
                    var points = [
                        [
                            size[0],
                            0
                        ],
                        [
                            0,
                            0
                        ]
                    ];
                    var step = thisShadowExtent[1] / (data.count() - 1);
                    var thisCoord = 0;
                    var stride = Math.round(data.count() / size[0]);
                    data.each([otherDim], function (value, index) {
                        if (stride > 0 && index % stride) {
                            thisCoord += step;
                            return;
                        }
                        var otherCoord = value == null || isNaN(value) || value === '' ? null : linearMap(value, otherDataExtent, otherShadowExtent, true);
                        otherCoord != null && points.push([
                            thisCoord,
                            otherCoord
                        ]);
                        thisCoord += step;
                    });
                    this._displayables.barGroup.add(new graphic.Polyline({
                        shape: { points: points },
                        style: {
                            fill: this.dataZoomModel.get('dataBackgroundColor'),
                            lineWidth: 0
                        },
                        silent: true,
                        z2: -20
                    }));
                },
                _prepareDataShadowInfo: function () {
                    var dataZoomModel = this.dataZoomModel;
                    var showDataShadow = dataZoomModel.get('showDataShadow');
                    if (showDataShadow === false) {
                        return;
                    }
                    var result;
                    var ecModel = this.ecModel;
                    dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
                        var seriesModels = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getTargetSeriesModels();
                        zrUtil.each(seriesModels, function (seriesModel) {
                            if (result) {
                                return;
                            }
                            if (showDataShadow !== true && zrUtil.indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {
                                return;
                            }
                            var otherDim = getOtherDim(dimNames.name);
                            var thisAxis = ecModel.getComponent(dimNames.axis, axisIndex).axis;
                            result = {
                                thisAxis: thisAxis,
                                series: seriesModel,
                                thisDim: dimNames.name,
                                otherDim: otherDim,
                                otherAxisInverse: seriesModel.coordinateSystem.getOtherAxis(thisAxis).inverse
                            };
                        }, this);
                    }, this);
                    return result;
                },
                _renderHandle: function () {
                    var displaybles = this._displayables;
                    var handles = displaybles.handles = [];
                    var handleLabels = displaybles.handleLabels = [];
                    var barGroup = this._displayables.barGroup;
                    var size = this._size;
                    barGroup.add(displaybles.filler = new Rect({
                        draggable: true,
                        cursor: 'move',
                        drift: bind(this._onDragMove, this, 'all'),
                        ondragend: bind(this._onDragEnd, this),
                        onmouseover: bind(this._showDataInfo, this, true),
                        onmouseout: bind(this._showDataInfo, this, false),
                        style: {
                            fill: this.dataZoomModel.get('fillerColor'),
                            textPosition: 'inside'
                        }
                    }));
                    barGroup.add(new Rect(graphic.subPixelOptimizeRect({
                        silent: true,
                        shape: {
                            x: 0,
                            y: 0,
                            width: size[0],
                            height: size[1]
                        },
                        style: {
                            stroke: this.dataZoomModel.get('dataBackgroundColor'),
                            lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
                            fill: 'rgba(0,0,0,0)'
                        }
                    })));
                    each([
                        0,
                        1
                    ], function (handleIndex) {
                        barGroup.add(handles[handleIndex] = new Rect({
                            style: { fill: this.dataZoomModel.get('handleColor') },
                            cursor: 'move',
                            draggable: true,
                            drift: bind(this._onDragMove, this, handleIndex),
                            ondragend: bind(this._onDragEnd, this),
                            onmouseover: bind(this._showDataInfo, this, true),
                            onmouseout: bind(this._showDataInfo, this, false)
                        }));
                        var textStyleModel = this.dataZoomModel.textStyleModel;
                        this.group.add(handleLabels[handleIndex] = new graphic.Text({
                            silent: true,
                            invisible: true,
                            style: {
                                x: 0,
                                y: 0,
                                text: '',
                                textVerticalAlign: 'middle',
                                textAlign: 'center',
                                fill: textStyleModel.getTextColor(),
                                textFont: textStyleModel.getFont()
                            }
                        }));
                    }, this);
                },
                _resetInterval: function () {
                    var range = this._range = this.dataZoomModel.getPercentRange();
                    var viewExtent = this._getViewExtent();
                    this._handleEnds = [
                        linearMap(range[0], [
                            0,
                            100
                        ], viewExtent, true),
                        linearMap(range[1], [
                            0,
                            100
                        ], viewExtent, true)
                    ];
                },
                _updateInterval: function (handleIndex, delta) {
                    var handleEnds = this._handleEnds;
                    var viewExtend = this._getViewExtent();
                    sliderMove(delta, handleEnds, viewExtend, handleIndex === 'all' || this.dataZoomModel.get('zoomLock') ? 'rigid' : 'cross', handleIndex);
                    this._range = asc([
                        linearMap(handleEnds[0], viewExtend, [
                            0,
                            100
                        ], true),
                        linearMap(handleEnds[1], viewExtend, [
                            0,
                            100
                        ], true)
                    ]);
                },
                _updateView: function () {
                    var displaybles = this._displayables;
                    var handleEnds = this._handleEnds;
                    var handleInterval = asc(handleEnds.slice());
                    var size = this._size;
                    var halfHandleSize = this._halfHandleSize;
                    each([
                        0,
                        1
                    ], function (handleIndex) {
                        var handle = displaybles.handles[handleIndex];
                        handle.setShape({
                            x: handleEnds[handleIndex] - halfHandleSize,
                            y: -1,
                            width: halfHandleSize * 2,
                            height: size[1] + 2,
                            r: 1
                        });
                    }, this);
                    displaybles.filler.setShape({
                        x: handleInterval[0],
                        y: 0,
                        width: handleInterval[1] - handleInterval[0],
                        height: this._size[1]
                    });
                    this._updateDataInfo();
                },
                _updateDataInfo: function () {
                    var dataZoomModel = this.dataZoomModel;
                    var displaybles = this._displayables;
                    var handleLabels = displaybles.handleLabels;
                    var orient = this._orient;
                    var labelTexts = [
                        '',
                        ''
                    ];
                    if (dataZoomModel.get('showDetail')) {
                        var dataInterval;
                        var axis;
                        dataZoomModel.eachTargetAxis(function (dimNames, axisIndex) {
                            if (!dataInterval) {
                                dataInterval = dataZoomModel.getAxisProxy(dimNames.name, axisIndex).getDataValueWindow();
                                axis = this.ecModel.getComponent(dimNames.axis, axisIndex).axis;
                            }
                        }, this);
                        if (dataInterval) {
                            labelTexts = [
                                this._formatLabel(dataInterval[0], axis),
                                this._formatLabel(dataInterval[1], axis)
                            ];
                        }
                    }
                    var orderedHandleEnds = asc(this._handleEnds.slice());
                    setLabel.call(this, 0);
                    setLabel.call(this, 1);
                    function setLabel(handleIndex) {
                        var barTransform = graphic.getTransform(displaybles.handles[handleIndex], this.group);
                        var direction = graphic.transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform);
                        var offset = this._halfHandleSize + LABEL_GAP;
                        var textPoint = graphic.applyTransform([
                            orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset),
                            this._size[1] / 2
                        ], barTransform);
                        handleLabels[handleIndex].setStyle({
                            x: textPoint[0],
                            y: textPoint[1],
                            textVerticalAlign: orient === HORIZONTAL ? 'middle' : direction,
                            textAlign: orient === HORIZONTAL ? direction : 'center',
                            text: labelTexts[handleIndex]
                        });
                    }
                },
                _formatLabel: function (value, axis) {
                    var dataZoomModel = this.dataZoomModel;
                    var labelFormatter = dataZoomModel.get('labelFormatter');
                    if (zrUtil.isFunction(labelFormatter)) {
                        return labelFormatter(value);
                    }
                    var labelPrecision = dataZoomModel.get('labelPrecision');
                    if (labelPrecision == null || labelPrecision === 'auto') {
                        labelPrecision = axis.getPixelPrecision();
                    }
                    value = value == null && isNaN(value) ? '' : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel(Math.round(value)) : value.toFixed(Math.min(labelPrecision, 20));
                    if (zrUtil.isString(labelFormatter)) {
                        value = labelFormatter.replace('{value}', value);
                    }
                    return value;
                },
                _showDataInfo: function (showOrHide) {
                    showOrHide = this._dragging || showOrHide;
                    var handleLabels = this._displayables.handleLabels;
                    handleLabels[0].attr('invisible', !showOrHide);
                    handleLabels[1].attr('invisible', !showOrHide);
                },
                _onDragMove: function (handleIndex, dx, dy) {
                    this._dragging = true;
                    var vertex = this._applyBarTransform([
                        dx,
                        dy
                    ], true);
                    this._updateInterval(handleIndex, vertex[0]);
                    this._updateView();
                    if (this.dataZoomModel.get('realtime')) {
                        this._dispatchZoomAction();
                    }
                },
                _onDragEnd: function () {
                    this._dragging = false;
                    this._showDataInfo(false);
                    this._dispatchZoomAction();
                },
                _dispatchZoomAction: function () {
                    var range = this._range;
                    this.api.dispatchAction({
                        type: 'dataZoom',
                        from: this.uid,
                        dataZoomId: this.dataZoomModel.id,
                        start: range[0],
                        end: range[1]
                    });
                },
                _applyBarTransform: function (vertex, inverse) {
                    var barTransform = this._displayables.barGroup.getLocalTransform();
                    return graphic.applyTransform(vertex, barTransform, inverse);
                },
                _findCoordRect: function () {
                    var targetInfo = this.getTargetInfo();
                    var rect;
                    if (targetInfo.cartesians.length) {
                        rect = targetInfo.cartesians[0].model.coordinateSystem.getRect();
                    } else {
                        var width = this.api.getWidth();
                        var height = this.api.getHeight();
                        rect = {
                            x: width * 0.2,
                            y: height * 0.2,
                            width: width * 0.6,
                            height: height * 0.6
                        };
                    }
                    return rect;
                }
            });
            function getOtherDim(thisDim) {
                return thisDim === 'x' ? 'y' : 'x';
            }
            module.exports = SliderZoomView;
        },
        function (module, exports) {
            var lib = {};
            var ORIGIN_METHOD = '\0__throttleOriginMethod';
            var RATE = '\0__throttleRate';
            lib.throttle = function (fn, delay, trailing, debounce) {
                var currCall = new Date().getTime();
                var lastCall = 0;
                var lastExec = 0;
                var timer = null;
                var diff;
                var scope;
                var args;
                var isSingle = typeof fn === 'function';
                delay = delay || 0;
                if (isSingle) {
                    return createCallback();
                } else {
                    var ret = [];
                    for (var i = 0; i < fn.length; i++) {
                        ret[i] = createCallback(i);
                    }
                    return ret;
                }
                function createCallback(index) {
                    function exec() {
                        lastExec = new Date().getTime();
                        timer = null;
                        (isSingle ? fn : fn[index]).apply(scope, args || []);
                    }
                    var cb = function () {
                        currCall = new Date().getTime();
                        scope = this;
                        args = arguments;
                        diff = currCall - (debounce ? lastCall : lastExec) - delay;
                        clearTimeout(timer);
                        if (debounce) {
                            if (trailing) {
                                timer = setTimeout(exec, delay);
                            } else if (diff >= 0) {
                                exec();
                            }
                        } else {
                            if (diff >= 0) {
                                exec();
                            } else if (trailing) {
                                timer = setTimeout(exec, -diff);
                            }
                        }
                        lastCall = currCall;
                    };
                    cb.clear = function () {
                        if (timer) {
                            clearTimeout(timer);
                            timer = null;
                        }
                    };
                    return cb;
                }
            };
            lib.fixRate = function (fn, delay) {
                return delay != null ? lib.throttle(fn, delay, true, false) : fn;
            };
            lib.debounce = function (fn, delay) {
                return delay != null ? lib.throttle(fn, delay, true, true) : fn;
            };
            lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {
                var fn = obj[fnAttr];
                if (!fn || rate == null || !throttleType) {
                    return;
                }
                var originFn = fn[ORIGIN_METHOD] || fn;
                var lastRate = fn[RATE];
                if (lastRate !== rate) {
                    fn = obj[fnAttr] = lib[throttleType](originFn, rate);
                    fn[ORIGIN_METHOD] = originFn;
                    fn[RATE] = rate;
                }
            };
            lib.clear = function (obj, fnAttr) {
                var fn = obj[fnAttr];
                if (fn && fn[ORIGIN_METHOD]) {
                    obj[fnAttr] = fn[ORIGIN_METHOD];
                }
            };
            module.exports = lib;
        },
        function (module, exports) {
            module.exports = function (delta, handleEnds, extent, mode, handleIndex) {
                if (!delta) {
                    return handleEnds;
                }
                if (mode === 'rigid') {
                    delta = getRealDelta(delta, handleEnds, extent);
                    handleEnds[0] += delta;
                    handleEnds[1] += delta;
                } else {
                    delta = getRealDelta(delta, handleEnds[handleIndex], extent);
                    handleEnds[handleIndex] += delta;
                    if (mode === 'push' && handleEnds[0] > handleEnds[1]) {
                        handleEnds[1 - handleIndex] = handleEnds[handleIndex];
                    }
                }
                return handleEnds;
                function getRealDelta(delta, handleEnds, extent) {
                    var handleMinMax = !handleEnds.length ? [
                        handleEnds,
                        handleEnds
                    ] : handleEnds.slice();
                    handleEnds[0] > handleEnds[1] && handleMinMax.reverse();
                    if (delta < 0 && handleMinMax[0] + delta < extent[0]) {
                        delta = extent[0] - handleMinMax[0];
                    }
                    if (delta > 0 && handleMinMax[1] + delta > extent[1]) {
                        delta = extent[1] - handleMinMax[1];
                    }
                    return delta;
                }
            };
        },
        function (module, exports, __webpack_require__) {
            module.exports = __webpack_require__(288).extend({
                type: 'dataZoom.inside',
                defaultOption: { zoomLock: false }
            });
        },
        function (module, exports, __webpack_require__) {
            var DataZoomView = __webpack_require__(290);
            var zrUtil = __webpack_require__(3);
            var sliderMove = __webpack_require__(294);
            var roams = __webpack_require__(297);
            var bind = zrUtil.bind;
            var InsideZoomView = DataZoomView.extend({
                type: 'dataZoom.inside',
                init: function (ecModel, api) {
                    this._range;
                },
                render: function (dataZoomModel, ecModel, api, payload) {
                    InsideZoomView.superApply(this, 'render', arguments);
                    if (roams.shouldRecordRange(payload, dataZoomModel.id)) {
                        this._range = dataZoomModel.getPercentRange();
                    }
                    var coordInfoList = this.getTargetInfo().cartesians;
                    var allCoordIds = zrUtil.map(coordInfoList, function (coordInfo) {
                        return roams.generateCoordId(coordInfo.model);
                    });
                    zrUtil.each(coordInfoList, function (coordInfo) {
                        var coordModel = coordInfo.model;
                        roams.register(api, {
                            coordId: roams.generateCoordId(coordModel),
                            allCoordIds: allCoordIds,
                            coordinateSystem: coordModel.coordinateSystem,
                            dataZoomId: dataZoomModel.id,
                            throttleRage: dataZoomModel.get('throttle', true),
                            panGetRange: bind(this._onPan, this, coordInfo),
                            zoomGetRange: bind(this._onZoom, this, coordInfo)
                        });
                    }, this);
                },
                remove: function () {
                    roams.unregister(this.api, this.dataZoomModel.id);
                    InsideZoomView.superApply(this, 'remove', arguments);
                    this._range = null;
                },
                dispose: function () {
                    roams.unregister(this.api, this.dataZoomModel.id);
                    InsideZoomView.superApply(this, 'dispose', arguments);
                    this._range = null;
                },
                _onPan: function (coordInfo, controller, dx, dy) {
                    return this._range = panCartesian([
                        dx,
                        dy
                    ], this._range, controller, coordInfo);
                },
                _onZoom: function (coordInfo, controller, scale, mouseX, mouseY) {
                    var dataZoomModel = this.dataZoomModel;
                    if (dataZoomModel.option.zoomLock) {
                        return this._range;
                    }
                    return this._range = scaleCartesian(1 / scale, [
                        mouseX,
                        mouseY
                    ], this._range, controller, coordInfo, dataZoomModel);
                }
            });
            function panCartesian(pixelDeltas, range, controller, coordInfo) {
                range = range.slice();
                var axisModel = coordInfo.axisModels[0];
                if (!axisModel) {
                    return;
                }
                var directionInfo = getDirectionInfo(pixelDeltas, axisModel, controller);
                var percentDelta = directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength;
                sliderMove(percentDelta, range, [
                    0,
                    100
                ], 'rigid');
                return range;
            }
            function scaleCartesian(scale, mousePoint, range, controller, coordInfo, dataZoomModel) {
                range = range.slice();
                var axisModel = coordInfo.axisModels[0];
                if (!axisModel) {
                    return;
                }
                var directionInfo = getDirectionInfo(mousePoint, axisModel, controller);
                var mouse = directionInfo.pixel - directionInfo.pixelStart;
                var percentPoint = mouse / directionInfo.pixelLength * (range[1] - range[0]) + range[0];
                scale = Math.max(scale, 0);
                range[0] = (range[0] - percentPoint) * scale + percentPoint;
                range[1] = (range[1] - percentPoint) * scale + percentPoint;
                return fixRange(range);
            }
            function getDirectionInfo(xy, axisModel, controller) {
                var axis = axisModel.axis;
                var rect = controller.rect;
                var ret = {};
                if (axis.dim === 'x') {
                    ret.pixel = xy[0];
                    ret.pixelLength = rect.width;
                    ret.pixelStart = rect.x;
                    ret.signal = axis.inverse ? 1 : -1;
                } else {
                    ret.pixel = xy[1];
                    ret.pixelLength = rect.height;
                    ret.pixelStart = rect.y;
                    ret.signal = axis.inverse ? -1 : 1;
                }
                return ret;
            }
            function fixRange(range) {
                var bound = [
                    0,
                    100
                ];
                !(range[0] <= bound[1]) && (range[0] = bound[1]);
                !(range[1] <= bound[1]) && (range[1] = bound[1]);
                !(range[0] >= bound[0]) && (range[0] = bound[0]);
                !(range[1] >= bound[0]) && (range[1] = bound[0]);
                return range;
            }
            module.exports = InsideZoomView;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var RoamController = __webpack_require__(159);
            var throttle = __webpack_require__(293);
            var curry = zrUtil.curry;
            var ATTR = '\0_ec_dataZoom_roams';
            var roams = {
                register: function (api, dataZoomInfo) {
                    var store = giveStore(api);
                    var theDataZoomId = dataZoomInfo.dataZoomId;
                    var theCoordId = dataZoomInfo.coordId;
                    zrUtil.each(store, function (record, coordId) {
                        var dataZoomInfos = record.dataZoomInfos;
                        if (dataZoomInfos[theDataZoomId] && zrUtil.indexOf(dataZoomInfo.allCoordIds, theCoordId) < 0) {
                            delete dataZoomInfos[theDataZoomId];
                            record.count--;
                        }
                    });
                    cleanStore(store);
                    var record = store[theCoordId];
                    if (!record) {
                        record = store[theCoordId] = {
                            coordId: theCoordId,
                            dataZoomInfos: {},
                            count: 0
                        };
                        record.controller = createController(api, dataZoomInfo, record);
                        record.dispatchAction = zrUtil.curry(dispatchAction, api);
                    }
                    record.controller.rect = dataZoomInfo.coordinateSystem.getRect().clone();
                    throttle.createOrUpdate(record, 'dispatchAction', dataZoomInfo.throttleRate, 'fixRate');
                    !record.dataZoomInfos[theDataZoomId] && record.count++;
                    record.dataZoomInfos[theDataZoomId] = dataZoomInfo;
                },
                unregister: function (api, dataZoomId) {
                    var store = giveStore(api);
                    zrUtil.each(store, function (record) {
                        var dataZoomInfos = record.dataZoomInfos;
                        if (dataZoomInfos[dataZoomId]) {
                            delete dataZoomInfos[dataZoomId];
                            record.count--;
                        }
                    });
                    cleanStore(store);
                },
                shouldRecordRange: function (payload, dataZoomId) {
                    if (payload && payload.type === 'dataZoom' && payload.batch) {
                        for (var i = 0, len = payload.batch.length; i < len; i++) {
                            if (payload.batch[i].dataZoomId === dataZoomId) {
                                return false;
                            }
                        }
                    }
                    return true;
                },
                generateCoordId: function (coordModel) {
                    return coordModel.type + '\0_' + coordModel.id;
                }
            };
            function giveStore(api) {
                var zr = api.getZr();
                return zr[ATTR] || (zr[ATTR] = {});
            }
            function createController(api, dataZoomInfo, newRecord) {
                var controller = new RoamController(api.getZr());
                controller.enable();
                controller.on('pan', curry(onPan, newRecord));
                controller.on('zoom', curry(onZoom, newRecord));
                return controller;
            }
            function cleanStore(store) {
                zrUtil.each(store, function (record, coordId) {
                    if (!record.count) {
                        record.controller.off('pan').off('zoom');
                        delete store[coordId];
                    }
                });
            }
            function onPan(record, dx, dy) {
                wrapAndDispatch(record, function (info) {
                    return info.panGetRange(record.controller, dx, dy);
                });
            }
            function onZoom(record, scale, mouseX, mouseY) {
                wrapAndDispatch(record, function (info) {
                    return info.zoomGetRange(record.controller, scale, mouseX, mouseY);
                });
            }
            function wrapAndDispatch(record, getRange) {
                var batch = [];
                zrUtil.each(record.dataZoomInfos, function (info) {
                    var range = getRange(info);
                    range && batch.push({
                        dataZoomId: info.dataZoomId,
                        start: range[0],
                        end: range[1]
                    });
                });
                record.dispatchAction(batch);
            }
            function dispatchAction(api, batch) {
                api.dispatchAction({
                    type: 'dataZoom',
                    batch: batch
                });
            }
            module.exports = roams;
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            echarts.registerProcessor('filter', function (ecModel, api) {
                ecModel.eachComponent('dataZoom', function (dataZoomModel) {
                    dataZoomModel.eachTargetAxis(resetSingleAxis);
                    dataZoomModel.eachTargetAxis(filterSingleAxis);
                });
                ecModel.eachComponent('dataZoom', function (dataZoomModel) {
                    var axisProxy = dataZoomModel.findRepresentativeAxisProxy();
                    var percentRange = axisProxy.getDataPercentWindow();
                    var valueRange = axisProxy.getDataValueWindow();
                    dataZoomModel.setRawRange({
                        start: percentRange[0],
                        end: percentRange[1],
                        startValue: valueRange[0],
                        endValue: valueRange[1]
                    });
                });
            });
            function resetSingleAxis(dimNames, axisIndex, dataZoomModel) {
                dataZoomModel.getAxisProxy(dimNames.name, axisIndex).reset(dataZoomModel);
            }
            function filterSingleAxis(dimNames, axisIndex, dataZoomModel) {
                dataZoomModel.getAxisProxy(dimNames.name, axisIndex).filterData(dataZoomModel);
            }
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var modelUtil = __webpack_require__(5);
            var echarts = __webpack_require__(1);
            echarts.registerAction('dataZoom', function (payload, ecModel) {
                var linkedNodesFinder = modelUtil.createLinkedNodesFinder(zrUtil.bind(ecModel.eachComponent, ecModel, 'dataZoom'), modelUtil.eachAxisDim, function (model, dimNames) {
                    return model.get(dimNames.axisIndex);
                });
                var effectedModels = [];
                ecModel.eachComponent({
                    mainType: 'dataZoom',
                    query: payload
                }, function (model, index) {
                    effectedModels.push.apply(effectedModels, linkedNodesFinder(model).nodes);
                });
                zrUtil.each(effectedModels, function (dataZoomModel, index) {
                    dataZoomModel.setRawRange({
                        start: payload.start,
                        end: payload.end,
                        startValue: payload.startValue,
                        endValue: payload.endValue
                    });
                });
            });
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(301);
            __webpack_require__(312);
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(1).registerPreprocessor(__webpack_require__(302));
            __webpack_require__(303);
            __webpack_require__(304);
            __webpack_require__(305);
            __webpack_require__(308);
            __webpack_require__(311);
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var each = zrUtil.each;
            module.exports = function (option) {
                var visualMap = option && option.visualMap;
                if (!zrUtil.isArray(visualMap)) {
                    visualMap = visualMap ? [visualMap] : [];
                }
                each(visualMap, function (opt) {
                    if (!opt) {
                        return;
                    }
                    if (has(opt, 'splitList') && !has(opt, 'pieces')) {
                        opt.pieces = opt.splitList;
                        delete opt.splitList;
                    }
                    var pieces = opt.pieces;
                    if (pieces && zrUtil.isArray(pieces)) {
                        each(pieces, function (piece) {
                            if (zrUtil.isObject(piece)) {
                                if (has(piece, 'start') && !has(piece, 'min')) {
                                    piece.min = piece.start;
                                }
                                if (has(piece, 'end') && !has(piece, 'max')) {
                                    piece.max = piece.end;
                                }
                            }
                        });
                    }
                });
            };
            function has(obj, name) {
                return obj && obj.hasOwnProperty && obj.hasOwnProperty(name);
            }
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(19).registerSubTypeDefaulter('visualMap', function (option) {
                return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? 'continuous' : 'piecewise';
            });
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            var VisualMapping = __webpack_require__(187);
            var zrUtil = __webpack_require__(3);
            echarts.registerVisualCoding('component', function (ecModel) {
                ecModel.eachComponent('visualMap', function (visualMapModel) {
                    processSingleVisualMap(visualMapModel, ecModel);
                });
            });
            function processSingleVisualMap(visualMapModel, ecModel) {
                var visualMappings = visualMapModel.targetVisuals;
                var visualTypesMap = {};
                zrUtil.each([
                    'inRange',
                    'outOfRange'
                ], function (state) {
                    var visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state]);
                    visualTypesMap[state] = visualTypes;
                });
                visualMapModel.eachTargetSeries(function (seriesModel) {
                    var data = seriesModel.getData();
                    var dimension = visualMapModel.getDataDimension(data);
                    var dataIndex;
                    function getVisual(key) {
                        return data.getItemVisual(dataIndex, key);
                    }
                    function setVisual(key, value) {
                        data.setItemVisual(dataIndex, key, value);
                    }
                    data.each([dimension], function (value, index) {
                        dataIndex = index;
                        var valueState = visualMapModel.getValueState(value);
                        var mappings = visualMappings[valueState];
                        var visualTypes = visualTypesMap[valueState];
                        for (var i = 0, len = visualTypes.length; i < len; i++) {
                            var type = visualTypes[i];
                            mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual);
                        }
                    });
                });
            }
        },
        function (module, exports, __webpack_require__) {
            var VisualMapModel = __webpack_require__(306);
            var zrUtil = __webpack_require__(3);
            var numberUtil = __webpack_require__(7);
            var DEFAULT_BAR_BOUND = [
                20,
                140
            ];
            var ContinuousModel = VisualMapModel.extend({
                type: 'visualMap.continuous',
                defaultOption: {
                    align: 'auto',
                    calculable: false,
                    range: [
                        -Infinity,
                        Infinity
                    ],
                    hoverLink: true,
                    realtime: true,
                    itemWidth: null,
                    itemHeight: null
                },
                doMergeOption: function (newOption, isInit) {
                    ContinuousModel.superApply(this, 'doMergeOption', arguments);
                    this.resetTargetSeries(newOption, isInit);
                    this.resetExtent();
                    this.resetVisual(function (mappingOption) {
                        mappingOption.mappingMethod = 'linear';
                    });
                    this._resetRange();
                },
                resetItemSize: function () {
                    VisualMapModel.prototype.resetItemSize.apply(this, arguments);
                    var itemSize = this.itemSize;
                    this._orient === 'horizontal' && itemSize.reverse();
                    (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
                    (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1]);
                },
                _resetRange: function () {
                    var dataExtent = this.getExtent();
                    var range = this.option.range;
                    if (range[0] > range[1]) {
                        range.reverse();
                    }
                    range[0] = Math.max(range[0], dataExtent[0]);
                    range[1] = Math.min(range[1], dataExtent[1]);
                },
                completeVisualOption: function () {
                    VisualMapModel.prototype.completeVisualOption.apply(this, arguments);
                    zrUtil.each(this.stateList, function (state) {
                        var symbolSize = this.option.controller[state].symbolSize;
                        if (symbolSize && symbolSize[0] !== symbolSize[1]) {
                            symbolSize[0] = 0;
                        }
                    }, this);
                },
                setSelected: function (selected) {
                    this.option.range = selected.slice();
                    this._resetRange();
                },
                getSelected: function () {
                    var dataExtent = this.getExtent();
                    var dataInterval = numberUtil.asc((this.get('range') || []).slice());
                    dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1]);
                    dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1]);
                    dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0]);
                    dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0]);
                    return dataInterval;
                },
                getValueState: function (value) {
                    var range = this.option.range;
                    var dataExtent = this.getExtent();
                    return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? 'inRange' : 'outOfRange';
                }
            });
            module.exports = ContinuousModel;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var env = __webpack_require__(78);
            var echarts = __webpack_require__(1);
            var modelUtil = __webpack_require__(5);
            var visualDefault = __webpack_require__(307);
            var VisualMapping = __webpack_require__(187);
            var mapVisual = VisualMapping.mapVisual;
            var eachVisual = VisualMapping.eachVisual;
            var numberUtil = __webpack_require__(7);
            var isArray = zrUtil.isArray;
            var each = zrUtil.each;
            var asc = numberUtil.asc;
            var linearMap = numberUtil.linearMap;
            var VisualMapModel = echarts.extendComponentModel({
                type: 'visualMap',
                dependencies: ['series'],
                dataBound: [
                    -Infinity,
                    Infinity
                ],
                stateList: [
                    'inRange',
                    'outOfRange'
                ],
                layoutMode: {
                    type: 'box',
                    ignoreSize: true
                },
                defaultOption: {
                    show: true,
                    zlevel: 0,
                    z: 4,
                    min: 0,
                    max: 200,
                    dimension: null,
                    inRange: null,
                    outOfRange: null,
                    left: 0,
                    right: null,
                    top: null,
                    bottom: 0,
                    itemWidth: null,
                    itemHeight: null,
                    inverse: false,
                    orient: 'vertical',
                    seriesIndex: null,
                    backgroundColor: 'rgba(0,0,0,0)',
                    borderColor: '#ccc',
                    contentColor: '#5793f3',
                    inactiveColor: '#aaa',
                    borderWidth: 0,
                    padding: 5,
                    textGap: 10,
                    precision: 0,
                    color: [
                        '#bf444c',
                        '#d88273',
                        '#f6efa6'
                    ],
                    formatter: null,
                    text: null,
                    textStyle: { color: '#333' }
                },
                init: function (option, parentModel, ecModel) {
                    this._dataExtent;
                    this.controllerVisuals = {};
                    this.targetVisuals = {};
                    this.textStyleModel;
                    this.itemSize;
                    this.mergeDefaultAndTheme(option, ecModel);
                    this.doMergeOption({}, true);
                },
                mergeOption: function (option) {
                    VisualMapModel.superApply(this, 'mergeOption', arguments);
                    this.doMergeOption(option, false);
                },
                doMergeOption: function (newOption, isInit) {
                    var thisOption = this.option;
                    !isInit && replaceVisualOption(thisOption, newOption);
                    if (!env.canvasSupported) {
                        thisOption.realtime = false;
                    }
                    this.textStyleModel = this.getModel('textStyle');
                    this.resetItemSize();
                    this.completeVisualOption();
                },
                formatValueText: function (value, isCategory) {
                    var option = this.option;
                    var precision = option.precision;
                    var dataBound = this.dataBound;
                    var formatter = option.formatter;
                    var isMinMax;
                    var textValue;
                    if (zrUtil.isArray(value)) {
                        value = value.slice();
                        isMinMax = true;
                    }
                    textValue = isCategory ? value : isMinMax ? [
                        toFixed(value[0]),
                        toFixed(value[1])
                    ] : toFixed(value);
                    if (zrUtil.isString(formatter)) {
                        return formatter.replace('{value}', isMinMax ? textValue[0] : textValue).replace('{value2}', isMinMax ? textValue[1] : textValue);
                    } else if (zrUtil.isFunction(formatter)) {
                        return isMinMax ? formatter(value[0], value[1]) : formatter(value);
                    }
                    if (isMinMax) {
                        if (value[0] === dataBound[0]) {
                            return '< ' + textValue[1];
                        } else if (value[1] === dataBound[1]) {
                            return '> ' + textValue[0];
                        } else {
                            return textValue[0] + ' - ' + textValue[1];
                        }
                    } else {
                        return textValue;
                    }
                    function toFixed(val) {
                        return val === dataBound[0] ? 'min' : val === dataBound[1] ? 'max' : (+val).toFixed(precision);
                    }
                },
                resetTargetSeries: function (newOption, isInit) {
                    var thisOption = this.option;
                    var allSeriesIndex = thisOption.seriesIndex == null;
                    thisOption.seriesIndex = allSeriesIndex ? [] : modelUtil.normalizeToArray(thisOption.seriesIndex);
                    allSeriesIndex && this.ecModel.eachSeries(function (seriesModel, index) {
                        var data = seriesModel.getData();
                        if (data.type === 'list') {
                            thisOption.seriesIndex.push(index);
                        }
                    });
                },
                resetExtent: function () {
                    var thisOption = this.option;
                    var extent = asc([
                        thisOption.min,
                        thisOption.max
                    ]);
                    this._dataExtent = extent;
                },
                getDataDimension: function (list) {
                    var optDim = this.option.dimension;
                    return optDim != null ? optDim : list.dimensions.length - 1;
                },
                getExtent: function () {
                    return this._dataExtent.slice();
                },
                resetVisual: function (fillVisualOption) {
                    var dataExtent = this.getExtent();
                    doReset.call(this, 'controller', this.controllerVisuals);
                    doReset.call(this, 'target', this.targetVisuals);
                    function doReset(baseAttr, visualMappings) {
                        each(this.stateList, function (state) {
                            var mappings = visualMappings[state] || (visualMappings[state] = createMappings());
                            var visaulOption = this.option[baseAttr][state] || {};
                            each(visaulOption, function (visualData, visualType) {
                                if (!VisualMapping.isValidType(visualType)) {
                                    return;
                                }
                                var mappingOption = {
                                    type: visualType,
                                    dataExtent: dataExtent,
                                    visual: visualData
                                };
                                fillVisualOption && fillVisualOption.call(this, mappingOption, state);
                                mappings[visualType] = new VisualMapping(mappingOption);
                                if (baseAttr === 'controller' && visualType === 'opacity') {
                                    mappingOption = zrUtil.clone(mappingOption);
                                    mappingOption.type = 'colorAlpha';
                                    mappings.__hidden.__alphaForOpacity = new VisualMapping(mappingOption);
                                }
                            }, this);
                        }, this);
                    }
                    function createMappings() {
                        var Creater = function () {
                        };
                        Creater.prototype.__hidden = Creater.prototype;
                        var obj = new Creater();
                        return obj;
                    }
                },
                completeVisualOption: function () {
                    var thisOption = this.option;
                    var base = {
                        inRange: thisOption.inRange,
                        outOfRange: thisOption.outOfRange
                    };
                    var target = thisOption.target || (thisOption.target = {});
                    var controller = thisOption.controller || (thisOption.controller = {});
                    zrUtil.merge(target, base);
                    zrUtil.merge(controller, base);
                    var isCategory = this.isCategory();
                    completeSingle.call(this, target);
                    completeSingle.call(this, controller);
                    completeInactive.call(this, target, 'inRange', 'outOfRange');
                    completeInactive.call(this, target, 'outOfRange', 'inRange');
                    completeController.call(this, controller);
                    function completeSingle(base) {
                        if (isArray(thisOption.color) && !base.inRange) {
                            base.inRange = { color: thisOption.color.slice().reverse() };
                        }
                        each(this.stateList, function (state) {
                            var visualType = base[state];
                            if (zrUtil.isString(visualType)) {
                                var defa = visualDefault.get(visualType, 'active', isCategory);
                                if (defa) {
                                    base[state] = {};
                                    base[state][visualType] = defa;
                                } else {
                                    delete base[state];
                                }
                            }
                        }, this);
                    }
                    function completeInactive(base, stateExist, stateAbsent) {
                        var optExist = base[stateExist];
                        var optAbsent = base[stateAbsent];
                        if (optExist && !optAbsent) {
                            optAbsent = base[stateAbsent] = {};
                            each(optExist, function (visualData, visualType) {
                                var defa = visualDefault.get(visualType, 'inactive', isCategory);
                                if (VisualMapping.isValidType(visualType) && defa) {
                                    optAbsent[visualType] = defa;
                                }
                            });
                        }
                    }
                    function completeController(controller) {
                        var symbolExists = (controller.inRange || {}).symbol || (controller.outOfRange || {}).symbol;
                        var symbolSizeExists = (controller.inRange || {}).symbolSize || (controller.outOfRange || {}).symbolSize;
                        var inactiveColor = this.get('inactiveColor');
                        each(this.stateList, function (state) {
                            var itemSize = this.itemSize;
                            var visuals = controller[state];
                            if (!visuals) {
                                visuals = controller[state] = { color: isCategory ? inactiveColor : [inactiveColor] };
                            }
                            if (!visuals.symbol) {
                                visuals.symbol = symbolExists && zrUtil.clone(symbolExists) || (isCategory ? 'roundRect' : ['roundRect']);
                            }
                            if (!visuals.symbolSize) {
                                visuals.symbolSize = symbolSizeExists && zrUtil.clone(symbolSizeExists) || (isCategory ? itemSize[0] : [
                                    itemSize[0],
                                    itemSize[0]
                                ]);
                            }
                            visuals.symbol = mapVisual(visuals.symbol, function (symbol) {
                                return symbol === 'none' || symbol === 'square' ? 'roundRect' : symbol;
                            });
                            var symbolSize = visuals.symbolSize;
                            if (symbolSize) {
                                var max = -Infinity;
                                eachVisual(symbolSize, function (value) {
                                    value > max && (max = value);
                                });
                                visuals.symbolSize = mapVisual(symbolSize, function (value) {
                                    return linearMap(value, [
                                        0,
                                        max
                                    ], [
                                        0,
                                        itemSize[0]
                                    ], true);
                                });
                            }
                        }, this);
                    }
                },
                eachTargetSeries: function (callback, context) {
                    zrUtil.each(this.option.seriesIndex, function (seriesIndex) {
                        callback.call(context, this.ecModel.getSeriesByIndex(seriesIndex));
                    }, this);
                },
                isCategory: function () {
                    return !!this.option.categories;
                },
                resetItemSize: function () {
                    this.itemSize = [
                        parseFloat(this.get('itemWidth')),
                        parseFloat(this.get('itemHeight'))
                    ];
                },
                setSelected: zrUtil.noop,
                getValueState: zrUtil.noop
            });
            function replaceVisualOption(targetOption, sourceOption) {
                zrUtil.each([
                    'inRange',
                    'outOfRange',
                    'target',
                    'controller',
                    'color'
                ], function (key) {
                    if (sourceOption.hasOwnProperty(key)) {
                        targetOption[key] = zrUtil.clone(sourceOption[key]);
                    } else {
                        delete targetOption[key];
                    }
                });
            }
            module.exports = VisualMapModel;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var visualDefault = {
                get: function (visualType, key, isCategory) {
                    var value = zrUtil.clone((defaultOption[visualType] || {})[key]);
                    return isCategory ? zrUtil.isArray(value) ? value[value.length - 1] : value : value;
                }
            };
            var defaultOption = {
                color: {
                    active: [
                        '#006edd',
                        '#e0ffff'
                    ],
                    inactive: ['rgba(0,0,0,0)']
                },
                colorHue: {
                    active: [
                        0,
                        360
                    ],
                    inactive: [
                        0,
                        0
                    ]
                },
                colorSaturation: {
                    active: [
                        0.3,
                        1
                    ],
                    inactive: [
                        0,
                        0
                    ]
                },
                colorLightness: {
                    active: [
                        0.9,
                        0.5
                    ],
                    inactive: [
                        0,
                        0
                    ]
                },
                colorAlpha: {
                    active: [
                        0.3,
                        1
                    ],
                    inactive: [
                        0,
                        0
                    ]
                },
                symbol: {
                    active: [
                        'circle',
                        'roundRect',
                        'diamond'
                    ],
                    inactive: ['none']
                },
                symbolSize: {
                    active: [
                        10,
                        50
                    ],
                    inactive: [
                        0,
                        0
                    ]
                }
            };
            module.exports = visualDefault;
        },
        function (module, exports, __webpack_require__) {
            var VisualMapView = __webpack_require__(309);
            var graphic = __webpack_require__(42);
            var zrUtil = __webpack_require__(3);
            var numberUtil = __webpack_require__(7);
            var sliderMove = __webpack_require__(294);
            var linearMap = numberUtil.linearMap;
            var LinearGradient = __webpack_require__(75);
            var helper = __webpack_require__(310);
            var each = zrUtil.each;
            var ContinuousVisualMapView = VisualMapView.extend({
                type: 'visualMap.continuous',
                init: function () {
                    VisualMapView.prototype.init.apply(this, arguments);
                    this._shapes = {};
                    this._dataInterval = [];
                    this._handleEnds = [];
                    this._orient;
                    this._useHandle;
                },
                doRender: function (visualMapModel, ecModel, api, payload) {
                    if (!payload || payload.type !== 'selectDataRange' || payload.from !== this.uid) {
                        this._buildView();
                    } else {
                        this._updateView();
                    }
                },
                _buildView: function () {
                    this.group.removeAll();
                    var visualMapModel = this.visualMapModel;
                    var thisGroup = this.group;
                    this._orient = visualMapModel.get('orient');
                    this._useHandle = visualMapModel.get('calculable');
                    this._resetInterval();
                    this._renderBar(thisGroup);
                    var dataRangeText = visualMapModel.get('text');
                    this._renderEndsText(thisGroup, dataRangeText, 0);
                    this._renderEndsText(thisGroup, dataRangeText, 1);
                    this._updateView(true);
                    this.renderBackground(thisGroup);
                    this._updateView();
                    this.positionGroup(thisGroup);
                },
                _renderEndsText: function (group, dataRangeText, endsIndex) {
                    if (!dataRangeText) {
                        return;
                    }
                    var text = dataRangeText[1 - endsIndex];
                    text = text != null ? text + '' : '';
                    var visualMapModel = this.visualMapModel;
                    var textGap = visualMapModel.get('textGap');
                    var itemSize = visualMapModel.itemSize;
                    var barGroup = this._shapes.barGroup;
                    var position = this._applyTransform([
                        itemSize[0] / 2,
                        endsIndex === 0 ? -textGap : itemSize[1] + textGap
                    ], barGroup);
                    var align = this._applyTransform(endsIndex === 0 ? 'bottom' : 'top', barGroup);
                    var orient = this._orient;
                    var textStyleModel = this.visualMapModel.textStyleModel;
                    this.group.add(new graphic.Text({
                        style: {
                            x: position[0],
                            y: position[1],
                            textVerticalAlign: orient === 'horizontal' ? 'middle' : align,
                            textAlign: orient === 'horizontal' ? align : 'center',
                            text: text,
                            textFont: textStyleModel.getFont(),
                            fill: textStyleModel.getTextColor()
                        }
                    }));
                },
                _renderBar: function (targetGroup) {
                    var visualMapModel = this.visualMapModel;
                    var shapes = this._shapes;
                    var itemSize = visualMapModel.itemSize;
                    var orient = this._orient;
                    var useHandle = this._useHandle;
                    var itemAlign = helper.getItemAlign(visualMapModel, this.api, itemSize);
                    var barGroup = shapes.barGroup = this._createBarGroup(itemAlign);
                    barGroup.add(shapes.outOfRange = createPolygon());
                    barGroup.add(shapes.inRange = createPolygon(null, zrUtil.bind(this._modifyHandle, this, 'all'), useHandle ? 'move' : null));
                    var textRect = visualMapModel.textStyleModel.getTextRect('国');
                    var textSize = Math.max(textRect.width, textRect.height);
                    if (useHandle) {
                        shapes.handleGroups = [];
                        shapes.handleThumbs = [];
                        shapes.handleLabels = [];
                        shapes.handleLabelPoints = [];
                        this._createHandle(barGroup, 0, itemSize, textSize, orient, itemAlign);
                        this._createHandle(barGroup, 1, itemSize, textSize, orient, itemAlign);
                    }
                    targetGroup.add(barGroup);
                },
                _createHandle: function (barGroup, handleIndex, itemSize, textSize, orient) {
                    var handleGroup = new graphic.Group({
                        position: [
                            itemSize[0],
                            0
                        ]
                    });
                    var handleThumb = createPolygon(createHandlePoints(handleIndex, textSize), zrUtil.bind(this._modifyHandle, this, handleIndex), 'move');
                    handleGroup.add(handleThumb);
                    var handleLabelPoint = {
                        x: orient === 'horizontal' ? textSize / 2 : textSize * 1.5,
                        y: orient === 'horizontal' ? handleIndex === 0 ? -(textSize * 1.5) : textSize * 1.5 : handleIndex === 0 ? -textSize / 2 : textSize / 2
                    };
                    var textStyleModel = this.visualMapModel.textStyleModel;
                    var handleLabel = new graphic.Text({
                        silent: true,
                        style: {
                            x: 0,
                            y: 0,
                            text: '',
                            textVerticalAlign: 'middle',
                            textFont: textStyleModel.getFont(),
                            fill: textStyleModel.getTextColor()
                        }
                    });
                    this.group.add(handleLabel);
                    var shapes = this._shapes;
                    shapes.handleThumbs[handleIndex] = handleThumb;
                    shapes.handleGroups[handleIndex] = handleGroup;
                    shapes.handleLabelPoints[handleIndex] = handleLabelPoint;
                    shapes.handleLabels[handleIndex] = handleLabel;
                    barGroup.add(handleGroup);
                },
                _modifyHandle: function (handleIndex, dx, dy) {
                    if (!this._useHandle) {
                        return;
                    }
                    var vertex = this._applyTransform([
                        dx,
                        dy
                    ], this._shapes.barGroup, true);
                    this._updateInterval(handleIndex, vertex[1]);
                    this.api.dispatchAction({
                        type: 'selectDataRange',
                        from: this.uid,
                        visualMapId: this.visualMapModel.id,
                        selected: this._dataInterval.slice()
                    });
                },
                _resetInterval: function () {
                    var visualMapModel = this.visualMapModel;
                    var dataInterval = this._dataInterval = visualMapModel.getSelected();
                    var dataExtent = visualMapModel.getExtent();
                    var sizeExtent = [
                        0,
                        visualMapModel.itemSize[1]
                    ];
                    this._handleEnds = [
                        linearMap(dataInterval[0], dataExtent, sizeExtent, true),
                        linearMap(dataInterval[1], dataExtent, sizeExtent, true)
                    ];
                },
                _updateInterval: function (handleIndex, delta) {
                    delta = delta || 0;
                    var visualMapModel = this.visualMapModel;
                    var handleEnds = this._handleEnds;
                    sliderMove(delta, handleEnds, [
                        0,
                        visualMapModel.itemSize[1]
                    ], handleIndex === 'all' ? 'rigid' : 'push', handleIndex);
                    var dataExtent = visualMapModel.getExtent();
                    var sizeExtent = [
                        0,
                        visualMapModel.itemSize[1]
                    ];
                    this._dataInterval = [
                        linearMap(handleEnds[0], sizeExtent, dataExtent, true),
                        linearMap(handleEnds[1], sizeExtent, dataExtent, true)
                    ];
                },
                _updateView: function (forSketch) {
                    var visualMapModel = this.visualMapModel;
                    var dataExtent = visualMapModel.getExtent();
                    var shapes = this._shapes;
                    var dataInterval = this._dataInterval;
                    var outOfRangeHandleEnds = [
                        0,
                        visualMapModel.itemSize[1]
                    ];
                    var inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds;
                    var visualInRange = this._createBarVisual(dataInterval, dataExtent, inRangeHandleEnds, 'inRange');
                    var visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, 'outOfRange');
                    shapes.inRange.setStyle({
                        fill: visualInRange.barColor,
                        opacity: visualInRange.opacity
                    }).setShape('points', visualInRange.barPoints);
                    shapes.outOfRange.setStyle({
                        fill: visualOutOfRange.barColor,
                        opacity: visualOutOfRange.opacity
                    }).setShape('points', visualOutOfRange.barPoints);
                    this._useHandle && each([
                        0,
                        1
                    ], function (handleIndex) {
                        shapes.handleThumbs[handleIndex].setStyle('fill', visualInRange.handlesColor[handleIndex]);
                        shapes.handleLabels[handleIndex].setStyle({
                            text: visualMapModel.formatValueText(dataInterval[handleIndex]),
                            textAlign: this._applyTransform(this._orient === 'horizontal' ? handleIndex === 0 ? 'bottom' : 'top' : 'left', shapes.barGroup)
                        });
                    }, this);
                    this._updateHandlePosition(inRangeHandleEnds);
                },
                _createBarVisual: function (dataInterval, dataExtent, handleEnds, forceState) {
                    var opts = {
                        forceState: forceState,
                        convertOpacityToAlpha: true
                    };
                    var colorStops = this.getControllerVisual(dataInterval, 'color', opts);
                    var symbolSizes = [
                        this.getControllerVisual(dataInterval[0], 'symbolSize', opts),
                        this.getControllerVisual(dataInterval[1], 'symbolSize', opts)
                    ];
                    var barPoints = this._createBarPoints(handleEnds, symbolSizes);
                    return {
                        barColor: new LinearGradient(0, 0, 1, 1, colorStops),
                        barPoints: barPoints,
                        handlesColor: [
                            colorStops[0].color,
                            colorStops[colorStops.length - 1].color
                        ]
                    };
                },
                _createBarPoints: function (handleEnds, symbolSizes) {
                    var itemSize = this.visualMapModel.itemSize;
                    return [
                        [
                            itemSize[0] - symbolSizes[0],
                            handleEnds[0]
                        ],
                        [
                            itemSize[0],
                            handleEnds[0]
                        ],
                        [
                            itemSize[0],
                            handleEnds[1]
                        ],
                        [
                            itemSize[0] - symbolSizes[1],
                            handleEnds[1]
                        ]
                    ];
                },
                _createBarGroup: function (itemAlign) {
                    var orient = this._orient;
                    var inverse = this.visualMapModel.get('inverse');
                    return new graphic.Group(orient === 'horizontal' && !inverse ? {
                        scale: itemAlign === 'bottom' ? [
                            1,
                            1
                        ] : [
                            -1,
                            1
                        ],
                        rotation: Math.PI / 2
                    } : orient === 'horizontal' && inverse ? {
                        scale: itemAlign === 'bottom' ? [
                            -1,
                            1
                        ] : [
                            1,
                            1
                        ],
                        rotation: -Math.PI / 2
                    } : orient === 'vertical' && !inverse ? {
                        scale: itemAlign === 'left' ? [
                            1,
                            -1
                        ] : [
                            -1,
                            -1
                        ]
                    } : {
                        scale: itemAlign === 'left' ? [
                            1,
                            1
                        ] : [
                            -1,
                            1
                        ]
                    });
                },
                _updateHandlePosition: function (handleEnds) {
                    if (!this._useHandle) {
                        return;
                    }
                    var shapes = this._shapes;
                    each([
                        0,
                        1
                    ], function (handleIndex) {
                        var handleGroup = shapes.handleGroups[handleIndex];
                        handleGroup.position[1] = handleEnds[handleIndex];
                        var labelPoint = shapes.handleLabelPoints[handleIndex];
                        var textPoint = graphic.applyTransform([
                            labelPoint.x,
                            labelPoint.y
                        ], graphic.getTransform(handleGroup, this.group));
                        shapes.handleLabels[handleIndex].setStyle({
                            x: textPoint[0],
                            y: textPoint[1]
                        });
                    }, this);
                },
                _applyTransform: function (vertex, element, inverse) {
                    var transform = graphic.getTransform(element, this.group);
                    return graphic[zrUtil.isArray(vertex) ? 'applyTransform' : 'transformDirection'](vertex, transform, inverse);
                }
            });
            function createPolygon(points, onDrift, cursor) {
                return new graphic.Polygon({
                    shape: { points: points },
                    draggable: !!onDrift,
                    cursor: cursor,
                    drift: onDrift
                });
            }
            function createHandlePoints(handleIndex, textSize) {
                return handleIndex === 0 ? [
                    [
                        0,
                        0
                    ],
                    [
                        textSize,
                        0
                    ],
                    [
                        textSize,
                        -textSize
                    ]
                ] : [
                    [
                        0,
                        0
                    ],
                    [
                        textSize,
                        0
                    ],
                    [
                        textSize,
                        textSize
                    ]
                ];
            }
            module.exports = ContinuousVisualMapView;
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var formatUtil = __webpack_require__(6);
            var layout = __webpack_require__(21);
            var VisualMapping = __webpack_require__(187);
            module.exports = echarts.extendComponentView({
                type: 'visualMap',
                autoPositionValues: {
                    left: 1,
                    right: 1,
                    top: 1,
                    bottom: 1
                },
                init: function (ecModel, api) {
                    this.ecModel = ecModel;
                    this.api = api;
                    this.visualMapModel;
                    this._updatableShapes = {};
                },
                render: function (visualMapModel, ecModel, api, payload) {
                    this.visualMapModel = visualMapModel;
                    if (visualMapModel.get('show') === false) {
                        this.group.removeAll();
                        return;
                    }
                    this.doRender.apply(this, arguments);
                },
                renderBackground: function (group) {
                    var visualMapModel = this.visualMapModel;
                    var padding = formatUtil.normalizeCssArray(visualMapModel.get('padding') || 0);
                    var rect = group.getBoundingRect();
                    group.add(new graphic.Rect({
                        z2: -1,
                        silent: true,
                        shape: {
                            x: rect.x - padding[3],
                            y: rect.y - padding[0],
                            width: rect.width + padding[3] + padding[1],
                            height: rect.height + padding[0] + padding[2]
                        },
                        style: {
                            fill: visualMapModel.get('backgroundColor'),
                            stroke: visualMapModel.get('borderColor'),
                            lineWidth: visualMapModel.get('borderWidth')
                        }
                    }));
                },
                getControllerVisual: function (targetValue, visualCluster, opts) {
                    opts = opts || {};
                    var forceState = opts.forceState;
                    var visualMapModel = this.visualMapModel;
                    var targetIsArray = zrUtil.isArray(targetValue);
                    if (targetIsArray && (!forceState || visualCluster !== 'color')) {
                        throw new Error(targetValue);
                    }
                    var visualObj = {};
                    if (visualCluster === 'symbol') {
                        visualObj.symbol = visualMapModel.get('itemSymbol');
                    }
                    if (visualCluster === 'color') {
                        var defaultColor = visualMapModel.get('contentColor');
                        visualObj.color = targetIsArray ? [
                            {
                                color: defaultColor,
                                offset: 0
                            },
                            {
                                color: defaultColor,
                                offset: 1
                            }
                        ] : defaultColor;
                    }
                    function getter(key) {
                        return visualObj[key];
                    }
                    function setter(key, value) {
                        visualObj[key] = value;
                    }
                    var mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)];
                    var visualTypes = VisualMapping.prepareVisualTypes(mappings);
                    zrUtil.each(visualTypes, function (type) {
                        var visualMapping = mappings[type];
                        if (opts.convertOpacityToAlpha && type === 'opacity') {
                            type = 'colorAlpha';
                            visualMapping = mappings.__alphaForOpacity;
                        }
                        if (VisualMapping.dependsOn(type, visualCluster)) {
                            visualMapping && visualMapping.applyVisual(targetValue, getter, setter);
                        }
                    });
                    return visualObj[visualCluster];
                },
                positionGroup: function (group) {
                    var model = this.visualMapModel;
                    var api = this.api;
                    layout.positionGroup(group, model.getBoxLayoutParams(), {
                        width: api.getWidth(),
                        height: api.getHeight()
                    });
                },
                doRender: zrUtil.noop
            });
        },
        function (module, exports, __webpack_require__) {
            var layout = __webpack_require__(21);
            var helper = {
                getItemAlign: function (visualMapModel, api, itemSize) {
                    var modelOption = visualMapModel.option;
                    var itemAlign = modelOption.align;
                    if (itemAlign != null && itemAlign !== 'auto') {
                        return itemAlign;
                    }
                    var ecSize = {
                        width: api.getWidth(),
                        height: api.getHeight()
                    };
                    var realIndex = modelOption.orient === 'horizontal' ? 1 : 0;
                    var paramsSet = [
                        [
                            'left',
                            'right',
                            'width'
                        ],
                        [
                            'top',
                            'bottom',
                            'height'
                        ]
                    ];
                    var reals = paramsSet[realIndex];
                    var fakeValue = [
                        0,
                        null,
                        10
                    ];
                    var layoutInput = {};
                    for (var i = 0; i < 3; i++) {
                        layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i];
                        layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]];
                    }
                    var rParam = [
                        [
                            'x',
                            'width',
                            3
                        ],
                        [
                            'y',
                            'height',
                            0
                        ]
                    ][realIndex];
                    var rect = layout.getLayoutRect(layoutInput, ecSize, modelOption.padding);
                    return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1];
                }
            };
            module.exports = helper;
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            var actionInfo = {
                type: 'selectDataRange',
                event: 'dataRangeSelected',
                update: 'update'
            };
            echarts.registerAction(actionInfo, function (payload, ecModel) {
                ecModel.eachComponent({
                    mainType: 'visualMap',
                    query: payload
                }, function (model) {
                    model.setSelected(payload.selected);
                });
            });
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(1).registerPreprocessor(__webpack_require__(302));
            __webpack_require__(303);
            __webpack_require__(304);
            __webpack_require__(313);
            __webpack_require__(314);
            __webpack_require__(311);
        },
        function (module, exports, __webpack_require__) {
            var VisualMapModel = __webpack_require__(306);
            var zrUtil = __webpack_require__(3);
            var VisualMapping = __webpack_require__(187);
            var PiecewiseModel = VisualMapModel.extend({
                type: 'visualMap.piecewise',
                defaultOption: {
                    selected: null,
                    align: 'auto',
                    itemWidth: 20,
                    itemHeight: 14,
                    itemSymbol: 'roundRect',
                    pieceList: null,
                    categories: null,
                    splitNumber: 5,
                    selectedMode: 'multiple',
                    itemGap: 10
                },
                doMergeOption: function (newOption, isInit) {
                    PiecewiseModel.superApply(this, 'doMergeOption', arguments);
                    this._pieceList = [];
                    this.resetTargetSeries(newOption, isInit);
                    this.resetExtent();
                    var mode = this._mode = this._decideMode();
                    resetMethods[this._mode].call(this);
                    this._resetSelected(newOption, isInit);
                    var categories = this.option.categories;
                    this.resetVisual(function (mappingOption, state) {
                        if (mode === 'categories') {
                            mappingOption.mappingMethod = 'category';
                            mappingOption.categories = zrUtil.clone(categories);
                        } else {
                            mappingOption.mappingMethod = 'piecewise';
                            mappingOption.pieceList = zrUtil.map(this._pieceList, function (piece) {
                                var piece = zrUtil.clone(piece);
                                if (state !== 'inRange') {
                                    piece.visual = null;
                                }
                                return piece;
                            });
                        }
                    });
                },
                _resetSelected: function (newOption, isInit) {
                    var thisOption = this.option;
                    var pieceList = this._pieceList;
                    var selected = (isInit ? thisOption : newOption).selected || {};
                    thisOption.selected = selected;
                    zrUtil.each(pieceList, function (piece, index) {
                        var key = this.getSelectedMapKey(piece);
                        if (!(key in selected)) {
                            selected[key] = true;
                        }
                    }, this);
                    if (thisOption.selectedMode === 'single') {
                        var hasSel = false;
                        zrUtil.each(pieceList, function (piece, index) {
                            var key = this.getSelectedMapKey(piece);
                            if (selected[key]) {
                                hasSel ? selected[key] = false : hasSel = true;
                            }
                        }, this);
                    }
                },
                getSelectedMapKey: function (piece) {
                    return this._mode === 'categories' ? piece.value + '' : piece.index + '';
                },
                getPieceList: function () {
                    return this._pieceList;
                },
                _decideMode: function () {
                    var option = this.option;
                    return option.pieces && option.pieces.length > 0 ? 'pieces' : this.option.categories ? 'categories' : 'splitNumber';
                },
                setSelected: function (selected) {
                    this.option.selected = zrUtil.clone(selected);
                },
                getValueState: function (value) {
                    var pieceList = this._pieceList;
                    var index = VisualMapping.findPieceIndex(value, pieceList);
                    return index != null ? this.option.selected[this.getSelectedMapKey(pieceList[index])] ? 'inRange' : 'outOfRange' : 'outOfRange';
                }
            });
            var resetMethods = {
                splitNumber: function () {
                    var thisOption = this.option;
                    var precision = thisOption.precision;
                    var dataExtent = this.getExtent();
                    var splitNumber = thisOption.splitNumber;
                    splitNumber = Math.max(parseInt(splitNumber, 10), 1);
                    thisOption.splitNumber = splitNumber;
                    var splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber;
                    while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
                        precision++;
                    }
                    thisOption.precision = precision;
                    splitStep = +splitStep.toFixed(precision);
                    for (var i = 0, curr = dataExtent[0]; i < splitNumber; i++, curr += splitStep) {
                        var max = i === splitNumber - 1 ? dataExtent[1] : curr + splitStep;
                        this._pieceList.push({
                            text: this.formatValueText([
                                curr,
                                max
                            ]),
                            index: i,
                            interval: [
                                curr,
                                max
                            ]
                        });
                    }
                },
                categories: function () {
                    var thisOption = this.option;
                    zrUtil.each(thisOption.categories, function (cate) {
                        this._pieceList.push({
                            text: this.formatValueText(cate, true),
                            value: cate
                        });
                    }, this);
                    normalizeReverse(thisOption, this._pieceList);
                },
                pieces: function () {
                    var thisOption = this.option;
                    zrUtil.each(thisOption.pieces, function (pieceListItem, index) {
                        if (!zrUtil.isObject(pieceListItem)) {
                            pieceListItem = { value: pieceListItem };
                        }
                        var item = {
                            text: '',
                            index: index
                        };
                        var hasLabel;
                        if (pieceListItem.label != null) {
                            item.text = pieceListItem.label;
                            hasLabel = true;
                        }
                        if (pieceListItem.hasOwnProperty('value')) {
                            item.value = pieceListItem.value;
                            if (!hasLabel) {
                                item.text = this.formatValueText(item.value);
                            }
                        } else {
                            var min = pieceListItem.min;
                            var max = pieceListItem.max;
                            min == null && (min = -Infinity);
                            max == null && (max = Infinity);
                            if (min === max) {
                                item.value = min;
                            }
                            item.interval = [
                                min,
                                max
                            ];
                            if (!hasLabel) {
                                item.text = this.formatValueText([
                                    min,
                                    max
                                ]);
                            }
                        }
                        item.visual = VisualMapping.retrieveVisuals(pieceListItem);
                        this._pieceList.push(item);
                    }, this);
                    normalizeReverse(thisOption, this._pieceList);
                }
            };
            function normalizeReverse(thisOption, arr) {
                var inverse = thisOption.inverse;
                if (thisOption.orient === 'vertical' ? !inverse : inverse) {
                    arr.reverse();
                }
            }
            module.exports = PiecewiseModel;
        },
        function (module, exports, __webpack_require__) {
            var VisualMapView = __webpack_require__(309);
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var symbolCreators = __webpack_require__(100);
            var layout = __webpack_require__(21);
            var helper = __webpack_require__(310);
            var PiecewiseVisualMapView = VisualMapView.extend({
                type: 'visualMap.piecewise',
                doRender: function () {
                    var thisGroup = this.group;
                    thisGroup.removeAll();
                    var visualMapModel = this.visualMapModel;
                    var textGap = visualMapModel.get('textGap');
                    var textStyleModel = visualMapModel.textStyleModel;
                    var textFont = textStyleModel.getFont();
                    var textFill = textStyleModel.getTextColor();
                    var itemAlign = this._getItemAlign();
                    var itemSize = visualMapModel.itemSize;
                    var viewData = this._getViewData();
                    var showLabel = !viewData.endsText;
                    var showEndsText = !showLabel;
                    showEndsText && this._renderEndsText(thisGroup, viewData.endsText[0], itemSize);
                    zrUtil.each(viewData.pieceList, renderItem, this);
                    showEndsText && this._renderEndsText(thisGroup, viewData.endsText[1], itemSize);
                    layout.box(visualMapModel.get('orient'), thisGroup, visualMapModel.get('itemGap'));
                    this.renderBackground(thisGroup);
                    this.positionGroup(thisGroup);
                    function renderItem(item) {
                        var itemGroup = new graphic.Group();
                        itemGroup.onclick = zrUtil.bind(this._onItemClick, this, item.piece);
                        this._createItemSymbol(itemGroup, item.piece, [
                            0,
                            0,
                            itemSize[0],
                            itemSize[1]
                        ]);
                        if (showLabel) {
                            itemGroup.add(new graphic.Text({
                                style: {
                                    x: itemAlign === 'right' ? -textGap : itemSize[0] + textGap,
                                    y: itemSize[1] / 2,
                                    text: item.piece.text,
                                    textVerticalAlign: 'middle',
                                    textAlign: itemAlign,
                                    textFont: textFont,
                                    fill: textFill
                                }
                            }));
                        }
                        thisGroup.add(itemGroup);
                    }
                },
                _getItemAlign: function () {
                    var visualMapModel = this.visualMapModel;
                    var modelOption = visualMapModel.option;
                    if (modelOption.orient === 'vertical') {
                        return helper.getItemAlign(visualMapModel, this.api, visualMapModel.itemSize);
                    } else {
                        var align = modelOption.align;
                        if (!align || align === 'auto') {
                            align = 'left';
                        }
                        return align;
                    }
                },
                _renderEndsText: function (group, text, itemSize) {
                    if (!text) {
                        return;
                    }
                    var itemGroup = new graphic.Group();
                    var textStyleModel = this.visualMapModel.textStyleModel;
                    itemGroup.add(new graphic.Text({
                        style: {
                            x: itemSize[0] / 2,
                            y: itemSize[1] / 2,
                            textVerticalAlign: 'middle',
                            textAlign: 'center',
                            text: text,
                            textFont: textStyleModel.getFont(),
                            fill: textStyleModel.getTextColor()
                        }
                    }));
                    group.add(itemGroup);
                },
                _getViewData: function () {
                    var visualMapModel = this.visualMapModel;
                    var pieceList = zrUtil.map(visualMapModel.getPieceList(), function (piece, index) {
                        return {
                            piece: piece,
                            index: index
                        };
                    });
                    var endsText = visualMapModel.get('text');
                    var orient = visualMapModel.get('orient');
                    var inverse = visualMapModel.get('inverse');
                    if (orient === 'horizontal' ? inverse : !inverse) {
                        pieceList.reverse();
                    } else if (endsText) {
                        endsText = endsText.slice().reverse();
                    }
                    return {
                        pieceList: pieceList,
                        endsText: endsText
                    };
                },
                _createItemSymbol: function (group, piece, shapeParam) {
                    var representValue;
                    if (this.visualMapModel.isCategory()) {
                        representValue = piece.value;
                    } else {
                        if (piece.value != null) {
                            representValue = piece.value;
                        } else {
                            var pieceInterval = piece.interval || [];
                            representValue = (pieceInterval[0] + pieceInterval[1]) / 2;
                        }
                    }
                    group.add(symbolCreators.createSymbol(this.getControllerVisual(representValue, 'symbol'), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], this.getControllerVisual(representValue, 'color')));
                },
                _onItemClick: function (piece) {
                    var visualMapModel = this.visualMapModel;
                    var option = visualMapModel.option;
                    var selected = zrUtil.clone(option.selected);
                    var newKey = visualMapModel.getSelectedMapKey(piece);
                    if (option.selectedMode === 'single') {
                        selected[newKey] = true;
                        zrUtil.each(selected, function (o, key) {
                            selected[key] = key === newKey;
                        });
                    } else {
                        selected[newKey] = !selected[newKey];
                    }
                    this.api.dispatchAction({
                        type: 'selectDataRange',
                        from: this.uid,
                        visualMapId: this.visualMapModel.id,
                        selected: selected
                    });
                }
            });
            module.exports = PiecewiseVisualMapView;
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(316);
            __webpack_require__(317);
            __webpack_require__(1).registerPreprocessor(function (opt) {
                opt.markPoint = opt.markPoint || {};
            });
        },
        function (module, exports, __webpack_require__) {
            var modelUtil = __webpack_require__(5);
            var MarkPointModel = __webpack_require__(1).extendComponentModel({
                type: 'markPoint',
                dependencies: [
                    'series',
                    'grid',
                    'polar'
                ],
                init: function (option, parentModel, ecModel, extraOpt) {
                    this.mergeDefaultAndTheme(option, ecModel);
                    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);
                },
                mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {
                    if (!createdBySelf) {
                        ecModel.eachSeries(function (seriesModel) {
                            var markPointOpt = seriesModel.get('markPoint');
                            var mpModel = seriesModel.markPointModel;
                            if (!markPointOpt || !markPointOpt.data) {
                                seriesModel.markPointModel = null;
                                return;
                            }
                            if (!mpModel) {
                                if (isInit) {
                                    modelUtil.defaultEmphasis(markPointOpt.label, [
                                        'position',
                                        'show',
                                        'textStyle',
                                        'distance',
                                        'formatter'
                                    ]);
                                }
                                var opt = {
                                    seriesIndex: seriesModel.seriesIndex,
                                    name: seriesModel.name,
                                    createdBySelf: true
                                };
                                mpModel = new MarkPointModel(markPointOpt, this, ecModel, opt);
                            } else {
                                mpModel.mergeOption(markPointOpt, ecModel, true);
                            }
                            seriesModel.markPointModel = mpModel;
                        }, this);
                    }
                },
                defaultOption: {
                    zlevel: 0,
                    z: 5,
                    symbol: 'pin',
                    symbolSize: 50,
                    tooltip: { trigger: 'item' },
                    label: {
                        normal: {
                            show: true,
                            position: 'inside'
                        },
                        emphasis: { show: true }
                    },
                    itemStyle: {
                        normal: { borderWidth: 2 },
                        emphasis: {}
                    }
                }
            });
            module.exports = MarkPointModel;
        },
        function (module, exports, __webpack_require__) {
            var SymbolDraw = __webpack_require__(98);
            var zrUtil = __webpack_require__(3);
            var formatUtil = __webpack_require__(6);
            var modelUtil = __webpack_require__(5);
            var numberUtil = __webpack_require__(7);
            var addCommas = formatUtil.addCommas;
            var encodeHTML = formatUtil.encodeHTML;
            var List = __webpack_require__(94);
            var markerHelper = __webpack_require__(318);
            function updateMarkerLayout(mpData, seriesModel, api) {
                var coordSys = seriesModel.coordinateSystem;
                mpData.each(function (idx) {
                    var itemModel = mpData.getItemModel(idx);
                    var point;
                    var xPx = itemModel.getShallow('x');
                    var yPx = itemModel.getShallow('y');
                    if (xPx != null && yPx != null) {
                        point = [
                            numberUtil.parsePercent(xPx, api.getWidth()),
                            numberUtil.parsePercent(yPx, api.getHeight())
                        ];
                    } else if (seriesModel.getMarkerPosition) {
                        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx));
                    } else if (coordSys) {
                        var x = mpData.get(coordSys.dimensions[0], idx);
                        var y = mpData.get(coordSys.dimensions[1], idx);
                        point = coordSys.dataToPoint([
                            x,
                            y
                        ]);
                    }
                    mpData.setItemLayout(idx, point);
                });
            }
            var markPointFormatMixin = {
                getRawDataArray: function () {
                    return this.option.data;
                },
                formatTooltip: function (dataIndex) {
                    var data = this.getData();
                    var value = this.getRawValue(dataIndex);
                    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);
                    var name = data.getName(dataIndex);
                    return this.name + '<br />' + ((name ? encodeHTML(name) + ' : ' : '') + formattedValue);
                },
                getData: function () {
                    return this._data;
                },
                setData: function (data) {
                    this._data = data;
                }
            };
            zrUtil.defaults(markPointFormatMixin, modelUtil.dataFormatMixin);
            __webpack_require__(1).extendComponentView({
                type: 'markPoint',
                init: function () {
                    this._symbolDrawMap = {};
                },
                render: function (markPointModel, ecModel, api) {
                    var symbolDrawMap = this._symbolDrawMap;
                    for (var name in symbolDrawMap) {
                        symbolDrawMap[name].__keep = false;
                    }
                    ecModel.eachSeries(function (seriesModel) {
                        var mpModel = seriesModel.markPointModel;
                        mpModel && this._renderSeriesMP(seriesModel, mpModel, api);
                    }, this);
                    for (var name in symbolDrawMap) {
                        if (!symbolDrawMap[name].__keep) {
                            symbolDrawMap[name].remove();
                            this.group.remove(symbolDrawMap[name].group);
                        }
                    }
                },
                updateLayout: function (markPointModel, ecModel, api) {
                    ecModel.eachSeries(function (seriesModel) {
                        var mpModel = seriesModel.markPointModel;
                        if (mpModel) {
                            updateMarkerLayout(mpModel.getData(), seriesModel, api);
                            this._symbolDrawMap[seriesModel.name].updateLayout(mpModel);
                        }
                    }, this);
                },
                _renderSeriesMP: function (seriesModel, mpModel, api) {
                    var coordSys = seriesModel.coordinateSystem;
                    var seriesName = seriesModel.name;
                    var seriesData = seriesModel.getData();
                    var symbolDrawMap = this._symbolDrawMap;
                    var symbolDraw = symbolDrawMap[seriesName];
                    if (!symbolDraw) {
                        symbolDraw = symbolDrawMap[seriesName] = new SymbolDraw();
                    }
                    var mpData = createList(coordSys, seriesModel, mpModel);
                    zrUtil.mixin(mpModel, markPointFormatMixin);
                    mpModel.setData(mpData);
                    updateMarkerLayout(mpModel.getData(), seriesModel, api);
                    mpData.each(function (idx) {
                        var itemModel = mpData.getItemModel(idx);
                        var symbolSize = itemModel.getShallow('symbolSize');
                        if (typeof symbolSize === 'function') {
                            symbolSize = symbolSize(mpModel.getRawValue(idx), mpModel.getDataParams(idx));
                        }
                        mpData.setItemVisual(idx, {
                            symbolSize: symbolSize,
                            color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color'),
                            symbol: itemModel.getShallow('symbol')
                        });
                    });
                    symbolDraw.updateData(mpData);
                    this.group.add(symbolDraw.group);
                    mpData.eachItemGraphicEl(function (el) {
                        el.traverse(function (child) {
                            child.dataModel = mpModel;
                        });
                    });
                    symbolDraw.__keep = true;
                }
            });
            function createList(coordSys, seriesModel, mpModel) {
                var coordDimsInfos;
                if (coordSys) {
                    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {
                        var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {};
                        info.name = coordDim;
                        return info;
                    });
                } else {
                    coordDimsInfos = [{
                            name: 'value',
                            type: 'float'
                        }];
                }
                var mpData = new List(coordDimsInfos, mpModel);
                var dataOpt = zrUtil.map(mpModel.get('data'), zrUtil.curry(markerHelper.dataTransform, seriesModel));
                if (coordSys) {
                    dataOpt = zrUtil.filter(dataOpt, zrUtil.curry(markerHelper.dataFilter, coordSys));
                }
                mpData.initData(dataOpt, null, coordSys ? markerHelper.dimValueGetter : function (item) {
                    return item.value;
                });
                return mpData;
            }
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var numberUtil = __webpack_require__(7);
            var indexOf = zrUtil.indexOf;
            function getPrecision(data, valueAxisDim, dataIndex) {
                var precision = -1;
                do {
                    precision = Math.max(numberUtil.getPrecision(data.get(valueAxisDim, dataIndex)), precision);
                    data = data.stackedOn;
                } while (data);
                return precision;
            }
            function markerTypeCalculatorWithExtent(mlType, data, baseDataDim, valueDataDim, baseCoordIndex, valueCoordIndex) {
                var coordArr = [];
                var value = numCalculate(data, valueDataDim, mlType);
                var dataIndex = data.indexOfNearest(valueDataDim, value, true);
                coordArr[baseCoordIndex] = data.get(baseDataDim, dataIndex, true);
                coordArr[valueCoordIndex] = data.get(valueDataDim, dataIndex, true);
                var precision = getPrecision(data, valueDataDim, dataIndex);
                if (precision >= 0) {
                    coordArr[valueCoordIndex] = +coordArr[valueCoordIndex].toFixed(precision);
                }
                return coordArr;
            }
            var curry = zrUtil.curry;
            var markerTypeCalculator = {
                min: curry(markerTypeCalculatorWithExtent, 'min'),
                max: curry(markerTypeCalculatorWithExtent, 'max'),
                average: curry(markerTypeCalculatorWithExtent, 'average')
            };
            var dataTransform = function (seriesModel, item) {
                var data = seriesModel.getData();
                var coordSys = seriesModel.coordinateSystem;
                if ((isNaN(item.x) || isNaN(item.y)) && !zrUtil.isArray(item.coord) && coordSys) {
                    var axisInfo = getAxisInfo(item, data, coordSys, seriesModel);
                    item = zrUtil.clone(item);
                    if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
                        var dims = coordSys.dimensions;
                        var baseCoordIndex = indexOf(dims, axisInfo.baseAxis.dim);
                        var valueCoordIndex = indexOf(dims, axisInfo.valueAxis.dim);
                        item.coord = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, baseCoordIndex, valueCoordIndex);
                        item.value = item.coord[valueCoordIndex];
                    } else {
                        item.coord = [
                            item.xAxis != null ? item.xAxis : item.radiusAxis,
                            item.yAxis != null ? item.yAxis : item.angleAxis
                        ];
                    }
                }
                return item;
            };
            var getAxisInfo = function (item, data, coordSys, seriesModel) {
                var ret = {};
                if (item.valueIndex != null || item.valueDim != null) {
                    ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim;
                    ret.valueAxis = coordSys.getAxis(seriesModel.dataDimToCoordDim(ret.valueDataDim));
                    ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis);
                    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];
                } else {
                    ret.baseAxis = seriesModel.getBaseAxis();
                    ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis);
                    ret.baseDataDim = seriesModel.coordDimToDataDim(ret.baseAxis.dim)[0];
                    ret.valueDataDim = seriesModel.coordDimToDataDim(ret.valueAxis.dim)[0];
                }
                return ret;
            };
            var dataFilter = function (coordSys, item) {
                return coordSys && coordSys.containData && item.coord && (item.x == null || item.y == null) ? coordSys.containData(item.coord) : true;
            };
            var dimValueGetter = function (item, dimName, dataIndex, dimIndex) {
                if (dimIndex < 2) {
                    return item.coord && item.coord[dimIndex];
                } else {
                    return item.value;
                }
            };
            var numCalculate = function (data, valueDataDim, mlType) {
                return mlType === 'average' ? data.getSum(valueDataDim, true) / data.count() : data.getDataExtent(valueDataDim, true)[mlType === 'max' ? 1 : 0];
            };
            module.exports = {
                dataTransform: dataTransform,
                dataFilter: dataFilter,
                dimValueGetter: dimValueGetter,
                getAxisInfo: getAxisInfo,
                numCalculate: numCalculate
            };
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(320);
            __webpack_require__(321);
            __webpack_require__(1).registerPreprocessor(function (opt) {
                opt.markLine = opt.markLine || {};
            });
        },
        function (module, exports, __webpack_require__) {
            var modelUtil = __webpack_require__(5);
            var MarkLineModel = __webpack_require__(1).extendComponentModel({
                type: 'markLine',
                dependencies: [
                    'series',
                    'grid',
                    'polar'
                ],
                init: function (option, parentModel, ecModel, extraOpt) {
                    this.mergeDefaultAndTheme(option, ecModel);
                    this.mergeOption(option, ecModel, extraOpt.createdBySelf, true);
                },
                mergeOption: function (newOpt, ecModel, createdBySelf, isInit) {
                    if (!createdBySelf) {
                        ecModel.eachSeries(function (seriesModel) {
                            var markLineOpt = seriesModel.get('markLine');
                            var mlModel = seriesModel.markLineModel;
                            if (!markLineOpt || !markLineOpt.data) {
                                seriesModel.markLineModel = null;
                                return;
                            }
                            if (!mlModel) {
                                if (isInit) {
                                    modelUtil.defaultEmphasis(markLineOpt.label, [
                                        'position',
                                        'show',
                                        'textStyle',
                                        'distance',
                                        'formatter'
                                    ]);
                                }
                                var opt = {
                                    seriesIndex: seriesModel.seriesIndex,
                                    name: seriesModel.name,
                                    createdBySelf: true
                                };
                                mlModel = new MarkLineModel(markLineOpt, this, ecModel, opt);
                            } else {
                                mlModel.mergeOption(markLineOpt, ecModel, true);
                            }
                            seriesModel.markLineModel = mlModel;
                        }, this);
                    }
                },
                defaultOption: {
                    zlevel: 0,
                    z: 5,
                    symbol: [
                        'circle',
                        'arrow'
                    ],
                    symbolSize: [
                        8,
                        16
                    ],
                    precision: 2,
                    tooltip: { trigger: 'item' },
                    label: {
                        normal: {
                            show: true,
                            position: 'end'
                        },
                        emphasis: { show: true }
                    },
                    lineStyle: {
                        normal: { type: 'dashed' },
                        emphasis: { width: 3 }
                    },
                    animationEasing: 'linear'
                }
            });
            module.exports = MarkLineModel;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var List = __webpack_require__(94);
            var formatUtil = __webpack_require__(6);
            var modelUtil = __webpack_require__(5);
            var numberUtil = __webpack_require__(7);
            var addCommas = formatUtil.addCommas;
            var encodeHTML = formatUtil.encodeHTML;
            var markerHelper = __webpack_require__(318);
            var LineDraw = __webpack_require__(194);
            var markLineTransform = function (seriesModel, coordSys, mlModel, item) {
                var data = seriesModel.getData();
                var mlType = item.type;
                if (!zrUtil.isArray(item) && (mlType === 'min' || mlType === 'max' || mlType === 'average')) {
                    var axisInfo = markerHelper.getAxisInfo(item, data, coordSys, seriesModel);
                    var baseAxisKey = axisInfo.baseAxis.dim + 'Axis';
                    var valueAxisKey = axisInfo.valueAxis.dim + 'Axis';
                    var baseScaleExtent = axisInfo.baseAxis.scale.getExtent();
                    var mlFrom = zrUtil.clone(item);
                    var mlTo = {};
                    mlFrom.type = null;
                    mlFrom[baseAxisKey] = baseScaleExtent[0];
                    mlTo[baseAxisKey] = baseScaleExtent[1];
                    var value = markerHelper.numCalculate(data, axisInfo.valueDataDim, mlType);
                    value = axisInfo.valueAxis.coordToData(axisInfo.valueAxis.dataToCoord(value));
                    var precision = mlModel.get('precision');
                    if (precision >= 0) {
                        value = +value.toFixed(precision);
                    }
                    mlFrom[valueAxisKey] = mlTo[valueAxisKey] = value;
                    item = [
                        mlFrom,
                        mlTo,
                        {
                            type: mlType,
                            valueIndex: item.valueIndex,
                            value: value
                        }
                    ];
                }
                item = [
                    markerHelper.dataTransform(seriesModel, item[0]),
                    markerHelper.dataTransform(seriesModel, item[1]),
                    zrUtil.extend({}, item[2])
                ];
                item[2].type = item[2].type || '';
                zrUtil.merge(item[2], item[0]);
                zrUtil.merge(item[2], item[1]);
                return item;
            };
            function markLineFilter(coordSys, item) {
                return markerHelper.dataFilter(coordSys, item[0]) && markerHelper.dataFilter(coordSys, item[1]);
            }
            function updateSingleMarkerEndLayout(data, idx, isFrom, mlType, valueIndex, seriesModel, api) {
                var coordSys = seriesModel.coordinateSystem;
                var itemModel = data.getItemModel(idx);
                var point;
                var xPx = itemModel.get('x');
                var yPx = itemModel.get('y');
                if (xPx != null && yPx != null) {
                    point = [
                        numberUtil.parsePercent(xPx, api.getWidth()),
                        numberUtil.parsePercent(yPx, api.getHeight())
                    ];
                } else {
                    if (seriesModel.getMarkerPosition) {
                        point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx));
                    } else {
                        var dims = coordSys.dimensions;
                        var x = data.get(dims[0], idx);
                        var y = data.get(dims[1], idx);
                        point = coordSys.dataToPoint([
                            x,
                            y
                        ]);
                    }
                    if (mlType && coordSys.type === 'cartesian2d') {
                        var mlOnAxis = valueIndex != null ? coordSys.getAxis(valueIndex === 1 ? 'x' : 'y') : coordSys.getAxesByScale('ordinal')[0];
                        if (mlOnAxis && mlOnAxis.onBand) {
                            point[mlOnAxis.dim === 'x' ? 0 : 1] = mlOnAxis.toGlobalCoord(mlOnAxis.getExtent()[isFrom ? 0 : 1]);
                        }
                    }
                }
                data.setItemLayout(idx, point);
            }
            var markLineFormatMixin = {
                formatTooltip: function (dataIndex) {
                    var data = this._data;
                    var value = this.getRawValue(dataIndex);
                    var formattedValue = zrUtil.isArray(value) ? zrUtil.map(value, addCommas).join(', ') : addCommas(value);
                    var name = data.getName(dataIndex);
                    return this.name + '<br />' + ((name ? encodeHTML(name) + ' : ' : '') + formattedValue);
                },
                getRawDataArray: function () {
                    return this.option.data;
                },
                getData: function () {
                    return this._data;
                },
                setData: function (data) {
                    this._data = data;
                }
            };
            zrUtil.defaults(markLineFormatMixin, modelUtil.dataFormatMixin);
            __webpack_require__(1).extendComponentView({
                type: 'markLine',
                init: function () {
                    this._markLineMap = {};
                },
                render: function (markLineModel, ecModel, api) {
                    var lineDrawMap = this._markLineMap;
                    for (var name in lineDrawMap) {
                        lineDrawMap[name].__keep = false;
                    }
                    ecModel.eachSeries(function (seriesModel) {
                        var mlModel = seriesModel.markLineModel;
                        mlModel && this._renderSeriesML(seriesModel, mlModel, ecModel, api);
                    }, this);
                    for (var name in lineDrawMap) {
                        if (!lineDrawMap[name].__keep) {
                            this.group.remove(lineDrawMap[name].group);
                        }
                    }
                },
                updateLayout: function (markLineModel, ecModel, api) {
                    ecModel.eachSeries(function (seriesModel) {
                        var mlModel = seriesModel.markLineModel;
                        if (mlModel) {
                            var mlData = mlModel.getData();
                            var fromData = mlModel.__from;
                            var toData = mlModel.__to;
                            fromData.each(function (idx) {
                                var lineModel = mlData.getItemModel(idx);
                                var mlType = lineModel.get('type');
                                var valueIndex = lineModel.get('valueIndex');
                                updateSingleMarkerEndLayout(fromData, idx, true, mlType, valueIndex, seriesModel, api);
                                updateSingleMarkerEndLayout(toData, idx, false, mlType, valueIndex, seriesModel, api);
                            });
                            mlData.each(function (idx) {
                                mlData.setItemLayout(idx, [
                                    fromData.getItemLayout(idx),
                                    toData.getItemLayout(idx)
                                ]);
                            });
                            this._markLineMap[seriesModel.name].updateLayout();
                        }
                    }, this);
                },
                _renderSeriesML: function (seriesModel, mlModel, ecModel, api) {
                    var coordSys = seriesModel.coordinateSystem;
                    var seriesName = seriesModel.name;
                    var seriesData = seriesModel.getData();
                    var lineDrawMap = this._markLineMap;
                    var lineDraw = lineDrawMap[seriesName];
                    if (!lineDraw) {
                        lineDraw = lineDrawMap[seriesName] = new LineDraw();
                    }
                    this.group.add(lineDraw.group);
                    var mlData = createList(coordSys, seriesModel, mlModel);
                    var fromData = mlData.from;
                    var toData = mlData.to;
                    var lineData = mlData.line;
                    mlModel.__from = fromData;
                    mlModel.__to = toData;
                    zrUtil.extend(mlModel, markLineFormatMixin);
                    mlModel.setData(lineData);
                    var symbolType = mlModel.get('symbol');
                    var symbolSize = mlModel.get('symbolSize');
                    if (!zrUtil.isArray(symbolType)) {
                        symbolType = [
                            symbolType,
                            symbolType
                        ];
                    }
                    if (typeof symbolSize === 'number') {
                        symbolSize = [
                            symbolSize,
                            symbolSize
                        ];
                    }
                    mlData.from.each(function (idx) {
                        var lineModel = lineData.getItemModel(idx);
                        var mlType = lineModel.get('type');
                        var valueIndex = lineModel.get('valueIndex');
                        updateDataVisualAndLayout(fromData, idx, true, mlType, valueIndex);
                        updateDataVisualAndLayout(toData, idx, false, mlType, valueIndex);
                    });
                    lineData.each(function (idx) {
                        var lineColor = lineData.getItemModel(idx).get('lineStyle.normal.color');
                        lineData.setItemVisual(idx, { color: lineColor || fromData.getItemVisual(idx, 'color') });
                        lineData.setItemLayout(idx, [
                            fromData.getItemLayout(idx),
                            toData.getItemLayout(idx)
                        ]);
                    });
                    lineDraw.updateData(lineData, fromData, toData);
                    mlData.line.eachItemGraphicEl(function (el, idx) {
                        el.traverse(function (child) {
                            child.dataModel = mlModel;
                        });
                    });
                    function updateDataVisualAndLayout(data, idx, isFrom, mlType, valueIndex) {
                        var itemModel = data.getItemModel(idx);
                        updateSingleMarkerEndLayout(data, idx, isFrom, mlType, valueIndex, seriesModel, api);
                        data.setItemVisual(idx, {
                            symbolSize: itemModel.get('symbolSize') || symbolSize[isFrom ? 0 : 1],
                            symbol: itemModel.get('symbol', true) || symbolType[isFrom ? 0 : 1],
                            color: itemModel.get('itemStyle.normal.color') || seriesData.getVisual('color')
                        });
                    }
                    lineDraw.__keep = true;
                }
            });
            function createList(coordSys, seriesModel, mlModel) {
                var coordDimsInfos;
                if (coordSys) {
                    coordDimsInfos = zrUtil.map(coordSys && coordSys.dimensions, function (coordDim) {
                        var info = seriesModel.getData().getDimensionInfo(seriesModel.coordDimToDataDim(coordDim)[0]) || {};
                        info.name = coordDim;
                        return info;
                    });
                } else {
                    coordDimsInfos = [{
                            name: 'value',
                            type: 'float'
                        }];
                }
                var fromData = new List(coordDimsInfos, mlModel);
                var toData = new List(coordDimsInfos, mlModel);
                var lineData = new List([], mlModel);
                var optData = zrUtil.map(mlModel.get('data'), zrUtil.curry(markLineTransform, seriesModel, coordSys, mlModel));
                if (coordSys) {
                    optData = zrUtil.filter(optData, zrUtil.curry(markLineFilter, coordSys));
                }
                var dimValueGetter = coordSys ? markerHelper.dimValueGetter : function (item) {
                    return item.value;
                };
                fromData.initData(zrUtil.map(optData, function (item) {
                    return item[0];
                }), null, dimValueGetter);
                toData.initData(zrUtil.map(optData, function (item) {
                    return item[1];
                }), null, dimValueGetter);
                lineData.initData(zrUtil.map(optData, function (item) {
                    return item[2];
                }));
                return {
                    from: fromData,
                    to: toData,
                    line: lineData
                };
            }
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            echarts.registerPreprocessor(__webpack_require__(323));
            __webpack_require__(324);
            __webpack_require__(325);
            __webpack_require__(326);
            __webpack_require__(328);
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            module.exports = function (option) {
                var timelineOpt = option && option.timeline;
                if (!zrUtil.isArray(timelineOpt)) {
                    timelineOpt = timelineOpt ? [timelineOpt] : [];
                }
                zrUtil.each(timelineOpt, function (opt) {
                    if (!opt) {
                        return;
                    }
                    compatibleEC2(opt);
                });
            };
            function compatibleEC2(opt) {
                var type = opt.type;
                var ec2Types = {
                    'number': 'value',
                    'time': 'time'
                };
                if (ec2Types[type]) {
                    opt.axisType = ec2Types[type];
                    delete opt.type;
                }
                transferItem(opt);
                if (has(opt, 'controlPosition')) {
                    var controlStyle = opt.controlStyle || (opt.controlStyle = {});
                    if (!has(controlStyle, 'position')) {
                        controlStyle.position = opt.controlPosition;
                    }
                    if (controlStyle.position === 'none' && !has(controlStyle, 'show')) {
                        controlStyle.show = false;
                        delete controlStyle.position;
                    }
                    delete opt.controlPosition;
                }
                zrUtil.each(opt.data || [], function (dataItem) {
                    if (zrUtil.isObject(dataItem) && !zrUtil.isArray(dataItem)) {
                        if (!has(dataItem, 'value') && has(dataItem, 'name')) {
                            dataItem.value = dataItem.name;
                        }
                        transferItem(dataItem);
                    }
                });
            }
            function transferItem(opt) {
                var itemStyle = opt.itemStyle || (opt.itemStyle = {});
                var itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {});
                var label = opt.label || (opt.label || {});
                var labelNormal = label.normal || (label.normal = {});
                var excludeLabelAttr = {
                    normal: 1,
                    emphasis: 1
                };
                zrUtil.each(label, function (value, name) {
                    if (!excludeLabelAttr[name] && !has(labelNormal, name)) {
                        labelNormal[name] = value;
                    }
                });
                if (itemStyleEmphasis.label && !has(label, 'emphasis')) {
                    label.emphasis = itemStyleEmphasis.label;
                    delete itemStyleEmphasis.label;
                }
            }
            function has(obj, attr) {
                return obj.hasOwnProperty(attr);
            }
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(19).registerSubTypeDefaulter('timeline', function () {
                return 'slider';
            });
        },
        function (module, exports, __webpack_require__) {
            var echarts = __webpack_require__(1);
            echarts.registerAction({
                type: 'timelineChange',
                event: 'timelineChanged',
                update: 'prepareAndUpdate'
            }, function (payload, ecModel) {
                var timelineModel = ecModel.getComponent('timeline');
                if (timelineModel && payload.currentIndex != null) {
                    timelineModel.setCurrentIndex(payload.currentIndex);
                    if (!timelineModel.get('loop', true) && timelineModel.isIndexMax()) {
                        timelineModel.setPlayState(false);
                    }
                }
                ecModel.resetOption('timeline');
            });
            echarts.registerAction({
                type: 'timelinePlayChange',
                event: 'timelinePlayChanged',
                update: 'update'
            }, function (payload, ecModel) {
                var timelineModel = ecModel.getComponent('timeline');
                if (timelineModel && payload.playState != null) {
                    timelineModel.setPlayState(payload.playState);
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var TimelineModel = __webpack_require__(327);
            module.exports = TimelineModel.extend({
                type: 'timeline.slider',
                defaultOption: {
                    backgroundColor: 'rgba(0,0,0,0)',
                    borderColor: '#ccc',
                    borderWidth: 0,
                    orient: 'horizontal',
                    inverse: false,
                    tooltip: { trigger: 'item' },
                    symbol: 'emptyCircle',
                    symbolSize: 10,
                    lineStyle: {
                        show: true,
                        width: 2,
                        color: '#304654'
                    },
                    label: {
                        position: 'auto',
                        normal: {
                            show: true,
                            interval: 'auto',
                            rotate: 0,
                            textStyle: { color: '#304654' }
                        },
                        emphasis: {
                            show: true,
                            textStyle: { color: '#c23531' }
                        }
                    },
                    itemStyle: {
                        normal: {
                            color: '#304654',
                            borderWidth: 1
                        },
                        emphasis: { color: '#c23531' }
                    },
                    checkpointStyle: {
                        symbol: 'circle',
                        symbolSize: 13,
                        color: '#c23531',
                        borderWidth: 5,
                        borderColor: 'rgba(194,53,49, 0.5)',
                        animation: true,
                        animationDuration: 300,
                        animationEasing: 'quinticInOut'
                    },
                    controlStyle: {
                        show: true,
                        showPlayBtn: true,
                        showPrevBtn: true,
                        showNextBtn: true,
                        itemSize: 22,
                        itemGap: 12,
                        position: 'left',
                        playIcon: 'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z',
                        stopIcon: 'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z',
                        nextIcon: 'path://M18.6,50.8l22.5-22.5c0.2-0.2,0.3-0.4,0.3-0.7c0-0.3-0.1-0.5-0.3-0.7L18.7,4.4c-0.1-0.1-0.2-0.3-0.2-0.5 c0-0.4,0.3-0.8,0.8-0.8c0.2,0,0.5,0.1,0.6,0.3l23.5,23.5l0,0c0.2,0.2,0.3,0.4,0.3,0.7c0,0.3-0.1,0.5-0.3,0.7l-0.1,0.1L19.7,52 c-0.1,0.1-0.3,0.2-0.5,0.2c-0.4,0-0.8-0.3-0.8-0.8C18.4,51.2,18.5,51,18.6,50.8z',
                        prevIcon: 'path://M43,52.8L20.4,30.3c-0.2-0.2-0.3-0.4-0.3-0.7c0-0.3,0.1-0.5,0.3-0.7L42.9,6.4c0.1-0.1,0.2-0.3,0.2-0.5 c0-0.4-0.3-0.8-0.8-0.8c-0.2,0-0.5,0.1-0.6,0.3L18.3,28.8l0,0c-0.2,0.2-0.3,0.4-0.3,0.7c0,0.3,0.1,0.5,0.3,0.7l0.1,0.1L41.9,54 c0.1,0.1,0.3,0.2,0.5,0.2c0.4,0,0.8-0.3,0.8-0.8C43.2,53.2,43.1,53,43,52.8z',
                        normal: {
                            color: '#304654',
                            borderColor: '#304654',
                            borderWidth: 1
                        },
                        emphasis: {
                            color: '#c23531',
                            borderColor: '#c23531',
                            borderWidth: 2
                        }
                    },
                    data: []
                }
            });
        },
        function (module, exports, __webpack_require__) {
            var ComponentModel = __webpack_require__(19);
            var List = __webpack_require__(94);
            var zrUtil = __webpack_require__(3);
            var modelUtil = __webpack_require__(5);
            var TimelineModel = ComponentModel.extend({
                type: 'timeline',
                layoutMode: 'box',
                defaultOption: {
                    zlevel: 0,
                    z: 4,
                    show: true,
                    axisType: 'time',
                    realtime: true,
                    left: '20%',
                    top: null,
                    right: '20%',
                    bottom: 0,
                    width: null,
                    height: 40,
                    padding: 5,
                    controlPosition: 'left',
                    autoPlay: false,
                    rewind: false,
                    loop: true,
                    playInterval: 2000,
                    currentIndex: 0,
                    itemStyle: {
                        normal: {},
                        emphasis: {}
                    },
                    label: {
                        normal: { textStyle: { color: '#000' } },
                        emphasis: {}
                    },
                    data: []
                },
                init: function (option, parentModel, ecModel) {
                    this._data;
                    this._names;
                    this.mergeDefaultAndTheme(option, ecModel);
                    this._initData();
                },
                mergeOption: function (option) {
                    TimelineModel.superApply(this, 'mergeOption', arguments);
                    this._initData();
                },
                setCurrentIndex: function (currentIndex) {
                    if (currentIndex == null) {
                        currentIndex = this.option.currentIndex;
                    }
                    var count = this._data.count();
                    if (this.option.loop) {
                        currentIndex = (currentIndex % count + count) % count;
                    } else {
                        currentIndex >= count && (currentIndex = count - 1);
                        currentIndex < 0 && (currentIndex = 0);
                    }
                    this.option.currentIndex = currentIndex;
                },
                getCurrentIndex: function () {
                    return this.option.currentIndex;
                },
                isIndexMax: function () {
                    return this.getCurrentIndex() >= this._data.count() - 1;
                },
                setPlayState: function (state) {
                    this.option.autoPlay = !!state;
                },
                getPlayState: function () {
                    return !!this.option.autoPlay;
                },
                _initData: function () {
                    var thisOption = this.option;
                    var dataArr = thisOption.data || [];
                    var axisType = thisOption.axisType;
                    var names = this._names = [];
                    if (axisType === 'category') {
                        var idxArr = [];
                        zrUtil.each(dataArr, function (item, index) {
                            var value = modelUtil.getDataItemValue(item);
                            var newItem;
                            if (zrUtil.isObject(item)) {
                                newItem = zrUtil.clone(item);
                                newItem.value = index;
                            } else {
                                newItem = index;
                            }
                            idxArr.push(newItem);
                            if (!zrUtil.isString(value) && (value == null || isNaN(value))) {
                                value = '';
                            }
                            names.push(value + '');
                        });
                        dataArr = idxArr;
                    }
                    var dimType = {
                        category: 'ordinal',
                        time: 'time'
                    }[axisType] || 'number';
                    var data = this._data = new List([{
                            name: 'value',
                            type: dimType
                        }], this);
                    data.initData(dataArr, names);
                },
                getData: function () {
                    return this._data;
                },
                getCategories: function () {
                    if (this.get('axisType') === 'category') {
                        return this._names.slice();
                    }
                }
            });
            module.exports = TimelineModel;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var graphic = __webpack_require__(42);
            var layout = __webpack_require__(21);
            var TimelineView = __webpack_require__(329);
            var TimelineAxis = __webpack_require__(330);
            var symbolUtil = __webpack_require__(100);
            var axisHelper = __webpack_require__(108);
            var BoundingRect = __webpack_require__(15);
            var matrix = __webpack_require__(17);
            var numberUtil = __webpack_require__(7);
            var modelUtil = __webpack_require__(5);
            var formatUtil = __webpack_require__(6);
            var encodeHTML = formatUtil.encodeHTML;
            var bind = zrUtil.bind;
            var each = zrUtil.each;
            var PI = Math.PI;
            module.exports = TimelineView.extend({
                type: 'timeline.slider',
                init: function (ecModel, api) {
                    this.api = api;
                    this._axis;
                    this._viewRect;
                    this._timer;
                    this._currentPointer;
                    this._mainGroup;
                    this._labelGroup;
                },
                render: function (timelineModel, ecModel, api, payload) {
                    this.model = timelineModel;
                    this.api = api;
                    this.ecModel = ecModel;
                    this.group.removeAll();
                    if (timelineModel.get('show', true)) {
                        var layoutInfo = this._layout(timelineModel, api);
                        var mainGroup = this._createGroup('mainGroup');
                        var labelGroup = this._createGroup('labelGroup');
                        var axis = this._axis = this._createAxis(layoutInfo, timelineModel);
                        each([
                            'AxisLine',
                            'AxisTick',
                            'Control',
                            'CurrentPointer'
                        ], function (name) {
                            this['_render' + name](layoutInfo, mainGroup, axis, timelineModel);
                        }, this);
                        this._renderAxisLabel(layoutInfo, labelGroup, axis, timelineModel);
                        this._position(layoutInfo, timelineModel);
                    }
                    this._doPlayStop();
                },
                remove: function () {
                    this._clearTimer();
                    this.group.removeAll();
                },
                dispose: function () {
                    this._clearTimer();
                },
                _layout: function (timelineModel, api) {
                    var labelPosOpt = timelineModel.get('label.normal.position');
                    var orient = timelineModel.get('orient');
                    var viewRect = getViewRect(timelineModel, api);
                    if (labelPosOpt == null || labelPosOpt === 'auto') {
                        labelPosOpt = orient === 'horizontal' ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? '-' : '+' : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? '+' : '-';
                    } else if (isNaN(labelPosOpt)) {
                        labelPosOpt = {
                            horizontal: {
                                top: '-',
                                bottom: '+'
                            },
                            vertical: {
                                left: '-',
                                right: '+'
                            }
                        }[orient][labelPosOpt];
                    }
                    var labelAlignMap = {
                        horizontal: 'center',
                        vertical: labelPosOpt >= 0 || labelPosOpt === '+' ? 'left' : 'right'
                    };
                    var labelBaselineMap = {
                        horizontal: labelPosOpt >= 0 || labelPosOpt === '+' ? 'top' : 'bottom',
                        vertical: 'middle'
                    };
                    var rotationMap = {
                        horizontal: 0,
                        vertical: PI / 2
                    };
                    var mainLength = orient === 'vertical' ? viewRect.height : viewRect.width;
                    var controlModel = timelineModel.getModel('controlStyle');
                    var showControl = controlModel.get('show');
                    var controlSize = showControl ? controlModel.get('itemSize') : 0;
                    var controlGap = showControl ? controlModel.get('itemGap') : 0;
                    var sizePlusGap = controlSize + controlGap;
                    var labelRotation = timelineModel.get('label.normal.rotate') || 0;
                    labelRotation = labelRotation * PI / 180;
                    var playPosition;
                    var prevBtnPosition;
                    var nextBtnPosition;
                    var axisExtent;
                    var controlPosition = controlModel.get('position', true);
                    var showControl = controlModel.get('show', true);
                    var showPlayBtn = showControl && controlModel.get('showPlayBtn', true);
                    var showPrevBtn = showControl && controlModel.get('showPrevBtn', true);
                    var showNextBtn = showControl && controlModel.get('showNextBtn', true);
                    var xLeft = 0;
                    var xRight = mainLength;
                    if (controlPosition === 'left' || controlPosition === 'bottom') {
                        showPlayBtn && (playPosition = [
                            0,
                            0
                        ], xLeft += sizePlusGap);
                        showPrevBtn && (prevBtnPosition = [
                            xLeft,
                            0
                        ], xLeft += sizePlusGap);
                        showNextBtn && (nextBtnPosition = [
                            xRight - controlSize,
                            0
                        ], xRight -= sizePlusGap);
                    } else {
                        showPlayBtn && (playPosition = [
                            xRight - controlSize,
                            0
                        ], xRight -= sizePlusGap);
                        showPrevBtn && (prevBtnPosition = [
                            0,
                            0
                        ], xLeft += sizePlusGap);
                        showNextBtn && (nextBtnPosition = [
                            xRight - controlSize,
                            0
                        ], xRight -= sizePlusGap);
                    }
                    axisExtent = [
                        xLeft,
                        xRight
                    ];
                    if (timelineModel.get('inverse')) {
                        axisExtent.reverse();
                    }
                    return {
                        viewRect: viewRect,
                        mainLength: mainLength,
                        orient: orient,
                        rotation: rotationMap[orient],
                        labelRotation: labelRotation,
                        labelPosOpt: labelPosOpt,
                        labelAlign: labelAlignMap[orient],
                        labelBaseline: labelBaselineMap[orient],
                        playPosition: playPosition,
                        prevBtnPosition: prevBtnPosition,
                        nextBtnPosition: nextBtnPosition,
                        axisExtent: axisExtent,
                        controlSize: controlSize,
                        controlGap: controlGap
                    };
                },
                _position: function (layoutInfo, timelineModel) {
                    var mainGroup = this._mainGroup;
                    var labelGroup = this._labelGroup;
                    var viewRect = layoutInfo.viewRect;
                    if (layoutInfo.orient === 'vertical') {
                        var m = matrix.create();
                        var rotateOriginX = viewRect.x;
                        var rotateOriginY = viewRect.y + viewRect.height;
                        matrix.translate(m, m, [
                            -rotateOriginX,
                            -rotateOriginY
                        ]);
                        matrix.rotate(m, m, -PI / 2);
                        matrix.translate(m, m, [
                            rotateOriginX,
                            rotateOriginY
                        ]);
                        viewRect = viewRect.clone();
                        viewRect.applyTransform(m);
                    }
                    var viewBound = getBound(viewRect);
                    var mainBound = getBound(mainGroup.getBoundingRect());
                    var labelBound = getBound(labelGroup.getBoundingRect());
                    var mainPosition = mainGroup.position;
                    var labelsPosition = labelGroup.position;
                    labelsPosition[0] = mainPosition[0] = viewBound[0][0];
                    var labelPosOpt = layoutInfo.labelPosOpt;
                    if (isNaN(labelPosOpt)) {
                        var mainBoundIdx = labelPosOpt === '+' ? 0 : 1;
                        toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
                        toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx);
                    } else {
                        var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1;
                        toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx);
                        labelsPosition[1] = mainPosition[1] + labelPosOpt;
                    }
                    mainGroup.position = mainPosition;
                    labelGroup.position = labelsPosition;
                    mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation;
                    setOrigin(mainGroup);
                    setOrigin(labelGroup);
                    function setOrigin(targetGroup) {
                        var pos = targetGroup.position;
                        targetGroup.origin = [
                            viewBound[0][0] - pos[0],
                            viewBound[1][0] - pos[1]
                        ];
                    }
                    function getBound(rect) {
                        return [
                            [
                                rect.x,
                                rect.x + rect.width
                            ],
                            [
                                rect.y,
                                rect.y + rect.height
                            ]
                        ];
                    }
                    function toBound(fromPos, from, to, dimIdx, boundIdx) {
                        fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx];
                    }
                },
                _createAxis: function (layoutInfo, timelineModel) {
                    var data = timelineModel.getData();
                    var axisType = timelineModel.get('axisType');
                    var scale = axisHelper.createScaleByModel(timelineModel, axisType);
                    var dataExtent = data.getDataExtent('value');
                    scale.setExtent(dataExtent[0], dataExtent[1]);
                    this._customizeScale(scale, data);
                    scale.niceTicks();
                    var axis = new TimelineAxis('value', scale, layoutInfo.axisExtent, axisType);
                    axis.model = timelineModel;
                    return axis;
                },
                _customizeScale: function (scale, data) {
                    scale.getTicks = function () {
                        return data.mapArray(['value'], function (value) {
                            return value;
                        });
                    };
                    scale.getTicksLabels = function () {
                        return zrUtil.map(this.getTicks(), scale.getLabel, scale);
                    };
                },
                _createGroup: function (name) {
                    var newGroup = this['_' + name] = new graphic.Group();
                    this.group.add(newGroup);
                    return newGroup;
                },
                _renderAxisLine: function (layoutInfo, group, axis, timelineModel) {
                    var axisExtent = axis.getExtent();
                    if (!timelineModel.get('lineStyle.show')) {
                        return;
                    }
                    group.add(new graphic.Line({
                        shape: {
                            x1: axisExtent[0],
                            y1: 0,
                            x2: axisExtent[1],
                            y2: 0
                        },
                        style: zrUtil.extend({ lineCap: 'round' }, timelineModel.getModel('lineStyle').getLineStyle()),
                        silent: true,
                        z2: 1
                    }));
                },
                _renderAxisTick: function (layoutInfo, group, axis, timelineModel) {
                    var data = timelineModel.getData();
                    var ticks = axis.scale.getTicks();
                    var tooltipHostModel = this._prepareTooltipHostModel(data, timelineModel);
                    each(ticks, function (value, dataIndex) {
                        var tickCoord = axis.dataToCoord(value);
                        var itemModel = data.getItemModel(dataIndex);
                        var itemStyleModel = itemModel.getModel('itemStyle.normal');
                        var hoverStyleModel = itemModel.getModel('itemStyle.emphasis');
                        var symbolOpt = {
                            position: [
                                tickCoord,
                                0
                            ],
                            onclick: bind(this._changeTimeline, this, dataIndex)
                        };
                        var el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt);
                        graphic.setHoverStyle(el, hoverStyleModel.getItemStyle());
                        if (itemModel.get('tooltip')) {
                            el.dataIndex = dataIndex;
                            el.dataModel = tooltipHostModel;
                        } else {
                            el.dataIndex = el.dataModel = null;
                        }
                    }, this);
                },
                _prepareTooltipHostModel: function (data, timelineModel) {
                    var tooltipHostModel = modelUtil.createDataFormatModel({}, data, timelineModel.get('data'));
                    var me = this;
                    tooltipHostModel.formatTooltip = function (dataIndex) {
                        return encodeHTML(me._axis.scale.getLabel(dataIndex));
                    };
                    return tooltipHostModel;
                },
                _renderAxisLabel: function (layoutInfo, group, axis, timelineModel) {
                    var labelModel = timelineModel.getModel('label.normal');
                    if (!labelModel.get('show')) {
                        return;
                    }
                    var data = timelineModel.getData();
                    var ticks = axis.scale.getTicks();
                    var labels = axisHelper.getFormattedLabels(axis, labelModel.get('formatter'));
                    var labelInterval = axis.getLabelInterval();
                    each(ticks, function (tick, dataIndex) {
                        if (axis.isLabelIgnored(dataIndex, labelInterval)) {
                            return;
                        }
                        var itemModel = data.getItemModel(dataIndex);
                        var itemTextStyleModel = itemModel.getModel('label.normal.textStyle');
                        var hoverTextStyleModel = itemModel.getModel('label.emphasis.textStyle');
                        var tickCoord = axis.dataToCoord(tick);
                        var textEl = new graphic.Text({
                            style: {
                                text: labels[dataIndex],
                                textAlign: layoutInfo.labelAlign,
                                textVerticalAlign: layoutInfo.labelBaseline,
                                textFont: itemTextStyleModel.getFont(),
                                fill: itemTextStyleModel.getTextColor()
                            },
                            position: [
                                tickCoord,
                                0
                            ],
                            rotation: layoutInfo.labelRotation - layoutInfo.rotation,
                            onclick: bind(this._changeTimeline, this, dataIndex),
                            silent: false
                        });
                        group.add(textEl);
                        graphic.setHoverStyle(textEl, hoverTextStyleModel.getItemStyle());
                    }, this);
                },
                _renderControl: function (layoutInfo, group, axis, timelineModel) {
                    var controlSize = layoutInfo.controlSize;
                    var rotation = layoutInfo.rotation;
                    var itemStyle = timelineModel.getModel('controlStyle.normal').getItemStyle();
                    var hoverStyle = timelineModel.getModel('controlStyle.emphasis').getItemStyle();
                    var rect = [
                        0,
                        -controlSize / 2,
                        controlSize,
                        controlSize
                    ];
                    var playState = timelineModel.getPlayState();
                    var inverse = timelineModel.get('inverse', true);
                    makeBtn(layoutInfo.nextBtnPosition, 'controlStyle.nextIcon', bind(this._changeTimeline, this, inverse ? '-' : '+'));
                    makeBtn(layoutInfo.prevBtnPosition, 'controlStyle.prevIcon', bind(this._changeTimeline, this, inverse ? '+' : '-'));
                    makeBtn(layoutInfo.playPosition, 'controlStyle.' + (playState ? 'stopIcon' : 'playIcon'), bind(this._handlePlayClick, this, !playState), true);
                    function makeBtn(position, iconPath, onclick, willRotate) {
                        if (!position) {
                            return;
                        }
                        var opt = {
                            position: position,
                            origin: [
                                controlSize / 2,
                                0
                            ],
                            rotation: willRotate ? -rotation : 0,
                            rectHover: true,
                            style: itemStyle,
                            onclick: onclick
                        };
                        var btn = makeIcon(timelineModel, iconPath, rect, opt);
                        group.add(btn);
                        graphic.setHoverStyle(btn, hoverStyle);
                    }
                },
                _renderCurrentPointer: function (layoutInfo, group, axis, timelineModel) {
                    var data = timelineModel.getData();
                    var currentIndex = timelineModel.getCurrentIndex();
                    var pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle');
                    var me = this;
                    var callback = {
                        onCreate: function (pointer) {
                            pointer.draggable = true;
                            pointer.drift = bind(me._handlePointerDrag, me);
                            pointer.ondragend = bind(me._handlePointerDragend, me);
                            pointerMoveTo(pointer, currentIndex, axis, timelineModel, true);
                        },
                        onUpdate: function (pointer) {
                            pointerMoveTo(pointer, currentIndex, axis, timelineModel);
                        }
                    };
                    this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback);
                },
                _handlePlayClick: function (nextState) {
                    this._clearTimer();
                    this.api.dispatchAction({
                        type: 'timelinePlayChange',
                        playState: nextState,
                        from: this.uid
                    });
                },
                _handlePointerDrag: function (dx, dy, e) {
                    this._clearTimer();
                    this._pointerChangeTimeline([
                        e.offsetX,
                        e.offsetY
                    ]);
                },
                _handlePointerDragend: function (e) {
                    this._pointerChangeTimeline([
                        e.offsetX,
                        e.offsetY
                    ], true);
                },
                _pointerChangeTimeline: function (mousePos, trigger) {
                    var toCoord = this._toAxisCoord(mousePos)[0];
                    var axis = this._axis;
                    var axisExtent = numberUtil.asc(axis.getExtent().slice());
                    toCoord > axisExtent[1] && (toCoord = axisExtent[1]);
                    toCoord < axisExtent[0] && (toCoord = axisExtent[0]);
                    this._currentPointer.position[0] = toCoord;
                    this._currentPointer.dirty();
                    var targetDataIndex = this._findNearestTick(toCoord);
                    var timelineModel = this.model;
                    if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime')) {
                        this._changeTimeline(targetDataIndex);
                    }
                },
                _doPlayStop: function () {
                    this._clearTimer();
                    if (this.model.getPlayState()) {
                        this._timer = setTimeout(bind(handleFrame, this), this.model.get('playInterval'));
                    }
                    function handleFrame() {
                        var timelineModel = this.model;
                        this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1));
                    }
                },
                _toAxisCoord: function (vertex) {
                    var trans = this._mainGroup.getLocalTransform();
                    return graphic.applyTransform(vertex, trans, true);
                },
                _findNearestTick: function (axisCoord) {
                    var data = this.model.getData();
                    var dist = Infinity;
                    var targetDataIndex;
                    var axis = this._axis;
                    data.each(['value'], function (value, dataIndex) {
                        var coord = axis.dataToCoord(value);
                        var d = Math.abs(coord - axisCoord);
                        if (d < dist) {
                            dist = d;
                            targetDataIndex = dataIndex;
                        }
                    });
                    return targetDataIndex;
                },
                _clearTimer: function () {
                    if (this._timer) {
                        clearTimeout(this._timer);
                        this._timer = null;
                    }
                },
                _changeTimeline: function (nextIndex) {
                    var currentIndex = this.model.getCurrentIndex();
                    if (nextIndex === '+') {
                        nextIndex = currentIndex + 1;
                    } else if (nextIndex === '-') {
                        nextIndex = currentIndex - 1;
                    }
                    this.api.dispatchAction({
                        type: 'timelineChange',
                        currentIndex: nextIndex,
                        from: this.uid
                    });
                }
            });
            function getViewRect(model, api) {
                return layout.getLayoutRect(model.getBoxLayoutParams(), {
                    width: api.getWidth(),
                    height: api.getHeight()
                }, model.get('padding'));
            }
            function makeIcon(timelineModel, objPath, rect, opts) {
                var icon = graphic.makePath(timelineModel.get(objPath).replace(/^path:\/\//, ''), zrUtil.clone(opts || {}), new BoundingRect(rect[0], rect[1], rect[2], rect[3]), 'center');
                return icon;
            }
            function giveSymbol(hostModel, itemStyleModel, group, opt, symbol, callback) {
                var symbolType = hostModel.get('symbol');
                var color = itemStyleModel.get('color');
                var symbolSize = hostModel.get('symbolSize');
                var halfSymbolSize = symbolSize / 2;
                var itemStyle = itemStyleModel.getItemStyle([
                    'color',
                    'symbol',
                    'symbolSize'
                ]);
                if (!symbol) {
                    symbol = symbolUtil.createSymbol(symbolType, -halfSymbolSize, -halfSymbolSize, symbolSize, symbolSize, color);
                    group.add(symbol);
                    callback && callback.onCreate(symbol);
                } else {
                    symbol.setStyle(itemStyle);
                    symbol.setColor(color);
                    group.add(symbol);
                    callback && callback.onUpdate(symbol);
                }
                opt = zrUtil.merge({
                    rectHover: true,
                    style: itemStyle,
                    z2: 100
                }, opt, true);
                symbol.attr(opt);
                return symbol;
            }
            function pointerMoveTo(pointer, dataIndex, axis, timelineModel, noAnimation) {
                if (pointer.dragging) {
                    return;
                }
                var pointerModel = timelineModel.getModel('checkpointStyle');
                var toCoord = axis.dataToCoord(timelineModel.getData().get(['value'], dataIndex));
                if (noAnimation || !pointerModel.get('animation', true)) {
                    pointer.attr({
                        position: [
                            toCoord,
                            0
                        ]
                    });
                } else {
                    pointer.stopAnimation(true);
                    pointer.animateTo({
                        position: [
                            toCoord,
                            0
                        ]
                    }, pointerModel.get('animationDuration', true), pointerModel.get('animationEasing', true));
                }
            }
        },
        function (module, exports, __webpack_require__) {
            var ComponentView = __webpack_require__(28);
            module.exports = ComponentView.extend({ type: 'timeline' });
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var Axis = __webpack_require__(117);
            var axisHelper = __webpack_require__(108);
            var TimelineAxis = function (dim, scale, coordExtent, axisType) {
                Axis.call(this, dim, scale, coordExtent);
                this.type = axisType || 'value';
                this._autoLabelInterval;
                this.model = null;
            };
            TimelineAxis.prototype = {
                constructor: TimelineAxis,
                getLabelInterval: function () {
                    var timelineModel = this.model;
                    var labelModel = timelineModel.getModel('label.normal');
                    var labelInterval = labelModel.get('interval');
                    if (labelInterval != null && labelInterval != 'auto') {
                        return labelInterval;
                    }
                    var labelInterval = this._autoLabelInterval;
                    if (!labelInterval) {
                        labelInterval = this._autoLabelInterval = axisHelper.getAxisLabelInterval(zrUtil.map(this.scale.getTicks(), this.dataToCoord, this), axisHelper.getFormattedLabels(this, labelModel.get('formatter')), labelModel.getModel('textStyle').getFont(), timelineModel.get('orient') === 'horizontal');
                    }
                    return labelInterval;
                },
                isLabelIgnored: function (idx) {
                    if (this.type === 'category') {
                        var labelInterval = this.getLabelInterval();
                        return typeof labelInterval === 'function' && !labelInterval(idx, this.scale.getLabel(idx)) || idx % (labelInterval + 1);
                    }
                }
            };
            zrUtil.inherits(TimelineAxis, Axis);
            module.exports = TimelineAxis;
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(332);
            __webpack_require__(334);
            __webpack_require__(336);
            __webpack_require__(337);
            __webpack_require__(338);
            __webpack_require__(339);
            __webpack_require__(344);
        },
        function (module, exports, __webpack_require__) {
            var featureManager = __webpack_require__(333);
            var zrUtil = __webpack_require__(3);
            var ToolboxModel = __webpack_require__(1).extendComponentModel({
                type: 'toolbox',
                layoutMode: {
                    type: 'box',
                    ignoreSize: true
                },
                mergeDefaultAndTheme: function (option) {
                    ToolboxModel.superApply(this, 'mergeDefaultAndTheme', arguments);
                    zrUtil.each(this.option.feature, function (featureOpt, featureName) {
                        var Feature = featureManager.get(featureName);
                        Feature && zrUtil.merge(featureOpt, Feature.defaultOption);
                    });
                },
                defaultOption: {
                    show: true,
                    z: 6,
                    zlevel: 0,
                    orient: 'horizontal',
                    left: 'right',
                    top: 'top',
                    backgroundColor: 'transparent',
                    borderColor: '#ccc',
                    borderWidth: 0,
                    padding: 5,
                    itemSize: 15,
                    itemGap: 8,
                    showTitle: true,
                    iconStyle: {
                        normal: {
                            borderColor: '#666',
                            color: 'none'
                        },
                        emphasis: { borderColor: '#3E98C5' }
                    }
                }
            });
            module.exports = ToolboxModel;
        },
        function (module, exports) {
            'use strict';
            var features = {};
            module.exports = {
                register: function (name, ctor) {
                    features[name] = ctor;
                },
                get: function (name) {
                    return features[name];
                }
            };
        },
        function (module, exports, __webpack_require__) {
            (function (process) {
                var featureManager = __webpack_require__(333);
                var zrUtil = __webpack_require__(3);
                var graphic = __webpack_require__(42);
                var Model = __webpack_require__(8);
                var DataDiffer = __webpack_require__(95);
                var listComponentHelper = __webpack_require__(266);
                var textContain = __webpack_require__(14);
                module.exports = __webpack_require__(1).extendComponentView({
                    type: 'toolbox',
                    render: function (toolboxModel, ecModel, api) {
                        var group = this.group;
                        group.removeAll();
                        if (!toolboxModel.get('show')) {
                            return;
                        }
                        var itemSize = +toolboxModel.get('itemSize');
                        var featureOpts = toolboxModel.get('feature') || {};
                        var features = this._features || (this._features = {});
                        var featureNames = [];
                        zrUtil.each(featureOpts, function (opt, name) {
                            featureNames.push(name);
                        });
                        new DataDiffer(this._featureNames || [], featureNames).add(process).update(process).remove(zrUtil.curry(process, null)).execute();
                        this._featureNames = featureNames;
                        function process(newIndex, oldIndex) {
                            var featureName = featureNames[newIndex];
                            var oldName = featureNames[oldIndex];
                            var featureOpt = featureOpts[featureName];
                            var featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel);
                            var feature;
                            if (featureName && !oldName) {
                                if (isUserFeatureName(featureName)) {
                                    feature = {
                                        model: featureModel,
                                        onclick: featureModel.option.onclick,
                                        featureName: featureName
                                    };
                                } else {
                                    var Feature = featureManager.get(featureName);
                                    if (!Feature) {
                                        return;
                                    }
                                    feature = new Feature(featureModel);
                                }
                                features[featureName] = feature;
                            } else {
                                feature = features[oldName];
                                if (!feature) {
                                    return;
                                }
                                feature.model = featureModel;
                            }
                            if (!featureName && oldName) {
                                feature.dispose && feature.dispose(ecModel, api);
                                return;
                            }
                            if (!featureModel.get('show') || feature.unusable) {
                                feature.remove && feature.remove(ecModel, api);
                                return;
                            }
                            createIconPaths(featureModel, feature, featureName);
                            featureModel.setIconStatus = function (iconName, status) {
                                var option = this.option;
                                var iconPaths = this.iconPaths;
                                option.iconStatus = option.iconStatus || {};
                                option.iconStatus[iconName] = status;
                                iconPaths[iconName] && iconPaths[iconName].trigger(status);
                            };
                            if (feature.render) {
                                feature.render(featureModel, ecModel, api);
                            }
                        }
                        function createIconPaths(featureModel, feature, featureName) {
                            var iconStyleModel = featureModel.getModel('iconStyle');
                            var icons = feature.getIcons ? feature.getIcons() : featureModel.get('icon');
                            var titles = featureModel.get('title') || {};
                            if (typeof icons === 'string') {
                                var icon = icons;
                                var title = titles;
                                icons = {};
                                titles = {};
                                icons[featureName] = icon;
                                titles[featureName] = title;
                            }
                            var iconPaths = featureModel.iconPaths = {};
                            zrUtil.each(icons, function (icon, iconName) {
                                var normalStyle = iconStyleModel.getModel('normal').getItemStyle();
                                var hoverStyle = iconStyleModel.getModel('emphasis').getItemStyle();
                                var style = {
                                    x: -itemSize / 2,
                                    y: -itemSize / 2,
                                    width: itemSize,
                                    height: itemSize
                                };
                                var path = icon.indexOf('image://') === 0 ? (style.image = icon.slice(8), new graphic.Image({ style: style })) : graphic.makePath(icon.replace('path://', ''), {
                                    style: normalStyle,
                                    hoverStyle: hoverStyle,
                                    rectHover: true
                                }, style, 'center');
                                graphic.setHoverStyle(path);
                                if (toolboxModel.get('showTitle')) {
                                    path.__title = titles[iconName];
                                    path.on('mouseover', function () {
                                        path.setStyle({
                                            text: titles[iconName],
                                            textPosition: hoverStyle.textPosition || 'bottom',
                                            textFill: hoverStyle.fill || hoverStyle.stroke || '#000',
                                            textAlign: hoverStyle.textAlign || 'center'
                                        });
                                    }).on('mouseout', function () {
                                        path.setStyle({ textFill: null });
                                    });
                                }
                                path.trigger(featureModel.get('iconStatus.' + iconName) || 'normal');
                                group.add(path);
                                path.on('click', zrUtil.bind(feature.onclick, feature, ecModel, api, iconName));
                                iconPaths[iconName] = path;
                            });
                        }
                        listComponentHelper.layout(group, toolboxModel, api);
                        listComponentHelper.addBackground(group, toolboxModel);
                        group.eachChild(function (icon) {
                            var titleText = icon.__title;
                            var hoverStyle = icon.hoverStyle;
                            if (hoverStyle && titleText) {
                                var rect = textContain.getBoundingRect(titleText, hoverStyle.font);
                                var offsetX = icon.position[0] + group.position[0];
                                var offsetY = icon.position[1] + group.position[1] + itemSize;
                                var needPutOnTop = false;
                                if (offsetY + rect.height > api.getHeight()) {
                                    hoverStyle.textPosition = 'top';
                                    needPutOnTop = true;
                                }
                                var topOffset = needPutOnTop ? -5 - rect.height : itemSize + 8;
                                if (offsetX + rect.width / 2 > api.getWidth()) {
                                    hoverStyle.textPosition = [
                                        '100%',
                                        topOffset
                                    ];
                                    hoverStyle.textAlign = 'right';
                                } else if (offsetX - rect.width / 2 < 0) {
                                    hoverStyle.textPosition = [
                                        0,
                                        topOffset
                                    ];
                                    hoverStyle.textAlign = 'left';
                                }
                            }
                        });
                    },
                    remove: function (ecModel, api) {
                        zrUtil.each(this._features, function (feature) {
                            feature.remove && feature.remove(ecModel, api);
                        });
                        this.group.removeAll();
                    },
                    dispose: function (ecModel, api) {
                        zrUtil.each(this._features, function (feature) {
                            feature.dispose && feature.dispose(ecModel, api);
                        });
                    }
                });
                function isUserFeatureName(featureName) {
                    return featureName.indexOf('my') === 0;
                }
            }.call(exports, __webpack_require__(335)));
        },
        function (module, exports) {
            var process = module.exports = {};
            var queue = [];
            var draining = false;
            var currentQueue;
            var queueIndex = -1;
            function cleanUpNextTick() {
                draining = false;
                if (currentQueue.length) {
                    queue = currentQueue.concat(queue);
                } else {
                    queueIndex = -1;
                }
                if (queue.length) {
                    drainQueue();
                }
            }
            function drainQueue() {
                if (draining) {
                    return;
                }
                var timeout = setTimeout(cleanUpNextTick);
                draining = true;
                var len = queue.length;
                while (len) {
                    currentQueue = queue;
                    queue = [];
                    while (++queueIndex < len) {
                        if (currentQueue) {
                            currentQueue[queueIndex].run();
                        }
                    }
                    queueIndex = -1;
                    len = queue.length;
                }
                currentQueue = null;
                draining = false;
                clearTimeout(timeout);
            }
            process.nextTick = function (fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) {
                    for (var i = 1; i < arguments.length; i++) {
                        args[i - 1] = arguments[i];
                    }
                }
                queue.push(new Item(fun, args));
                if (queue.length === 1 && !draining) {
                    setTimeout(drainQueue, 0);
                }
            };
            function Item(fun, array) {
                this.fun = fun;
                this.array = array;
            }
            Item.prototype.run = function () {
                this.fun.apply(null, this.array);
            };
            process.title = 'browser';
            process.browser = true;
            process.env = {};
            process.argv = [];
            process.version = '';
            process.versions = {};
            function noop() {
            }
            process.on = noop;
            process.addListener = noop;
            process.once = noop;
            process.off = noop;
            process.removeListener = noop;
            process.removeAllListeners = noop;
            process.emit = noop;
            process.binding = function (name) {
                throw new Error('process.binding is not supported');
            };
            process.cwd = function () {
                return '/';
            };
            process.chdir = function (dir) {
                throw new Error('process.chdir is not supported');
            };
            process.umask = function () {
                return 0;
            };
        },
        function (module, exports, __webpack_require__) {
            var env = __webpack_require__(78);
            function SaveAsImage(model) {
                this.model = model;
            }
            SaveAsImage.defaultOption = {
                show: true,
                icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
                title: '保存为图片',
                type: 'png',
                name: '',
                excludeComponents: ['toolbox'],
                pixelRatio: 1,
                lang: ['右键另存为图片']
            };
            SaveAsImage.prototype.unusable = !env.canvasSupported;
            var proto = SaveAsImage.prototype;
            proto.onclick = function (ecModel, api) {
                var model = this.model;
                var title = model.get('name') || ecModel.get('title.0.text') || 'echarts';
                var $a = document.createElement('a');
                var type = model.get('type', true) || 'png';
                $a.download = title + '.' + type;
                $a.target = '_blank';
                var url = api.getConnectedDataURL({
                    type: type,
                    backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',
                    excludeComponents: model.get('excludeComponents'),
                    pixelRatio: model.get('pixelRatio')
                });
                $a.href = url;
                if (typeof MouseEvent === 'function') {
                    var evt = new MouseEvent('click', {
                        view: window,
                        bubbles: true,
                        cancelable: false
                    });
                    $a.dispatchEvent(evt);
                } else {
                    var lang = model.get('lang');
                    var html = '' + '<body style="margin:0;">' + '<img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || '') + '" />' + '</body>';
                    var tab = window.open();
                    tab.document.write(html);
                }
            };
            __webpack_require__(333).register('saveAsImage', SaveAsImage);
            module.exports = SaveAsImage;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            function MagicType(model) {
                this.model = model;
            }
            MagicType.defaultOption = {
                show: true,
                type: [],
                icon: {
                    line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
                    bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
                    stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z',
                    tiled: 'M2.3,2.2h22.8V25H2.3V2.2z M35,2.2h22.8V25H35V2.2zM2.3,35h22.8v22.8H2.3V35z M35,35h22.8v22.8H35V35z'
                },
                title: {
                    line: '切换为折线图',
                    bar: '切换为柱状图',
                    stack: '切换为堆叠',
                    tiled: '切换为平铺'
                },
                option: {},
                seriesIndex: {}
            };
            var proto = MagicType.prototype;
            proto.getIcons = function () {
                var model = this.model;
                var availableIcons = model.get('icon');
                var icons = {};
                zrUtil.each(model.get('type'), function (type) {
                    if (availableIcons[type]) {
                        icons[type] = availableIcons[type];
                    }
                });
                return icons;
            };
            var seriesOptGenreator = {
                'line': function (seriesType, seriesId, seriesModel, model) {
                    if (seriesType === 'bar') {
                        return zrUtil.merge({
                            id: seriesId,
                            type: 'line',
                            data: seriesModel.get('data'),
                            stack: seriesModel.get('stack'),
                            markPoint: seriesModel.get('markPoint'),
                            markLine: seriesModel.get('markLine')
                        }, model.get('option.line') || {}, true);
                    }
                },
                'bar': function (seriesType, seriesId, seriesModel, model) {
                    if (seriesType === 'line') {
                        return zrUtil.merge({
                            id: seriesId,
                            type: 'bar',
                            data: seriesModel.get('data'),
                            stack: seriesModel.get('stack'),
                            markPoint: seriesModel.get('markPoint'),
                            markLine: seriesModel.get('markLine')
                        }, model.get('option.bar') || {}, true);
                    }
                },
                'stack': function (seriesType, seriesId, seriesModel, model) {
                    if (seriesType === 'line' || seriesType === 'bar') {
                        return zrUtil.merge({
                            id: seriesId,
                            stack: '__ec_magicType_stack__'
                        }, model.get('option.stack') || {}, true);
                    }
                },
                'tiled': function (seriesType, seriesId, seriesModel, model) {
                    if (seriesType === 'line' || seriesType === 'bar') {
                        return zrUtil.merge({
                            id: seriesId,
                            stack: ''
                        }, model.get('option.tiled') || {}, true);
                    }
                }
            };
            var radioTypes = [
                [
                    'line',
                    'bar'
                ],
                [
                    'stack',
                    'tiled'
                ]
            ];
            proto.onclick = function (ecModel, api, type) {
                var model = this.model;
                var seriesIndex = model.get('seriesIndex.' + type);
                if (!seriesOptGenreator[type]) {
                    return;
                }
                var newOption = { series: [] };
                var generateNewSeriesTypes = function (seriesModel) {
                    var seriesType = seriesModel.subType;
                    var seriesId = seriesModel.id;
                    var newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model);
                    if (newSeriesOpt) {
                        zrUtil.defaults(newSeriesOpt, seriesModel.option);
                        newOption.series.push(newSeriesOpt);
                    }
                    var coordSys = seriesModel.coordinateSystem;
                    if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {
                        var categoryAxis = coordSys.getAxesByScale('ordinal')[0];
                        if (categoryAxis) {
                            var axisDim = categoryAxis.dim;
                            var axisIndex = seriesModel.get(axisDim + 'AxisIndex');
                            var axisKey = axisDim + 'Axis';
                            newOption[axisKey] = newOption[axisKey] || [];
                            for (var i = 0; i <= axisIndex; i++) {
                                newOption[axisKey][axisIndex] = newOption[axisKey][axisIndex] || {};
                            }
                            newOption[axisKey][axisIndex].boundaryGap = type === 'bar' ? true : false;
                        }
                    }
                };
                zrUtil.each(radioTypes, function (radio) {
                    if (zrUtil.indexOf(radio, type) >= 0) {
                        zrUtil.each(radio, function (item) {
                            model.setIconStatus(item, 'normal');
                        });
                    }
                });
                model.setIconStatus(type, 'emphasis');
                ecModel.eachComponent({
                    mainType: 'series',
                    query: seriesIndex == null ? null : { seriesIndex: seriesIndex }
                }, generateNewSeriesTypes);
                api.dispatchAction({
                    type: 'changeMagicType',
                    currentType: type,
                    newOption: newOption
                });
            };
            var echarts = __webpack_require__(1);
            echarts.registerAction({
                type: 'changeMagicType',
                event: 'magicTypeChanged',
                update: 'prepareAndUpdate'
            }, function (payload, ecModel) {
                ecModel.mergeOption(payload.newOption);
            });
            __webpack_require__(333).register('magicType', MagicType);
            module.exports = MagicType;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var eventTool = __webpack_require__(80);
            var BLOCK_SPLITER = new Array(60).join('-');
            var ITEM_SPLITER = '\t';
            function groupSeries(ecModel) {
                var seriesGroupByCategoryAxis = {};
                var otherSeries = [];
                var meta = [];
                ecModel.eachRawSeries(function (seriesModel) {
                    var coordSys = seriesModel.coordinateSystem;
                    if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {
                        var baseAxis = coordSys.getBaseAxis();
                        if (baseAxis.type === 'category') {
                            var key = baseAxis.dim + '_' + baseAxis.index;
                            if (!seriesGroupByCategoryAxis[key]) {
                                seriesGroupByCategoryAxis[key] = {
                                    categoryAxis: baseAxis,
                                    valueAxis: coordSys.getOtherAxis(baseAxis),
                                    series: []
                                };
                                meta.push({
                                    axisDim: baseAxis.dim,
                                    axisIndex: baseAxis.index
                                });
                            }
                            seriesGroupByCategoryAxis[key].series.push(seriesModel);
                        } else {
                            otherSeries.push(seriesModel);
                        }
                    } else {
                        otherSeries.push(seriesModel);
                    }
                });
                return {
                    seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,
                    other: otherSeries,
                    meta: meta
                };
            }
            function assembleSeriesWithCategoryAxis(series) {
                var tables = [];
                zrUtil.each(series, function (group, key) {
                    var categoryAxis = group.categoryAxis;
                    var valueAxis = group.valueAxis;
                    var valueAxisDim = valueAxis.dim;
                    var headers = [' '].concat(zrUtil.map(group.series, function (series) {
                        return series.name;
                    }));
                    var columns = [categoryAxis.model.getCategories()];
                    zrUtil.each(group.series, function (series) {
                        columns.push(series.getRawData().mapArray(valueAxisDim, function (val) {
                            return val;
                        }));
                    });
                    var lines = [headers.join(ITEM_SPLITER)];
                    for (var i = 0; i < columns[0].length; i++) {
                        var items = [];
                        for (var j = 0; j < columns.length; j++) {
                            items.push(columns[j][i]);
                        }
                        lines.push(items.join(ITEM_SPLITER));
                    }
                    tables.push(lines.join('\n'));
                });
                return tables.join('\n\n' + BLOCK_SPLITER + '\n\n');
            }
            function assembleOtherSeries(series) {
                return zrUtil.map(series, function (series) {
                    var data = series.getRawData();
                    var lines = [series.name];
                    var vals = [];
                    data.each(data.dimensions, function () {
                        var argLen = arguments.length;
                        var dataIndex = arguments[argLen - 1];
                        var name = data.getName(dataIndex);
                        for (var i = 0; i < argLen - 1; i++) {
                            vals[i] = arguments[i];
                        }
                        lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER));
                    });
                    return lines.join('\n');
                }).join('\n\n' + BLOCK_SPLITER + '\n\n');
            }
            function getContentFromModel(ecModel) {
                var result = groupSeries(ecModel);
                return {
                    value: zrUtil.filter([
                        assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis),
                        assembleOtherSeries(result.other)
                    ], function (str) {
                        return str.replace(/[\n\t\s]/g, '');
                    }).join('\n\n' + BLOCK_SPLITER + '\n\n'),
                    meta: result.meta
                };
            }
            function trim(str) {
                return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
            }
            function isTSVFormat(block) {
                var firstLine = block.slice(0, block.indexOf('\n'));
                if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
                    return true;
                }
            }
            var itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g');
            function parseTSVContents(tsv) {
                var tsvLines = tsv.split(/\n+/g);
                var headers = trim(tsvLines.shift()).split(itemSplitRegex);
                var categories = [];
                var series = zrUtil.map(headers, function (header) {
                    return {
                        name: header,
                        data: []
                    };
                });
                for (var i = 0; i < tsvLines.length; i++) {
                    var items = trim(tsvLines[i]).split(itemSplitRegex);
                    categories.push(items.shift());
                    for (var j = 0; j < items.length; j++) {
                        series[j] && (series[j].data[i] = items[j]);
                    }
                }
                return {
                    series: series,
                    categories: categories
                };
            }
            function parseListContents(str) {
                var lines = str.split(/\n+/g);
                var seriesName = trim(lines.shift());
                var data = [];
                for (var i = 0; i < lines.length; i++) {
                    var items = trim(lines[i]).split(itemSplitRegex);
                    var name = '';
                    var value;
                    var hasName = false;
                    if (isNaN(items[0])) {
                        hasName = true;
                        name = items[0];
                        items = items.slice(1);
                        data[i] = {
                            name: name,
                            value: []
                        };
                        value = data[i].value;
                    } else {
                        value = data[i] = [];
                    }
                    for (var j = 0; j < items.length; j++) {
                        value.push(+items[j]);
                    }
                    if (value.length === 1) {
                        hasName ? data[i].value = value[0] : data[i] = value[0];
                    }
                }
                return {
                    name: seriesName,
                    data: data
                };
            }
            function parseContents(str, blockMetaList) {
                var blocks = str.split(new RegExp('\n*' + BLOCK_SPLITER + '\n*', 'g'));
                var newOption = { series: [] };
                zrUtil.each(blocks, function (block, idx) {
                    if (isTSVFormat(block)) {
                        var result = parseTSVContents(block);
                        var blockMeta = blockMetaList[idx];
                        var axisKey = blockMeta.axisDim + 'Axis';
                        if (blockMeta) {
                            newOption[axisKey] = newOption[axisKey] || [];
                            newOption[axisKey][blockMeta.axisIndex] = { data: result.categories };
                            newOption.series = newOption.series.concat(result.series);
                        }
                    } else {
                        var result = parseListContents(block);
                        newOption.series.push(result);
                    }
                });
                return newOption;
            }
            function DataView(model) {
                this._dom = null;
                this.model = model;
            }
            DataView.defaultOption = {
                show: true,
                readOnly: false,
                optionToContent: null,
                contentToOption: null,
                icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
                title: '数据视图',
                lang: [
                    '数据视图',
                    '关闭',
                    '刷新'
                ],
                backgroundColor: '#fff',
                textColor: '#000',
                textareaColor: '#fff',
                textareaBorderColor: '#333',
                buttonColor: '#c23531',
                buttonTextColor: '#fff'
            };
            DataView.prototype.onclick = function (ecModel, api) {
                var container = api.getDom();
                var model = this.model;
                if (this._dom) {
                    container.removeChild(this._dom);
                }
                var root = document.createElement('div');
                root.style.cssText = 'position:absolute;left:5px;top:5px;bottom:5px;right:5px;';
                root.style.backgroundColor = model.get('backgroundColor') || '#fff';
                var header = document.createElement('h4');
                var lang = model.get('lang') || [];
                header.innerHTML = lang[0] || model.get('title');
                header.style.cssText = 'margin: 10px 20px;';
                header.style.color = model.get('textColor');
                var viewMain = document.createElement('div');
                var textarea = document.createElement('textarea');
                viewMain.style.cssText = 'display:block;width:100%;overflow:hidden;';
                var optionToContent = model.get('optionToContent');
                var contentToOption = model.get('contentToOption');
                var result = getContentFromModel(ecModel);
                if (typeof optionToContent === 'function') {
                    var htmlOrDom = optionToContent(api.getOption());
                    if (typeof htmlOrDom === 'string') {
                        viewMain.innerHTML = htmlOrDom;
                    } else if (zrUtil.isDom(htmlOrDom)) {
                        viewMain.appendChild(htmlOrDom);
                    }
                } else {
                    viewMain.appendChild(textarea);
                    textarea.readOnly = model.get('readOnly');
                    textarea.style.cssText = 'width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;';
                    textarea.style.color = model.get('textColor');
                    textarea.style.borderColor = model.get('textareaBorderColor');
                    textarea.style.backgroundColor = model.get('textareaColor');
                    textarea.value = result.value;
                }
                var blockMetaList = result.meta;
                var buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = 'position:absolute;bottom:0;left:0;right:0;';
                var buttonStyle = 'float:right;margin-right:20px;border:none;' + 'cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px';
                var closeButton = document.createElement('div');
                var refreshButton = document.createElement('div');
                buttonStyle += ';background-color:' + model.get('buttonColor');
                buttonStyle += ';color:' + model.get('buttonTextColor');
                var self = this;
                function close() {
                    container.removeChild(root);
                    self._dom = null;
                }
                eventTool.addEventListener(closeButton, 'click', close);
                eventTool.addEventListener(refreshButton, 'click', function () {
                    var newOption;
                    try {
                        if (typeof contentToOption === 'function') {
                            newOption = contentToOption(viewMain, api.getOption());
                        } else {
                            newOption = parseContents(textarea.value, blockMetaList);
                        }
                    } catch (e) {
                        close();
                        throw new Error('Data view format error ' + e);
                    }
                    if (newOption) {
                        api.dispatchAction({
                            type: 'changeDataView',
                            newOption: newOption
                        });
                    }
                    close();
                });
                closeButton.innerHTML = lang[1];
                refreshButton.innerHTML = lang[2];
                refreshButton.style.cssText = buttonStyle;
                closeButton.style.cssText = buttonStyle;
                !model.get('readOnly') && buttonContainer.appendChild(refreshButton);
                buttonContainer.appendChild(closeButton);
                eventTool.addEventListener(textarea, 'keydown', function (e) {
                    if ((e.keyCode || e.which) === 9) {
                        var val = this.value;
                        var start = this.selectionStart;
                        var end = this.selectionEnd;
                        this.value = val.substring(0, start) + ITEM_SPLITER + val.substring(end);
                        this.selectionStart = this.selectionEnd = start + 1;
                        eventTool.stop(e);
                    }
                });
                root.appendChild(header);
                root.appendChild(viewMain);
                root.appendChild(buttonContainer);
                viewMain.style.height = container.clientHeight - 80 + 'px';
                container.appendChild(root);
                this._dom = root;
            };
            DataView.prototype.remove = function (ecModel, api) {
                this._dom && api.getDom().removeChild(this._dom);
            };
            DataView.prototype.dispose = function (ecModel, api) {
                this.remove(ecModel, api);
            };
            function tryMergeDataOption(newData, originalData) {
                return zrUtil.map(newData, function (newVal, idx) {
                    var original = originalData && originalData[idx];
                    if (zrUtil.isObject(original) && !zrUtil.isArray(original)) {
                        if (zrUtil.isObject(newVal) && !zrUtil.isArray(newVal)) {
                            newVal = newVal.value;
                        }
                        return zrUtil.defaults({ value: newVal }, original);
                    } else {
                        return newVal;
                    }
                });
            }
            __webpack_require__(333).register('dataView', DataView);
            __webpack_require__(1).registerAction({
                type: 'changeDataView',
                event: 'dataViewChanged',
                update: 'prepareAndUpdate'
            }, function (payload, ecModel) {
                var newSeriesOptList = [];
                zrUtil.each(payload.newOption.series, function (seriesOpt) {
                    var seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0];
                    if (!seriesModel) {
                        newSeriesOptList.push(zrUtil.extend({ type: 'scatter' }, seriesOpt));
                    } else {
                        var originalData = seriesModel.get('data');
                        newSeriesOptList.push({
                            name: seriesOpt.name,
                            data: tryMergeDataOption(seriesOpt.data, originalData)
                        });
                    }
                });
                ecModel.mergeOption(zrUtil.defaults({ series: newSeriesOptList }, payload.newOption));
            });
            module.exports = DataView;
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var zrUtil = __webpack_require__(3);
            var numberUtil = __webpack_require__(7);
            var SelectController = __webpack_require__(225);
            var BoundingRect = __webpack_require__(15);
            var Group = __webpack_require__(29);
            var history = __webpack_require__(340);
            var interactionMutex = __webpack_require__(160);
            var each = zrUtil.each;
            var asc = numberUtil.asc;
            __webpack_require__(341);
            var DATA_ZOOM_ID_BASE = '\0_ec_\0toolbox-dataZoom_';
            function DataZoom(model) {
                this.model = model;
                this._controllerGroup;
                this._controller;
                this._isZoomActive;
            }
            DataZoom.defaultOption = {
                show: true,
                icon: {
                    zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
                    back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'
                },
                title: {
                    zoom: '区域缩放',
                    back: '区域缩放还原'
                }
            };
            var proto = DataZoom.prototype;
            proto.render = function (featureModel, ecModel, api) {
                updateBackBtnStatus(featureModel, ecModel);
            };
            proto.onclick = function (ecModel, api, type) {
                var controllerGroup = this._controllerGroup;
                if (!this._controllerGroup) {
                    controllerGroup = this._controllerGroup = new Group();
                    api.getZr().add(controllerGroup);
                }
                handlers[type].call(this, controllerGroup, this.model, ecModel, api);
            };
            proto.remove = function (ecModel, api) {
                this._disposeController();
                interactionMutex.release('globalPan', api.getZr());
            };
            proto.dispose = function (ecModel, api) {
                var zr = api.getZr();
                interactionMutex.release('globalPan', zr);
                this._disposeController();
                this._controllerGroup && zr.remove(this._controllerGroup);
            };
            var handlers = {
                zoom: function (controllerGroup, featureModel, ecModel, api) {
                    var isZoomActive = this._isZoomActive = !this._isZoomActive;
                    var zr = api.getZr();
                    interactionMutex[isZoomActive ? 'take' : 'release']('globalPan', zr);
                    featureModel.setIconStatus('zoom', isZoomActive ? 'emphasis' : 'normal');
                    if (isZoomActive) {
                        zr.setDefaultCursorStyle('crosshair');
                        this._createController(controllerGroup, featureModel, ecModel, api);
                    } else {
                        zr.setDefaultCursorStyle('default');
                        this._disposeController();
                    }
                },
                back: function (controllerGroup, featureModel, ecModel, api) {
                    this._dispatchAction(history.pop(ecModel), api);
                }
            };
            proto._createController = function (controllerGroup, featureModel, ecModel, api) {
                var controller = this._controller = new SelectController('rect', api.getZr(), {
                    lineWidth: 3,
                    stroke: '#333',
                    fill: 'rgba(0,0,0,0.2)'
                });
                controller.on('selectEnd', zrUtil.bind(this._onSelected, this, controller, featureModel, ecModel, api));
                controller.enable(controllerGroup, false);
            };
            proto._disposeController = function () {
                var controller = this._controller;
                if (controller) {
                    controller.off('selected');
                    controller.dispose();
                }
            };
            function prepareCoordInfo(grid, ecModel) {
                var coordInfo = [
                    {
                        axisModel: grid.getAxis('x').model,
                        axisIndex: 0
                    },
                    {
                        axisModel: grid.getAxis('y').model,
                        axisIndex: 0
                    }
                ];
                coordInfo.grid = grid;
                ecModel.eachComponent({
                    mainType: 'dataZoom',
                    subType: 'select'
                }, function (dzModel, dataZoomIndex) {
                    if (isTheAxis('xAxis', coordInfo[0].axisModel, dzModel, ecModel)) {
                        coordInfo[0].dataZoomModel = dzModel;
                    }
                    if (isTheAxis('yAxis', coordInfo[1].axisModel, dzModel, ecModel)) {
                        coordInfo[1].dataZoomModel = dzModel;
                    }
                });
                return coordInfo;
            }
            function isTheAxis(axisName, axisModel, dataZoomModel, ecModel) {
                var axisIndex = dataZoomModel.get(axisName + 'Index');
                return axisIndex != null && ecModel.getComponent(axisName, axisIndex) === axisModel;
            }
            proto._onSelected = function (controller, featureModel, ecModel, api, selRanges) {
                if (!selRanges.length) {
                    return;
                }
                var selRange = selRanges[0];
                controller.update();
                var snapshot = {};
                ecModel.eachComponent('grid', function (gridModel, gridIndex) {
                    var grid = gridModel.coordinateSystem;
                    var coordInfo = prepareCoordInfo(grid, ecModel);
                    var selDataRange = pointToDataInCartesian(selRange, coordInfo);
                    if (selDataRange) {
                        var xBatchItem = scaleCartesianAxis(selDataRange, coordInfo, 0, 'x');
                        var yBatchItem = scaleCartesianAxis(selDataRange, coordInfo, 1, 'y');
                        xBatchItem && (snapshot[xBatchItem.dataZoomId] = xBatchItem);
                        yBatchItem && (snapshot[yBatchItem.dataZoomId] = yBatchItem);
                    }
                }, this);
                history.push(ecModel, snapshot);
                this._dispatchAction(snapshot, api);
            };
            function pointToDataInCartesian(selRange, coordInfo) {
                var grid = coordInfo.grid;
                var selRect = new BoundingRect(selRange[0][0], selRange[1][0], selRange[0][1] - selRange[0][0], selRange[1][1] - selRange[1][0]);
                if (!selRect.intersect(grid.getRect())) {
                    return;
                }
                var cartesian = grid.getCartesian(coordInfo[0].axisIndex, coordInfo[1].axisIndex);
                var dataLeftTop = cartesian.pointToData([
                    selRange[0][0],
                    selRange[1][0]
                ], true);
                var dataRightBottom = cartesian.pointToData([
                    selRange[0][1],
                    selRange[1][1]
                ], true);
                return [
                    asc([
                        dataLeftTop[0],
                        dataRightBottom[0]
                    ]),
                    asc([
                        dataLeftTop[1],
                        dataRightBottom[1]
                    ])
                ];
            }
            function scaleCartesianAxis(selDataRange, coordInfo, dimIdx, dimName) {
                var dimCoordInfo = coordInfo[dimIdx];
                var dataZoomModel = dimCoordInfo.dataZoomModel;
                if (dataZoomModel) {
                    return {
                        dataZoomId: dataZoomModel.id,
                        startValue: selDataRange[dimIdx][0],
                        endValue: selDataRange[dimIdx][1]
                    };
                }
            }
            proto._dispatchAction = function (snapshot, api) {
                var batch = [];
                each(snapshot, function (batchItem) {
                    batch.push(batchItem);
                });
                batch.length && api.dispatchAction({
                    type: 'dataZoom',
                    from: this.uid,
                    batch: zrUtil.clone(batch, true)
                });
            };
            function updateBackBtnStatus(featureModel, ecModel) {
                featureModel.setIconStatus('back', history.count(ecModel) > 1 ? 'emphasis' : 'normal');
            }
            __webpack_require__(333).register('dataZoom', DataZoom);
            __webpack_require__(1).registerPreprocessor(function (option) {
                if (!option) {
                    return;
                }
                var dataZoomOpts = option.dataZoom || (option.dataZoom = []);
                if (!zrUtil.isArray(dataZoomOpts)) {
                    dataZoomOpts = [dataZoomOpts];
                }
                var toolboxOpt = option.toolbox;
                if (toolboxOpt) {
                    if (zrUtil.isArray(toolboxOpt)) {
                        toolboxOpt = toolboxOpt[0];
                    }
                    if (toolboxOpt && toolboxOpt.feature) {
                        var dataZoomOpt = toolboxOpt.feature.dataZoom;
                        addForAxis('xAxis', dataZoomOpt);
                        addForAxis('yAxis', dataZoomOpt);
                    }
                }
                function addForAxis(axisName, dataZoomOpt) {
                    if (!dataZoomOpt) {
                        return;
                    }
                    var axisIndicesName = axisName + 'Index';
                    var givenAxisIndices = dataZoomOpt[axisIndicesName];
                    if (givenAxisIndices != null && !zrUtil.isArray(givenAxisIndices)) {
                        givenAxisIndices = givenAxisIndices === false ? [] : [givenAxisIndices];
                    }
                    forEachComponent(axisName, function (axisOpt, axisIndex) {
                        if (givenAxisIndices != null && zrUtil.indexOf(givenAxisIndices, axisIndex) === -1) {
                            return;
                        }
                        var newOpt = {
                            type: 'select',
                            $fromToolbox: true,
                            id: DATA_ZOOM_ID_BASE + axisName + axisIndex
                        };
                        newOpt[axisIndicesName] = axisIndex;
                        dataZoomOpts.push(newOpt);
                    });
                }
                function forEachComponent(mainType, cb) {
                    var opts = option[mainType];
                    if (!zrUtil.isArray(opts)) {
                        opts = opts ? [opts] : [];
                    }
                    each(opts, cb);
                }
            });
            module.exports = DataZoom;
        },
        function (module, exports, __webpack_require__) {
            var zrUtil = __webpack_require__(3);
            var each = zrUtil.each;
            var ATTR = '\0_ec_hist_store';
            var history = {
                push: function (ecModel, newSnapshot) {
                    var store = giveStore(ecModel);
                    each(newSnapshot, function (batchItem, dataZoomId) {
                        var i = store.length - 1;
                        for (; i >= 0; i--) {
                            var snapshot = store[i];
                            if (snapshot[dataZoomId]) {
                                break;
                            }
                        }
                        if (i < 0) {
                            var dataZoomModel = ecModel.queryComponents({
                                mainType: 'dataZoom',
                                subType: 'select',
                                id: dataZoomId
                            })[0];
                            if (dataZoomModel) {
                                var percentRange = dataZoomModel.getPercentRange();
                                store[0][dataZoomId] = {
                                    dataZoomId: dataZoomId,
                                    start: percentRange[0],
                                    end: percentRange[1]
                                };
                            }
                        }
                    });
                    store.push(newSnapshot);
                },
                pop: function (ecModel) {
                    var store = giveStore(ecModel);
                    var head = store[store.length - 1];
                    store.length > 1 && store.pop();
                    var snapshot = {};
                    each(head, function (batchItem, dataZoomId) {
                        for (var i = store.length - 1; i >= 0; i--) {
                            var batchItem = store[i][dataZoomId];
                            if (batchItem) {
                                snapshot[dataZoomId] = batchItem;
                                break;
                            }
                        }
                    });
                    return snapshot;
                },
                clear: function (ecModel) {
                    ecModel[ATTR] = null;
                },
                count: function (ecModel) {
                    return giveStore(ecModel).length;
                }
            };
            function giveStore(ecModel) {
                var store = ecModel[ATTR];
                if (!store) {
                    store = ecModel[ATTR] = [{}];
                }
                return store;
            }
            module.exports = history;
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(287);
            __webpack_require__(288);
            __webpack_require__(290);
            __webpack_require__(342);
            __webpack_require__(343);
            __webpack_require__(298);
            __webpack_require__(299);
        },
        function (module, exports, __webpack_require__) {
            var DataZoomModel = __webpack_require__(288);
            module.exports = DataZoomModel.extend({ type: 'dataZoom.select' });
        },
        function (module, exports, __webpack_require__) {
            module.exports = __webpack_require__(290).extend({ type: 'dataZoom.select' });
        },
        function (module, exports, __webpack_require__) {
            'use strict';
            var history = __webpack_require__(340);
            function Restore(model) {
                this.model = model;
            }
            Restore.defaultOption = {
                show: true,
                icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',
                title: '还原'
            };
            var proto = Restore.prototype;
            proto.onclick = function (ecModel, api, type) {
                history.clear(ecModel);
                api.dispatchAction({
                    type: 'restore',
                    from: this.uid
                });
            };
            __webpack_require__(333).register('restore', Restore);
            __webpack_require__(1).registerAction({
                type: 'restore',
                event: 'restore',
                update: 'prepareAndUpdate'
            }, function (payload, ecModel) {
                ecModel.resetOption('recreate');
            });
            module.exports = Restore;
        },
        function (module, exports, __webpack_require__) {
            __webpack_require__(346);
            __webpack_require__(77).registerPainter('vml', __webpack_require__(348));
        },
        function (module, exports, __webpack_require__) {
            if (!__webpack_require__(78).canvasSupported) {
                var vec2 = __webpack_require__(16);
                var BoundingRect = __webpack_require__(15);
                var CMD = __webpack_require__(48).CMD;
                var colorTool = __webpack_require__(38);
                var textContain = __webpack_require__(14);
                var RectText = __webpack_require__(47);
                var Displayable = __webpack_require__(45);
                var ZImage = __webpack_require__(59);
                var Text = __webpack_require__(62);
                var Path = __webpack_require__(44);
                var Gradient = __webpack_require__(4);
                var vmlCore = __webpack_require__(347);
                var round = Math.round;
                var sqrt = Math.sqrt;
                var abs = Math.abs;
                var cos = Math.cos;
                var sin = Math.sin;
                var mathMax = Math.max;
                var applyTransform = vec2.applyTransform;
                var comma = ',';
                var imageTransformPrefix = 'progid:DXImageTransform.Microsoft';
                var Z = 21600;
                var Z2 = Z / 2;
                var ZLEVEL_BASE = 100000;
                var Z_BASE = 1000;
                var initRootElStyle = function (el) {
                    el.style.cssText = 'position:absolute;left:0;top:0;width:1px;height:1px;';
                    el.coordsize = Z + ',' + Z;
                    el.coordorigin = '0,0';
                };
                var encodeHtmlAttribute = function (s) {
                    return String(s).replace(/&/g, '&amp;').replace(/"/g, '&quot;');
                };
                var rgb2Str = function (r, g, b) {
                    return 'rgb(' + [
                        r,
                        g,
                        b
                    ].join(',') + ')';
                };
                var append = function (parent, child) {
                    if (child && parent && child.parentNode !== parent) {
                        parent.appendChild(child);
                    }
                };
                var remove = function (parent, child) {
                    if (child && parent && child.parentNode === parent) {
                        parent.removeChild(child);
                    }
                };
                var getZIndex = function (zlevel, z, z2) {
                    return (parseFloat(zlevel) || 0) * ZLEVEL_BASE + (parseFloat(z) || 0) * Z_BASE + z2;
                };
                var parsePercent = function (value, maxValue) {
                    if (typeof value === 'string') {
                        if (value.lastIndexOf('%') >= 0) {
                            return parseFloat(value) / 100 * maxValue;
                        }
                        return parseFloat(value);
                    }
                    return value;
                };
                var setColorAndOpacity = function (el, color, opacity) {
                    var colorArr = colorTool.parse(color);
                    opacity = +opacity;
                    if (isNaN(opacity)) {
                        opacity = 1;
                    }
                    if (colorArr) {
                        el.color = rgb2Str(colorArr[0], colorArr[1], colorArr[2]);
                        el.opacity = opacity * colorArr[3];
                    }
                };
                var getColorAndAlpha = function (color) {
                    var colorArr = colorTool.parse(color);
                    return [
                        rgb2Str(colorArr[0], colorArr[1], colorArr[2]),
                        colorArr[3]
                    ];
                };
                var updateFillNode = function (el, style, zrEl) {
                    var fill = style.fill;
                    if (fill != null) {
                        if (fill instanceof Gradient) {
                            var gradientType;
                            var angle = 0;
                            var focus = [
                                0,
                                0
                            ];
                            var shift = 0;
                            var expansion = 1;
                            var rect = zrEl.getBoundingRect();
                            var rectWidth = rect.width;
                            var rectHeight = rect.height;
                            if (fill.type === 'linear') {
                                gradientType = 'gradient';
                                var transform = zrEl.transform;
                                var p0 = [
                                    fill.x * rectWidth,
                                    fill.y * rectHeight
                                ];
                                var p1 = [
                                    fill.x2 * rectWidth,
                                    fill.y2 * rectHeight
                                ];
                                if (transform) {
                                    applyTransform(p0, p0, transform);
                                    applyTransform(p1, p1, transform);
                                }
                                var dx = p1[0] - p0[0];
                                var dy = p1[1] - p0[1];
                                angle = Math.atan2(dx, dy) * 180 / Math.PI;
                                if (angle < 0) {
                                    angle += 360;
                                }
                                if (angle < 0.000001) {
                                    angle = 0;
                                }
                            } else {
                                gradientType = 'gradientradial';
                                var p0 = [
                                    fill.x * rectWidth,
                                    fill.y * rectHeight
                                ];
                                var transform = zrEl.transform;
                                var scale = zrEl.scale;
                                var width = rectWidth;
                                var height = rectHeight;
                                focus = [
                                    (p0[0] - rect.x) / width,
                                    (p0[1] - rect.y) / height
                                ];
                                if (transform) {
                                    applyTransform(p0, p0, transform);
                                }
                                width /= scale[0] * Z;
                                height /= scale[1] * Z;
                                var dimension = mathMax(width, height);
                                shift = 2 * 0 / dimension;
                                expansion = 2 * fill.r / dimension - shift;
                            }
                            var stops = fill.colorStops.slice();
                            stops.sort(function (cs1, cs2) {
                                return cs1.offset - cs2.offset;
                            });
                            var length = stops.length;
                            var colorAndAlphaList = [];
                            var colors = [];
                            for (var i = 0; i < length; i++) {
                                var stop = stops[i];
                                var colorAndAlpha = getColorAndAlpha(stop.color);
                                colors.push(stop.offset * expansion + shift + ' ' + colorAndAlpha[0]);
                                if (i === 0 || i === length - 1) {
                                    colorAndAlphaList.push(colorAndAlpha);
                                }
                            }
                            if (length >= 2) {
                                var color1 = colorAndAlphaList[0][0];
                                var color2 = colorAndAlphaList[1][0];
                                var opacity1 = colorAndAlphaList[0][1] * style.opacity;
                                var opacity2 = colorAndAlphaList[1][1] * style.opacity;
                                el.type = gradientType;
                                el.method = 'none';
                                el.focus = '100%';
                                el.angle = angle;
                                el.color = color1;
                                el.color2 = color2;
                                el.colors = colors.join(',');
                                el.opacity = opacity2;
                                el.opacity2 = opacity1;
                            }
                            if (gradientType === 'radial') {
                                el.focusposition = focus.join(',');
                            }
                        } else {
                            setColorAndOpacity(el, fill, style.opacity);
                        }
                    }
                };
                var updateStrokeNode = function (el, style) {
                    if (style.lineJoin != null) {
                        el.joinstyle = style.lineJoin;
                    }
                    if (style.miterLimit != null) {
                        el.miterlimit = style.miterLimit * Z;
                    }
                    if (style.lineCap != null) {
                        el.endcap = style.lineCap;
                    }
                    if (style.lineDash != null) {
                        el.dashstyle = style.lineDash.join(' ');
                    }
                    if (style.stroke != null && !(style.stroke instanceof Gradient)) {
                        setColorAndOpacity(el, style.stroke, style.opacity);
                    }
                };
                var updateFillAndStroke = function (vmlEl, type, style, zrEl) {
                    var isFill = type == 'fill';
                    var el = vmlEl.getElementsByTagName(type)[0];
                    if (style[type] != null && style[type] !== 'none' && (isFill || !isFill && style.lineWidth)) {
                        vmlEl[isFill ? 'filled' : 'stroked'] = 'true';
                        if (style[type] instanceof Gradient) {
                            remove(vmlEl, el);
                        }
                        if (!el) {
                            el = vmlCore.createNode(type);
                        }
                        isFill ? updateFillNode(el, style, zrEl) : updateStrokeNode(el, style);
                        append(vmlEl, el);
                    } else {
                        vmlEl[isFill ? 'filled' : 'stroked'] = 'false';
                        remove(vmlEl, el);
                    }
                };
                var points = [
                    [],
                    [],
                    []
                ];
                var pathDataToString = function (data, m) {
                    var M = CMD.M;
                    var C = CMD.C;
                    var L = CMD.L;
                    var A = CMD.A;
                    var Q = CMD.Q;
                    var str = [];
                    var nPoint;
                    var cmdStr;
                    var cmd;
                    var i;
                    var xi;
                    var yi;
                    for (i = 0; i < data.length;) {
                        cmd = data[i++];
                        cmdStr = '';
                        nPoint = 0;
                        switch (cmd) {
                        case M:
                            cmdStr = ' m ';
                            nPoint = 1;
                            xi = data[i++];
                            yi = data[i++];
                            points[0][0] = xi;
                            points[0][1] = yi;
                            break;
                        case L:
                            cmdStr = ' l ';
                            nPoint = 1;
                            xi = data[i++];
                            yi = data[i++];
                            points[0][0] = xi;
                            points[0][1] = yi;
                            break;
                        case Q:
                        case C:
                            cmdStr = ' c ';
                            nPoint = 3;
                            var x1 = data[i++];
                            var y1 = data[i++];
                            var x2 = data[i++];
                            var y2 = data[i++];
                            var x3;
                            var y3;
                            if (cmd === Q) {
                                x3 = x2;
                                y3 = y2;
                                x2 = (x2 + 2 * x1) / 3;
                                y2 = (y2 + 2 * y1) / 3;
                                x1 = (xi + 2 * x1) / 3;
                                y1 = (yi + 2 * y1) / 3;
                            } else {
                                x3 = data[i++];
                                y3 = data[i++];
                            }
                            points[0][0] = x1;
                            points[0][1] = y1;
                            points[1][0] = x2;
                            points[1][1] = y2;
                            points[2][0] = x3;
                            points[2][1] = y3;
                            xi = x3;
                            yi = y3;
                            break;
                        case A:
                            var x = 0;
                            var y = 0;
                            var sx = 1;
                            var sy = 1;
                            var angle = 0;
                            if (m) {
                                x = m[4];
                                y = m[5];
                                sx = sqrt(m[0] * m[0] + m[1] * m[1]);
                                sy = sqrt(m[2] * m[2] + m[3] * m[3]);
                                angle = Math.atan2(-m[1] / sy, m[0] / sx);
                            }
                            var cx = data[i++];
                            var cy = data[i++];
                            var rx = data[i++];
                            var ry = data[i++];
                            var startAngle = data[i++] + angle;
                            var endAngle = data[i++] + startAngle + angle;
                            i++;
                            var clockwise = data[i++];
                            var x0 = cx + cos(startAngle) * rx;
                            var y0 = cy + sin(startAngle) * ry;
                            var x1 = cx + cos(endAngle) * rx;
                            var y1 = cy + sin(endAngle) * ry;
                            var type = clockwise ? ' wa ' : ' at ';
                            if (Math.abs(x0 - x1) < 1e-10 && clockwise) {
                                x0 += 270 / Z;
                            }
                            str.push(type, round(((cx - rx) * sx + x) * Z - Z2), comma, round(((cy - ry) * sy + y) * Z - Z2), comma, round(((cx + rx) * sx + x) * Z - Z2), comma, round(((cy + ry) * sy + y) * Z - Z2), comma, round((x0 * sx + x) * Z - Z2), comma, round((y0 * sy + y) * Z - Z2), comma, round((x1 * sx + x) * Z - Z2), comma, round((y1 * sy + y) * Z - Z2));
                            xi = x1;
                            yi = y1;
                            break;
                        case CMD.R:
                            var p0 = points[0];
                            var p1 = points[1];
                            p0[0] = data[i++];
                            p0[1] = data[i++];
                            p1[0] = p0[0] + data[i++];
                            p1[1] = p0[1] + data[i++];
                            if (m) {
                                applyTransform(p0, p0, m);
                                applyTransform(p1, p1, m);
                            }
                            p0[0] = round(p0[0] * Z - Z2);
                            p1[0] = round(p1[0] * Z - Z2);
                            p0[1] = round(p0[1] * Z - Z2);
                            p1[1] = round(p1[1] * Z - Z2);
                            str.push(' m ', p0[0], comma, p0[1], ' l ', p1[0], comma, p0[1], ' l ', p1[0], comma, p1[1], ' l ', p0[0], comma, p1[1]);
                            break;
                        case CMD.Z:
                            str.push(' x ');
                        }
                        if (nPoint > 0) {
                            str.push(cmdStr);
                            for (var k = 0; k < nPoint; k++) {
                                var p = points[k];
                                m && applyTransform(p, p, m);
                                str.push(round(p[0] * Z - Z2), comma, round(p[1] * Z - Z2), k < nPoint - 1 ? comma : '');
                            }
                        }
                    }
                    return str.join('');
                };
                Path.prototype.brushVML = function (vmlRoot) {
                    var style = this.style;
                    var vmlEl = this._vmlEl;
                    if (!vmlEl) {
                        vmlEl = vmlCore.createNode('shape');
                        initRootElStyle(vmlEl);
                        this._vmlEl = vmlEl;
                    }
                    updateFillAndStroke(vmlEl, 'fill', style, this);
                    updateFillAndStroke(vmlEl, 'stroke', style, this);
                    var m = this.transform;
                    var needTransform = m != null;
                    var strokeEl = vmlEl.getElementsByTagName('stroke')[0];
                    if (strokeEl) {
                        var lineWidth = style.lineWidth;
                        if (needTransform && !style.strokeNoScale) {
                            var det = m[0] * m[3] - m[1] * m[2];
                            lineWidth *= sqrt(abs(det));
                        }
                        strokeEl.weight = lineWidth + 'px';
                    }
                    var path = this.path;
                    if (this.__dirtyPath) {
                        path.beginPath();
                        this.buildPath(path, this.shape);
                        path.toStatic();
                        this.__dirtyPath = false;
                    }
                    vmlEl.path = pathDataToString(path.data, this.transform);
                    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
                    append(vmlRoot, vmlEl);
                    if (style.text) {
                        this.drawRectText(vmlRoot, this.getBoundingRect());
                    }
                };
                Path.prototype.onRemove = function (vmlRoot) {
                    remove(vmlRoot, this._vmlEl);
                    this.removeRectText(vmlRoot);
                };
                Path.prototype.onAdd = function (vmlRoot) {
                    append(vmlRoot, this._vmlEl);
                    this.appendRectText(vmlRoot);
                };
                var isImage = function (img) {
                    return typeof img === 'object' && img.tagName && img.tagName.toUpperCase() === 'IMG';
                };
                ZImage.prototype.brushVML = function (vmlRoot) {
                    var style = this.style;
                    var image = style.image;
                    var ow;
                    var oh;
                    if (isImage(image)) {
                        var src = image.src;
                        if (src === this._imageSrc) {
                            ow = this._imageWidth;
                            oh = this._imageHeight;
                        } else {
                            var imageRuntimeStyle = image.runtimeStyle;
                            var oldRuntimeWidth = imageRuntimeStyle.width;
                            var oldRuntimeHeight = imageRuntimeStyle.height;
                            imageRuntimeStyle.width = 'auto';
                            imageRuntimeStyle.height = 'auto';
                            ow = image.width;
                            oh = image.height;
                            imageRuntimeStyle.width = oldRuntimeWidth;
                            imageRuntimeStyle.height = oldRuntimeHeight;
                            this._imageSrc = src;
                            this._imageWidth = ow;
                            this._imageHeight = oh;
                        }
                        image = src;
                    } else {
                        if (image === this._imageSrc) {
                            ow = this._imageWidth;
                            oh = this._imageHeight;
                        }
                    }
                    if (!image) {
                        return;
                    }
                    var x = style.x || 0;
                    var y = style.y || 0;
                    var dw = style.width;
                    var dh = style.height;
                    var sw = style.sWidth;
                    var sh = style.sHeight;
                    var sx = style.sx || 0;
                    var sy = style.sy || 0;
                    var hasCrop = sw && sh;
                    var vmlEl = this._vmlEl;
                    if (!vmlEl) {
                        vmlEl = vmlCore.doc.createElement('div');
                        initRootElStyle(vmlEl);
                        this._vmlEl = vmlEl;
                    }
                    var vmlElStyle = vmlEl.style;
                    var hasRotation = false;
                    var m;
                    var scaleX = 1;
                    var scaleY = 1;
                    if (this.transform) {
                        m = this.transform;
                        scaleX = sqrt(m[0] * m[0] + m[1] * m[1]);
                        scaleY = sqrt(m[2] * m[2] + m[3] * m[3]);
                        hasRotation = m[1] || m[2];
                    }
                    if (hasRotation) {
                        var p0 = [
                            x,
                            y
                        ];
                        var p1 = [
                            x + dw,
                            y
                        ];
                        var p2 = [
                            x,
                            y + dh
                        ];
                        var p3 = [
                            x + dw,
                            y + dh
                        ];
                        applyTransform(p0, p0, m);
                        applyTransform(p1, p1, m);
                        applyTransform(p2, p2, m);
                        applyTransform(p3, p3, m);
                        var maxX = mathMax(p0[0], p1[0], p2[0], p3[0]);
                        var maxY = mathMax(p0[1], p1[1], p2[1], p3[1]);
                        var transformFilter = [];
                        transformFilter.push('M11=', m[0] / scaleX, comma, 'M12=', m[2] / scaleY, comma, 'M21=', m[1] / scaleX, comma, 'M22=', m[3] / scaleY, comma, 'Dx=', round(x * scaleX + m[4]), comma, 'Dy=', round(y * scaleY + m[5]));
                        vmlElStyle.padding = '0 ' + round(maxX) + 'px ' + round(maxY) + 'px 0';
                        vmlElStyle.filter = imageTransformPrefix + '.Matrix(' + transformFilter.join('') + ', SizingMethod=clip)';
                    } else {
                        if (m) {
                            x = x * scaleX + m[4];
                            y = y * scaleY + m[5];
                        }
                        vmlElStyle.filter = '';
                        vmlElStyle.left = round(x) + 'px';
                        vmlElStyle.top = round(y) + 'px';
                    }
                    var imageEl = this._imageEl;
                    var cropEl = this._cropEl;
                    if (!imageEl) {
                        imageEl = vmlCore.doc.createElement('div');
                        this._imageEl = imageEl;
                    }
                    var imageELStyle = imageEl.style;
                    if (hasCrop) {
                        if (!(ow && oh)) {
                            var tmpImage = new Image();
                            var self = this;
                            tmpImage.onload = function () {
                                tmpImage.onload = null;
                                ow = tmpImage.width;
                                oh = tmpImage.height;
                                imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
                                imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
                                self._imageWidth = ow;
                                self._imageHeight = oh;
                                self._imageSrc = image;
                            };
                            tmpImage.src = image;
                        } else {
                            imageELStyle.width = round(scaleX * ow * dw / sw) + 'px';
                            imageELStyle.height = round(scaleY * oh * dh / sh) + 'px';
                        }
                        if (!cropEl) {
                            cropEl = vmlCore.doc.createElement('div');
                            cropEl.style.overflow = 'hidden';
                            this._cropEl = cropEl;
                        }
                        var cropElStyle = cropEl.style;
                        cropElStyle.width = round((dw + sx * dw / sw) * scaleX);
                        cropElStyle.height = round((dh + sy * dh / sh) * scaleY);
                        cropElStyle.filter = imageTransformPrefix + '.Matrix(Dx=' + -sx * dw / sw * scaleX + ',Dy=' + -sy * dh / sh * scaleY + ')';
                        if (!cropEl.parentNode) {
                            vmlEl.appendChild(cropEl);
                        }
                        if (imageEl.parentNode != cropEl) {
                            cropEl.appendChild(imageEl);
                        }
                    } else {
                        imageELStyle.width = round(scaleX * dw) + 'px';
                        imageELStyle.height = round(scaleY * dh) + 'px';
                        vmlEl.appendChild(imageEl);
                        if (cropEl && cropEl.parentNode) {
                            vmlEl.removeChild(cropEl);
                            this._cropEl = null;
                        }
                    }
                    var filterStr = '';
                    var alpha = style.opacity;
                    if (alpha < 1) {
                        filterStr += '.Alpha(opacity=' + round(alpha * 100) + ') ';
                    }
                    filterStr += imageTransformPrefix + '.AlphaImageLoader(src=' + image + ', SizingMethod=scale)';
                    imageELStyle.filter = filterStr;
                    vmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
                    append(vmlRoot, vmlEl);
                    if (style.text) {
                        this.drawRectText(vmlRoot, this.getBoundingRect());
                    }
                };
                ZImage.prototype.onRemove = function (vmlRoot) {
                    remove(vmlRoot, this._vmlEl);
                    this._vmlEl = null;
                    this._cropEl = null;
                    this._imageEl = null;
                    this.removeRectText(vmlRoot);
                };
                ZImage.prototype.onAdd = function (vmlRoot) {
                    append(vmlRoot, this._vmlEl);
                    this.appendRectText(vmlRoot);
                };
                var DEFAULT_STYLE_NORMAL = 'normal';
                var fontStyleCache = {};
                var fontStyleCacheCount = 0;
                var MAX_FONT_CACHE_SIZE = 100;
                var fontEl = document.createElement('div');
                var getFontStyle = function (fontString) {
                    var fontStyle = fontStyleCache[fontString];
                    if (!fontStyle) {
                        if (fontStyleCacheCount > MAX_FONT_CACHE_SIZE) {
                            fontStyleCacheCount = 0;
                            fontStyleCache = {};
                        }
                        var style = fontEl.style;
                        var fontFamily;
                        try {
                            style.font = fontString;
                            fontFamily = style.fontFamily.split(',')[0];
                        } catch (e) {
                        }
                        fontStyle = {
                            style: style.fontStyle || DEFAULT_STYLE_NORMAL,
                            variant: style.fontVariant || DEFAULT_STYLE_NORMAL,
                            weight: style.fontWeight || DEFAULT_STYLE_NORMAL,
                            size: parseFloat(style.fontSize || 12) | 0,
                            family: fontFamily || 'Microsoft YaHei'
                        };
                        fontStyleCache[fontString] = fontStyle;
                        fontStyleCacheCount++;
                    }
                    return fontStyle;
                };
                var textMeasureEl;
                textContain.measureText = function (text, textFont) {
                    var doc = vmlCore.doc;
                    if (!textMeasureEl) {
                        textMeasureEl = doc.createElement('div');
                        textMeasureEl.style.cssText = 'position:absolute;top:-20000px;left:0;' + 'padding:0;margin:0;border:none;white-space:pre;';
                        vmlCore.doc.body.appendChild(textMeasureEl);
                    }
                    try {
                        textMeasureEl.style.font = textFont;
                    } catch (ex) {
                    }
                    textMeasureEl.innerHTML = '';
                    textMeasureEl.appendChild(doc.createTextNode(text));
                    return { width: textMeasureEl.offsetWidth };
                };
                var tmpRect = new BoundingRect();
                var drawRectText = function (vmlRoot, rect, textRect, fromTextEl) {
                    var style = this.style;
                    var text = style.text;
                    if (!text) {
                        return;
                    }
                    var x;
                    var y;
                    var align = style.textAlign;
                    var fontStyle = getFontStyle(style.textFont);
                    var font = fontStyle.style + ' ' + fontStyle.variant + ' ' + fontStyle.weight + ' ' + fontStyle.size + 'px "' + fontStyle.family + '"';
                    var baseline = style.textBaseline;
                    var verticalAlign = style.textVerticalAlign;
                    textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);
                    var m = this.transform;
                    if (m && !fromTextEl) {
                        tmpRect.copy(rect);
                        tmpRect.applyTransform(m);
                        rect = tmpRect;
                    }
                    if (!fromTextEl) {
                        var textPosition = style.textPosition;
                        var distance = style.textDistance;
                        if (textPosition instanceof Array) {
                            x = rect.x + parsePercent(textPosition[0], rect.width);
                            y = rect.y + parsePercent(textPosition[1], rect.height);
                            align = align || 'left';
                            baseline = baseline || 'top';
                        } else {
                            var res = textContain.adjustTextPositionOnRect(textPosition, rect, textRect, distance);
                            x = res.x;
                            y = res.y;
                            align = align || res.textAlign;
                            baseline = baseline || res.textBaseline;
                        }
                    } else {
                        x = rect.x;
                        y = rect.y;
                    }
                    if (verticalAlign) {
                        switch (verticalAlign) {
                        case 'middle':
                            y -= textRect.height / 2;
                            break;
                        case 'bottom':
                            y -= textRect.height;
                            break;
                        }
                        baseline = 'top';
                    }
                    var fontSize = fontStyle.size;
                    switch (baseline) {
                    case 'hanging':
                    case 'top':
                        y += fontSize / 1.75;
                        break;
                    case 'middle':
                        break;
                    default:
                        y -= fontSize / 2.25;
                        break;
                    }
                    switch (align) {
                    case 'left':
                        break;
                    case 'center':
                        x -= textRect.width / 2;
                        break;
                    case 'right':
                        x -= textRect.width;
                        break;
                    }
                    var createNode = vmlCore.createNode;
                    var textVmlEl = this._textVmlEl;
                    var pathEl;
                    var textPathEl;
                    var skewEl;
                    if (!textVmlEl) {
                        textVmlEl = createNode('line');
                        pathEl = createNode('path');
                        textPathEl = createNode('textpath');
                        skewEl = createNode('skew');
                        textPathEl.style['v-text-align'] = 'left';
                        initRootElStyle(textVmlEl);
                        pathEl.textpathok = true;
                        textPathEl.on = true;
                        textVmlEl.from = '0 0';
                        textVmlEl.to = '1000 0.05';
                        append(textVmlEl, skewEl);
                        append(textVmlEl, pathEl);
                        append(textVmlEl, textPathEl);
                        this._textVmlEl = textVmlEl;
                    } else {
                        skewEl = textVmlEl.firstChild;
                        pathEl = skewEl.nextSibling;
                        textPathEl = pathEl.nextSibling;
                    }
                    var coords = [
                        x,
                        y
                    ];
                    var textVmlElStyle = textVmlEl.style;
                    if (m && fromTextEl) {
                        applyTransform(coords, coords, m);
                        skewEl.on = true;
                        skewEl.matrix = m[0].toFixed(3) + comma + m[2].toFixed(3) + comma + m[1].toFixed(3) + comma + m[3].toFixed(3) + ',0,0';
                        skewEl.offset = (round(coords[0]) || 0) + ',' + (round(coords[1]) || 0);
                        skewEl.origin = '0 0';
                        textVmlElStyle.left = '0px';
                        textVmlElStyle.top = '0px';
                    } else {
                        skewEl.on = false;
                        textVmlElStyle.left = round(x) + 'px';
                        textVmlElStyle.top = round(y) + 'px';
                    }
                    textPathEl.string = encodeHtmlAttribute(text);
                    try {
                        textPathEl.style.font = font;
                    } catch (e) {
                    }
                    updateFillAndStroke(textVmlEl, 'fill', {
                        fill: fromTextEl ? style.fill : style.textFill,
                        opacity: style.opacity
                    }, this);
                    updateFillAndStroke(textVmlEl, 'stroke', {
                        stroke: fromTextEl ? style.stroke : style.textStroke,
                        opacity: style.opacity,
                        lineDash: style.lineDash
                    }, this);
                    textVmlEl.style.zIndex = getZIndex(this.zlevel, this.z, this.z2);
                    append(vmlRoot, textVmlEl);
                };
                var removeRectText = function (vmlRoot) {
                    remove(vmlRoot, this._textVmlEl);
                    this._textVmlEl = null;
                };
                var appendRectText = function (vmlRoot) {
                    append(vmlRoot, this._textVmlEl);
                };
                var list = [
                    RectText,
                    Displayable,
                    ZImage,
                    Path,
                    Text
                ];
                for (var i = 0; i < list.length; i++) {
                    var proto = list[i].prototype;
                    proto.drawRectText = drawRectText;
                    proto.removeRectText = removeRectText;
                    proto.appendRectText = appendRectText;
                }
                Text.prototype.brushVML = function (root) {
                    var style = this.style;
                    if (style.text) {
                        this.drawRectText(root, {
                            x: style.x || 0,
                            y: style.y || 0,
                            width: 0,
                            height: 0
                        }, this.getBoundingRect(), true);
                    }
                };
                Text.prototype.onRemove = function (vmlRoot) {
                    this.removeRectText(vmlRoot);
                };
                Text.prototype.onAdd = function (vmlRoot) {
                    this.appendRectText(vmlRoot);
                };
            }
        },
        function (module, exports, __webpack_require__) {
            if (!__webpack_require__(78).canvasSupported) {
                var urn = 'urn:schemas-microsoft-com:vml';
                var createNode;
                var win = window;
                var doc = win.document;
                var vmlInited = false;
                try {
                    !doc.namespaces.zrvml && doc.namespaces.add('zrvml', urn);
                    createNode = function (tagName) {
                        return doc.createElement('<zrvml:' + tagName + ' class="zrvml">');
                    };
                } catch (e) {
                    createNode = function (tagName) {
                        return doc.createElement('<' + tagName + ' xmlns="' + urn + '" class="zrvml">');
                    };
                }
                var initVML = function () {
                    if (vmlInited) {
                        return;
                    }
                    vmlInited = true;
                    var styleSheets = doc.styleSheets;
                    if (styleSheets.length < 31) {
                        doc.createStyleSheet().addRule('.zrvml', 'behavior:url(#default#VML)');
                    } else {
                        styleSheets[0].addRule('.zrvml', 'behavior:url(#default#VML)');
                    }
                };
                module.exports = {
                    doc: doc,
                    initVML: initVML,
                    createNode: createNode
                };
            }
        },
        function (module, exports, __webpack_require__) {
            var zrLog = __webpack_require__(39);
            var vmlCore = __webpack_require__(347);
            function parseInt10(val) {
                return parseInt(val, 10);
            }
            function VMLPainter(root, storage) {
                vmlCore.initVML();
                this.root = root;
                this.storage = storage;
                var vmlViewport = document.createElement('div');
                var vmlRoot = document.createElement('div');
                vmlViewport.style.cssText = 'display:inline-block;overflow:hidden;position:relative;width:300px;height:150px;';
                vmlRoot.style.cssText = 'position:absolute;left:0;top:0;';
                root.appendChild(vmlViewport);
                this._vmlRoot = vmlRoot;
                this._vmlViewport = vmlViewport;
                this.resize();
                var oldDelFromMap = storage.delFromMap;
                var oldAddToMap = storage.addToMap;
                storage.delFromMap = function (elId) {
                    var el = storage.get(elId);
                    oldDelFromMap.call(storage, elId);
                    if (el) {
                        el.onRemove && el.onRemove(vmlRoot);
                    }
                };
                storage.addToMap = function (el) {
                    el.onAdd && el.onAdd(vmlRoot);
                    oldAddToMap.call(storage, el);
                };
                this._firstPaint = true;
            }
            VMLPainter.prototype = {
                constructor: VMLPainter,
                getViewportRoot: function () {
                    return this._vmlViewport;
                },
                refresh: function () {
                    var list = this.storage.getDisplayList(true, true);
                    this._paintList(list);
                },
                _paintList: function (list) {
                    var vmlRoot = this._vmlRoot;
                    for (var i = 0; i < list.length; i++) {
                        var el = list[i];
                        if (el.invisible || el.ignore) {
                            if (!el.__alreadyNotVisible) {
                                el.onRemove(vmlRoot);
                            }
                            el.__alreadyNotVisible = true;
                        } else {
                            if (el.__alreadyNotVisible) {
                                el.onAdd(vmlRoot);
                            }
                            el.__alreadyNotVisible = false;
                            if (el.__dirty) {
                                el.beforeBrush && el.beforeBrush();
                                (el.brushVML || el.brush).call(el, vmlRoot);
                                el.afterBrush && el.afterBrush();
                            }
                        }
                        el.__dirty = false;
                    }
                    if (this._firstPaint) {
                        this._vmlViewport.appendChild(vmlRoot);
                        this._firstPaint = false;
                    }
                },
                resize: function () {
                    var width = this._getWidth();
                    var height = this._getHeight();
                    if (this._width != width && this._height != height) {
                        this._width = width;
                        this._height = height;
                        var vmlViewportStyle = this._vmlViewport.style;
                        vmlViewportStyle.width = width + 'px';
                        vmlViewportStyle.height = height + 'px';
                    }
                },
                dispose: function () {
                    this.root.innerHTML = '';
                    this._vmlRoot = this._vmlViewport = this.storage = null;
                },
                getWidth: function () {
                    return this._width;
                },
                getHeight: function () {
                    return this._height;
                },
                _getWidth: function () {
                    var root = this.root;
                    var stl = root.currentStyle;
                    return (root.clientWidth || parseInt10(stl.width)) - parseInt10(stl.paddingLeft) - parseInt10(stl.paddingRight) | 0;
                },
                _getHeight: function () {
                    var root = this.root;
                    var stl = root.currentStyle;
                    return (root.clientHeight || parseInt10(stl.height)) - parseInt10(stl.paddingTop) - parseInt10(stl.paddingBottom) | 0;
                }
            };
            function createMethodNotSupport(method) {
                return function () {
                    zrLog('In IE8.0 VML mode painter not support method "' + method + '"');
                };
            }
            var notSupportedMethods = [
                'getLayer',
                'insertLayer',
                'eachLayer',
                'eachBuildinLayer',
                'eachOtherLayer',
                'getLayers',
                'modLayer',
                'delLayer',
                'clearLayer',
                'toDataURL',
                'pathToImage'
            ];
            for (var i = 0; i < notSupportedMethods.length; i++) {
                var name = notSupportedMethods[i];
                VMLPainter.prototype[name] = createMethodNotSupport(name);
            }
            module.exports = VMLPainter;
        }
    ]);
}));
;
;
(function (root, factory) {
    if (typeof module == 'object' && module.exports)
        module.exports = factory();
    else if (typeof define == 'function' && define.amd)
        define('spin', [], factory);
    else
        root.Spinner = factory();
}(this, function () {
    'use strict';
    var prefixes = [
            'webkit',
            'Moz',
            'ms',
            'O'
        ], animations = {}, useCssAnimations, sheet;
    function createEl(tag, prop) {
        var el = document.createElement(tag || 'div'), n;
        for (n in prop)
            el[n] = prop[n];
        return el;
    }
    function ins(parent) {
        for (var i = 1, n = arguments.length; i < n; i++) {
            parent.appendChild(arguments[i]);
        }
        return parent;
    }
    function addAnimation(alpha, trail, i, lines) {
        var name = [
                'opacity',
                trail,
                ~~(alpha * 100),
                i,
                lines
            ].join('-'), start = 0.01 + i / lines * 100, z = Math.max(1 - (1 - alpha) / trail * (100 - start), alpha), prefix = useCssAnimations.substring(0, useCssAnimations.indexOf('Animation')).toLowerCase(), pre = prefix && '-' + prefix + '-' || '';
        if (!animations[name]) {
            sheet.insertRule('@' + pre + 'keyframes ' + name + '{' + '0%{opacity:' + z + '}' + start + '%{opacity:' + alpha + '}' + (start + 0.01) + '%{opacity:1}' + (start + trail) % 100 + '%{opacity:' + alpha + '}' + '100%{opacity:' + z + '}' + '}', sheet.cssRules.length);
            animations[name] = 1;
        }
        return name;
    }
    function vendor(el, prop) {
        var s = el.style, pp, i;
        prop = prop.charAt(0).toUpperCase() + prop.slice(1);
        if (s[prop] !== undefined)
            return prop;
        for (i = 0; i < prefixes.length; i++) {
            pp = prefixes[i] + prop;
            if (s[pp] !== undefined)
                return pp;
        }
    }
    function css(el, prop) {
        for (var n in prop) {
            el.style[vendor(el, n) || n] = prop[n];
        }
        return el;
    }
    function merge(obj) {
        for (var i = 1; i < arguments.length; i++) {
            var def = arguments[i];
            for (var n in def) {
                if (obj[n] === undefined)
                    obj[n] = def[n];
            }
        }
        return obj;
    }
    function getColor(color, idx) {
        return typeof color == 'string' ? color : color[idx % color.length];
    }
    var defaults = {
        lines: 12,
        length: 7,
        width: 5,
        radius: 10,
        scale: 1,
        corners: 1,
        color: '#000',
        opacity: 1 / 4,
        rotate: 0,
        direction: 1,
        speed: 1,
        trail: 100,
        fps: 20,
        zIndex: 2000000000,
        className: 'spinner',
        top: '50%',
        left: '50%',
        shadow: false,
        hwaccel: false,
        position: 'absolute'
    };
    function Spinner(o) {
        this.opts = merge(o || {}, Spinner.defaults, defaults);
    }
    Spinner.defaults = {};
    merge(Spinner.prototype, {
        spin: function (target) {
            this.stop();
            var self = this, o = self.opts, el = self.el = createEl(null, { className: o.className });
            css(el, {
                position: o.position,
                width: 0,
                zIndex: o.zIndex,
                left: o.left,
                top: o.top
            });
            if (target) {
                target.insertBefore(el, target.firstChild || null);
            }
            el.setAttribute('role', 'progressbar');
            self.lines(el, self.opts);
            if (!useCssAnimations) {
                var i = 0, start = (o.lines - 1) * (1 - o.direction) / 2, alpha, fps = o.fps, f = fps / o.speed, ostep = (1 - o.opacity) / (f * o.trail / 100), astep = f / o.lines;
                (function anim() {
                    i++;
                    for (var j = 0; j < o.lines; j++) {
                        alpha = Math.max(1 - (i + (o.lines - j) * astep) % f * ostep, o.opacity);
                        self.opacity(el, j * o.direction + start, alpha, o);
                    }
                    self.timeout = self.el && setTimeout(anim, ~~(1000 / fps));
                }());
            }
            return self;
        },
        stop: function () {
            var el = this.el;
            if (el) {
                clearTimeout(this.timeout);
                if (el.parentNode)
                    el.parentNode.removeChild(el);
                this.el = undefined;
            }
            return this;
        },
        lines: function (el, o) {
            var i = 0, start = (o.lines - 1) * (1 - o.direction) / 2, seg;
            function fill(color, shadow) {
                return css(createEl(), {
                    position: 'absolute',
                    width: o.scale * (o.length + o.width) + 'px',
                    height: o.scale * o.width + 'px',
                    background: color,
                    boxShadow: shadow,
                    transformOrigin: 'left',
                    transform: 'rotate(' + ~~(360 / o.lines * i + o.rotate) + 'deg) translate(' + o.scale * o.radius + 'px' + ',0)',
                    borderRadius: (o.corners * o.scale * o.width >> 1) + 'px'
                });
            }
            for (; i < o.lines; i++) {
                seg = css(createEl(), {
                    position: 'absolute',
                    top: 1 + ~(o.scale * o.width / 2) + 'px',
                    transform: o.hwaccel ? 'translate3d(0,0,0)' : '',
                    opacity: o.opacity,
                    animation: useCssAnimations && addAnimation(o.opacity, o.trail, start + i * o.direction, o.lines) + ' ' + 1 / o.speed + 's linear infinite'
                });
                if (o.shadow)
                    ins(seg, css(fill('#000', '0 0 4px #000'), { top: '2px' }));
                ins(el, ins(seg, fill(getColor(o.color, i), '0 0 1px rgba(0,0,0,.1)')));
            }
            return el;
        },
        opacity: function (el, i, val) {
            if (i < el.childNodes.length)
                el.childNodes[i].style.opacity = val;
        }
    });
    function initVML() {
        function vml(tag, attr) {
            return createEl('<' + tag + ' xmlns="urn:schemas-microsoft.com:vml" class="spin-vml">', attr);
        }
        sheet.addRule('.spin-vml', 'behavior:url(#default#VML)');
        Spinner.prototype.lines = function (el, o) {
            var r = o.scale * (o.length + o.width), s = o.scale * 2 * r;
            function grp() {
                return css(vml('group', {
                    coordsize: s + ' ' + s,
                    coordorigin: -r + ' ' + -r
                }), {
                    width: s,
                    height: s
                });
            }
            var margin = -(o.width + o.length) * o.scale * 2 + 'px', g = css(grp(), {
                    position: 'absolute',
                    top: margin,
                    left: margin
                }), i;
            function seg(i, dx, filter) {
                ins(g, ins(css(grp(), {
                    rotation: 360 / o.lines * i + 'deg',
                    left: ~~dx
                }), ins(css(vml('roundrect', { arcsize: o.corners }), {
                    width: r,
                    height: o.scale * o.width,
                    left: o.scale * o.radius,
                    top: -o.scale * o.width >> 1,
                    filter: filter
                }), vml('fill', {
                    color: getColor(o.color, i),
                    opacity: o.opacity
                }), vml('stroke', { opacity: 0 }))));
            }
            if (o.shadow)
                for (i = 1; i <= o.lines; i++) {
                    seg(i, -2, 'progid:DXImageTransform.Microsoft.Blur(pixelradius=2,makeshadow=1,shadowopacity=.3)');
                }
            for (i = 1; i <= o.lines; i++)
                seg(i);
            return ins(el, g);
        };
        Spinner.prototype.opacity = function (el, i, val, o) {
            var c = el.firstChild;
            o = o.shadow && o.lines || 0;
            if (c && i + o < c.childNodes.length) {
                c = c.childNodes[i + o];
                c = c && c.firstChild;
                c = c && c.firstChild;
                if (c)
                    c.opacity = val;
            }
        };
    }
    if (typeof document !== 'undefined') {
        sheet = function () {
            var el = createEl('style', { type: 'text/css' });
            ins(document.getElementsByTagName('head')[0], el);
            return el.sheet || el.styleSheet;
        }();
        var probe = css(createEl('group'), { behavior: 'url(#default#VML)' });
        if (!vendor(probe, 'transform') && probe.adj)
            initVML();
        else
            useCssAnimations = vendor(probe, 'animation');
    }
    return Spinner;
}));
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('lib/jquery-ui/ui/core', ['jquery'], factory);
    } else {
        factory(jQuery);
    }
}(function ($) {
    $.ui = $.ui || {};
    $.extend($.ui, {
        version: '1.11.4',
        keyCode: {
            BACKSPACE: 8,
            COMMA: 188,
            DELETE: 46,
            DOWN: 40,
            END: 35,
            ENTER: 13,
            ESCAPE: 27,
            HOME: 36,
            LEFT: 37,
            PAGE_DOWN: 34,
            PAGE_UP: 33,
            PERIOD: 190,
            RIGHT: 39,
            SPACE: 32,
            TAB: 9,
            UP: 38
        }
    });
    $.fn.extend({
        scrollParent: function (includeHidden) {
            var position = this.css('position'), excludeStaticParent = position === 'absolute', overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/, scrollParent = this.parents().filter(function () {
                    var parent = $(this);
                    if (excludeStaticParent && parent.css('position') === 'static') {
                        return false;
                    }
                    return overflowRegex.test(parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x'));
                }).eq(0);
            return position === 'fixed' || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
        },
        uniqueId: function () {
            var uuid = 0;
            return function () {
                return this.each(function () {
                    if (!this.id) {
                        this.id = 'ui-id-' + ++uuid;
                    }
                });
            };
        }(),
        removeUniqueId: function () {
            return this.each(function () {
                if (/^ui-id-\d+$/.test(this.id)) {
                    $(this).removeAttr('id');
                }
            });
        }
    });
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img, nodeName = element.nodeName.toLowerCase();
        if ('area' === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
                return false;
            }
            img = $('img[usemap=\'#' + mapName + '\']')[0];
            return !!img && visible(img);
        }
        return (/^(input|select|textarea|button|object)$/.test(nodeName) ? !element.disabled : 'a' === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
    }
    function visible(element) {
        return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
            return $.css(this, 'visibility') === 'hidden';
        }).length;
    }
    $.extend($.expr[':'], {
        data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {
            return function (elem) {
                return !!$.data(elem, dataName);
            };
        }) : function (elem, i, match) {
            return !!$.data(elem, match[3]);
        },
        focusable: function (element) {
            return focusable(element, !isNaN($.attr(element, 'tabindex')));
        },
        tabbable: function (element) {
            var tabIndex = $.attr(element, 'tabindex'), isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });
    if (!$('<a>').outerWidth(1).jquery) {
        $.each([
            'Width',
            'Height'
        ], function (i, name) {
            var side = name === 'Width' ? [
                    'Left',
                    'Right'
                ] : [
                    'Top',
                    'Bottom'
                ], type = name.toLowerCase(), orig = {
                    innerWidth: $.fn.innerWidth,
                    innerHeight: $.fn.innerHeight,
                    outerWidth: $.fn.outerWidth,
                    outerHeight: $.fn.outerHeight
                };
            function reduce(elem, size, border, margin) {
                $.each(side, function () {
                    size -= parseFloat($.css(elem, 'padding' + this)) || 0;
                    if (border) {
                        size -= parseFloat($.css(elem, 'border' + this + 'Width')) || 0;
                    }
                    if (margin) {
                        size -= parseFloat($.css(elem, 'margin' + this)) || 0;
                    }
                });
                return size;
            }
            $.fn['inner' + name] = function (size) {
                if (size === undefined) {
                    return orig['inner' + name].call(this);
                }
                return this.each(function () {
                    $(this).css(type, reduce(this, size) + 'px');
                });
            };
            $.fn['outer' + name] = function (size, margin) {
                if (typeof size !== 'number') {
                    return orig['outer' + name].call(this, size);
                }
                return this.each(function () {
                    $(this).css(type, reduce(this, size, true, margin) + 'px');
                });
            };
        });
    }
    if (!$.fn.addBack) {
        $.fn.addBack = function (selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        };
    }
    if ($('<a>').data('a-b', 'a').removeData('a-b').data('a-b')) {
        $.fn.removeData = function (removeData) {
            return function (key) {
                if (arguments.length) {
                    return removeData.call(this, $.camelCase(key));
                } else {
                    return removeData.call(this);
                }
            };
        }($.fn.removeData);
    }
    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    $.fn.extend({
        focus: function (orig) {
            return function (delay, fn) {
                return typeof delay === 'number' ? this.each(function () {
                    var elem = this;
                    setTimeout(function () {
                        $(elem).focus();
                        if (fn) {
                            fn.call(elem);
                        }
                    }, delay);
                }) : orig.apply(this, arguments);
            };
        }($.fn.focus),
        disableSelection: function () {
            var eventType = 'onselectstart' in document.createElement('div') ? 'selectstart' : 'mousedown';
            return function () {
                return this.bind(eventType + '.ui-disableSelection', function (event) {
                    event.preventDefault();
                });
            };
        }(),
        enableSelection: function () {
            return this.unbind('.ui-disableSelection');
        },
        zIndex: function (zIndex) {
            if (zIndex !== undefined) {
                return this.css('zIndex', zIndex);
            }
            if (this.length) {
                var elem = $(this[0]), position, value;
                while (elem.length && elem[0] !== document) {
                    position = elem.css('position');
                    if (position === 'absolute' || position === 'relative' || position === 'fixed') {
                        value = parseInt(elem.css('zIndex'), 10);
                        if (!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }
            return 0;
        }
    });
    $.ui.plugin = {
        add: function (module, option, set) {
            var i, proto = $.ui[module].prototype;
            for (i in set) {
                proto.plugins[i] = proto.plugins[i] || [];
                proto.plugins[i].push([
                    option,
                    set[i]
                ]);
            }
        },
        call: function (instance, name, args, allowDisconnected) {
            var i, set = instance.plugins[name];
            if (!set) {
                return;
            }
            if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
                return;
            }
            for (i = 0; i < set.length; i++) {
                if (instance.options[set[i][0]]) {
                    set[i][1].apply(instance.element, args);
                }
            }
        }
    };
}));
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('jquery-ui/datepicker', [
            'jquery',
            'lib/jquery-ui/ui/core'
        ], factory);
    } else {
        factory(jQuery);
    }
}(function ($) {
    $.extend($.ui, { datepicker: { version: '1.11.4' } });
    var datepicker_instActive;
    function datepicker_getZindex(elem) {
        var position, value;
        while (elem.length && elem[0] !== document) {
            position = elem.css('position');
            if (position === 'absolute' || position === 'relative' || position === 'fixed') {
                value = parseInt(elem.css('zIndex'), 10);
                if (!isNaN(value) && value !== 0) {
                    return value;
                }
            }
            elem = elem.parent();
        }
        return 0;
    }
    function Datepicker() {
        this._curInst = null;
        this._keyEvent = false;
        this._disabledInputs = [];
        this._datepickerShowing = false;
        this._inDialog = false;
        this._mainDivId = 'ui-datepicker-div';
        this._inlineClass = 'ui-datepicker-inline';
        this._appendClass = 'ui-datepicker-append';
        this._triggerClass = 'ui-datepicker-trigger';
        this._dialogClass = 'ui-datepicker-dialog';
        this._disableClass = 'ui-datepicker-disabled';
        this._unselectableClass = 'ui-datepicker-unselectable';
        this._currentClass = 'ui-datepicker-current-day';
        this._dayOverClass = 'ui-datepicker-days-cell-over';
        this.regional = [];
        this.regional[''] = {
            closeText: 'Done',
            prevText: 'Prev',
            nextText: 'Next',
            currentText: 'Today',
            monthNames: [
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December'
            ],
            monthNamesShort: [
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec'
            ],
            dayNames: [
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday'
            ],
            dayNamesShort: [
                'Sun',
                'Mon',
                'Tue',
                'Wed',
                'Thu',
                'Fri',
                'Sat'
            ],
            dayNamesMin: [
                'Su',
                'Mo',
                'Tu',
                'We',
                'Th',
                'Fr',
                'Sa'
            ],
            weekHeader: 'Wk',
            dateFormat: 'mm/dd/yy',
            firstDay: 0,
            isRTL: false,
            showMonthAfterYear: false,
            yearSuffix: ''
        };
        this._defaults = {
            showOn: 'focus',
            showAnim: 'fadeIn',
            showOptions: {},
            defaultDate: null,
            appendText: '',
            buttonText: '...',
            buttonImage: '',
            buttonImageOnly: false,
            hideIfNoPrevNext: false,
            navigationAsDateFormat: false,
            gotoCurrent: false,
            changeMonth: false,
            changeYear: false,
            yearRange: 'c-10:c+10',
            showOtherMonths: false,
            selectOtherMonths: false,
            showWeek: false,
            calculateWeek: this.iso8601Week,
            shortYearCutoff: '+10',
            minDate: null,
            maxDate: null,
            duration: 'fast',
            beforeShowDay: null,
            beforeShow: null,
            onSelect: null,
            onChangeMonthYear: null,
            onClose: null,
            numberOfMonths: 1,
            showCurrentAtPos: 0,
            stepMonths: 1,
            stepBigMonths: 12,
            altField: '',
            altFormat: '',
            constrainInput: true,
            showButtonPanel: false,
            autoSize: false,
            disabled: false
        };
        $.extend(this._defaults, this.regional['']);
        this.regional.en = $.extend(true, {}, this.regional['']);
        this.regional['en-US'] = $.extend(true, {}, this.regional.en);
        this.dpDiv = datepicker_bindHover($('<div id=\'' + this._mainDivId + '\' class=\'ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>'));
    }
    $.extend(Datepicker.prototype, {
        markerClassName: 'hasDatepicker',
        maxRows: 4,
        _widgetDatepicker: function () {
            return this.dpDiv;
        },
        setDefaults: function (settings) {
            datepicker_extendRemove(this._defaults, settings || {});
            return this;
        },
        _attachDatepicker: function (target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = nodeName === 'div' || nodeName === 'span';
            if (!target.id) {
                this.uuid += 1;
                target.id = 'dp' + this.uuid;
            }
            inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {});
            if (nodeName === 'input') {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
        },
        _newInst: function (target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, '\\\\$1');
            return {
                id: id,
                input: target,
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0,
                drawMonth: 0,
                drawYear: 0,
                inline: inline,
                dpDiv: !inline ? this.dpDiv : datepicker_bindHover($('<div class=\'' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>'))
            };
        },
        _connectDatepicker: function (target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) {
                return;
            }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
            this._autoSize(inst);
            $.data(target, 'datepicker', inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
        },
        _attachments: function (input, inst) {
            var showOn, buttonText, buttonImage, appendText = this._get(inst, 'appendText'), isRTL = this._get(inst, 'isRTL');
            if (inst.append) {
                inst.append.remove();
            }
            if (appendText) {
                inst.append = $('<span class=\'' + this._appendClass + '\'>' + appendText + '</span>');
                input[isRTL ? 'before' : 'after'](inst.append);
            }
            input.unbind('focus', this._showDatepicker);
            if (inst.trigger) {
                inst.trigger.remove();
            }
            showOn = this._get(inst, 'showOn');
            if (showOn === 'focus' || showOn === 'both') {
                input.focus(this._showDatepicker);
            }
            if (showOn === 'button' || showOn === 'both') {
                buttonText = this._get(inst, 'buttonText');
                buttonImage = this._get(inst, 'buttonImage');
                inst.trigger = $(this._get(inst, 'buttonImageOnly') ? $('<img/>').addClass(this._triggerClass).attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                }) : $('<button type=\'button\'></button>').addClass(this._triggerClass).html(!buttonImage ? buttonText : $('<img/>').attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                })));
                input[isRTL ? 'before' : 'after'](inst.trigger);
                inst.trigger.click(function () {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                        $.datepicker._hideDatepicker();
                    } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker(input[0]);
                    } else {
                        $.datepicker._showDatepicker(input[0]);
                    }
                    return false;
                });
            }
        },
        _autoSize: function (inst) {
            if (this._get(inst, 'autoSize') && !inst.inline) {
                var findMax, max, maxI, i, date = new Date(2009, 12 - 1, 20), dateFormat = this._get(inst, 'dateFormat');
                if (dateFormat.match(/[DM]/)) {
                    findMax = function (names) {
                        max = 0;
                        maxI = 0;
                        for (i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? 'monthNames' : 'monthNamesShort')));
                    date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? 'dayNames' : 'dayNamesShort')) + 20 - date.getDay());
                }
                inst.input.attr('size', this._formatDate(inst, date).length);
            }
        },
        _inlineDatepicker: function (target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName)) {
                return;
            }
            divSpan.addClass(this.markerClassName).append(inst.dpDiv);
            $.data(target, 'datepicker', inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
            inst.dpDiv.css('display', 'block');
        },
        _dialogDatepicker: function (input, date, onSelect, settings, pos) {
            var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
            if (!inst) {
                this.uuid += 1;
                id = 'dp' + this.uuid;
                this._dialogInput = $('<input type=\'text\' id=\'' + id + '\' style=\'position: absolute; top: -100px; width: 0px;\'/>');
                this._dialogInput.keydown(this._doKeyDown);
                $('body').append(this._dialogInput);
                inst = this._dialogInst = this._newInst(this._dialogInput, false);
                inst.settings = {};
                $.data(this._dialogInput[0], 'datepicker', inst);
            }
            datepicker_extendRemove(inst.settings, settings || {});
            date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
            this._dialogInput.val(date);
            this._pos = pos ? pos.length ? pos : [
                pos.pageX,
                pos.pageY
            ] : null;
            if (!this._pos) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = [
                    browserWidth / 2 - 100 + scrollX,
                    browserHeight / 2 - 150 + scrollY
                ];
            }
            this._dialogInput.css('left', this._pos[0] + 20 + 'px').css('top', this._pos[1] + 'px');
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this.dpDiv);
            }
            $.data(this._dialogInput[0], 'datepicker', inst);
            return this;
        },
        _destroyDatepicker: function (target) {
            var nodeName, $target = $(target), inst = $.data(target, 'datepicker');
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            $.removeData(target, 'datepicker');
            if (nodeName === 'input') {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass(this.markerClassName).unbind('focus', this._showDatepicker).unbind('keydown', this._doKeyDown).unbind('keypress', this._doKeyPress).unbind('keyup', this._doKeyUp);
            } else if (nodeName === 'div' || nodeName === 'span') {
                $target.removeClass(this.markerClassName).empty();
            }
            if (datepicker_instActive === inst) {
                datepicker_instActive = null;
            }
        },
        _enableDatepicker: function (target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, 'datepicker');
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === 'input') {
                target.disabled = false;
                inst.trigger.filter('button').each(function () {
                    this.disabled = false;
                }).end().filter('img').css({
                    opacity: '1.0',
                    cursor: ''
                });
            } else if (nodeName === 'div' || nodeName === 'span') {
                inline = $target.children('.' + this._inlineClass);
                inline.children().removeClass('ui-state-disabled');
                inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', false);
            }
            this._disabledInputs = $.map(this._disabledInputs, function (value) {
                return value === target ? null : value;
            });
        },
        _disableDatepicker: function (target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, 'datepicker');
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === 'input') {
                target.disabled = true;
                inst.trigger.filter('button').each(function () {
                    this.disabled = true;
                }).end().filter('img').css({
                    opacity: '0.5',
                    cursor: 'default'
                });
            } else if (nodeName === 'div' || nodeName === 'span') {
                inline = $target.children('.' + this._inlineClass);
                inline.children().addClass('ui-state-disabled');
                inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', true);
            }
            this._disabledInputs = $.map(this._disabledInputs, function (value) {
                return value === target ? null : value;
            });
            this._disabledInputs[this._disabledInputs.length] = target;
        },
        _isDisabledDatepicker: function (target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] === target) {
                    return true;
                }
            }
            return false;
        },
        _getInst: function (target) {
            try {
                return $.data(target, 'datepicker');
            } catch (err) {
                throw 'Missing instance data for this datepicker';
            }
        },
        _optionDatepicker: function (target, name, value) {
            var settings, date, minDate, maxDate, inst = this._getInst(target);
            if (arguments.length === 2 && typeof name === 'string') {
                return name === 'defaults' ? $.extend({}, $.datepicker._defaults) : inst ? name === 'all' ? $.extend({}, inst.settings) : this._get(inst, name) : null;
            }
            settings = name || {};
            if (typeof name === 'string') {
                settings = {};
                settings[name] = value;
            }
            if (inst) {
                if (this._curInst === inst) {
                    this._hideDatepicker();
                }
                date = this._getDateDatepicker(target, true);
                minDate = this._getMinMaxDate(inst, 'min');
                maxDate = this._getMinMaxDate(inst, 'max');
                datepicker_extendRemove(inst.settings, settings);
                if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                    inst.settings.minDate = this._formatDate(inst, minDate);
                }
                if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                }
                if ('disabled' in settings) {
                    if (settings.disabled) {
                        this._disableDatepicker(target);
                    } else {
                        this._enableDatepicker(target);
                    }
                }
                this._attachments($(target), inst);
                this._autoSize(inst);
                this._setDate(inst, date);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },
        _changeDatepicker: function (target, name, value) {
            this._optionDatepicker(target, name, value);
        },
        _refreshDatepicker: function (target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },
        _setDateDatepicker: function (target, date) {
            var inst = this._getInst(target);
            if (inst) {
                this._setDate(inst, date);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
            }
        },
        _getDateDatepicker: function (target, noDefault) {
            var inst = this._getInst(target);
            if (inst && !inst.inline) {
                this._setDateFromField(inst, noDefault);
            }
            return inst ? this._getDate(inst) : null;
        },
        _doKeyDown: function (event) {
            var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = true, isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing) {
                switch (event.keyCode) {
                case 9:
                    $.datepicker._hideDatepicker();
                    handled = false;
                    break;
                case 13:
                    sel = $('td.' + $.datepicker._dayOverClass + ':not(.' + $.datepicker._currentClass + ')', inst.dpDiv);
                    if (sel[0]) {
                        $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                    }
                    onSelect = $.datepicker._get(inst, 'onSelect');
                    if (onSelect) {
                        dateStr = $.datepicker._formatDate(inst);
                        onSelect.apply(inst.input ? inst.input[0] : null, [
                            dateStr,
                            inst
                        ]);
                    } else {
                        $.datepicker._hideDatepicker();
                    }
                    return false;
                case 27:
                    $.datepicker._hideDatepicker();
                    break;
                case 33:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'), 'M');
                    break;
                case 34:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'), 'M');
                    break;
                case 35:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._clearDate(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;
                case 36:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._gotoToday(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;
                case 37:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, 'D');
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'), 'M');
                    }
                    break;
                case 38:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, -7, 'D');
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;
                case 39:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, 'D');
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'), 'M');
                    }
                    break;
                case 40:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, +7, 'D');
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;
                default:
                    handled = false;
                }
            } else if (event.keyCode === 36 && event.ctrlKey) {
                $.datepicker._showDatepicker(this);
            } else {
                handled = false;
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },
        _doKeyPress: function (event) {
            var chars, chr, inst = $.datepicker._getInst(event.target);
            if ($.datepicker._get(inst, 'constrainInput')) {
                chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
                chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
            }
        },
        _doKeyUp: function (event) {
            var date, inst = $.datepicker._getInst(event.target);
            if (inst.input.val() !== inst.lastVal) {
                try {
                    date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
                    if (date) {
                        $.datepicker._setDateFromField(inst);
                        $.datepicker._updateAlternate(inst);
                        $.datepicker._updateDatepicker(inst);
                    }
                } catch (err) {
                }
            }
            return true;
        },
        _showDatepicker: function (input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() !== 'input') {
                input = $('input', input.parentNode)[0];
            }
            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
                return;
            }
            var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
            inst = $.datepicker._getInst(input);
            if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if (inst && $.datepicker._datepickerShowing) {
                    $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                }
            }
            beforeShow = $.datepicker._get(inst, 'beforeShow');
            beforeShowSettings = beforeShow ? beforeShow.apply(input, [
                input,
                inst
            ]) : {};
            if (beforeShowSettings === false) {
                return;
            }
            datepicker_extendRemove(inst.settings, beforeShowSettings);
            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst);
            if ($.datepicker._inDialog) {
                input.value = '';
            }
            if (!$.datepicker._pos) {
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight;
            }
            isFixed = false;
            $(input).parents().each(function () {
                isFixed |= $(this).css('position') === 'fixed';
                return !isFixed;
            });
            offset = {
                left: $.datepicker._pos[0],
                top: $.datepicker._pos[1]
            };
            $.datepicker._pos = null;
            inst.dpDiv.empty();
            inst.dpDiv.css({
                position: 'absolute',
                display: 'block',
                top: '-1000px'
            });
            $.datepicker._updateDatepicker(inst);
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            inst.dpDiv.css({
                position: $.datepicker._inDialog && $.blockUI ? 'static' : isFixed ? 'fixed' : 'absolute',
                display: 'none',
                left: offset.left + 'px',
                top: offset.top + 'px'
            });
            if (!inst.inline) {
                showAnim = $.datepicker._get(inst, 'showAnim');
                duration = $.datepicker._get(inst, 'duration');
                inst.dpDiv.css('z-index', datepicker_getZindex($(input)) + 1);
                $.datepicker._datepickerShowing = true;
                if ($.effects && $.effects.effect[showAnim]) {
                    inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration);
                } else {
                    inst.dpDiv[showAnim || 'show'](showAnim ? duration : null);
                }
                if ($.datepicker._shouldFocusInput(inst)) {
                    inst.input.focus();
                }
                $.datepicker._curInst = inst;
            }
        },
        _updateDatepicker: function (inst) {
            this.maxRows = 4;
            datepicker_instActive = inst;
            inst.dpDiv.empty().append(this._generateHTML(inst));
            this._attachHandlers(inst);
            var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17, activeCell = inst.dpDiv.find('.' + this._dayOverClass + ' a');
            if (activeCell.length > 0) {
                datepicker_handleMouseover.apply(activeCell.get(0));
            }
            inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
            if (cols > 1) {
                inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', width * cols + 'em');
            }
            inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? 'add' : 'remove') + 'Class']('ui-datepicker-multi');
            inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') + 'Class']('ui-datepicker-rtl');
            if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                inst.input.focus();
            }
            if (inst.yearshtml) {
                origyearshtml = inst.yearshtml;
                setTimeout(function () {
                    if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                        inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }
        },
        _shouldFocusInput: function (inst) {
            return inst.input && inst.input.is(':visible') && !inst.input.is(':disabled') && !inst.input.is(':focus');
        },
        _checkOffset: function (inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
            offset.left -= this._get(inst, 'isRTL') ? dpWidth - inputWidth : 0;
            offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
            offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
            offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
            return offset;
        },
        _findPos: function (obj) {
            var position, inst = this._getInst(obj), isRTL = this._get(inst, 'isRTL');
            while (obj && (obj.type === 'hidden' || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
            }
            position = $(obj).offset();
            return [
                position.left,
                position.top
            ];
        },
        _hideDatepicker: function (input) {
            var showAnim, duration, postProcess, onClose, inst = this._curInst;
            if (!inst || input && inst !== $.data(input, 'datepicker')) {
                return;
            }
            if (this._datepickerShowing) {
                showAnim = this._get(inst, 'showAnim');
                duration = this._get(inst, 'duration');
                postProcess = function () {
                    $.datepicker._tidyDialog(inst);
                };
                if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                    inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
                } else {
                    inst.dpDiv[showAnim === 'slideDown' ? 'slideUp' : showAnim === 'fadeIn' ? 'fadeOut' : 'hide'](showAnim ? duration : null, postProcess);
                }
                if (!showAnim) {
                    postProcess();
                }
                this._datepickerShowing = false;
                onClose = this._get(inst, 'onClose');
                if (onClose) {
                    onClose.apply(inst.input ? inst.input[0] : null, [
                        inst.input ? inst.input.val() : '',
                        inst
                    ]);
                }
                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({
                        position: 'absolute',
                        left: '0',
                        top: '-100px'
                    });
                    if ($.blockUI) {
                        $.unblockUI();
                        $('body').append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },
        _tidyDialog: function (inst) {
            inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
        },
        _checkExternalClick: function (event) {
            if (!$.datepicker._curInst) {
                return;
            }
            var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
            if ($target[0].id !== $.datepicker._mainDivId && $target.parents('#' + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest('.' + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
                $.datepicker._hideDatepicker();
            }
        },
        _adjustDate: function (id, offset, period) {
            var target = $(id), inst = this._getInst(target[0]);
            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset + (period === 'M' ? this._get(inst, 'showCurrentAtPos') : 0), period);
            this._updateDatepicker(inst);
        },
        _gotoToday: function (id) {
            var date, target = $(id), inst = this._getInst(target[0]);
            if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectMonthYear: function (id, select, period) {
            var target = $(id), inst = this._getInst(target[0]);
            inst['selected' + (period === 'M' ? 'Month' : 'Year')] = inst['draw' + (period === 'M' ? 'Month' : 'Year')] = parseInt(select.options[select.selectedIndex].value, 10);
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectDay: function (id, month, year, td) {
            var inst, target = $(id);
            if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                return;
            }
            inst = this._getInst(target[0]);
            inst.selectedDay = inst.currentDay = $('a', td).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
        },
        _clearDate: function (id) {
            var target = $(id);
            this._selectDate(target, '');
        },
        _selectDate: function (id, dateStr) {
            var onSelect, target = $(id), inst = this._getInst(target[0]);
            dateStr = dateStr != null ? dateStr : this._formatDate(inst);
            if (inst.input) {
                inst.input.val(dateStr);
            }
            this._updateAlternate(inst);
            onSelect = this._get(inst, 'onSelect');
            if (onSelect) {
                onSelect.apply(inst.input ? inst.input[0] : null, [
                    dateStr,
                    inst
                ]);
            } else if (inst.input) {
                inst.input.trigger('change');
            }
            if (inst.inline) {
                this._updateDatepicker(inst);
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                if (typeof inst.input[0] !== 'object') {
                    inst.input.focus();
                }
                this._lastInput = null;
            }
        },
        _updateAlternate: function (inst) {
            var altFormat, date, dateStr, altField = this._get(inst, 'altField');
            if (altField) {
                altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
                date = this._getDate(inst);
                dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                $(altField).each(function () {
                    $(this).val(dateStr);
                });
            }
        },
        noWeekends: function (date) {
            var day = date.getDay();
            return [
                day > 0 && day < 6,
                ''
            ];
        },
        iso8601Week: function (date) {
            var time, checkDate = new Date(date.getTime());
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
            time = checkDate.getTime();
            checkDate.setMonth(0);
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        },
        parseDate: function (format, value, settings) {
            if (format == null || value == null) {
                throw 'Invalid arguments';
            }
            value = typeof value === 'object' ? value.toString() : value + '';
            if (value === '') {
                return null;
            }
            var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = typeof shortYearCutoffTemp !== 'string' ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date, lookAhead = function (match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                }, getNumber = function (match) {
                    var isDoubled = lookAhead(match), size = match === '@' ? 14 : match === '!' ? 20 : match === 'y' && isDoubled ? 4 : match === 'o' ? 3 : 2, minSize = match === 'y' ? size : 1, digits = new RegExp('^\\d{' + minSize + ',' + size + '}'), num = value.substring(iValue).match(digits);
                    if (!num) {
                        throw 'Missing number at position ' + iValue;
                    }
                    iValue += num[0].length;
                    return parseInt(num[0], 10);
                }, getName = function (match, shortNames, longNames) {
                    var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
                            return [[
                                    k,
                                    v
                                ]];
                        }).sort(function (a, b) {
                            return -(a[1].length - b[1].length);
                        });
                    $.each(names, function (i, pair) {
                        var name = pair[1];
                        if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                            index = pair[0];
                            iValue += name.length;
                            return false;
                        }
                    });
                    if (index !== -1) {
                        return index + 1;
                    } else {
                        throw 'Unknown name at position ' + iValue;
                    }
                }, checkLiteral = function () {
                    if (value.charAt(iValue) !== format.charAt(iFormat)) {
                        throw 'Unexpected literal at position ' + iValue;
                    }
                    iValue++;
                };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                    case 'd':
                        day = getNumber('d');
                        break;
                    case 'D':
                        getName('D', dayNamesShort, dayNames);
                        break;
                    case 'o':
                        doy = getNumber('o');
                        break;
                    case 'm':
                        month = getNumber('m');
                        break;
                    case 'M':
                        month = getName('M', monthNamesShort, monthNames);
                        break;
                    case 'y':
                        year = getNumber('y');
                        break;
                    case '@':
                        date = new Date(getNumber('@'));
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;
                    case '!':
                        date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;
                    case '\'':
                        if (lookAhead('\'')) {
                            checkLiteral();
                        } else {
                            literal = true;
                        }
                        break;
                    default:
                        checkLiteral();
                    }
                }
            }
            if (iValue < value.length) {
                extra = value.substr(iValue);
                if (!/^\s+/.test(extra)) {
                    throw 'Extra/unparsed characters found in date: ' + extra;
                }
            }
            if (year === -1) {
                year = new Date().getFullYear();
            } else if (year < 100) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
            }
            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while (true);
            }
            date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                throw 'Invalid date';
            }
            return date;
        },
        ATOM: 'yy-mm-dd',
        COOKIE: 'D, dd M yy',
        ISO_8601: 'yy-mm-dd',
        RFC_822: 'D, d M y',
        RFC_850: 'DD, dd-M-y',
        RFC_1036: 'D, d M y',
        RFC_1123: 'D, d M yy',
        RFC_2822: 'D, d M yy',
        RSS: 'D, d M y',
        TICKS: '!',
        TIMESTAMP: '@',
        W3C: 'yy-mm-dd',
        _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000,
        formatDate: function (format, date, settings) {
            if (!date) {
                return '';
            }
            var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, lookAhead = function (match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                }, formatNumber = function (match, value, len) {
                    var num = '' + value;
                    if (lookAhead(match)) {
                        while (num.length < len) {
                            num = '0' + num;
                        }
                    }
                    return num;
                }, formatName = function (match, value, shortNames, longNames) {
                    return lookAhead(match) ? longNames[value] : shortNames[value];
                }, output = '', literal = false;
            if (date) {
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
                            literal = false;
                        } else {
                            output += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                        case 'd':
                            output += formatNumber('d', date.getDate(), 2);
                            break;
                        case 'D':
                            output += formatName('D', date.getDay(), dayNamesShort, dayNames);
                            break;
                        case 'o':
                            output += formatNumber('o', Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                            break;
                        case 'm':
                            output += formatNumber('m', date.getMonth() + 1, 2);
                            break;
                        case 'M':
                            output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
                            break;
                        case 'y':
                            output += lookAhead('y') ? date.getFullYear() : (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100;
                            break;
                        case '@':
                            output += date.getTime();
                            break;
                        case '!':
                            output += date.getTime() * 10000 + this._ticksTo1970;
                            break;
                        case '\'':
                            if (lookAhead('\'')) {
                                output += '\'';
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            output += format.charAt(iFormat);
                        }
                    }
                }
            }
            return output;
        },
        _possibleChars: function (format) {
            var iFormat, chars = '', literal = false, lookAhead = function (match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
                        literal = false;
                    } else {
                        chars += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                    case 'd':
                    case 'm':
                    case 'y':
                    case '@':
                        chars += '0123456789';
                        break;
                    case 'D':
                    case 'M':
                        return null;
                    case '\'':
                        if (lookAhead('\'')) {
                            chars += '\'';
                        } else {
                            literal = true;
                        }
                        break;
                    default:
                        chars += format.charAt(iFormat);
                    }
                }
            }
            return chars;
        },
        _get: function (inst, name) {
            return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
        },
        _setDateFromField: function (inst, noDefault) {
            if (inst.input.val() === inst.lastVal) {
                return;
            }
            var dateFormat = this._get(inst, 'dateFormat'), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
            try {
                date = this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                dates = noDefault ? '' : dates;
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = dates ? date.getDate() : 0;
            inst.currentMonth = dates ? date.getMonth() : 0;
            inst.currentYear = dates ? date.getFullYear() : 0;
            this._adjustInstDate(inst);
        },
        _getDefaultDate: function (inst) {
            return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
        },
        _determineDate: function (inst, date, defaultDate) {
            var offsetNumeric = function (offset) {
                    var date = new Date();
                    date.setDate(date.getDate() + offset);
                    return date;
                }, offsetString = function (offset) {
                    try {
                        return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), offset, $.datepicker._getFormatConfig(inst));
                    } catch (e) {
                    }
                    var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset);
                    while (matches) {
                        switch (matches[2] || 'd') {
                        case 'd':
                        case 'D':
                            day += parseInt(matches[1], 10);
                            break;
                        case 'w':
                        case 'W':
                            day += parseInt(matches[1], 10) * 7;
                            break;
                        case 'm':
                        case 'M':
                            month += parseInt(matches[1], 10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;
                        case 'y':
                        case 'Y':
                            year += parseInt(matches[1], 10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;
                        }
                        matches = pattern.exec(offset);
                    }
                    return new Date(year, month, day);
                }, newDate = date == null || date === '' ? defaultDate : typeof date === 'string' ? offsetString(date) : typeof date === 'number' ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
            newDate = newDate && newDate.toString() === 'Invalid Date' ? defaultDate : newDate;
            if (newDate) {
                newDate.setHours(0);
                newDate.setMinutes(0);
                newDate.setSeconds(0);
                newDate.setMilliseconds(0);
            }
            return this._daylightSavingAdjust(newDate);
        },
        _daylightSavingAdjust: function (date) {
            if (!date) {
                return null;
            }
            date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
            return date;
        },
        _setDate: function (inst, date, noChange) {
            var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                this._notifyChange(inst);
            }
            this._adjustInstDate(inst);
            if (inst.input) {
                inst.input.val(clear ? '' : this._formatDate(inst));
            }
        },
        _getDate: function (inst) {
            var startDate = !inst.currentYear || inst.input && inst.input.val() === '' ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return startDate;
        },
        _attachHandlers: function (inst) {
            var stepMonths = this._get(inst, 'stepMonths'), id = '#' + inst.id.replace(/\\\\/g, '\\');
            inst.dpDiv.find('[data-handler]').map(function () {
                var handler = {
                    prev: function () {
                        $.datepicker._adjustDate(id, -stepMonths, 'M');
                    },
                    next: function () {
                        $.datepicker._adjustDate(id, +stepMonths, 'M');
                    },
                    hide: function () {
                        $.datepicker._hideDatepicker();
                    },
                    today: function () {
                        $.datepicker._gotoToday(id);
                    },
                    selectDay: function () {
                        $.datepicker._selectDay(id, +this.getAttribute('data-month'), +this.getAttribute('data-year'), this);
                        return false;
                    },
                    selectMonth: function () {
                        $.datepicker._selectMonthYear(id, this, 'M');
                        return false;
                    },
                    selectYear: function () {
                        $.datepicker._selectMonthYear(id, this, 'Y');
                        return false;
                    }
                };
                $(this).bind(this.getAttribute('data-event'), handler[this.getAttribute('data-handler')]);
            });
        },
        _generateHTML: function (inst) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), isRTL = this._get(inst, 'isRTL'), showButtonPanel = this._get(inst, 'showButtonPanel'), hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext'), navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat'), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, 'showCurrentAtPos'), stepMonths = this._get(inst, 'stepMonths'), isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1, currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)), minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
                maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
                while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;
            prevText = this._get(inst, 'prevText');
            prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
            prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? '<a class=\'ui-datepicker-prev ui-corner-all\' data-handler=\'prev\' data-event=\'click\'' + ' title=\'' + prevText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '\'>' + prevText + '</span></a>' : hideIfNoPrevNext ? '' : '<a class=\'ui-datepicker-prev ui-corner-all ui-state-disabled\' title=\'' + prevText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '\'>' + prevText + '</span></a>';
            nextText = this._get(inst, 'nextText');
            nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
            next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? '<a class=\'ui-datepicker-next ui-corner-all\' data-handler=\'next\' data-event=\'click\'' + ' title=\'' + nextText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '\'>' + nextText + '</span></a>' : hideIfNoPrevNext ? '' : '<a class=\'ui-datepicker-next ui-corner-all ui-state-disabled\' title=\'' + nextText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '\'>' + nextText + '</span></a>';
            currentText = this._get(inst, 'currentText');
            gotoDate = this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today;
            currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
            controls = !inst.inline ? '<button type=\'button\' class=\'ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all\' data-handler=\'hide\' data-event=\'click\'>' + this._get(inst, 'closeText') + '</button>' : '';
            buttonPanel = showButtonPanel ? '<div class=\'ui-datepicker-buttonpane ui-widget-content\'>' + (isRTL ? controls : '') + (this._isInRange(inst, gotoDate) ? '<button type=\'button\' class=\'ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all\' data-handler=\'today\' data-event=\'click\'' + '>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
            firstDay = parseInt(this._get(inst, 'firstDay'), 10);
            firstDay = isNaN(firstDay) ? 0 : firstDay;
            showWeek = this._get(inst, 'showWeek');
            dayNames = this._get(inst, 'dayNames');
            dayNamesMin = this._get(inst, 'dayNamesMin');
            monthNames = this._get(inst, 'monthNames');
            monthNamesShort = this._get(inst, 'monthNamesShort');
            beforeShowDay = this._get(inst, 'beforeShowDay');
            showOtherMonths = this._get(inst, 'showOtherMonths');
            selectOtherMonths = this._get(inst, 'selectOtherMonths');
            defaultDate = this._getDefaultDate(inst);
            html = '';
            dow;
            for (row = 0; row < numMonths[0]; row++) {
                group = '';
                this.maxRows = 4;
                for (col = 0; col < numMonths[1]; col++) {
                    selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                    cornerClass = ' ui-corner-all';
                    calender = '';
                    if (isMultiMonth) {
                        calender += '<div class=\'ui-datepicker-group';
                        if (numMonths[1] > 1) {
                            switch (col) {
                            case 0:
                                calender += ' ui-datepicker-group-first';
                                cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left');
                                break;
                            case numMonths[1] - 1:
                                calender += ' ui-datepicker-group-last';
                                cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right');
                                break;
                            default:
                                calender += ' ui-datepicker-group-middle';
                                cornerClass = '';
                                break;
                            }
                        }
                        calender += '\'>';
                    }
                    calender += '<div class=\'ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '\'>' + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : '') + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : '') + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + '</div><table class=\'ui-datepicker-calendar\'><thead>' + '<tr>';
                    thead = showWeek ? '<th class=\'ui-datepicker-week-col\'>' + this._get(inst, 'weekHeader') + '</th>' : '';
                    for (dow = 0; dow < 7; dow++) {
                        day = (dow + firstDay) % 7;
                        thead += '<th scope=\'col\'' + ((dow + firstDay + 6) % 7 >= 5 ? ' class=\'ui-datepicker-week-end\'' : '') + '>' + '<span title=\'' + dayNames[day] + '\'>' + dayNamesMin[day] + '</span></th>';
                    }
                    calender += thead + '</tr></thead><tbody>';
                    daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                        inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                    }
                    leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    curRows = Math.ceil((leadDays + daysInMonth) / 7);
                    numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                    for (dRow = 0; dRow < numRows; dRow++) {
                        calender += '<tr>';
                        tbody = !showWeek ? '' : '<td class=\'ui-datepicker-week-col\'>' + this._get(inst, 'calculateWeek')(printDate) + '</td>';
                        for (dow = 0; dow < 7; dow++) {
                            daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate]) : [
                                true,
                                ''
                            ];
                            otherMonth = printDate.getMonth() !== drawMonth;
                            unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
                            tbody += '<td class=\'' + ((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + (otherMonth ? ' ui-datepicker-other-month' : '') + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? ' ' + this._dayOverClass : '') + (unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled' : '') + (otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? ' ' + this._currentClass : '') + (printDate.getTime() === today.getTime() ? ' ui-datepicker-today' : '')) + '\'' + ((!otherMonth || showOtherMonths) && daySettings[2] ? ' title=\'' + daySettings[2].replace(/'/g, '&#39;') + '\'' : '') + (unselectable ? '' : ' data-handler=\'selectDay\' data-event=\'click\' data-month=\'' + printDate.getMonth() + '\' data-year=\'' + printDate.getFullYear() + '\'') + '>' + (otherMonth && !showOtherMonths ? '&#xa0;' : unselectable ? '<span class=\'ui-state-default\'>' + printDate.getDate() + '</span>' : '<a class=\'ui-state-default' + (printDate.getTime() === today.getTime() ? ' ui-state-highlight' : '') + (printDate.getTime() === currentDate.getTime() ? ' ui-state-active' : '') + (otherMonth ? ' ui-priority-secondary' : '') + '\' href=\'#\'>' + printDate.getDate() + '</a>') + '</td>';
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + '</tr>';
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += '</tbody></table>' + (isMultiMonth ? '</div>' + (numMonths[0] > 0 && col === numMonths[1] - 1 ? '<div class=\'ui-datepicker-row-break\'></div>' : '') : '');
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },
        _generateMonthYearHeader: function (inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, 'changeMonth'), changeYear = this._get(inst, 'changeYear'), showMonthAfterYear = this._get(inst, 'showMonthAfterYear'), html = '<div class=\'ui-datepicker-title\'>', monthHtml = '';
            if (secondary || !changeMonth) {
                monthHtml += '<span class=\'ui-datepicker-month\'>' + monthNames[drawMonth] + '</span>';
            } else {
                inMinYear = minDate && minDate.getFullYear() === drawYear;
                inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
                monthHtml += '<select class=\'ui-datepicker-month\' data-handler=\'selectMonth\' data-event=\'change\'>';
                for (month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                        monthHtml += '<option value=\'' + month + '\'' + (month === drawMonth ? ' selected=\'selected\'' : '') + '>' + monthNamesShort[month] + '</option>';
                    }
                }
                monthHtml += '</select>';
            }
            if (!showMonthAfterYear) {
                html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
            }
            if (!inst.yearshtml) {
                inst.yearshtml = '';
                if (secondary || !changeYear) {
                    html += '<span class=\'ui-datepicker-year\'>' + drawYear + '</span>';
                } else {
                    years = this._get(inst, 'yearRange').split(':');
                    thisYear = new Date().getFullYear();
                    determineYear = function (value) {
                        var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
                        return isNaN(year) ? thisYear : year;
                    };
                    year = determineYear(years[0]);
                    endYear = Math.max(year, determineYear(years[1] || ''));
                    year = minDate ? Math.max(year, minDate.getFullYear()) : year;
                    endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
                    inst.yearshtml += '<select class=\'ui-datepicker-year\' data-handler=\'selectYear\' data-event=\'change\'>';
                    for (; year <= endYear; year++) {
                        inst.yearshtml += '<option value=\'' + year + '\'' + (year === drawYear ? ' selected=\'selected\'' : '') + '>' + year + '</option>';
                    }
                    inst.yearshtml += '</select>';
                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }
            html += this._get(inst, 'yearSuffix');
            if (showMonthAfterYear) {
                html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
            }
            html += '</div>';
            return html;
        },
        _adjustInstDate: function (inst, offset, period) {
            var year = inst.drawYear + (period === 'Y' ? offset : 0), month = inst.drawMonth + (period === 'M' ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === 'D' ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if (period === 'M' || period === 'Y') {
                this._notifyChange(inst);
            }
        },
        _restrictMinMax: function (inst, date) {
            var minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), newDate = minDate && date < minDate ? minDate : date;
            return maxDate && newDate > maxDate ? maxDate : newDate;
        },
        _notifyChange: function (inst) {
            var onChange = this._get(inst, 'onChangeMonthYear');
            if (onChange) {
                onChange.apply(inst.input ? inst.input[0] : null, [
                    inst.selectedYear,
                    inst.selectedMonth + 1,
                    inst
                ]);
            }
        },
        _getNumberOfMonths: function (inst) {
            var numMonths = this._get(inst, 'numberOfMonths');
            return numMonths == null ? [
                1,
                1
            ] : typeof numMonths === 'number' ? [
                1,
                numMonths
            ] : numMonths;
        },
        _getMinMaxDate: function (inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
        },
        _getDaysInMonth: function (year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },
        _getFirstDayOfMonth: function (year, month) {
            return new Date(year, month, 1).getDay();
        },
        _canAdjustMonth: function (inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
            if (offset < 0) {
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
            }
            return this._isInRange(inst, date);
        },
        _isInRange: function (inst, date) {
            var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), minYear = null, maxYear = null, years = this._get(inst, 'yearRange');
            if (years) {
                yearSplit = years.split(':');
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if (yearSplit[0].match(/[+\-].*/)) {
                    minYear += currentYear;
                }
                if (yearSplit[1].match(/[+\-].*/)) {
                    maxYear += currentYear;
                }
            }
            return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
        },
        _getFormatConfig: function (inst) {
            var shortYearCutoff = this._get(inst, 'shortYearCutoff');
            shortYearCutoff = typeof shortYearCutoff !== 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, 'dayNamesShort'),
                dayNames: this._get(inst, 'dayNames'),
                monthNamesShort: this._get(inst, 'monthNamesShort'),
                monthNames: this._get(inst, 'monthNames')
            };
        },
        _formatDate: function (inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = day ? typeof day === 'object' ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
        }
    });
    function datepicker_bindHover(dpDiv) {
        var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
        return dpDiv.delegate(selector, 'mouseout', function () {
            $(this).removeClass('ui-state-hover');
            if (this.className.indexOf('ui-datepicker-prev') !== -1) {
                $(this).removeClass('ui-datepicker-prev-hover');
            }
            if (this.className.indexOf('ui-datepicker-next') !== -1) {
                $(this).removeClass('ui-datepicker-next-hover');
            }
        }).delegate(selector, 'mouseover', datepicker_handleMouseover);
    }
    function datepicker_handleMouseover() {
        if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
            $(this).parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
            $(this).addClass('ui-state-hover');
            if (this.className.indexOf('ui-datepicker-prev') !== -1) {
                $(this).addClass('ui-datepicker-prev-hover');
            }
            if (this.className.indexOf('ui-datepicker-next') !== -1) {
                $(this).addClass('ui-datepicker-next-hover');
            }
        }
    }
    function datepicker_extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = props[name];
            }
        }
        return target;
    }
    $.fn.datepicker = function (options) {
        if (!this.length) {
            return this;
        }
        if (!$.datepicker.initialized) {
            $(document).mousedown($.datepicker._checkExternalClick);
            $.datepicker.initialized = true;
        }
        if ($('#' + $.datepicker._mainDivId).length === 0) {
            $('body').append($.datepicker.dpDiv);
        }
        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options === 'string' && (options === 'isDisabled' || options === 'getDate' || options === 'widget')) {
            return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
        }
        if (options === 'option' && arguments.length === 2 && typeof arguments[1] === 'string') {
            return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
        }
        return this.each(function () {
            typeof options === 'string' ? $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
        });
    };
    $.datepicker = new Datepicker();
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = '1.11.4';
    return $.datepicker;
}));
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('lib/jquery-ui/ui/datepicker', [
            'jquery',
            'lib/jquery-ui/ui/core'
        ], factory);
    } else {
        factory(jQuery);
    }
}(function ($) {
    $.extend($.ui, { datepicker: { version: '1.11.4' } });
    var datepicker_instActive;
    function datepicker_getZindex(elem) {
        var position, value;
        while (elem.length && elem[0] !== document) {
            position = elem.css('position');
            if (position === 'absolute' || position === 'relative' || position === 'fixed') {
                value = parseInt(elem.css('zIndex'), 10);
                if (!isNaN(value) && value !== 0) {
                    return value;
                }
            }
            elem = elem.parent();
        }
        return 0;
    }
    function Datepicker() {
        this._curInst = null;
        this._keyEvent = false;
        this._disabledInputs = [];
        this._datepickerShowing = false;
        this._inDialog = false;
        this._mainDivId = 'ui-datepicker-div';
        this._inlineClass = 'ui-datepicker-inline';
        this._appendClass = 'ui-datepicker-append';
        this._triggerClass = 'ui-datepicker-trigger';
        this._dialogClass = 'ui-datepicker-dialog';
        this._disableClass = 'ui-datepicker-disabled';
        this._unselectableClass = 'ui-datepicker-unselectable';
        this._currentClass = 'ui-datepicker-current-day';
        this._dayOverClass = 'ui-datepicker-days-cell-over';
        this.regional = [];
        this.regional[''] = {
            closeText: 'Done',
            prevText: 'Prev',
            nextText: 'Next',
            currentText: 'Today',
            monthNames: [
                'January',
                'February',
                'March',
                'April',
                'May',
                'June',
                'July',
                'August',
                'September',
                'October',
                'November',
                'December'
            ],
            monthNamesShort: [
                'Jan',
                'Feb',
                'Mar',
                'Apr',
                'May',
                'Jun',
                'Jul',
                'Aug',
                'Sep',
                'Oct',
                'Nov',
                'Dec'
            ],
            dayNames: [
                'Sunday',
                'Monday',
                'Tuesday',
                'Wednesday',
                'Thursday',
                'Friday',
                'Saturday'
            ],
            dayNamesShort: [
                'Sun',
                'Mon',
                'Tue',
                'Wed',
                'Thu',
                'Fri',
                'Sat'
            ],
            dayNamesMin: [
                'Su',
                'Mo',
                'Tu',
                'We',
                'Th',
                'Fr',
                'Sa'
            ],
            weekHeader: 'Wk',
            dateFormat: 'mm/dd/yy',
            firstDay: 0,
            isRTL: false,
            showMonthAfterYear: false,
            yearSuffix: ''
        };
        this._defaults = {
            showOn: 'focus',
            showAnim: 'fadeIn',
            showOptions: {},
            defaultDate: null,
            appendText: '',
            buttonText: '...',
            buttonImage: '',
            buttonImageOnly: false,
            hideIfNoPrevNext: false,
            navigationAsDateFormat: false,
            gotoCurrent: false,
            changeMonth: false,
            changeYear: false,
            yearRange: 'c-10:c+10',
            showOtherMonths: false,
            selectOtherMonths: false,
            showWeek: false,
            calculateWeek: this.iso8601Week,
            shortYearCutoff: '+10',
            minDate: null,
            maxDate: null,
            duration: 'fast',
            beforeShowDay: null,
            beforeShow: null,
            onSelect: null,
            onChangeMonthYear: null,
            onClose: null,
            numberOfMonths: 1,
            showCurrentAtPos: 0,
            stepMonths: 1,
            stepBigMonths: 12,
            altField: '',
            altFormat: '',
            constrainInput: true,
            showButtonPanel: false,
            autoSize: false,
            disabled: false
        };
        $.extend(this._defaults, this.regional['']);
        this.regional.en = $.extend(true, {}, this.regional['']);
        this.regional['en-US'] = $.extend(true, {}, this.regional.en);
        this.dpDiv = datepicker_bindHover($('<div id=\'' + this._mainDivId + '\' class=\'ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>'));
    }
    $.extend(Datepicker.prototype, {
        markerClassName: 'hasDatepicker',
        maxRows: 4,
        _widgetDatepicker: function () {
            return this.dpDiv;
        },
        setDefaults: function (settings) {
            datepicker_extendRemove(this._defaults, settings || {});
            return this;
        },
        _attachDatepicker: function (target, settings) {
            var nodeName, inline, inst;
            nodeName = target.nodeName.toLowerCase();
            inline = nodeName === 'div' || nodeName === 'span';
            if (!target.id) {
                this.uuid += 1;
                target.id = 'dp' + this.uuid;
            }
            inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {});
            if (nodeName === 'input') {
                this._connectDatepicker(target, inst);
            } else if (inline) {
                this._inlineDatepicker(target, inst);
            }
        },
        _newInst: function (target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, '\\\\$1');
            return {
                id: id,
                input: target,
                selectedDay: 0,
                selectedMonth: 0,
                selectedYear: 0,
                drawMonth: 0,
                drawYear: 0,
                inline: inline,
                dpDiv: !inline ? this.dpDiv : datepicker_bindHover($('<div class=\'' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>'))
            };
        },
        _connectDatepicker: function (target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) {
                return;
            }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
            this._autoSize(inst);
            $.data(target, 'datepicker', inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
        },
        _attachments: function (input, inst) {
            var showOn, buttonText, buttonImage, appendText = this._get(inst, 'appendText'), isRTL = this._get(inst, 'isRTL');
            if (inst.append) {
                inst.append.remove();
            }
            if (appendText) {
                inst.append = $('<span class=\'' + this._appendClass + '\'>' + appendText + '</span>');
                input[isRTL ? 'before' : 'after'](inst.append);
            }
            input.unbind('focus', this._showDatepicker);
            if (inst.trigger) {
                inst.trigger.remove();
            }
            showOn = this._get(inst, 'showOn');
            if (showOn === 'focus' || showOn === 'both') {
                input.focus(this._showDatepicker);
            }
            if (showOn === 'button' || showOn === 'both') {
                buttonText = this._get(inst, 'buttonText');
                buttonImage = this._get(inst, 'buttonImage');
                inst.trigger = $(this._get(inst, 'buttonImageOnly') ? $('<img/>').addClass(this._triggerClass).attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                }) : $('<button type=\'button\'></button>').addClass(this._triggerClass).html(!buttonImage ? buttonText : $('<img/>').attr({
                    src: buttonImage,
                    alt: buttonText,
                    title: buttonText
                })));
                input[isRTL ? 'before' : 'after'](inst.trigger);
                inst.trigger.click(function () {
                    if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
                        $.datepicker._hideDatepicker();
                    } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
                        $.datepicker._hideDatepicker();
                        $.datepicker._showDatepicker(input[0]);
                    } else {
                        $.datepicker._showDatepicker(input[0]);
                    }
                    return false;
                });
            }
        },
        _autoSize: function (inst) {
            if (this._get(inst, 'autoSize') && !inst.inline) {
                var findMax, max, maxI, i, date = new Date(2009, 12 - 1, 20), dateFormat = this._get(inst, 'dateFormat');
                if (dateFormat.match(/[DM]/)) {
                    findMax = function (names) {
                        max = 0;
                        maxI = 0;
                        for (i = 0; i < names.length; i++) {
                            if (names[i].length > max) {
                                max = names[i].length;
                                maxI = i;
                            }
                        }
                        return maxI;
                    };
                    date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? 'monthNames' : 'monthNamesShort')));
                    date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? 'dayNames' : 'dayNamesShort')) + 20 - date.getDay());
                }
                inst.input.attr('size', this._formatDate(inst, date).length);
            }
        },
        _inlineDatepicker: function (target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName)) {
                return;
            }
            divSpan.addClass(this.markerClassName).append(inst.dpDiv);
            $.data(target, 'datepicker', inst);
            this._setDate(inst, this._getDefaultDate(inst), true);
            this._updateDatepicker(inst);
            this._updateAlternate(inst);
            if (inst.settings.disabled) {
                this._disableDatepicker(target);
            }
            inst.dpDiv.css('display', 'block');
        },
        _dialogDatepicker: function (input, date, onSelect, settings, pos) {
            var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
            if (!inst) {
                this.uuid += 1;
                id = 'dp' + this.uuid;
                this._dialogInput = $('<input type=\'text\' id=\'' + id + '\' style=\'position: absolute; top: -100px; width: 0px;\'/>');
                this._dialogInput.keydown(this._doKeyDown);
                $('body').append(this._dialogInput);
                inst = this._dialogInst = this._newInst(this._dialogInput, false);
                inst.settings = {};
                $.data(this._dialogInput[0], 'datepicker', inst);
            }
            datepicker_extendRemove(inst.settings, settings || {});
            date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
            this._dialogInput.val(date);
            this._pos = pos ? pos.length ? pos : [
                pos.pageX,
                pos.pageY
            ] : null;
            if (!this._pos) {
                browserWidth = document.documentElement.clientWidth;
                browserHeight = document.documentElement.clientHeight;
                scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
                scrollY = document.documentElement.scrollTop || document.body.scrollTop;
                this._pos = [
                    browserWidth / 2 - 100 + scrollX,
                    browserHeight / 2 - 150 + scrollY
                ];
            }
            this._dialogInput.css('left', this._pos[0] + 20 + 'px').css('top', this._pos[1] + 'px');
            inst.settings.onSelect = onSelect;
            this._inDialog = true;
            this.dpDiv.addClass(this._dialogClass);
            this._showDatepicker(this._dialogInput[0]);
            if ($.blockUI) {
                $.blockUI(this.dpDiv);
            }
            $.data(this._dialogInput[0], 'datepicker', inst);
            return this;
        },
        _destroyDatepicker: function (target) {
            var nodeName, $target = $(target), inst = $.data(target, 'datepicker');
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            $.removeData(target, 'datepicker');
            if (nodeName === 'input') {
                inst.append.remove();
                inst.trigger.remove();
                $target.removeClass(this.markerClassName).unbind('focus', this._showDatepicker).unbind('keydown', this._doKeyDown).unbind('keypress', this._doKeyPress).unbind('keyup', this._doKeyUp);
            } else if (nodeName === 'div' || nodeName === 'span') {
                $target.removeClass(this.markerClassName).empty();
            }
            if (datepicker_instActive === inst) {
                datepicker_instActive = null;
            }
        },
        _enableDatepicker: function (target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, 'datepicker');
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === 'input') {
                target.disabled = false;
                inst.trigger.filter('button').each(function () {
                    this.disabled = false;
                }).end().filter('img').css({
                    opacity: '1.0',
                    cursor: ''
                });
            } else if (nodeName === 'div' || nodeName === 'span') {
                inline = $target.children('.' + this._inlineClass);
                inline.children().removeClass('ui-state-disabled');
                inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', false);
            }
            this._disabledInputs = $.map(this._disabledInputs, function (value) {
                return value === target ? null : value;
            });
        },
        _disableDatepicker: function (target) {
            var nodeName, inline, $target = $(target), inst = $.data(target, 'datepicker');
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            nodeName = target.nodeName.toLowerCase();
            if (nodeName === 'input') {
                target.disabled = true;
                inst.trigger.filter('button').each(function () {
                    this.disabled = true;
                }).end().filter('img').css({
                    opacity: '0.5',
                    cursor: 'default'
                });
            } else if (nodeName === 'div' || nodeName === 'span') {
                inline = $target.children('.' + this._inlineClass);
                inline.children().addClass('ui-state-disabled');
                inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', true);
            }
            this._disabledInputs = $.map(this._disabledInputs, function (value) {
                return value === target ? null : value;
            });
            this._disabledInputs[this._disabledInputs.length] = target;
        },
        _isDisabledDatepicker: function (target) {
            if (!target) {
                return false;
            }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] === target) {
                    return true;
                }
            }
            return false;
        },
        _getInst: function (target) {
            try {
                return $.data(target, 'datepicker');
            } catch (err) {
                throw 'Missing instance data for this datepicker';
            }
        },
        _optionDatepicker: function (target, name, value) {
            var settings, date, minDate, maxDate, inst = this._getInst(target);
            if (arguments.length === 2 && typeof name === 'string') {
                return name === 'defaults' ? $.extend({}, $.datepicker._defaults) : inst ? name === 'all' ? $.extend({}, inst.settings) : this._get(inst, name) : null;
            }
            settings = name || {};
            if (typeof name === 'string') {
                settings = {};
                settings[name] = value;
            }
            if (inst) {
                if (this._curInst === inst) {
                    this._hideDatepicker();
                }
                date = this._getDateDatepicker(target, true);
                minDate = this._getMinMaxDate(inst, 'min');
                maxDate = this._getMinMaxDate(inst, 'max');
                datepicker_extendRemove(inst.settings, settings);
                if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
                    inst.settings.minDate = this._formatDate(inst, minDate);
                }
                if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
                    inst.settings.maxDate = this._formatDate(inst, maxDate);
                }
                if ('disabled' in settings) {
                    if (settings.disabled) {
                        this._disableDatepicker(target);
                    } else {
                        this._enableDatepicker(target);
                    }
                }
                this._attachments($(target), inst);
                this._autoSize(inst);
                this._setDate(inst, date);
                this._updateAlternate(inst);
                this._updateDatepicker(inst);
            }
        },
        _changeDatepicker: function (target, name, value) {
            this._optionDatepicker(target, name, value);
        },
        _refreshDatepicker: function (target) {
            var inst = this._getInst(target);
            if (inst) {
                this._updateDatepicker(inst);
            }
        },
        _setDateDatepicker: function (target, date) {
            var inst = this._getInst(target);
            if (inst) {
                this._setDate(inst, date);
                this._updateDatepicker(inst);
                this._updateAlternate(inst);
            }
        },
        _getDateDatepicker: function (target, noDefault) {
            var inst = this._getInst(target);
            if (inst && !inst.inline) {
                this._setDateFromField(inst, noDefault);
            }
            return inst ? this._getDate(inst) : null;
        },
        _doKeyDown: function (event) {
            var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = true, isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
            inst._keyEvent = true;
            if ($.datepicker._datepickerShowing) {
                switch (event.keyCode) {
                case 9:
                    $.datepicker._hideDatepicker();
                    handled = false;
                    break;
                case 13:
                    sel = $('td.' + $.datepicker._dayOverClass + ':not(.' + $.datepicker._currentClass + ')', inst.dpDiv);
                    if (sel[0]) {
                        $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
                    }
                    onSelect = $.datepicker._get(inst, 'onSelect');
                    if (onSelect) {
                        dateStr = $.datepicker._formatDate(inst);
                        onSelect.apply(inst.input ? inst.input[0] : null, [
                            dateStr,
                            inst
                        ]);
                    } else {
                        $.datepicker._hideDatepicker();
                    }
                    return false;
                case 27:
                    $.datepicker._hideDatepicker();
                    break;
                case 33:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'), 'M');
                    break;
                case 34:
                    $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'), 'M');
                    break;
                case 35:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._clearDate(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;
                case 36:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._gotoToday(event.target);
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;
                case 37:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, 'D');
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'), 'M');
                    }
                    break;
                case 38:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, -7, 'D');
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;
                case 39:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, 'D');
                    }
                    handled = event.ctrlKey || event.metaKey;
                    if (event.originalEvent.altKey) {
                        $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'), 'M');
                    }
                    break;
                case 40:
                    if (event.ctrlKey || event.metaKey) {
                        $.datepicker._adjustDate(event.target, +7, 'D');
                    }
                    handled = event.ctrlKey || event.metaKey;
                    break;
                default:
                    handled = false;
                }
            } else if (event.keyCode === 36 && event.ctrlKey) {
                $.datepicker._showDatepicker(this);
            } else {
                handled = false;
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },
        _doKeyPress: function (event) {
            var chars, chr, inst = $.datepicker._getInst(event.target);
            if ($.datepicker._get(inst, 'constrainInput')) {
                chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
                chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
                return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
            }
        },
        _doKeyUp: function (event) {
            var date, inst = $.datepicker._getInst(event.target);
            if (inst.input.val() !== inst.lastVal) {
                try {
                    date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
                    if (date) {
                        $.datepicker._setDateFromField(inst);
                        $.datepicker._updateAlternate(inst);
                        $.datepicker._updateDatepicker(inst);
                    }
                } catch (err) {
                }
            }
            return true;
        },
        _showDatepicker: function (input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() !== 'input') {
                input = $('input', input.parentNode)[0];
            }
            if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
                return;
            }
            var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
            inst = $.datepicker._getInst(input);
            if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
                $.datepicker._curInst.dpDiv.stop(true, true);
                if (inst && $.datepicker._datepickerShowing) {
                    $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
                }
            }
            beforeShow = $.datepicker._get(inst, 'beforeShow');
            beforeShowSettings = beforeShow ? beforeShow.apply(input, [
                input,
                inst
            ]) : {};
            if (beforeShowSettings === false) {
                return;
            }
            datepicker_extendRemove(inst.settings, beforeShowSettings);
            inst.lastVal = null;
            $.datepicker._lastInput = input;
            $.datepicker._setDateFromField(inst);
            if ($.datepicker._inDialog) {
                input.value = '';
            }
            if (!$.datepicker._pos) {
                $.datepicker._pos = $.datepicker._findPos(input);
                $.datepicker._pos[1] += input.offsetHeight;
            }
            isFixed = false;
            $(input).parents().each(function () {
                isFixed |= $(this).css('position') === 'fixed';
                return !isFixed;
            });
            offset = {
                left: $.datepicker._pos[0],
                top: $.datepicker._pos[1]
            };
            $.datepicker._pos = null;
            inst.dpDiv.empty();
            inst.dpDiv.css({
                position: 'absolute',
                display: 'block',
                top: '-1000px'
            });
            $.datepicker._updateDatepicker(inst);
            offset = $.datepicker._checkOffset(inst, offset, isFixed);
            inst.dpDiv.css({
                position: $.datepicker._inDialog && $.blockUI ? 'static' : isFixed ? 'fixed' : 'absolute',
                display: 'none',
                left: offset.left + 'px',
                top: offset.top + 'px'
            });
            if (!inst.inline) {
                showAnim = $.datepicker._get(inst, 'showAnim');
                duration = $.datepicker._get(inst, 'duration');
                inst.dpDiv.css('z-index', datepicker_getZindex($(input)) + 1);
                $.datepicker._datepickerShowing = true;
                if ($.effects && $.effects.effect[showAnim]) {
                    inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration);
                } else {
                    inst.dpDiv[showAnim || 'show'](showAnim ? duration : null);
                }
                if ($.datepicker._shouldFocusInput(inst)) {
                    inst.input.focus();
                }
                $.datepicker._curInst = inst;
            }
        },
        _updateDatepicker: function (inst) {
            this.maxRows = 4;
            datepicker_instActive = inst;
            inst.dpDiv.empty().append(this._generateHTML(inst));
            this._attachHandlers(inst);
            var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17, activeCell = inst.dpDiv.find('.' + this._dayOverClass + ' a');
            if (activeCell.length > 0) {
                datepicker_handleMouseover.apply(activeCell.get(0));
            }
            inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
            if (cols > 1) {
                inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', width * cols + 'em');
            }
            inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? 'add' : 'remove') + 'Class']('ui-datepicker-multi');
            inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') + 'Class']('ui-datepicker-rtl');
            if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
                inst.input.focus();
            }
            if (inst.yearshtml) {
                origyearshtml = inst.yearshtml;
                setTimeout(function () {
                    if (origyearshtml === inst.yearshtml && inst.yearshtml) {
                        inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
                    }
                    origyearshtml = inst.yearshtml = null;
                }, 0);
            }
        },
        _shouldFocusInput: function (inst) {
            return inst.input && inst.input.is(':visible') && !inst.input.is(':disabled') && !inst.input.is(':focus');
        },
        _checkOffset: function (inst, offset, isFixed) {
            var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
            offset.left -= this._get(inst, 'isRTL') ? dpWidth - inputWidth : 0;
            offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
            offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
            offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
            return offset;
        },
        _findPos: function (obj) {
            var position, inst = this._getInst(obj), isRTL = this._get(inst, 'isRTL');
            while (obj && (obj.type === 'hidden' || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
                obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
            }
            position = $(obj).offset();
            return [
                position.left,
                position.top
            ];
        },
        _hideDatepicker: function (input) {
            var showAnim, duration, postProcess, onClose, inst = this._curInst;
            if (!inst || input && inst !== $.data(input, 'datepicker')) {
                return;
            }
            if (this._datepickerShowing) {
                showAnim = this._get(inst, 'showAnim');
                duration = this._get(inst, 'duration');
                postProcess = function () {
                    $.datepicker._tidyDialog(inst);
                };
                if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
                    inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
                } else {
                    inst.dpDiv[showAnim === 'slideDown' ? 'slideUp' : showAnim === 'fadeIn' ? 'fadeOut' : 'hide'](showAnim ? duration : null, postProcess);
                }
                if (!showAnim) {
                    postProcess();
                }
                this._datepickerShowing = false;
                onClose = this._get(inst, 'onClose');
                if (onClose) {
                    onClose.apply(inst.input ? inst.input[0] : null, [
                        inst.input ? inst.input.val() : '',
                        inst
                    ]);
                }
                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({
                        position: 'absolute',
                        left: '0',
                        top: '-100px'
                    });
                    if ($.blockUI) {
                        $.unblockUI();
                        $('body').append(this.dpDiv);
                    }
                }
                this._inDialog = false;
            }
        },
        _tidyDialog: function (inst) {
            inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
        },
        _checkExternalClick: function (event) {
            if (!$.datepicker._curInst) {
                return;
            }
            var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
            if ($target[0].id !== $.datepicker._mainDivId && $target.parents('#' + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest('.' + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
                $.datepicker._hideDatepicker();
            }
        },
        _adjustDate: function (id, offset, period) {
            var target = $(id), inst = this._getInst(target[0]);
            if (this._isDisabledDatepicker(target[0])) {
                return;
            }
            this._adjustInstDate(inst, offset + (period === 'M' ? this._get(inst, 'showCurrentAtPos') : 0), period);
            this._updateDatepicker(inst);
        },
        _gotoToday: function (id) {
            var date, target = $(id), inst = this._getInst(target[0]);
            if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
                inst.selectedDay = inst.currentDay;
                inst.drawMonth = inst.selectedMonth = inst.currentMonth;
                inst.drawYear = inst.selectedYear = inst.currentYear;
            } else {
                date = new Date();
                inst.selectedDay = date.getDate();
                inst.drawMonth = inst.selectedMonth = date.getMonth();
                inst.drawYear = inst.selectedYear = date.getFullYear();
            }
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectMonthYear: function (id, select, period) {
            var target = $(id), inst = this._getInst(target[0]);
            inst['selected' + (period === 'M' ? 'Month' : 'Year')] = inst['draw' + (period === 'M' ? 'Month' : 'Year')] = parseInt(select.options[select.selectedIndex].value, 10);
            this._notifyChange(inst);
            this._adjustDate(target);
        },
        _selectDay: function (id, month, year, td) {
            var inst, target = $(id);
            if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
                return;
            }
            inst = this._getInst(target[0]);
            inst.selectedDay = inst.currentDay = $('a', td).html();
            inst.selectedMonth = inst.currentMonth = month;
            inst.selectedYear = inst.currentYear = year;
            this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
        },
        _clearDate: function (id) {
            var target = $(id);
            this._selectDate(target, '');
        },
        _selectDate: function (id, dateStr) {
            var onSelect, target = $(id), inst = this._getInst(target[0]);
            dateStr = dateStr != null ? dateStr : this._formatDate(inst);
            if (inst.input) {
                inst.input.val(dateStr);
            }
            this._updateAlternate(inst);
            onSelect = this._get(inst, 'onSelect');
            if (onSelect) {
                onSelect.apply(inst.input ? inst.input[0] : null, [
                    dateStr,
                    inst
                ]);
            } else if (inst.input) {
                inst.input.trigger('change');
            }
            if (inst.inline) {
                this._updateDatepicker(inst);
            } else {
                this._hideDatepicker();
                this._lastInput = inst.input[0];
                if (typeof inst.input[0] !== 'object') {
                    inst.input.focus();
                }
                this._lastInput = null;
            }
        },
        _updateAlternate: function (inst) {
            var altFormat, date, dateStr, altField = this._get(inst, 'altField');
            if (altField) {
                altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
                date = this._getDate(inst);
                dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
                $(altField).each(function () {
                    $(this).val(dateStr);
                });
            }
        },
        noWeekends: function (date) {
            var day = date.getDay();
            return [
                day > 0 && day < 6,
                ''
            ];
        },
        iso8601Week: function (date) {
            var time, checkDate = new Date(date.getTime());
            checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
            time = checkDate.getTime();
            checkDate.setMonth(0);
            checkDate.setDate(1);
            return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
        },
        parseDate: function (format, value, settings) {
            if (format == null || value == null) {
                throw 'Invalid arguments';
            }
            value = typeof value === 'object' ? value.toString() : value + '';
            if (value === '') {
                return null;
            }
            var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = typeof shortYearCutoffTemp !== 'string' ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date, lookAhead = function (match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                }, getNumber = function (match) {
                    var isDoubled = lookAhead(match), size = match === '@' ? 14 : match === '!' ? 20 : match === 'y' && isDoubled ? 4 : match === 'o' ? 3 : 2, minSize = match === 'y' ? size : 1, digits = new RegExp('^\\d{' + minSize + ',' + size + '}'), num = value.substring(iValue).match(digits);
                    if (!num) {
                        throw 'Missing number at position ' + iValue;
                    }
                    iValue += num[0].length;
                    return parseInt(num[0], 10);
                }, getName = function (match, shortNames, longNames) {
                    var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
                            return [[
                                    k,
                                    v
                                ]];
                        }).sort(function (a, b) {
                            return -(a[1].length - b[1].length);
                        });
                    $.each(names, function (i, pair) {
                        var name = pair[1];
                        if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                            index = pair[0];
                            iValue += name.length;
                            return false;
                        }
                    });
                    if (index !== -1) {
                        return index + 1;
                    } else {
                        throw 'Unknown name at position ' + iValue;
                    }
                }, checkLiteral = function () {
                    if (value.charAt(iValue) !== format.charAt(iFormat)) {
                        throw 'Unexpected literal at position ' + iValue;
                    }
                    iValue++;
                };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
                        literal = false;
                    } else {
                        checkLiteral();
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                    case 'd':
                        day = getNumber('d');
                        break;
                    case 'D':
                        getName('D', dayNamesShort, dayNames);
                        break;
                    case 'o':
                        doy = getNumber('o');
                        break;
                    case 'm':
                        month = getNumber('m');
                        break;
                    case 'M':
                        month = getName('M', monthNamesShort, monthNames);
                        break;
                    case 'y':
                        year = getNumber('y');
                        break;
                    case '@':
                        date = new Date(getNumber('@'));
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;
                    case '!':
                        date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
                        year = date.getFullYear();
                        month = date.getMonth() + 1;
                        day = date.getDate();
                        break;
                    case '\'':
                        if (lookAhead('\'')) {
                            checkLiteral();
                        } else {
                            literal = true;
                        }
                        break;
                    default:
                        checkLiteral();
                    }
                }
            }
            if (iValue < value.length) {
                extra = value.substr(iValue);
                if (!/^\s+/.test(extra)) {
                    throw 'Extra/unparsed characters found in date: ' + extra;
                }
            }
            if (year === -1) {
                year = new Date().getFullYear();
            } else if (year < 100) {
                year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
            }
            if (doy > -1) {
                month = 1;
                day = doy;
                do {
                    dim = this._getDaysInMonth(year, month - 1);
                    if (day <= dim) {
                        break;
                    }
                    month++;
                    day -= dim;
                } while (true);
            }
            date = this._daylightSavingAdjust(new Date(year, month - 1, day));
            if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
                throw 'Invalid date';
            }
            return date;
        },
        ATOM: 'yy-mm-dd',
        COOKIE: 'D, dd M yy',
        ISO_8601: 'yy-mm-dd',
        RFC_822: 'D, d M y',
        RFC_850: 'DD, dd-M-y',
        RFC_1036: 'D, d M y',
        RFC_1123: 'D, d M yy',
        RFC_2822: 'D, d M yy',
        RSS: 'D, d M y',
        TICKS: '!',
        TIMESTAMP: '@',
        W3C: 'yy-mm-dd',
        _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000,
        formatDate: function (format, date, settings) {
            if (!date) {
                return '';
            }
            var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, lookAhead = function (match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                }, formatNumber = function (match, value, len) {
                    var num = '' + value;
                    if (lookAhead(match)) {
                        while (num.length < len) {
                            num = '0' + num;
                        }
                    }
                    return num;
                }, formatName = function (match, value, shortNames, longNames) {
                    return lookAhead(match) ? longNames[value] : shortNames[value];
                }, output = '', literal = false;
            if (date) {
                for (iFormat = 0; iFormat < format.length; iFormat++) {
                    if (literal) {
                        if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
                            literal = false;
                        } else {
                            output += format.charAt(iFormat);
                        }
                    } else {
                        switch (format.charAt(iFormat)) {
                        case 'd':
                            output += formatNumber('d', date.getDate(), 2);
                            break;
                        case 'D':
                            output += formatName('D', date.getDay(), dayNamesShort, dayNames);
                            break;
                        case 'o':
                            output += formatNumber('o', Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                            break;
                        case 'm':
                            output += formatNumber('m', date.getMonth() + 1, 2);
                            break;
                        case 'M':
                            output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
                            break;
                        case 'y':
                            output += lookAhead('y') ? date.getFullYear() : (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100;
                            break;
                        case '@':
                            output += date.getTime();
                            break;
                        case '!':
                            output += date.getTime() * 10000 + this._ticksTo1970;
                            break;
                        case '\'':
                            if (lookAhead('\'')) {
                                output += '\'';
                            } else {
                                literal = true;
                            }
                            break;
                        default:
                            output += format.charAt(iFormat);
                        }
                    }
                }
            }
            return output;
        },
        _possibleChars: function (format) {
            var iFormat, chars = '', literal = false, lookAhead = function (match) {
                    var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
                    if (matches) {
                        iFormat++;
                    }
                    return matches;
                };
            for (iFormat = 0; iFormat < format.length; iFormat++) {
                if (literal) {
                    if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
                        literal = false;
                    } else {
                        chars += format.charAt(iFormat);
                    }
                } else {
                    switch (format.charAt(iFormat)) {
                    case 'd':
                    case 'm':
                    case 'y':
                    case '@':
                        chars += '0123456789';
                        break;
                    case 'D':
                    case 'M':
                        return null;
                    case '\'':
                        if (lookAhead('\'')) {
                            chars += '\'';
                        } else {
                            literal = true;
                        }
                        break;
                    default:
                        chars += format.charAt(iFormat);
                    }
                }
            }
            return chars;
        },
        _get: function (inst, name) {
            return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
        },
        _setDateFromField: function (inst, noDefault) {
            if (inst.input.val() === inst.lastVal) {
                return;
            }
            var dateFormat = this._get(inst, 'dateFormat'), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
            try {
                date = this.parseDate(dateFormat, dates, settings) || defaultDate;
            } catch (event) {
                dates = noDefault ? '' : dates;
            }
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            inst.currentDay = dates ? date.getDate() : 0;
            inst.currentMonth = dates ? date.getMonth() : 0;
            inst.currentYear = dates ? date.getFullYear() : 0;
            this._adjustInstDate(inst);
        },
        _getDefaultDate: function (inst) {
            return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
        },
        _determineDate: function (inst, date, defaultDate) {
            var offsetNumeric = function (offset) {
                    var date = new Date();
                    date.setDate(date.getDate() + offset);
                    return date;
                }, offsetString = function (offset) {
                    try {
                        return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), offset, $.datepicker._getFormatConfig(inst));
                    } catch (e) {
                    }
                    var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset);
                    while (matches) {
                        switch (matches[2] || 'd') {
                        case 'd':
                        case 'D':
                            day += parseInt(matches[1], 10);
                            break;
                        case 'w':
                        case 'W':
                            day += parseInt(matches[1], 10) * 7;
                            break;
                        case 'm':
                        case 'M':
                            month += parseInt(matches[1], 10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;
                        case 'y':
                        case 'Y':
                            year += parseInt(matches[1], 10);
                            day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                            break;
                        }
                        matches = pattern.exec(offset);
                    }
                    return new Date(year, month, day);
                }, newDate = date == null || date === '' ? defaultDate : typeof date === 'string' ? offsetString(date) : typeof date === 'number' ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
            newDate = newDate && newDate.toString() === 'Invalid Date' ? defaultDate : newDate;
            if (newDate) {
                newDate.setHours(0);
                newDate.setMinutes(0);
                newDate.setSeconds(0);
                newDate.setMilliseconds(0);
            }
            return this._daylightSavingAdjust(newDate);
        },
        _daylightSavingAdjust: function (date) {
            if (!date) {
                return null;
            }
            date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
            return date;
        },
        _setDate: function (inst, date, noChange) {
            var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
            inst.selectedDay = inst.currentDay = newDate.getDate();
            inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
            inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
            if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
                this._notifyChange(inst);
            }
            this._adjustInstDate(inst);
            if (inst.input) {
                inst.input.val(clear ? '' : this._formatDate(inst));
            }
        },
        _getDate: function (inst) {
            var startDate = !inst.currentYear || inst.input && inst.input.val() === '' ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return startDate;
        },
        _attachHandlers: function (inst) {
            var stepMonths = this._get(inst, 'stepMonths'), id = '#' + inst.id.replace(/\\\\/g, '\\');
            inst.dpDiv.find('[data-handler]').map(function () {
                var handler = {
                    prev: function () {
                        $.datepicker._adjustDate(id, -stepMonths, 'M');
                    },
                    next: function () {
                        $.datepicker._adjustDate(id, +stepMonths, 'M');
                    },
                    hide: function () {
                        $.datepicker._hideDatepicker();
                    },
                    today: function () {
                        $.datepicker._gotoToday(id);
                    },
                    selectDay: function () {
                        $.datepicker._selectDay(id, +this.getAttribute('data-month'), +this.getAttribute('data-year'), this);
                        return false;
                    },
                    selectMonth: function () {
                        $.datepicker._selectMonthYear(id, this, 'M');
                        return false;
                    },
                    selectYear: function () {
                        $.datepicker._selectMonthYear(id, this, 'Y');
                        return false;
                    }
                };
                $(this).bind(this.getAttribute('data-event'), handler[this.getAttribute('data-handler')]);
            });
        },
        _generateHTML: function (inst) {
            var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), isRTL = this._get(inst, 'isRTL'), showButtonPanel = this._get(inst, 'showButtonPanel'), hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext'), navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat'), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, 'showCurrentAtPos'), stepMonths = this._get(inst, 'stepMonths'), isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1, currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)), minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
            if (drawMonth < 0) {
                drawMonth += 12;
                drawYear--;
            }
            if (maxDate) {
                maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
                maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
                while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
                    drawMonth--;
                    if (drawMonth < 0) {
                        drawMonth = 11;
                        drawYear--;
                    }
                }
            }
            inst.drawMonth = drawMonth;
            inst.drawYear = drawYear;
            prevText = this._get(inst, 'prevText');
            prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
            prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? '<a class=\'ui-datepicker-prev ui-corner-all\' data-handler=\'prev\' data-event=\'click\'' + ' title=\'' + prevText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '\'>' + prevText + '</span></a>' : hideIfNoPrevNext ? '' : '<a class=\'ui-datepicker-prev ui-corner-all ui-state-disabled\' title=\'' + prevText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '\'>' + prevText + '</span></a>';
            nextText = this._get(inst, 'nextText');
            nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
            next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? '<a class=\'ui-datepicker-next ui-corner-all\' data-handler=\'next\' data-event=\'click\'' + ' title=\'' + nextText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '\'>' + nextText + '</span></a>' : hideIfNoPrevNext ? '' : '<a class=\'ui-datepicker-next ui-corner-all ui-state-disabled\' title=\'' + nextText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '\'>' + nextText + '</span></a>';
            currentText = this._get(inst, 'currentText');
            gotoDate = this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today;
            currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
            controls = !inst.inline ? '<button type=\'button\' class=\'ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all\' data-handler=\'hide\' data-event=\'click\'>' + this._get(inst, 'closeText') + '</button>' : '';
            buttonPanel = showButtonPanel ? '<div class=\'ui-datepicker-buttonpane ui-widget-content\'>' + (isRTL ? controls : '') + (this._isInRange(inst, gotoDate) ? '<button type=\'button\' class=\'ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all\' data-handler=\'today\' data-event=\'click\'' + '>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
            firstDay = parseInt(this._get(inst, 'firstDay'), 10);
            firstDay = isNaN(firstDay) ? 0 : firstDay;
            showWeek = this._get(inst, 'showWeek');
            dayNames = this._get(inst, 'dayNames');
            dayNamesMin = this._get(inst, 'dayNamesMin');
            monthNames = this._get(inst, 'monthNames');
            monthNamesShort = this._get(inst, 'monthNamesShort');
            beforeShowDay = this._get(inst, 'beforeShowDay');
            showOtherMonths = this._get(inst, 'showOtherMonths');
            selectOtherMonths = this._get(inst, 'selectOtherMonths');
            defaultDate = this._getDefaultDate(inst);
            html = '';
            dow;
            for (row = 0; row < numMonths[0]; row++) {
                group = '';
                this.maxRows = 4;
                for (col = 0; col < numMonths[1]; col++) {
                    selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
                    cornerClass = ' ui-corner-all';
                    calender = '';
                    if (isMultiMonth) {
                        calender += '<div class=\'ui-datepicker-group';
                        if (numMonths[1] > 1) {
                            switch (col) {
                            case 0:
                                calender += ' ui-datepicker-group-first';
                                cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left');
                                break;
                            case numMonths[1] - 1:
                                calender += ' ui-datepicker-group-last';
                                cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right');
                                break;
                            default:
                                calender += ' ui-datepicker-group-middle';
                                cornerClass = '';
                                break;
                            }
                        }
                        calender += '\'>';
                    }
                    calender += '<div class=\'ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '\'>' + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : '') + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : '') + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + '</div><table class=\'ui-datepicker-calendar\'><thead>' + '<tr>';
                    thead = showWeek ? '<th class=\'ui-datepicker-week-col\'>' + this._get(inst, 'weekHeader') + '</th>' : '';
                    for (dow = 0; dow < 7; dow++) {
                        day = (dow + firstDay) % 7;
                        thead += '<th scope=\'col\'' + ((dow + firstDay + 6) % 7 >= 5 ? ' class=\'ui-datepicker-week-end\'' : '') + '>' + '<span title=\'' + dayNames[day] + '\'>' + dayNamesMin[day] + '</span></th>';
                    }
                    calender += thead + '</tr></thead><tbody>';
                    daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
                    if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
                        inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
                    }
                    leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
                    curRows = Math.ceil((leadDays + daysInMonth) / 7);
                    numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;
                    this.maxRows = numRows;
                    printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
                    for (dRow = 0; dRow < numRows; dRow++) {
                        calender += '<tr>';
                        tbody = !showWeek ? '' : '<td class=\'ui-datepicker-week-col\'>' + this._get(inst, 'calculateWeek')(printDate) + '</td>';
                        for (dow = 0; dow < 7; dow++) {
                            daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate]) : [
                                true,
                                ''
                            ];
                            otherMonth = printDate.getMonth() !== drawMonth;
                            unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
                            tbody += '<td class=\'' + ((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + (otherMonth ? ' ui-datepicker-other-month' : '') + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? ' ' + this._dayOverClass : '') + (unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled' : '') + (otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? ' ' + this._currentClass : '') + (printDate.getTime() === today.getTime() ? ' ui-datepicker-today' : '')) + '\'' + ((!otherMonth || showOtherMonths) && daySettings[2] ? ' title=\'' + daySettings[2].replace(/'/g, '&#39;') + '\'' : '') + (unselectable ? '' : ' data-handler=\'selectDay\' data-event=\'click\' data-month=\'' + printDate.getMonth() + '\' data-year=\'' + printDate.getFullYear() + '\'') + '>' + (otherMonth && !showOtherMonths ? '&#xa0;' : unselectable ? '<span class=\'ui-state-default\'>' + printDate.getDate() + '</span>' : '<a class=\'ui-state-default' + (printDate.getTime() === today.getTime() ? ' ui-state-highlight' : '') + (printDate.getTime() === currentDate.getTime() ? ' ui-state-active' : '') + (otherMonth ? ' ui-priority-secondary' : '') + '\' href=\'#\'>' + printDate.getDate() + '</a>') + '</td>';
                            printDate.setDate(printDate.getDate() + 1);
                            printDate = this._daylightSavingAdjust(printDate);
                        }
                        calender += tbody + '</tr>';
                    }
                    drawMonth++;
                    if (drawMonth > 11) {
                        drawMonth = 0;
                        drawYear++;
                    }
                    calender += '</tbody></table>' + (isMultiMonth ? '</div>' + (numMonths[0] > 0 && col === numMonths[1] - 1 ? '<div class=\'ui-datepicker-row-break\'></div>' : '') : '');
                    group += calender;
                }
                html += group;
            }
            html += buttonPanel;
            inst._keyEvent = false;
            return html;
        },
        _generateMonthYearHeader: function (inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
            var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, 'changeMonth'), changeYear = this._get(inst, 'changeYear'), showMonthAfterYear = this._get(inst, 'showMonthAfterYear'), html = '<div class=\'ui-datepicker-title\'>', monthHtml = '';
            if (secondary || !changeMonth) {
                monthHtml += '<span class=\'ui-datepicker-month\'>' + monthNames[drawMonth] + '</span>';
            } else {
                inMinYear = minDate && minDate.getFullYear() === drawYear;
                inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
                monthHtml += '<select class=\'ui-datepicker-month\' data-handler=\'selectMonth\' data-event=\'change\'>';
                for (month = 0; month < 12; month++) {
                    if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
                        monthHtml += '<option value=\'' + month + '\'' + (month === drawMonth ? ' selected=\'selected\'' : '') + '>' + monthNamesShort[month] + '</option>';
                    }
                }
                monthHtml += '</select>';
            }
            if (!showMonthAfterYear) {
                html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
            }
            if (!inst.yearshtml) {
                inst.yearshtml = '';
                if (secondary || !changeYear) {
                    html += '<span class=\'ui-datepicker-year\'>' + drawYear + '</span>';
                } else {
                    years = this._get(inst, 'yearRange').split(':');
                    thisYear = new Date().getFullYear();
                    determineYear = function (value) {
                        var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
                        return isNaN(year) ? thisYear : year;
                    };
                    year = determineYear(years[0]);
                    endYear = Math.max(year, determineYear(years[1] || ''));
                    year = minDate ? Math.max(year, minDate.getFullYear()) : year;
                    endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
                    inst.yearshtml += '<select class=\'ui-datepicker-year\' data-handler=\'selectYear\' data-event=\'change\'>';
                    for (; year <= endYear; year++) {
                        inst.yearshtml += '<option value=\'' + year + '\'' + (year === drawYear ? ' selected=\'selected\'' : '') + '>' + year + '</option>';
                    }
                    inst.yearshtml += '</select>';
                    html += inst.yearshtml;
                    inst.yearshtml = null;
                }
            }
            html += this._get(inst, 'yearSuffix');
            if (showMonthAfterYear) {
                html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
            }
            html += '</div>';
            return html;
        },
        _adjustInstDate: function (inst, offset, period) {
            var year = inst.drawYear + (period === 'Y' ? offset : 0), month = inst.drawMonth + (period === 'M' ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === 'D' ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
            inst.selectedDay = date.getDate();
            inst.drawMonth = inst.selectedMonth = date.getMonth();
            inst.drawYear = inst.selectedYear = date.getFullYear();
            if (period === 'M' || period === 'Y') {
                this._notifyChange(inst);
            }
        },
        _restrictMinMax: function (inst, date) {
            var minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), newDate = minDate && date < minDate ? minDate : date;
            return maxDate && newDate > maxDate ? maxDate : newDate;
        },
        _notifyChange: function (inst) {
            var onChange = this._get(inst, 'onChangeMonthYear');
            if (onChange) {
                onChange.apply(inst.input ? inst.input[0] : null, [
                    inst.selectedYear,
                    inst.selectedMonth + 1,
                    inst
                ]);
            }
        },
        _getNumberOfMonths: function (inst) {
            var numMonths = this._get(inst, 'numberOfMonths');
            return numMonths == null ? [
                1,
                1
            ] : typeof numMonths === 'number' ? [
                1,
                numMonths
            ] : numMonths;
        },
        _getMinMaxDate: function (inst, minMax) {
            return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
        },
        _getDaysInMonth: function (year, month) {
            return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
        },
        _getFirstDayOfMonth: function (year, month) {
            return new Date(year, month, 1).getDay();
        },
        _canAdjustMonth: function (inst, offset, curYear, curMonth) {
            var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
            if (offset < 0) {
                date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
            }
            return this._isInRange(inst, date);
        },
        _isInRange: function (inst, date) {
            var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), minYear = null, maxYear = null, years = this._get(inst, 'yearRange');
            if (years) {
                yearSplit = years.split(':');
                currentYear = new Date().getFullYear();
                minYear = parseInt(yearSplit[0], 10);
                maxYear = parseInt(yearSplit[1], 10);
                if (yearSplit[0].match(/[+\-].*/)) {
                    minYear += currentYear;
                }
                if (yearSplit[1].match(/[+\-].*/)) {
                    maxYear += currentYear;
                }
            }
            return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
        },
        _getFormatConfig: function (inst) {
            var shortYearCutoff = this._get(inst, 'shortYearCutoff');
            shortYearCutoff = typeof shortYearCutoff !== 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
            return {
                shortYearCutoff: shortYearCutoff,
                dayNamesShort: this._get(inst, 'dayNamesShort'),
                dayNames: this._get(inst, 'dayNames'),
                monthNamesShort: this._get(inst, 'monthNamesShort'),
                monthNames: this._get(inst, 'monthNames')
            };
        },
        _formatDate: function (inst, day, month, year) {
            if (!day) {
                inst.currentDay = inst.selectedDay;
                inst.currentMonth = inst.selectedMonth;
                inst.currentYear = inst.selectedYear;
            }
            var date = day ? typeof day === 'object' ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
            return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
        }
    });
    function datepicker_bindHover(dpDiv) {
        var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
        return dpDiv.delegate(selector, 'mouseout', function () {
            $(this).removeClass('ui-state-hover');
            if (this.className.indexOf('ui-datepicker-prev') !== -1) {
                $(this).removeClass('ui-datepicker-prev-hover');
            }
            if (this.className.indexOf('ui-datepicker-next') !== -1) {
                $(this).removeClass('ui-datepicker-next-hover');
            }
        }).delegate(selector, 'mouseover', datepicker_handleMouseover);
    }
    function datepicker_handleMouseover() {
        if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
            $(this).parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
            $(this).addClass('ui-state-hover');
            if (this.className.indexOf('ui-datepicker-prev') !== -1) {
                $(this).addClass('ui-datepicker-prev-hover');
            }
            if (this.className.indexOf('ui-datepicker-next') !== -1) {
                $(this).addClass('ui-datepicker-next-hover');
            }
        }
    }
    function datepicker_extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props) {
            if (props[name] == null) {
                target[name] = props[name];
            }
        }
        return target;
    }
    $.fn.datepicker = function (options) {
        if (!this.length) {
            return this;
        }
        if (!$.datepicker.initialized) {
            $(document).mousedown($.datepicker._checkExternalClick);
            $.datepicker.initialized = true;
        }
        if ($('#' + $.datepicker._mainDivId).length === 0) {
            $('body').append($.datepicker.dpDiv);
        }
        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options === 'string' && (options === 'isDisabled' || options === 'getDate' || options === 'widget')) {
            return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
        }
        if (options === 'option' && arguments.length === 2 && typeof arguments[1] === 'string') {
            return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
        }
        return this.each(function () {
            typeof options === 'string' ? $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
        });
    };
    $.datepicker = new Datepicker();
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = '1.11.4';
    return $.datepicker;
}));
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('jquery-ui/datepicker/zh-CN', ['lib/jquery-ui/ui/datepicker'], factory);
    } else {
        factory(jQuery.datepicker);
    }
}(function (datepicker) {
    datepicker.regional['zh-CN'] = {
        closeText: '关闭',
        prevText: '&#x3C;上月',
        nextText: '下月&#x3E;',
        currentText: '今天',
        monthNames: [
            '一月',
            '二月',
            '三月',
            '四月',
            '五月',
            '六月',
            '七月',
            '八月',
            '九月',
            '十月',
            '十一月',
            '十二月'
        ],
        monthNamesShort: [
            '一月',
            '二月',
            '三月',
            '四月',
            '五月',
            '六月',
            '七月',
            '八月',
            '九月',
            '十月',
            '十一月',
            '十二月'
        ],
        dayNames: [
            '星期日',
            '星期一',
            '星期二',
            '星期三',
            '星期四',
            '星期五',
            '星期六'
        ],
        dayNamesShort: [
            '周日',
            '周一',
            '周二',
            '周三',
            '周四',
            '周五',
            '周六'
        ],
        dayNamesMin: [
            '日',
            '一',
            '二',
            '三',
            '四',
            '五',
            '六'
        ],
        weekHeader: '周',
        dateFormat: 'yy-mm-dd',
        firstDay: 1,
        isRTL: false,
        showMonthAfterYear: true,
        yearSuffix: '年'
    };
    datepicker.setDefaults(datepicker.regional['zh-CN']);
    return datepicker.regional['zh-CN'];
}));
(function () {
    (function webpackUniversalModuleDefinition(root, factory) {
        if (typeof exports === 'object' && typeof module === 'object')
            module.exports = factory(require('jquery'), require('angular'), require('jquery-ui/datepicker'));
        else if (typeof define === 'function' && define.amd)
            define('ngDate', [
                'jquery',
                'angular',
                'jquery-ui/datepicker',
                'angular',
                'jquery-ui/datepicker/zh-CN'
            ], factory);
        else if (typeof exports === 'object')
            exports['angularUiDate'] = factory(require('jquery'), require('angular'), require('jquery-ui/datepicker'));
        else
            root['angularUiDate'] = factory(root['jQuery'], root['angular'], root['jquery-ui/datepicker']);
    }(this, function (__WEBPACK_EXTERNAL_MODULE_1__, __WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {
        return function (modules) {
            var installedModules = {};
            function __webpack_require__(moduleId) {
                if (installedModules[moduleId])
                    return installedModules[moduleId].exports;
                var module = installedModules[moduleId] = {
                    exports: {},
                    id: moduleId,
                    loaded: false
                };
                modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
                module.loaded = true;
                return module.exports;
            }
            __webpack_require__.m = modules;
            __webpack_require__.c = installedModules;
            __webpack_require__.p = 'assets';
            return __webpack_require__(0);
        }([
            function (module, exports, __webpack_require__) {
                'use strict';
                Object.defineProperty(exports, '__esModule', { value: true });
                var _jquery = __webpack_require__(1);
                var _jquery2 = _interopRequireDefault(_jquery);
                var _angular = __webpack_require__(2);
                var _angular2 = _interopRequireDefault(_angular);
                var _datepicker = __webpack_require__(3);
                var _datepicker2 = _interopRequireDefault(_datepicker);
                function _interopRequireDefault(obj) {
                    return obj && obj.__esModule ? obj : { default: obj };
                }
                exports.default = _angular2.default.module('ui.date', []).constant('uiDateConfig', {}).constant('uiDateFormatConfig', '').factory('uiDateConverter', [
                    'uiDateFormatConfig',
                    function (uiDateFormatConfig) {
                        return {
                            stringToDate: stringToDate,
                            dateToString: dateToString
                        };
                        function dateToString(uiDateFormat, value) {
                            var dateFormat = uiDateFormat || uiDateFormatConfig;
                            if (value) {
                                if (dateFormat) {
                                    try {
                                        return _jquery2.default.datepicker.formatDate(dateFormat, value);
                                    } catch (formatException) {
                                        return undefined;
                                    }
                                }
                                if (value.toISOString) {
                                    return value.toISOString();
                                }
                            }
                            return null;
                        }
                        function stringToDate(dateFormat, valueToParse) {
                            dateFormat = dateFormat || uiDateFormatConfig;
                            if (_angular2.default.isDate(valueToParse) && !isNaN(valueToParse)) {
                                return valueToParse;
                            }
                            if (_angular2.default.isString(valueToParse)) {
                                if (dateFormat) {
                                    return _jquery2.default.datepicker.parseDate(dateFormat, valueToParse);
                                }
                                var isoDate = new Date(valueToParse);
                                return isNaN(isoDate.getTime()) ? null : isoDate;
                            }
                            if (_angular2.default.isNumber(valueToParse)) {
                                return new Date(valueToParse);
                            }
                            return null;
                        }
                    }
                ]).directive('uiDate', [
                    'uiDateConfig',
                    'uiDateConverter',
                    function uiDateDirective(uiDateConfig, uiDateConverter) {
                        return {
                            require: '?ngModel',
                            link: function link(scope, element, attrs, controller) {
                                var $element = (0, _jquery2.default)(element);
                                var getOptions = function getOptions() {
                                    return _angular2.default.extend({}, uiDateConfig, scope.$eval(attrs.uiDate));
                                };
                                var initDateWidget = function initDateWidget() {
                                    var showing = false;
                                    var opts = getOptions();
                                    function setVal(forcedUpdate) {
                                        var keys = [
                                            'Hours',
                                            'Minutes',
                                            'Seconds',
                                            'Milliseconds'
                                        ];
                                        var isDate = _angular2.default.isDate(controller.$modelValue);
                                        var preserve = {};
                                        if (!forcedUpdate && isDate && controller.$modelValue.toDateString() === $element.datepicker('getDate').toDateString()) {
                                            return;
                                        }
                                        if (isDate) {
                                            _angular2.default.forEach(keys, function (key) {
                                                preserve[key] = controller.$modelValue['get' + key]();
                                            });
                                        }
                                        var newViewValue = $element.datepicker('getDate');
                                        if (isDate) {
                                            _angular2.default.forEach(keys, function (key) {
                                                newViewValue['set' + key](preserve[key]);
                                            });
                                        }
                                        controller.$setViewValue(newViewValue);
                                    }
                                    if (controller) {
                                        var _onSelect = opts.onSelect || _angular2.default.noop;
                                        opts.onSelect = function (value, picker) {
                                            scope.$apply(function () {
                                                showing = true;
                                                setVal();
                                                $element.blur();
                                                _onSelect(value, picker, $element);
                                            });
                                        };
                                        var _beforeShow = opts.beforeShow || _angular2.default.noop;
                                        opts.beforeShow = function (input, picker) {
                                            showing = true;
                                            _beforeShow(input, picker, $element);
                                        };
                                        var _onClose = opts.onClose || _angular2.default.noop;
                                        opts.onClose = function (value, picker) {
                                            showing = false;
                                            $element.focus();
                                            _onClose(value, picker, $element);
                                        };
                                        element.on('focus', function (focusEvent) {
                                            if (attrs.readonly) {
                                                focusEvent.stopImmediatePropagation();
                                            }
                                        });
                                        $element.off('blur.datepicker').on('blur.datepicker', function () {
                                            if (!showing) {
                                                scope.$apply(function () {
                                                    $element.datepicker('setDate', $element.datepicker('getDate'));
                                                    setVal();
                                                });
                                            }
                                        });
                                        controller.$validators.uiDateValidator = function uiDateValidator(modelValue, viewValue) {
                                            return viewValue === null || viewValue === '' || _angular2.default.isDate(uiDateConverter.stringToDate(attrs.uiDateFormat, viewValue));
                                        };
                                        controller.$parsers.push(function uiDateParser(valueToParse) {
                                            return uiDateConverter.stringToDate(attrs.uiDateFormat, valueToParse);
                                        });
                                        controller.$render = function () {
                                            if (_angular2.default.isDate(controller.$modelValue) === false && _angular2.default.isString(controller.$modelValue)) {
                                                controller.$modelValue = uiDateConverter.stringToDate(attrs.uiDateFormat, controller.$modelValue);
                                            }
                                            $element.datepicker('setDate', controller.$modelValue);
                                        };
                                    }
                                    if ($element.data('datepicker')) {
                                        $element.datepicker('option', opts);
                                        $element.datepicker('refresh');
                                    } else {
                                        $element.datepicker(opts);
                                        $element.on('$destroy', function () {
                                            $element.datepicker('hide');
                                            $element.datepicker('destroy');
                                        });
                                    }
                                    if (controller) {
                                        controller.$render();
                                        setVal(true);
                                    }
                                };
                                scope.$watch(getOptions, initDateWidget, true);
                            }
                        };
                    }
                ]).directive('uiDateFormat', [
                    'uiDateConverter',
                    function (uiDateConverter) {
                        return {
                            require: 'ngModel',
                            link: function link(scope, element, attrs, modelCtrl) {
                                var dateFormat = attrs.uiDateFormat;
                                modelCtrl.$formatters.unshift(function (value) {
                                    return uiDateConverter.stringToDate(dateFormat, value);
                                });
                                modelCtrl.$parsers.push(function (value) {
                                    return uiDateConverter.dateToString(dateFormat, value);
                                });
                            }
                        };
                    }
                ]);
            },
            function (module, exports) {
                module.exports = __WEBPACK_EXTERNAL_MODULE_1__;
            },
            function (module, exports) {
                module.exports = __WEBPACK_EXTERNAL_MODULE_2__;
            },
            function (module, exports) {
                module.exports = __WEBPACK_EXTERNAL_MODULE_3__;
            }
        ]);
    }));
    ;
}.call(this));
define('ui-bootstrap-tpls', ['angular'], function () {
    angular.module('ui.bootstrap', [
        'ui.bootstrap.tpls',
        'ui.bootstrap.collapse',
        'ui.bootstrap.accordion',
        'ui.bootstrap.alert',
        'ui.bootstrap.buttons',
        'ui.bootstrap.carousel',
        'ui.bootstrap.dateparser',
        'ui.bootstrap.isClass',
        'ui.bootstrap.datepicker',
        'ui.bootstrap.position',
        'ui.bootstrap.datepickerPopup',
        'ui.bootstrap.debounce',
        'ui.bootstrap.dropdown',
        'ui.bootstrap.stackedMap',
        'ui.bootstrap.modal',
        'ui.bootstrap.paging',
        'ui.bootstrap.pager',
        'ui.bootstrap.pagination',
        'ui.bootstrap.tooltip',
        'ui.bootstrap.popover',
        'ui.bootstrap.progressbar',
        'ui.bootstrap.rating',
        'ui.bootstrap.tabs',
        'ui.bootstrap.timepicker',
        'ui.bootstrap.typeahead'
    ]);
    angular.module('ui.bootstrap.tpls', [
        'uib/template/accordion/accordion-group.html',
        'uib/template/accordion/accordion.html',
        'uib/template/alert/alert.html',
        'uib/template/carousel/carousel.html',
        'uib/template/carousel/slide.html',
        'uib/template/datepicker/datepicker.html',
        'uib/template/datepicker/day.html',
        'uib/template/datepicker/month.html',
        'uib/template/datepicker/year.html',
        'uib/template/datepickerPopup/popup.html',
        'uib/template/modal/backdrop.html',
        'uib/template/modal/window.html',
        'uib/template/pager/pager.html',
        'uib/template/pagination/pagination.html',
        'uib/template/tooltip/tooltip-html-popup.html',
        'uib/template/tooltip/tooltip-popup.html',
        'uib/template/tooltip/tooltip-template-popup.html',
        'uib/template/popover/popover-html.html',
        'uib/template/popover/popover-template.html',
        'uib/template/popover/popover.html',
        'uib/template/progressbar/bar.html',
        'uib/template/progressbar/progress.html',
        'uib/template/progressbar/progressbar.html',
        'uib/template/rating/rating.html',
        'uib/template/tabs/tab.html',
        'uib/template/tabs/tabset.html',
        'uib/template/timepicker/timepicker.html',
        'uib/template/typeahead/typeahead-match.html',
        'uib/template/typeahead/typeahead-popup.html'
    ]);
    angular.module('ui.bootstrap.collapse', []).directive('uibCollapse', [
        '$animate',
        '$q',
        '$parse',
        '$injector',
        function ($animate, $q, $parse, $injector) {
            var $animateCss = $injector.has('$animateCss') ? $injector.get('$animateCss') : null;
            return {
                link: function (scope, element, attrs) {
                    var expandingExpr = $parse(attrs.expanding), expandedExpr = $parse(attrs.expanded), collapsingExpr = $parse(attrs.collapsing), collapsedExpr = $parse(attrs.collapsed);
                    if (!scope.$eval(attrs.uibCollapse)) {
                        element.addClass('in').addClass('collapse').attr('aria-expanded', true).attr('aria-hidden', false).css({ height: 'auto' });
                    }
                    function expand() {
                        if (element.hasClass('collapse') && element.hasClass('in')) {
                            return;
                        }
                        $q.resolve(expandingExpr(scope)).then(function () {
                            element.removeClass('collapse').addClass('collapsing').attr('aria-expanded', true).attr('aria-hidden', false);
                            if ($animateCss) {
                                $animateCss(element, {
                                    addClass: 'in',
                                    easing: 'ease',
                                    to: { height: element[0].scrollHeight + 'px' }
                                }).start()['finally'](expandDone);
                            } else {
                                $animate.addClass(element, 'in', { to: { height: element[0].scrollHeight + 'px' } }).then(expandDone);
                            }
                        });
                    }
                    function expandDone() {
                        element.removeClass('collapsing').addClass('collapse').css({ height: 'auto' });
                        expandedExpr(scope);
                    }
                    function collapse() {
                        if (!element.hasClass('collapse') && !element.hasClass('in')) {
                            return collapseDone();
                        }
                        $q.resolve(collapsingExpr(scope)).then(function () {
                            element.css({ height: element[0].scrollHeight + 'px' }).removeClass('collapse').addClass('collapsing').attr('aria-expanded', false).attr('aria-hidden', true);
                            if ($animateCss) {
                                $animateCss(element, {
                                    removeClass: 'in',
                                    to: { height: '0' }
                                }).start()['finally'](collapseDone);
                            } else {
                                $animate.removeClass(element, 'in', { to: { height: '0' } }).then(collapseDone);
                            }
                        });
                    }
                    function collapseDone() {
                        element.css({ height: '0' });
                        element.removeClass('collapsing').addClass('collapse');
                        collapsedExpr(scope);
                    }
                    scope.$watch(attrs.uibCollapse, function (shouldCollapse) {
                        if (shouldCollapse) {
                            collapse();
                        } else {
                            expand();
                        }
                    });
                }
            };
        }
    ]);
    angular.module('ui.bootstrap.accordion', ['ui.bootstrap.collapse']).constant('uibAccordionConfig', { closeOthers: true }).controller('UibAccordionController', [
        '$scope',
        '$attrs',
        'uibAccordionConfig',
        function ($scope, $attrs, accordionConfig) {
            this.groups = [];
            this.closeOthers = function (openGroup) {
                var closeOthers = angular.isDefined($attrs.closeOthers) ? $scope.$eval($attrs.closeOthers) : accordionConfig.closeOthers;
                if (closeOthers) {
                    angular.forEach(this.groups, function (group) {
                        if (group !== openGroup) {
                            group.isOpen = false;
                        }
                    });
                }
            };
            this.addGroup = function (groupScope) {
                var that = this;
                this.groups.push(groupScope);
                groupScope.$on('$destroy', function (event) {
                    that.removeGroup(groupScope);
                });
            };
            this.removeGroup = function (group) {
                var index = this.groups.indexOf(group);
                if (index !== -1) {
                    this.groups.splice(index, 1);
                }
            };
        }
    ]).directive('uibAccordion', function () {
        return {
            controller: 'UibAccordionController',
            controllerAs: 'accordion',
            transclude: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/accordion/accordion.html';
            }
        };
    }).directive('uibAccordionGroup', function () {
        return {
            require: '^uibAccordion',
            transclude: true,
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/accordion/accordion-group.html';
            },
            scope: {
                heading: '@',
                panelClass: '@?',
                isOpen: '=?',
                isDisabled: '=?'
            },
            controller: function () {
                this.setHeading = function (element) {
                    this.heading = element;
                };
            },
            link: function (scope, element, attrs, accordionCtrl) {
                accordionCtrl.addGroup(scope);
                scope.openClass = attrs.openClass || 'panel-open';
                scope.panelClass = attrs.panelClass || 'panel-default';
                scope.$watch('isOpen', function (value) {
                    element.toggleClass(scope.openClass, !!value);
                    if (value) {
                        accordionCtrl.closeOthers(scope);
                    }
                });
                scope.toggleOpen = function ($event) {
                    if (!scope.isDisabled) {
                        if (!$event || $event.which === 32) {
                            scope.isOpen = !scope.isOpen;
                        }
                    }
                };
                var id = 'accordiongroup-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
                scope.headingId = id + '-tab';
                scope.panelId = id + '-panel';
            }
        };
    }).directive('uibAccordionHeading', function () {
        return {
            transclude: true,
            template: '',
            replace: true,
            require: '^uibAccordionGroup',
            link: function (scope, element, attrs, accordionGroupCtrl, transclude) {
                accordionGroupCtrl.setHeading(transclude(scope, angular.noop));
            }
        };
    }).directive('uibAccordionTransclude', function () {
        return {
            require: '^uibAccordionGroup',
            link: function (scope, element, attrs, controller) {
                scope.$watch(function () {
                    return controller[attrs.uibAccordionTransclude];
                }, function (heading) {
                    if (heading) {
                        var elem = angular.element(element[0].querySelector(getHeaderSelectors()));
                        elem.html('');
                        elem.append(heading);
                    }
                });
            }
        };
        function getHeaderSelectors() {
            return 'uib-accordion-header,' + 'data-uib-accordion-header,' + 'x-uib-accordion-header,' + 'uib\\:accordion-header,' + '[uib-accordion-header],' + '[data-uib-accordion-header],' + '[x-uib-accordion-header]';
        }
    });
    angular.module('ui.bootstrap.alert', []).controller('UibAlertController', [
        '$scope',
        '$attrs',
        '$interpolate',
        '$timeout',
        function ($scope, $attrs, $interpolate, $timeout) {
            $scope.closeable = !!$attrs.close;
            var dismissOnTimeout = angular.isDefined($attrs.dismissOnTimeout) ? $interpolate($attrs.dismissOnTimeout)($scope.$parent) : null;
            if (dismissOnTimeout) {
                $timeout(function () {
                    $scope.close();
                }, parseInt(dismissOnTimeout, 10));
            }
        }
    ]).directive('uibAlert', function () {
        return {
            controller: 'UibAlertController',
            controllerAs: 'alert',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/alert/alert.html';
            },
            transclude: true,
            replace: true,
            scope: {
                type: '@',
                close: '&'
            }
        };
    });
    angular.module('ui.bootstrap.buttons', []).constant('uibButtonConfig', {
        activeClass: 'active',
        toggleEvent: 'click'
    }).controller('UibButtonsController', [
        'uibButtonConfig',
        function (buttonConfig) {
            this.activeClass = buttonConfig.activeClass || 'active';
            this.toggleEvent = buttonConfig.toggleEvent || 'click';
        }
    ]).directive('uibBtnRadio', [
        '$parse',
        function ($parse) {
            return {
                require: [
                    'uibBtnRadio',
                    'ngModel'
                ],
                controller: 'UibButtonsController',
                controllerAs: 'buttons',
                link: function (scope, element, attrs, ctrls) {
                    var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                    var uncheckableExpr = $parse(attrs.uibUncheckable);
                    element.find('input').css({ display: 'none' });
                    ngModelCtrl.$render = function () {
                        element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, scope.$eval(attrs.uibBtnRadio)));
                    };
                    element.on(buttonsCtrl.toggleEvent, function () {
                        if (attrs.disabled) {
                            return;
                        }
                        var isActive = element.hasClass(buttonsCtrl.activeClass);
                        if (!isActive || angular.isDefined(attrs.uncheckable)) {
                            scope.$apply(function () {
                                ngModelCtrl.$setViewValue(isActive ? null : scope.$eval(attrs.uibBtnRadio));
                                ngModelCtrl.$render();
                            });
                        }
                    });
                    if (attrs.uibUncheckable) {
                        scope.$watch(uncheckableExpr, function (uncheckable) {
                            attrs.$set('uncheckable', uncheckable ? '' : undefined);
                        });
                    }
                }
            };
        }
    ]).directive('uibBtnCheckbox', function () {
        return {
            require: [
                'uibBtnCheckbox',
                'ngModel'
            ],
            controller: 'UibButtonsController',
            controllerAs: 'button',
            link: function (scope, element, attrs, ctrls) {
                var buttonsCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                element.find('input').css({ display: 'none' });
                function getTrueValue() {
                    return getCheckboxValue(attrs.btnCheckboxTrue, true);
                }
                function getFalseValue() {
                    return getCheckboxValue(attrs.btnCheckboxFalse, false);
                }
                function getCheckboxValue(attribute, defaultValue) {
                    return angular.isDefined(attribute) ? scope.$eval(attribute) : defaultValue;
                }
                ngModelCtrl.$render = function () {
                    element.toggleClass(buttonsCtrl.activeClass, angular.equals(ngModelCtrl.$modelValue, getTrueValue()));
                };
                element.on(buttonsCtrl.toggleEvent, function () {
                    if (attrs.disabled) {
                        return;
                    }
                    scope.$apply(function () {
                        ngModelCtrl.$setViewValue(element.hasClass(buttonsCtrl.activeClass) ? getFalseValue() : getTrueValue());
                        ngModelCtrl.$render();
                    });
                });
            }
        };
    });
    angular.module('ui.bootstrap.carousel', []).controller('UibCarouselController', [
        '$scope',
        '$element',
        '$interval',
        '$timeout',
        '$animate',
        function ($scope, $element, $interval, $timeout, $animate) {
            var self = this, slides = self.slides = $scope.slides = [], SLIDE_DIRECTION = 'uib-slideDirection', currentIndex = $scope.active, currentInterval, isPlaying, bufferedTransitions = [];
            var destroyed = false;
            self.addSlide = function (slide, element) {
                slides.push({
                    slide: slide,
                    element: element
                });
                slides.sort(function (a, b) {
                    return +a.slide.index - +b.slide.index;
                });
                if (slide.index === $scope.active || slides.length === 1 && !angular.isNumber($scope.active)) {
                    if ($scope.$currentTransition) {
                        $scope.$currentTransition = null;
                    }
                    currentIndex = slide.index;
                    $scope.active = slide.index;
                    setActive(currentIndex);
                    self.select(slides[findSlideIndex(slide)]);
                    if (slides.length === 1) {
                        $scope.play();
                    }
                }
            };
            self.getCurrentIndex = function () {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i].slide.index === currentIndex) {
                        return i;
                    }
                }
            };
            self.next = $scope.next = function () {
                var newIndex = (self.getCurrentIndex() + 1) % slides.length;
                if (newIndex === 0 && $scope.noWrap()) {
                    $scope.pause();
                    return;
                }
                return self.select(slides[newIndex], 'next');
            };
            self.prev = $scope.prev = function () {
                var newIndex = self.getCurrentIndex() - 1 < 0 ? slides.length - 1 : self.getCurrentIndex() - 1;
                if ($scope.noWrap() && newIndex === slides.length - 1) {
                    $scope.pause();
                    return;
                }
                return self.select(slides[newIndex], 'prev');
            };
            self.removeSlide = function (slide) {
                var index = findSlideIndex(slide);
                var bufferedIndex = bufferedTransitions.indexOf(slides[index]);
                if (bufferedIndex !== -1) {
                    bufferedTransitions.splice(bufferedIndex, 1);
                }
                slides.splice(index, 1);
                if (slides.length > 0 && currentIndex === index) {
                    if (index >= slides.length) {
                        currentIndex = slides.length - 1;
                        $scope.active = currentIndex;
                        setActive(currentIndex);
                        self.select(slides[slides.length - 1]);
                    } else {
                        currentIndex = index;
                        $scope.active = currentIndex;
                        setActive(currentIndex);
                        self.select(slides[index]);
                    }
                } else if (currentIndex > index) {
                    currentIndex--;
                    $scope.active = currentIndex;
                }
                if (slides.length === 0) {
                    currentIndex = null;
                    $scope.active = null;
                    clearBufferedTransitions();
                }
            };
            self.select = $scope.select = function (nextSlide, direction) {
                var nextIndex = findSlideIndex(nextSlide.slide);
                if (direction === undefined) {
                    direction = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
                }
                if (nextSlide.slide.index !== currentIndex && !$scope.$currentTransition) {
                    goNext(nextSlide.slide, nextIndex, direction);
                } else if (nextSlide && nextSlide.slide.index !== currentIndex && $scope.$currentTransition) {
                    bufferedTransitions.push(slides[nextIndex]);
                }
            };
            $scope.indexOfSlide = function (slide) {
                return +slide.slide.index;
            };
            $scope.isActive = function (slide) {
                return $scope.active === slide.slide.index;
            };
            $scope.isPrevDisabled = function () {
                return $scope.active === 0 && $scope.noWrap();
            };
            $scope.isNextDisabled = function () {
                return $scope.active === slides.length - 1 && $scope.noWrap();
            };
            $scope.pause = function () {
                if (!$scope.noPause) {
                    isPlaying = false;
                    resetTimer();
                }
            };
            $scope.play = function () {
                if (!isPlaying) {
                    isPlaying = true;
                    restartTimer();
                }
            };
            $scope.$on('$destroy', function () {
                destroyed = true;
                resetTimer();
            });
            $scope.$watch('noTransition', function (noTransition) {
                $animate.enabled($element, !noTransition);
            });
            $scope.$watch('interval', restartTimer);
            $scope.$watchCollection('slides', resetTransition);
            $scope.$watch('active', function (index) {
                if (angular.isNumber(index) && currentIndex !== index) {
                    for (var i = 0; i < slides.length; i++) {
                        if (slides[i].slide.index === index) {
                            index = i;
                            break;
                        }
                    }
                    var slide = slides[index];
                    if (slide) {
                        setActive(index);
                        self.select(slides[index]);
                        currentIndex = index;
                    }
                }
            });
            function clearBufferedTransitions() {
                while (bufferedTransitions.length) {
                    bufferedTransitions.shift();
                }
            }
            function getSlideByIndex(index) {
                for (var i = 0, l = slides.length; i < l; ++i) {
                    if (slides[i].index === index) {
                        return slides[i];
                    }
                }
            }
            function setActive(index) {
                for (var i = 0; i < slides.length; i++) {
                    slides[i].slide.active = i === index;
                }
            }
            function goNext(slide, index, direction) {
                if (destroyed) {
                    return;
                }
                angular.extend(slide, { direction: direction });
                angular.extend(slides[currentIndex].slide || {}, { direction: direction });
                if ($animate.enabled($element) && !$scope.$currentTransition && slides[index].element && self.slides.length > 1) {
                    slides[index].element.data(SLIDE_DIRECTION, slide.direction);
                    var currentIdx = self.getCurrentIndex();
                    if (angular.isNumber(currentIdx) && slides[currentIdx].element) {
                        slides[currentIdx].element.data(SLIDE_DIRECTION, slide.direction);
                    }
                    $scope.$currentTransition = true;
                    $animate.on('addClass', slides[index].element, function (element, phase) {
                        if (phase === 'close') {
                            $scope.$currentTransition = null;
                            $animate.off('addClass', element);
                            if (bufferedTransitions.length) {
                                var nextSlide = bufferedTransitions.pop().slide;
                                var nextIndex = nextSlide.index;
                                var nextDirection = nextIndex > self.getCurrentIndex() ? 'next' : 'prev';
                                clearBufferedTransitions();
                                goNext(nextSlide, nextIndex, nextDirection);
                            }
                        }
                    });
                }
                $scope.active = slide.index;
                currentIndex = slide.index;
                setActive(index);
                restartTimer();
            }
            function findSlideIndex(slide) {
                for (var i = 0; i < slides.length; i++) {
                    if (slides[i].slide === slide) {
                        return i;
                    }
                }
            }
            function resetTimer() {
                if (currentInterval) {
                    $interval.cancel(currentInterval);
                    currentInterval = null;
                }
            }
            function resetTransition(slides) {
                if (!slides.length) {
                    $scope.$currentTransition = null;
                    clearBufferedTransitions();
                }
            }
            function restartTimer() {
                resetTimer();
                var interval = +$scope.interval;
                if (!isNaN(interval) && interval > 0) {
                    currentInterval = $interval(timerFn, interval);
                }
            }
            function timerFn() {
                var interval = +$scope.interval;
                if (isPlaying && !isNaN(interval) && interval > 0 && slides.length) {
                    $scope.next();
                } else {
                    $scope.pause();
                }
            }
        }
    ]).directive('uibCarousel', function () {
        return {
            transclude: true,
            replace: true,
            controller: 'UibCarouselController',
            controllerAs: 'carousel',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/carousel/carousel.html';
            },
            scope: {
                active: '=',
                interval: '=',
                noTransition: '=',
                noPause: '=',
                noWrap: '&'
            }
        };
    }).directive('uibSlide', function () {
        return {
            require: '^uibCarousel',
            transclude: true,
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/carousel/slide.html';
            },
            scope: {
                actual: '=?',
                index: '=?'
            },
            link: function (scope, element, attrs, carouselCtrl) {
                carouselCtrl.addSlide(scope, element);
                scope.$on('$destroy', function () {
                    carouselCtrl.removeSlide(scope);
                });
            }
        };
    }).animation('.item', [
        '$animateCss',
        function ($animateCss) {
            var SLIDE_DIRECTION = 'uib-slideDirection';
            function removeClass(element, className, callback) {
                element.removeClass(className);
                if (callback) {
                    callback();
                }
            }
            return {
                beforeAddClass: function (element, className, done) {
                    if (className === 'active') {
                        var stopped = false;
                        var direction = element.data(SLIDE_DIRECTION);
                        var directionClass = direction === 'next' ? 'left' : 'right';
                        var removeClassFn = removeClass.bind(this, element, directionClass + ' ' + direction, done);
                        element.addClass(direction);
                        $animateCss(element, { addClass: directionClass }).start().done(removeClassFn);
                        return function () {
                            stopped = true;
                        };
                    }
                    done();
                },
                beforeRemoveClass: function (element, className, done) {
                    if (className === 'active') {
                        var stopped = false;
                        var direction = element.data(SLIDE_DIRECTION);
                        var directionClass = direction === 'next' ? 'left' : 'right';
                        var removeClassFn = removeClass.bind(this, element, directionClass, done);
                        $animateCss(element, { addClass: directionClass }).start().done(removeClassFn);
                        return function () {
                            stopped = true;
                        };
                    }
                    done();
                }
            };
        }
    ]);
    angular.module('ui.bootstrap.dateparser', []).service('uibDateParser', [
        '$log',
        '$locale',
        'dateFilter',
        'orderByFilter',
        function ($log, $locale, dateFilter, orderByFilter) {
            var SPECIAL_CHARACTERS_REGEXP = /[\\\^\$\*\+\?\|\[\]\(\)\.\{\}]/g;
            var localeId;
            var formatCodeToRegex;
            this.init = function () {
                localeId = $locale.id;
                this.parsers = {};
                this.formatters = {};
                formatCodeToRegex = [
                    {
                        key: 'yyyy',
                        regex: '\\d{4}',
                        apply: function (value) {
                            this.year = +value;
                        },
                        formatter: function (date) {
                            var _date = new Date();
                            _date.setFullYear(Math.abs(date.getFullYear()));
                            return dateFilter(_date, 'yyyy');
                        }
                    },
                    {
                        key: 'yy',
                        regex: '\\d{2}',
                        apply: function (value) {
                            value = +value;
                            this.year = value < 69 ? value + 2000 : value + 1900;
                        },
                        formatter: function (date) {
                            var _date = new Date();
                            _date.setFullYear(Math.abs(date.getFullYear()));
                            return dateFilter(_date, 'yy');
                        }
                    },
                    {
                        key: 'y',
                        regex: '\\d{1,4}',
                        apply: function (value) {
                            this.year = +value;
                        },
                        formatter: function (date) {
                            var _date = new Date();
                            _date.setFullYear(Math.abs(date.getFullYear()));
                            return dateFilter(_date, 'y');
                        }
                    },
                    {
                        key: 'M!',
                        regex: '0?[1-9]|1[0-2]',
                        apply: function (value) {
                            this.month = value - 1;
                        },
                        formatter: function (date) {
                            var value = date.getMonth();
                            if (/^[0-9]$/.test(value)) {
                                return dateFilter(date, 'MM');
                            }
                            return dateFilter(date, 'M');
                        }
                    },
                    {
                        key: 'MMMM',
                        regex: $locale.DATETIME_FORMATS.MONTH.join('|'),
                        apply: function (value) {
                            this.month = $locale.DATETIME_FORMATS.MONTH.indexOf(value);
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'MMMM');
                        }
                    },
                    {
                        key: 'MMM',
                        regex: $locale.DATETIME_FORMATS.SHORTMONTH.join('|'),
                        apply: function (value) {
                            this.month = $locale.DATETIME_FORMATS.SHORTMONTH.indexOf(value);
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'MMM');
                        }
                    },
                    {
                        key: 'MM',
                        regex: '0[1-9]|1[0-2]',
                        apply: function (value) {
                            this.month = value - 1;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'MM');
                        }
                    },
                    {
                        key: 'M',
                        regex: '[1-9]|1[0-2]',
                        apply: function (value) {
                            this.month = value - 1;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'M');
                        }
                    },
                    {
                        key: 'd!',
                        regex: '[0-2]?[0-9]{1}|3[0-1]{1}',
                        apply: function (value) {
                            this.date = +value;
                        },
                        formatter: function (date) {
                            var value = date.getDate();
                            if (/^[1-9]$/.test(value)) {
                                return dateFilter(date, 'dd');
                            }
                            return dateFilter(date, 'd');
                        }
                    },
                    {
                        key: 'dd',
                        regex: '[0-2][0-9]{1}|3[0-1]{1}',
                        apply: function (value) {
                            this.date = +value;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'dd');
                        }
                    },
                    {
                        key: 'd',
                        regex: '[1-2]?[0-9]{1}|3[0-1]{1}',
                        apply: function (value) {
                            this.date = +value;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'd');
                        }
                    },
                    {
                        key: 'EEEE',
                        regex: $locale.DATETIME_FORMATS.DAY.join('|'),
                        formatter: function (date) {
                            return dateFilter(date, 'EEEE');
                        }
                    },
                    {
                        key: 'EEE',
                        regex: $locale.DATETIME_FORMATS.SHORTDAY.join('|'),
                        formatter: function (date) {
                            return dateFilter(date, 'EEE');
                        }
                    },
                    {
                        key: 'HH',
                        regex: '(?:0|1)[0-9]|2[0-3]',
                        apply: function (value) {
                            this.hours = +value;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'HH');
                        }
                    },
                    {
                        key: 'hh',
                        regex: '0[0-9]|1[0-2]',
                        apply: function (value) {
                            this.hours = +value;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'hh');
                        }
                    },
                    {
                        key: 'H',
                        regex: '1?[0-9]|2[0-3]',
                        apply: function (value) {
                            this.hours = +value;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'H');
                        }
                    },
                    {
                        key: 'h',
                        regex: '[0-9]|1[0-2]',
                        apply: function (value) {
                            this.hours = +value;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'h');
                        }
                    },
                    {
                        key: 'mm',
                        regex: '[0-5][0-9]',
                        apply: function (value) {
                            this.minutes = +value;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'mm');
                        }
                    },
                    {
                        key: 'm',
                        regex: '[0-9]|[1-5][0-9]',
                        apply: function (value) {
                            this.minutes = +value;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'm');
                        }
                    },
                    {
                        key: 'sss',
                        regex: '[0-9][0-9][0-9]',
                        apply: function (value) {
                            this.milliseconds = +value;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'sss');
                        }
                    },
                    {
                        key: 'ss',
                        regex: '[0-5][0-9]',
                        apply: function (value) {
                            this.seconds = +value;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'ss');
                        }
                    },
                    {
                        key: 's',
                        regex: '[0-9]|[1-5][0-9]',
                        apply: function (value) {
                            this.seconds = +value;
                        },
                        formatter: function (date) {
                            return dateFilter(date, 's');
                        }
                    },
                    {
                        key: 'a',
                        regex: $locale.DATETIME_FORMATS.AMPMS.join('|'),
                        apply: function (value) {
                            if (this.hours === 12) {
                                this.hours = 0;
                            }
                            if (value === 'PM') {
                                this.hours += 12;
                            }
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'a');
                        }
                    },
                    {
                        key: 'Z',
                        regex: '[+-]\\d{4}',
                        apply: function (value) {
                            var matches = value.match(/([+-])(\d{2})(\d{2})/), sign = matches[1], hours = matches[2], minutes = matches[3];
                            this.hours += toInt(sign + hours);
                            this.minutes += toInt(sign + minutes);
                        },
                        formatter: function (date) {
                            return dateFilter(date, 'Z');
                        }
                    },
                    {
                        key: 'ww',
                        regex: '[0-4][0-9]|5[0-3]',
                        formatter: function (date) {
                            return dateFilter(date, 'ww');
                        }
                    },
                    {
                        key: 'w',
                        regex: '[0-9]|[1-4][0-9]|5[0-3]',
                        formatter: function (date) {
                            return dateFilter(date, 'w');
                        }
                    },
                    {
                        key: 'GGGG',
                        regex: $locale.DATETIME_FORMATS.ERANAMES.join('|').replace(/\s/g, '\\s'),
                        formatter: function (date) {
                            return dateFilter(date, 'GGGG');
                        }
                    },
                    {
                        key: 'GGG',
                        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                        formatter: function (date) {
                            return dateFilter(date, 'GGG');
                        }
                    },
                    {
                        key: 'GG',
                        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                        formatter: function (date) {
                            return dateFilter(date, 'GG');
                        }
                    },
                    {
                        key: 'G',
                        regex: $locale.DATETIME_FORMATS.ERAS.join('|'),
                        formatter: function (date) {
                            return dateFilter(date, 'G');
                        }
                    }
                ];
            };
            this.init();
            function createParser(format, func) {
                var map = [], regex = format.split('');
                var quoteIndex = format.indexOf('\'');
                if (quoteIndex > -1) {
                    var inLiteral = false;
                    format = format.split('');
                    for (var i = quoteIndex; i < format.length; i++) {
                        if (inLiteral) {
                            if (format[i] === '\'') {
                                if (i + 1 < format.length && format[i + 1] === '\'') {
                                    format[i + 1] = '$';
                                    regex[i + 1] = '';
                                } else {
                                    regex[i] = '';
                                    inLiteral = false;
                                }
                            }
                            format[i] = '$';
                        } else {
                            if (format[i] === '\'') {
                                format[i] = '$';
                                regex[i] = '';
                                inLiteral = true;
                            }
                        }
                    }
                    format = format.join('');
                }
                angular.forEach(formatCodeToRegex, function (data) {
                    var index = format.indexOf(data.key);
                    if (index > -1) {
                        format = format.split('');
                        regex[index] = '(' + data.regex + ')';
                        format[index] = '$';
                        for (var i = index + 1, n = index + data.key.length; i < n; i++) {
                            regex[i] = '';
                            format[i] = '$';
                        }
                        format = format.join('');
                        map.push({
                            index: index,
                            key: data.key,
                            apply: data[func],
                            matcher: data.regex
                        });
                    }
                });
                return {
                    regex: new RegExp('^' + regex.join('') + '$'),
                    map: orderByFilter(map, 'index')
                };
            }
            this.filter = function (date, format) {
                if (!angular.isDate(date) || isNaN(date) || !format) {
                    return '';
                }
                format = $locale.DATETIME_FORMATS[format] || format;
                if ($locale.id !== localeId) {
                    this.init();
                }
                if (!this.formatters[format]) {
                    this.formatters[format] = createParser(format, 'formatter');
                }
                var parser = this.formatters[format], map = parser.map;
                var _format = format;
                return map.reduce(function (str, mapper, i) {
                    var match = _format.match(new RegExp('(.*)' + mapper.key));
                    if (match && angular.isString(match[1])) {
                        str += match[1];
                        _format = _format.replace(match[1] + mapper.key, '');
                    }
                    var endStr = i === map.length - 1 ? _format : '';
                    if (mapper.apply) {
                        return str + mapper.apply.call(null, date) + endStr;
                    }
                    return str + endStr;
                }, '');
            };
            this.parse = function (input, format, baseDate) {
                if (!angular.isString(input) || !format) {
                    return input;
                }
                format = $locale.DATETIME_FORMATS[format] || format;
                format = format.replace(SPECIAL_CHARACTERS_REGEXP, '\\$&');
                if ($locale.id !== localeId) {
                    this.init();
                }
                if (!this.parsers[format]) {
                    this.parsers[format] = createParser(format, 'apply');
                }
                var parser = this.parsers[format], regex = parser.regex, map = parser.map, results = input.match(regex), tzOffset = false;
                if (results && results.length) {
                    var fields, dt;
                    if (angular.isDate(baseDate) && !isNaN(baseDate.getTime())) {
                        fields = {
                            year: baseDate.getFullYear(),
                            month: baseDate.getMonth(),
                            date: baseDate.getDate(),
                            hours: baseDate.getHours(),
                            minutes: baseDate.getMinutes(),
                            seconds: baseDate.getSeconds(),
                            milliseconds: baseDate.getMilliseconds()
                        };
                    } else {
                        if (baseDate) {
                            $log.warn('dateparser:', 'baseDate is not a valid date');
                        }
                        fields = {
                            year: 1900,
                            month: 0,
                            date: 1,
                            hours: 0,
                            minutes: 0,
                            seconds: 0,
                            milliseconds: 0
                        };
                    }
                    for (var i = 1, n = results.length; i < n; i++) {
                        var mapper = map[i - 1];
                        if (mapper.matcher === 'Z') {
                            tzOffset = true;
                        }
                        if (mapper.apply) {
                            mapper.apply.call(fields, results[i]);
                        }
                    }
                    var datesetter = tzOffset ? Date.prototype.setUTCFullYear : Date.prototype.setFullYear;
                    var timesetter = tzOffset ? Date.prototype.setUTCHours : Date.prototype.setHours;
                    if (isValid(fields.year, fields.month, fields.date)) {
                        if (angular.isDate(baseDate) && !isNaN(baseDate.getTime()) && !tzOffset) {
                            dt = new Date(baseDate);
                            datesetter.call(dt, fields.year, fields.month, fields.date);
                            timesetter.call(dt, fields.hours, fields.minutes, fields.seconds, fields.milliseconds);
                        } else {
                            dt = new Date(0);
                            datesetter.call(dt, fields.year, fields.month, fields.date);
                            timesetter.call(dt, fields.hours || 0, fields.minutes || 0, fields.seconds || 0, fields.milliseconds || 0);
                        }
                    }
                    return dt;
                }
            };
            function isValid(year, month, date) {
                if (date < 1) {
                    return false;
                }
                if (month === 1 && date > 28) {
                    return date === 29 && (year % 4 === 0 && year % 100 !== 0 || year % 400 === 0);
                }
                if (month === 3 || month === 5 || month === 8 || month === 10) {
                    return date < 31;
                }
                return true;
            }
            function toInt(str) {
                return parseInt(str, 10);
            }
            this.toTimezone = toTimezone;
            this.fromTimezone = fromTimezone;
            this.timezoneToOffset = timezoneToOffset;
            this.addDateMinutes = addDateMinutes;
            this.convertTimezoneToLocal = convertTimezoneToLocal;
            function toTimezone(date, timezone) {
                return date && timezone ? convertTimezoneToLocal(date, timezone) : date;
            }
            function fromTimezone(date, timezone) {
                return date && timezone ? convertTimezoneToLocal(date, timezone, true) : date;
            }
            function timezoneToOffset(timezone, fallback) {
                timezone = timezone.replace(/:/g, '');
                var requestedTimezoneOffset = Date.parse('Jan 01, 1970 00:00:00 ' + timezone) / 60000;
                return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset;
            }
            function addDateMinutes(date, minutes) {
                date = new Date(date.getTime());
                date.setMinutes(date.getMinutes() + minutes);
                return date;
            }
            function convertTimezoneToLocal(date, timezone, reverse) {
                reverse = reverse ? -1 : 1;
                var dateTimezoneOffset = date.getTimezoneOffset();
                var timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
                return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset));
            }
        }
    ]);
    angular.module('ui.bootstrap.isClass', []).directive('uibIsClass', [
        '$animate',
        function ($animate) {
            var ON_REGEXP = /^\s*([\s\S]+?)\s+on\s+([\s\S]+?)\s*$/;
            var IS_REGEXP = /^\s*([\s\S]+?)\s+for\s+([\s\S]+?)\s*$/;
            var dataPerTracked = {};
            return {
                restrict: 'A',
                compile: function (tElement, tAttrs) {
                    var linkedScopes = [];
                    var instances = [];
                    var expToData = {};
                    var lastActivated = null;
                    var onExpMatches = tAttrs.uibIsClass.match(ON_REGEXP);
                    var onExp = onExpMatches[2];
                    var expsStr = onExpMatches[1];
                    var exps = expsStr.split(',');
                    return linkFn;
                    function linkFn(scope, element, attrs) {
                        linkedScopes.push(scope);
                        instances.push({
                            scope: scope,
                            element: element
                        });
                        exps.forEach(function (exp, k) {
                            addForExp(exp, scope);
                        });
                        scope.$on('$destroy', removeScope);
                    }
                    function addForExp(exp, scope) {
                        var matches = exp.match(IS_REGEXP);
                        var clazz = scope.$eval(matches[1]);
                        var compareWithExp = matches[2];
                        var data = expToData[exp];
                        if (!data) {
                            var watchFn = function (compareWithVal) {
                                var newActivated = null;
                                instances.some(function (instance) {
                                    var thisVal = instance.scope.$eval(onExp);
                                    if (thisVal === compareWithVal) {
                                        newActivated = instance;
                                        return true;
                                    }
                                });
                                if (data.lastActivated !== newActivated) {
                                    if (data.lastActivated) {
                                        $animate.removeClass(data.lastActivated.element, clazz);
                                    }
                                    if (newActivated) {
                                        $animate.addClass(newActivated.element, clazz);
                                    }
                                    data.lastActivated = newActivated;
                                }
                            };
                            expToData[exp] = data = {
                                lastActivated: null,
                                scope: scope,
                                watchFn: watchFn,
                                compareWithExp: compareWithExp,
                                watcher: scope.$watch(compareWithExp, watchFn)
                            };
                        }
                        data.watchFn(scope.$eval(compareWithExp));
                    }
                    function removeScope(e) {
                        var removedScope = e.targetScope;
                        var index = linkedScopes.indexOf(removedScope);
                        linkedScopes.splice(index, 1);
                        instances.splice(index, 1);
                        if (linkedScopes.length) {
                            var newWatchScope = linkedScopes[0];
                            angular.forEach(expToData, function (data) {
                                if (data.scope === removedScope) {
                                    data.watcher = newWatchScope.$watch(data.compareWithExp, data.watchFn);
                                    data.scope = newWatchScope;
                                }
                            });
                        } else {
                            expToData = {};
                        }
                    }
                }
            };
        }
    ]);
    angular.module('ui.bootstrap.datepicker', [
        'ui.bootstrap.dateparser',
        'ui.bootstrap.isClass'
    ]).value('$datepickerSuppressError', false).value('$datepickerLiteralWarning', true).constant('uibDatepickerConfig', {
        datepickerMode: 'day',
        formatDay: 'dd',
        formatMonth: 'MMMM',
        formatYear: 'yyyy',
        formatDayHeader: 'EEE',
        formatDayTitle: 'MMMM yyyy',
        formatMonthTitle: 'yyyy',
        maxDate: null,
        maxMode: 'year',
        minDate: null,
        minMode: 'day',
        ngModelOptions: {},
        shortcutPropagation: false,
        showWeeks: true,
        yearColumns: 5,
        yearRows: 4
    }).controller('UibDatepickerController', [
        '$scope',
        '$attrs',
        '$parse',
        '$interpolate',
        '$locale',
        '$log',
        'dateFilter',
        'uibDatepickerConfig',
        '$datepickerLiteralWarning',
        '$datepickerSuppressError',
        'uibDateParser',
        function ($scope, $attrs, $parse, $interpolate, $locale, $log, dateFilter, datepickerConfig, $datepickerLiteralWarning, $datepickerSuppressError, dateParser) {
            var self = this, ngModelCtrl = { $setViewValue: angular.noop }, ngModelOptions = {}, watchListeners = [], optionsUsed = !!$attrs.datepickerOptions;
            if (!$scope.datepickerOptions) {
                $scope.datepickerOptions = {};
            }
            this.modes = [
                'day',
                'month',
                'year'
            ];
            [
                'customClass',
                'dateDisabled',
                'datepickerMode',
                'formatDay',
                'formatDayHeader',
                'formatDayTitle',
                'formatMonth',
                'formatMonthTitle',
                'formatYear',
                'maxDate',
                'maxMode',
                'minDate',
                'minMode',
                'showWeeks',
                'shortcutPropagation',
                'startingDay',
                'yearColumns',
                'yearRows'
            ].forEach(function (key) {
                switch (key) {
                case 'customClass':
                case 'dateDisabled':
                    $scope[key] = $scope.datepickerOptions[key] || angular.noop;
                    break;
                case 'datepickerMode':
                    $scope.datepickerMode = angular.isDefined($scope.datepickerOptions.datepickerMode) ? $scope.datepickerOptions.datepickerMode : datepickerConfig.datepickerMode;
                    break;
                case 'formatDay':
                case 'formatDayHeader':
                case 'formatDayTitle':
                case 'formatMonth':
                case 'formatMonthTitle':
                case 'formatYear':
                    self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $interpolate($scope.datepickerOptions[key])($scope.$parent) : datepickerConfig[key];
                    break;
                case 'showWeeks':
                case 'shortcutPropagation':
                case 'yearColumns':
                case 'yearRows':
                    self[key] = angular.isDefined($scope.datepickerOptions[key]) ? $scope.datepickerOptions[key] : datepickerConfig[key];
                    break;
                case 'startingDay':
                    if (angular.isDefined($scope.datepickerOptions.startingDay)) {
                        self.startingDay = $scope.datepickerOptions.startingDay;
                    } else if (angular.isNumber(datepickerConfig.startingDay)) {
                        self.startingDay = datepickerConfig.startingDay;
                    } else {
                        self.startingDay = ($locale.DATETIME_FORMATS.FIRSTDAYOFWEEK + 8) % 7;
                    }
                    break;
                case 'maxDate':
                case 'minDate':
                    $scope.$watch('datepickerOptions.' + key, function (value) {
                        if (value) {
                            if (angular.isDate(value)) {
                                self[key] = dateParser.fromTimezone(new Date(value), ngModelOptions.timezone);
                            } else {
                                if ($datepickerLiteralWarning) {
                                    $log.warn('Literal date support has been deprecated, please switch to date object usage');
                                }
                                self[key] = new Date(dateFilter(value, 'medium'));
                            }
                        } else {
                            self[key] = datepickerConfig[key] ? dateParser.fromTimezone(new Date(datepickerConfig[key]), ngModelOptions.timezone) : null;
                        }
                        self.refreshView();
                    });
                    break;
                case 'maxMode':
                case 'minMode':
                    if ($scope.datepickerOptions[key]) {
                        $scope.$watch(function () {
                            return $scope.datepickerOptions[key];
                        }, function (value) {
                            self[key] = $scope[key] = angular.isDefined(value) ? value : datepickerOptions[key];
                            if (key === 'minMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) < self.modes.indexOf(self[key]) || key === 'maxMode' && self.modes.indexOf($scope.datepickerOptions.datepickerMode) > self.modes.indexOf(self[key])) {
                                $scope.datepickerMode = self[key];
                                $scope.datepickerOptions.datepickerMode = self[key];
                            }
                        });
                    } else {
                        self[key] = $scope[key] = datepickerConfig[key] || null;
                    }
                    break;
                }
            });
            $scope.uniqueId = 'datepicker-' + $scope.$id + '-' + Math.floor(Math.random() * 10000);
            $scope.disabled = angular.isDefined($attrs.disabled) || false;
            if (angular.isDefined($attrs.ngDisabled)) {
                watchListeners.push($scope.$parent.$watch($attrs.ngDisabled, function (disabled) {
                    $scope.disabled = disabled;
                    self.refreshView();
                }));
            }
            $scope.isActive = function (dateObject) {
                if (self.compare(dateObject.date, self.activeDate) === 0) {
                    $scope.activeDateId = dateObject.uid;
                    return true;
                }
                return false;
            };
            this.init = function (ngModelCtrl_) {
                ngModelCtrl = ngModelCtrl_;
                ngModelOptions = ngModelCtrl_.$options || datepickerConfig.ngModelOptions;
                if ($scope.datepickerOptions.initDate) {
                    self.activeDate = dateParser.fromTimezone($scope.datepickerOptions.initDate, ngModelOptions.timezone) || new Date();
                    $scope.$watch('datepickerOptions.initDate', function (initDate) {
                        if (initDate && (ngModelCtrl.$isEmpty(ngModelCtrl.$modelValue) || ngModelCtrl.$invalid)) {
                            self.activeDate = dateParser.fromTimezone(initDate, ngModelOptions.timezone);
                            self.refreshView();
                        }
                    });
                } else {
                    self.activeDate = new Date();
                }
                var date = ngModelCtrl.$modelValue ? new Date(ngModelCtrl.$modelValue) : new Date();
                this.activeDate = !isNaN(date) ? dateParser.fromTimezone(date, ngModelOptions.timezone) : dateParser.fromTimezone(new Date(), ngModelOptions.timezone);
                ngModelCtrl.$render = function () {
                    self.render();
                };
            };
            this.render = function () {
                if (ngModelCtrl.$viewValue) {
                    var date = new Date(ngModelCtrl.$viewValue), isValid = !isNaN(date);
                    if (isValid) {
                        this.activeDate = dateParser.fromTimezone(date, ngModelOptions.timezone);
                    } else if (!$datepickerSuppressError) {
                        $log.error('Datepicker directive: "ng-model" value must be a Date object');
                    }
                }
                this.refreshView();
            };
            this.refreshView = function () {
                if (this.element) {
                    $scope.selectedDt = null;
                    this._refreshView();
                    if ($scope.activeDt) {
                        $scope.activeDateId = $scope.activeDt.uid;
                    }
                    var date = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
                    date = dateParser.fromTimezone(date, ngModelOptions.timezone);
                    ngModelCtrl.$setValidity('dateDisabled', !date || this.element && !this.isDisabled(date));
                }
            };
            this.createDateObject = function (date, format) {
                var model = ngModelCtrl.$viewValue ? new Date(ngModelCtrl.$viewValue) : null;
                model = dateParser.fromTimezone(model, ngModelOptions.timezone);
                var today = new Date();
                today = dateParser.fromTimezone(today, ngModelOptions.timezone);
                var time = this.compare(date, today);
                var dt = {
                    date: date,
                    label: dateParser.filter(date, format),
                    selected: model && this.compare(date, model) === 0,
                    disabled: this.isDisabled(date),
                    past: time < 0,
                    current: time === 0,
                    future: time > 0,
                    customClass: this.customClass(date) || null
                };
                if (model && this.compare(date, model) === 0) {
                    $scope.selectedDt = dt;
                }
                if (self.activeDate && this.compare(dt.date, self.activeDate) === 0) {
                    $scope.activeDt = dt;
                }
                return dt;
            };
            this.isDisabled = function (date) {
                return $scope.disabled || this.minDate && this.compare(date, this.minDate) < 0 || this.maxDate && this.compare(date, this.maxDate) > 0 || $scope.dateDisabled && $scope.dateDisabled({
                    date: date,
                    mode: $scope.datepickerMode
                });
            };
            this.customClass = function (date) {
                return $scope.customClass({
                    date: date,
                    mode: $scope.datepickerMode
                });
            };
            this.split = function (arr, size) {
                var arrays = [];
                while (arr.length > 0) {
                    arrays.push(arr.splice(0, size));
                }
                return arrays;
            };
            $scope.select = function (date) {
                if ($scope.datepickerMode === self.minMode) {
                    var dt = ngModelCtrl.$viewValue ? dateParser.fromTimezone(new Date(ngModelCtrl.$viewValue), ngModelOptions.timezone) : new Date(0, 0, 0, 0, 0, 0, 0);
                    dt.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());
                    dt = dateParser.toTimezone(dt, ngModelOptions.timezone);
                    ngModelCtrl.$setViewValue(dt);
                    ngModelCtrl.$render();
                } else {
                    self.activeDate = date;
                    setMode(self.modes[self.modes.indexOf($scope.datepickerMode) - 1]);
                    $scope.$emit('uib:datepicker.mode');
                }
                $scope.$broadcast('uib:datepicker.focus');
            };
            $scope.move = function (direction) {
                var year = self.activeDate.getFullYear() + direction * (self.step.years || 0), month = self.activeDate.getMonth() + direction * (self.step.months || 0);
                self.activeDate.setFullYear(year, month, 1);
                self.refreshView();
            };
            $scope.toggleMode = function (direction) {
                direction = direction || 1;
                if ($scope.datepickerMode === self.maxMode && direction === 1 || $scope.datepickerMode === self.minMode && direction === -1) {
                    return;
                }
                setMode(self.modes[self.modes.indexOf($scope.datepickerMode) + direction]);
                $scope.$emit('uib:datepicker.mode');
            };
            $scope.keys = {
                13: 'enter',
                32: 'space',
                33: 'pageup',
                34: 'pagedown',
                35: 'end',
                36: 'home',
                37: 'left',
                38: 'up',
                39: 'right',
                40: 'down'
            };
            var focusElement = function () {
                self.element[0].focus();
            };
            $scope.$on('uib:datepicker.focus', focusElement);
            $scope.keydown = function (evt) {
                var key = $scope.keys[evt.which];
                if (!key || evt.shiftKey || evt.altKey || $scope.disabled) {
                    return;
                }
                evt.preventDefault();
                if (!self.shortcutPropagation) {
                    evt.stopPropagation();
                }
                if (key === 'enter' || key === 'space') {
                    if (self.isDisabled(self.activeDate)) {
                        return;
                    }
                    $scope.select(self.activeDate);
                } else if (evt.ctrlKey && (key === 'up' || key === 'down')) {
                    $scope.toggleMode(key === 'up' ? 1 : -1);
                } else {
                    self.handleKeyDown(key, evt);
                    self.refreshView();
                }
            };
            $scope.$on('$destroy', function () {
                while (watchListeners.length) {
                    watchListeners.shift()();
                }
            });
            function setMode(mode) {
                $scope.datepickerMode = mode;
                $scope.datepickerOptions.datepickerMode = mode;
            }
        }
    ]).controller('UibDaypickerController', [
        '$scope',
        '$element',
        'dateFilter',
        function (scope, $element, dateFilter) {
            var DAYS_IN_MONTH = [
                31,
                28,
                31,
                30,
                31,
                30,
                31,
                31,
                30,
                31,
                30,
                31
            ];
            this.step = { months: 1 };
            this.element = $element;
            function getDaysInMonth(year, month) {
                return month === 1 && year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0) ? 29 : DAYS_IN_MONTH[month];
            }
            this.init = function (ctrl) {
                angular.extend(ctrl, this);
                scope.showWeeks = ctrl.showWeeks;
                ctrl.refreshView();
            };
            this.getDates = function (startDate, n) {
                var dates = new Array(n), current = new Date(startDate), i = 0, date;
                while (i < n) {
                    date = new Date(current);
                    dates[i++] = date;
                    current.setDate(current.getDate() + 1);
                }
                return dates;
            };
            this._refreshView = function () {
                var year = this.activeDate.getFullYear(), month = this.activeDate.getMonth(), firstDayOfMonth = new Date(this.activeDate);
                firstDayOfMonth.setFullYear(year, month, 1);
                var difference = this.startingDay - firstDayOfMonth.getDay(), numDisplayedFromPreviousMonth = difference > 0 ? 7 - difference : -difference, firstDate = new Date(firstDayOfMonth);
                if (numDisplayedFromPreviousMonth > 0) {
                    firstDate.setDate(-numDisplayedFromPreviousMonth + 1);
                }
                var days = this.getDates(firstDate, 42);
                for (var i = 0; i < 42; i++) {
                    days[i] = angular.extend(this.createDateObject(days[i], this.formatDay), {
                        secondary: days[i].getMonth() !== month,
                        uid: scope.uniqueId + '-' + i
                    });
                }
                scope.labels = new Array(7);
                for (var j = 0; j < 7; j++) {
                    scope.labels[j] = {
                        abbr: dateFilter(days[j].date, this.formatDayHeader),
                        full: dateFilter(days[j].date, 'EEEE')
                    };
                }
                scope.title = dateFilter(this.activeDate, this.formatDayTitle);
                scope.rows = this.split(days, 7);
                if (scope.showWeeks) {
                    scope.weekNumbers = [];
                    var thursdayIndex = (4 + 7 - this.startingDay) % 7, numWeeks = scope.rows.length;
                    for (var curWeek = 0; curWeek < numWeeks; curWeek++) {
                        scope.weekNumbers.push(getISO8601WeekNumber(scope.rows[curWeek][thursdayIndex].date));
                    }
                }
            };
            this.compare = function (date1, date2) {
                var _date1 = new Date(date1.getFullYear(), date1.getMonth(), date1.getDate());
                var _date2 = new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
                _date1.setFullYear(date1.getFullYear());
                _date2.setFullYear(date2.getFullYear());
                return _date1 - _date2;
            };
            function getISO8601WeekNumber(date) {
                var checkDate = new Date(date);
                checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
                var time = checkDate.getTime();
                checkDate.setMonth(0);
                checkDate.setDate(1);
                return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
            }
            this.handleKeyDown = function (key, evt) {
                var date = this.activeDate.getDate();
                if (key === 'left') {
                    date = date - 1;
                } else if (key === 'up') {
                    date = date - 7;
                } else if (key === 'right') {
                    date = date + 1;
                } else if (key === 'down') {
                    date = date + 7;
                } else if (key === 'pageup' || key === 'pagedown') {
                    var month = this.activeDate.getMonth() + (key === 'pageup' ? -1 : 1);
                    this.activeDate.setMonth(month, 1);
                    date = Math.min(getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth()), date);
                } else if (key === 'home') {
                    date = 1;
                } else if (key === 'end') {
                    date = getDaysInMonth(this.activeDate.getFullYear(), this.activeDate.getMonth());
                }
                this.activeDate.setDate(date);
            };
        }
    ]).controller('UibMonthpickerController', [
        '$scope',
        '$element',
        'dateFilter',
        function (scope, $element, dateFilter) {
            this.step = { years: 1 };
            this.element = $element;
            this.init = function (ctrl) {
                angular.extend(ctrl, this);
                ctrl.refreshView();
            };
            this._refreshView = function () {
                var months = new Array(12), year = this.activeDate.getFullYear(), date;
                for (var i = 0; i < 12; i++) {
                    date = new Date(this.activeDate);
                    date.setFullYear(year, i, 1);
                    months[i] = angular.extend(this.createDateObject(date, this.formatMonth), { uid: scope.uniqueId + '-' + i });
                }
                scope.title = dateFilter(this.activeDate, this.formatMonthTitle);
                scope.rows = this.split(months, 3);
            };
            this.compare = function (date1, date2) {
                var _date1 = new Date(date1.getFullYear(), date1.getMonth());
                var _date2 = new Date(date2.getFullYear(), date2.getMonth());
                _date1.setFullYear(date1.getFullYear());
                _date2.setFullYear(date2.getFullYear());
                return _date1 - _date2;
            };
            this.handleKeyDown = function (key, evt) {
                var date = this.activeDate.getMonth();
                if (key === 'left') {
                    date = date - 1;
                } else if (key === 'up') {
                    date = date - 3;
                } else if (key === 'right') {
                    date = date + 1;
                } else if (key === 'down') {
                    date = date + 3;
                } else if (key === 'pageup' || key === 'pagedown') {
                    var year = this.activeDate.getFullYear() + (key === 'pageup' ? -1 : 1);
                    this.activeDate.setFullYear(year);
                } else if (key === 'home') {
                    date = 0;
                } else if (key === 'end') {
                    date = 11;
                }
                this.activeDate.setMonth(date);
            };
        }
    ]).controller('UibYearpickerController', [
        '$scope',
        '$element',
        'dateFilter',
        function (scope, $element, dateFilter) {
            var columns, range;
            this.element = $element;
            function getStartingYear(year) {
                return parseInt((year - 1) / range, 10) * range + 1;
            }
            this.yearpickerInit = function () {
                columns = this.yearColumns;
                range = this.yearRows * columns;
                this.step = { years: range };
            };
            this._refreshView = function () {
                var years = new Array(range), date;
                for (var i = 0, start = getStartingYear(this.activeDate.getFullYear()); i < range; i++) {
                    date = new Date(this.activeDate);
                    date.setFullYear(start + i, 0, 1);
                    years[i] = angular.extend(this.createDateObject(date, this.formatYear), { uid: scope.uniqueId + '-' + i });
                }
                scope.title = [
                    years[0].label,
                    years[range - 1].label
                ].join(' - ');
                scope.rows = this.split(years, columns);
                scope.columns = columns;
            };
            this.compare = function (date1, date2) {
                return date1.getFullYear() - date2.getFullYear();
            };
            this.handleKeyDown = function (key, evt) {
                var date = this.activeDate.getFullYear();
                if (key === 'left') {
                    date = date - 1;
                } else if (key === 'up') {
                    date = date - columns;
                } else if (key === 'right') {
                    date = date + 1;
                } else if (key === 'down') {
                    date = date + columns;
                } else if (key === 'pageup' || key === 'pagedown') {
                    date += (key === 'pageup' ? -1 : 1) * range;
                } else if (key === 'home') {
                    date = getStartingYear(this.activeDate.getFullYear());
                } else if (key === 'end') {
                    date = getStartingYear(this.activeDate.getFullYear()) + range - 1;
                }
                this.activeDate.setFullYear(date);
            };
        }
    ]).directive('uibDatepicker', function () {
        return {
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/datepicker/datepicker.html';
            },
            scope: { datepickerOptions: '=?' },
            require: [
                'uibDatepicker',
                '^ngModel'
            ],
            controller: 'UibDatepickerController',
            controllerAs: 'datepicker',
            link: function (scope, element, attrs, ctrls) {
                var datepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                datepickerCtrl.init(ngModelCtrl);
            }
        };
    }).directive('uibDaypicker', function () {
        return {
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/datepicker/day.html';
            },
            require: [
                '^uibDatepicker',
                'uibDaypicker'
            ],
            controller: 'UibDaypickerController',
            link: function (scope, element, attrs, ctrls) {
                var datepickerCtrl = ctrls[0], daypickerCtrl = ctrls[1];
                daypickerCtrl.init(datepickerCtrl);
            }
        };
    }).directive('uibMonthpicker', function () {
        return {
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/datepicker/month.html';
            },
            require: [
                '^uibDatepicker',
                'uibMonthpicker'
            ],
            controller: 'UibMonthpickerController',
            link: function (scope, element, attrs, ctrls) {
                var datepickerCtrl = ctrls[0], monthpickerCtrl = ctrls[1];
                monthpickerCtrl.init(datepickerCtrl);
            }
        };
    }).directive('uibYearpicker', function () {
        return {
            replace: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/datepicker/year.html';
            },
            require: [
                '^uibDatepicker',
                'uibYearpicker'
            ],
            controller: 'UibYearpickerController',
            link: function (scope, element, attrs, ctrls) {
                var ctrl = ctrls[0];
                angular.extend(ctrl, ctrls[1]);
                ctrl.yearpickerInit();
                ctrl.refreshView();
            }
        };
    });
    angular.module('ui.bootstrap.position', []).factory('$uibPosition', [
        '$document',
        '$window',
        function ($document, $window) {
            var SCROLLBAR_WIDTH;
            var BODY_SCROLLBAR_WIDTH;
            var OVERFLOW_REGEX = {
                normal: /(auto|scroll)/,
                hidden: /(auto|scroll|hidden)/
            };
            var PLACEMENT_REGEX = {
                auto: /\s?auto?\s?/i,
                primary: /^(top|bottom|left|right)$/,
                secondary: /^(top|bottom|left|right|center)$/,
                vertical: /^(top|bottom)$/
            };
            var BODY_REGEX = /(HTML|BODY)/;
            return {
                getRawNode: function (elem) {
                    return elem.nodeName ? elem : elem[0] || elem;
                },
                parseStyle: function (value) {
                    value = parseFloat(value);
                    return isFinite(value) ? value : 0;
                },
                offsetParent: function (elem) {
                    elem = this.getRawNode(elem);
                    var offsetParent = elem.offsetParent || $document[0].documentElement;
                    function isStaticPositioned(el) {
                        return ($window.getComputedStyle(el).position || 'static') === 'static';
                    }
                    while (offsetParent && offsetParent !== $document[0].documentElement && isStaticPositioned(offsetParent)) {
                        offsetParent = offsetParent.offsetParent;
                    }
                    return offsetParent || $document[0].documentElement;
                },
                scrollbarWidth: function (isBody) {
                    if (isBody) {
                        if (angular.isUndefined(BODY_SCROLLBAR_WIDTH)) {
                            var bodyElem = $document.find('body');
                            bodyElem.addClass('uib-position-body-scrollbar-measure');
                            BODY_SCROLLBAR_WIDTH = $window.innerWidth - bodyElem[0].clientWidth;
                            BODY_SCROLLBAR_WIDTH = isFinite(BODY_SCROLLBAR_WIDTH) ? BODY_SCROLLBAR_WIDTH : 0;
                            bodyElem.removeClass('uib-position-body-scrollbar-measure');
                        }
                        return BODY_SCROLLBAR_WIDTH;
                    }
                    if (angular.isUndefined(SCROLLBAR_WIDTH)) {
                        var scrollElem = angular.element('<div class="uib-position-scrollbar-measure"></div>');
                        $document.find('body').append(scrollElem);
                        SCROLLBAR_WIDTH = scrollElem[0].offsetWidth - scrollElem[0].clientWidth;
                        SCROLLBAR_WIDTH = isFinite(SCROLLBAR_WIDTH) ? SCROLLBAR_WIDTH : 0;
                        scrollElem.remove();
                    }
                    return SCROLLBAR_WIDTH;
                },
                scrollbarPadding: function (elem) {
                    elem = this.getRawNode(elem);
                    var elemStyle = $window.getComputedStyle(elem);
                    var paddingRight = this.parseStyle(elemStyle.paddingRight);
                    var paddingBottom = this.parseStyle(elemStyle.paddingBottom);
                    var scrollParent = this.scrollParent(elem, false, true);
                    var scrollbarWidth = this.scrollbarWidth(scrollParent, BODY_REGEX.test(scrollParent.tagName));
                    return {
                        scrollbarWidth: scrollbarWidth,
                        widthOverflow: scrollParent.scrollWidth > scrollParent.clientWidth,
                        right: paddingRight + scrollbarWidth,
                        originalRight: paddingRight,
                        heightOverflow: scrollParent.scrollHeight > scrollParent.clientHeight,
                        bottom: paddingBottom + scrollbarWidth,
                        originalBottom: paddingBottom
                    };
                },
                isScrollable: function (elem, includeHidden) {
                    elem = this.getRawNode(elem);
                    var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
                    var elemStyle = $window.getComputedStyle(elem);
                    return overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX);
                },
                scrollParent: function (elem, includeHidden, includeSelf) {
                    elem = this.getRawNode(elem);
                    var overflowRegex = includeHidden ? OVERFLOW_REGEX.hidden : OVERFLOW_REGEX.normal;
                    var documentEl = $document[0].documentElement;
                    var elemStyle = $window.getComputedStyle(elem);
                    if (includeSelf && overflowRegex.test(elemStyle.overflow + elemStyle.overflowY + elemStyle.overflowX)) {
                        return elem;
                    }
                    var excludeStatic = elemStyle.position === 'absolute';
                    var scrollParent = elem.parentElement || documentEl;
                    if (scrollParent === documentEl || elemStyle.position === 'fixed') {
                        return documentEl;
                    }
                    while (scrollParent.parentElement && scrollParent !== documentEl) {
                        var spStyle = $window.getComputedStyle(scrollParent);
                        if (excludeStatic && spStyle.position !== 'static') {
                            excludeStatic = false;
                        }
                        if (!excludeStatic && overflowRegex.test(spStyle.overflow + spStyle.overflowY + spStyle.overflowX)) {
                            break;
                        }
                        scrollParent = scrollParent.parentElement;
                    }
                    return scrollParent;
                },
                position: function (elem, includeMagins) {
                    elem = this.getRawNode(elem);
                    var elemOffset = this.offset(elem);
                    if (includeMagins) {
                        var elemStyle = $window.getComputedStyle(elem);
                        elemOffset.top -= this.parseStyle(elemStyle.marginTop);
                        elemOffset.left -= this.parseStyle(elemStyle.marginLeft);
                    }
                    var parent = this.offsetParent(elem);
                    var parentOffset = {
                        top: 0,
                        left: 0
                    };
                    if (parent !== $document[0].documentElement) {
                        parentOffset = this.offset(parent);
                        parentOffset.top += parent.clientTop - parent.scrollTop;
                        parentOffset.left += parent.clientLeft - parent.scrollLeft;
                    }
                    return {
                        width: Math.round(angular.isNumber(elemOffset.width) ? elemOffset.width : elem.offsetWidth),
                        height: Math.round(angular.isNumber(elemOffset.height) ? elemOffset.height : elem.offsetHeight),
                        top: Math.round(elemOffset.top - parentOffset.top),
                        left: Math.round(elemOffset.left - parentOffset.left)
                    };
                },
                offset: function (elem) {
                    elem = this.getRawNode(elem);
                    var elemBCR = elem.getBoundingClientRect();
                    return {
                        width: Math.round(angular.isNumber(elemBCR.width) ? elemBCR.width : elem.offsetWidth),
                        height: Math.round(angular.isNumber(elemBCR.height) ? elemBCR.height : elem.offsetHeight),
                        top: Math.round(elemBCR.top + ($window.pageYOffset || $document[0].documentElement.scrollTop)),
                        left: Math.round(elemBCR.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft))
                    };
                },
                viewportOffset: function (elem, useDocument, includePadding) {
                    elem = this.getRawNode(elem);
                    includePadding = includePadding !== false ? true : false;
                    var elemBCR = elem.getBoundingClientRect();
                    var offsetBCR = {
                        top: 0,
                        left: 0,
                        bottom: 0,
                        right: 0
                    };
                    var offsetParent = useDocument ? $document[0].documentElement : this.scrollParent(elem);
                    var offsetParentBCR = offsetParent.getBoundingClientRect();
                    offsetBCR.top = offsetParentBCR.top + offsetParent.clientTop;
                    offsetBCR.left = offsetParentBCR.left + offsetParent.clientLeft;
                    if (offsetParent === $document[0].documentElement) {
                        offsetBCR.top += $window.pageYOffset;
                        offsetBCR.left += $window.pageXOffset;
                    }
                    offsetBCR.bottom = offsetBCR.top + offsetParent.clientHeight;
                    offsetBCR.right = offsetBCR.left + offsetParent.clientWidth;
                    if (includePadding) {
                        var offsetParentStyle = $window.getComputedStyle(offsetParent);
                        offsetBCR.top += this.parseStyle(offsetParentStyle.paddingTop);
                        offsetBCR.bottom -= this.parseStyle(offsetParentStyle.paddingBottom);
                        offsetBCR.left += this.parseStyle(offsetParentStyle.paddingLeft);
                        offsetBCR.right -= this.parseStyle(offsetParentStyle.paddingRight);
                    }
                    return {
                        top: Math.round(elemBCR.top - offsetBCR.top),
                        bottom: Math.round(offsetBCR.bottom - elemBCR.bottom),
                        left: Math.round(elemBCR.left - offsetBCR.left),
                        right: Math.round(offsetBCR.right - elemBCR.right)
                    };
                },
                parsePlacement: function (placement) {
                    var autoPlace = PLACEMENT_REGEX.auto.test(placement);
                    if (autoPlace) {
                        placement = placement.replace(PLACEMENT_REGEX.auto, '');
                    }
                    placement = placement.split('-');
                    placement[0] = placement[0] || 'top';
                    if (!PLACEMENT_REGEX.primary.test(placement[0])) {
                        placement[0] = 'top';
                    }
                    placement[1] = placement[1] || 'center';
                    if (!PLACEMENT_REGEX.secondary.test(placement[1])) {
                        placement[1] = 'center';
                    }
                    if (autoPlace) {
                        placement[2] = true;
                    } else {
                        placement[2] = false;
                    }
                    return placement;
                },
                positionElements: function (hostElem, targetElem, placement, appendToBody) {
                    hostElem = this.getRawNode(hostElem);
                    targetElem = this.getRawNode(targetElem);
                    var targetWidth = angular.isDefined(targetElem.offsetWidth) ? targetElem.offsetWidth : targetElem.prop('offsetWidth');
                    var targetHeight = angular.isDefined(targetElem.offsetHeight) ? targetElem.offsetHeight : targetElem.prop('offsetHeight');
                    placement = this.parsePlacement(placement);
                    var hostElemPos = appendToBody ? this.offset(hostElem) : this.position(hostElem);
                    var targetElemPos = {
                        top: 0,
                        left: 0,
                        placement: ''
                    };
                    if (placement[2]) {
                        var viewportOffset = this.viewportOffset(hostElem, appendToBody);
                        var targetElemStyle = $window.getComputedStyle(targetElem);
                        var adjustedSize = {
                            width: targetWidth + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginLeft) + this.parseStyle(targetElemStyle.marginRight))),
                            height: targetHeight + Math.round(Math.abs(this.parseStyle(targetElemStyle.marginTop) + this.parseStyle(targetElemStyle.marginBottom)))
                        };
                        placement[0] = placement[0] === 'top' && adjustedSize.height > viewportOffset.top && adjustedSize.height <= viewportOffset.bottom ? 'bottom' : placement[0] === 'bottom' && adjustedSize.height > viewportOffset.bottom && adjustedSize.height <= viewportOffset.top ? 'top' : placement[0] === 'left' && adjustedSize.width > viewportOffset.left && adjustedSize.width <= viewportOffset.right ? 'right' : placement[0] === 'right' && adjustedSize.width > viewportOffset.right && adjustedSize.width <= viewportOffset.left ? 'left' : placement[0];
                        placement[1] = placement[1] === 'top' && adjustedSize.height - hostElemPos.height > viewportOffset.bottom && adjustedSize.height - hostElemPos.height <= viewportOffset.top ? 'bottom' : placement[1] === 'bottom' && adjustedSize.height - hostElemPos.height > viewportOffset.top && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom ? 'top' : placement[1] === 'left' && adjustedSize.width - hostElemPos.width > viewportOffset.right && adjustedSize.width - hostElemPos.width <= viewportOffset.left ? 'right' : placement[1] === 'right' && adjustedSize.width - hostElemPos.width > viewportOffset.left && adjustedSize.width - hostElemPos.width <= viewportOffset.right ? 'left' : placement[1];
                        if (placement[1] === 'center') {
                            if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                                var xOverflow = hostElemPos.width / 2 - targetWidth / 2;
                                if (viewportOffset.left + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.right) {
                                    placement[1] = 'left';
                                } else if (viewportOffset.right + xOverflow < 0 && adjustedSize.width - hostElemPos.width <= viewportOffset.left) {
                                    placement[1] = 'right';
                                }
                            } else {
                                var yOverflow = hostElemPos.height / 2 - adjustedSize.height / 2;
                                if (viewportOffset.top + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.bottom) {
                                    placement[1] = 'top';
                                } else if (viewportOffset.bottom + yOverflow < 0 && adjustedSize.height - hostElemPos.height <= viewportOffset.top) {
                                    placement[1] = 'bottom';
                                }
                            }
                        }
                    }
                    switch (placement[0]) {
                    case 'top':
                        targetElemPos.top = hostElemPos.top - targetHeight;
                        break;
                    case 'bottom':
                        targetElemPos.top = hostElemPos.top + hostElemPos.height;
                        break;
                    case 'left':
                        targetElemPos.left = hostElemPos.left - targetWidth;
                        break;
                    case 'right':
                        targetElemPos.left = hostElemPos.left + hostElemPos.width;
                        break;
                    }
                    switch (placement[1]) {
                    case 'top':
                        targetElemPos.top = hostElemPos.top;
                        break;
                    case 'bottom':
                        targetElemPos.top = hostElemPos.top + hostElemPos.height - targetHeight;
                        break;
                    case 'left':
                        targetElemPos.left = hostElemPos.left;
                        break;
                    case 'right':
                        targetElemPos.left = hostElemPos.left + hostElemPos.width - targetWidth;
                        break;
                    case 'center':
                        if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                            targetElemPos.left = hostElemPos.left + hostElemPos.width / 2 - targetWidth / 2;
                        } else {
                            targetElemPos.top = hostElemPos.top + hostElemPos.height / 2 - targetHeight / 2;
                        }
                        break;
                    }
                    targetElemPos.top = Math.round(targetElemPos.top);
                    targetElemPos.left = Math.round(targetElemPos.left);
                    targetElemPos.placement = placement[1] === 'center' ? placement[0] : placement[0] + '-' + placement[1];
                    return targetElemPos;
                },
                positionArrow: function (elem, placement) {
                    elem = this.getRawNode(elem);
                    var innerElem = elem.querySelector('.tooltip-inner, .popover-inner');
                    if (!innerElem) {
                        return;
                    }
                    var isTooltip = angular.element(innerElem).hasClass('tooltip-inner');
                    var arrowElem = isTooltip ? elem.querySelector('.tooltip-arrow') : elem.querySelector('.arrow');
                    if (!arrowElem) {
                        return;
                    }
                    var arrowCss = {
                        top: '',
                        bottom: '',
                        left: '',
                        right: ''
                    };
                    placement = this.parsePlacement(placement);
                    if (placement[1] === 'center') {
                        angular.element(arrowElem).css(arrowCss);
                        return;
                    }
                    var borderProp = 'border-' + placement[0] + '-width';
                    var borderWidth = $window.getComputedStyle(arrowElem)[borderProp];
                    var borderRadiusProp = 'border-';
                    if (PLACEMENT_REGEX.vertical.test(placement[0])) {
                        borderRadiusProp += placement[0] + '-' + placement[1];
                    } else {
                        borderRadiusProp += placement[1] + '-' + placement[0];
                    }
                    borderRadiusProp += '-radius';
                    var borderRadius = $window.getComputedStyle(isTooltip ? innerElem : elem)[borderRadiusProp];
                    switch (placement[0]) {
                    case 'top':
                        arrowCss.bottom = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'bottom':
                        arrowCss.top = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'left':
                        arrowCss.right = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    case 'right':
                        arrowCss.left = isTooltip ? '0' : '-' + borderWidth;
                        break;
                    }
                    arrowCss[placement[1]] = borderRadius;
                    angular.element(arrowElem).css(arrowCss);
                }
            };
        }
    ]);
    angular.module('ui.bootstrap.datepickerPopup', [
        'ui.bootstrap.datepicker',
        'ui.bootstrap.position'
    ]).value('$datepickerPopupLiteralWarning', true).constant('uibDatepickerPopupConfig', {
        altInputFormats: [],
        appendToBody: false,
        clearText: 'Clear',
        closeOnDateSelection: true,
        closeText: 'Done',
        currentText: 'Today',
        datepickerPopup: 'yyyy-MM-dd',
        datepickerPopupTemplateUrl: 'uib/template/datepickerPopup/popup.html',
        datepickerTemplateUrl: 'uib/template/datepicker/datepicker.html',
        html5Types: {
            date: 'yyyy-MM-dd',
            'datetime-local': 'yyyy-MM-ddTHH:mm:ss.sss',
            'month': 'yyyy-MM'
        },
        onOpenFocus: true,
        showButtonBar: true,
        placement: 'auto bottom-left'
    }).controller('UibDatepickerPopupController', [
        '$scope',
        '$element',
        '$attrs',
        '$compile',
        '$log',
        '$parse',
        '$window',
        '$document',
        '$rootScope',
        '$uibPosition',
        'dateFilter',
        'uibDateParser',
        'uibDatepickerPopupConfig',
        '$timeout',
        'uibDatepickerConfig',
        '$datepickerPopupLiteralWarning',
        function ($scope, $element, $attrs, $compile, $log, $parse, $window, $document, $rootScope, $position, dateFilter, dateParser, datepickerPopupConfig, $timeout, datepickerConfig, $datepickerPopupLiteralWarning) {
            var cache = {}, isHtml5DateInput = false;
            var dateFormat, closeOnDateSelection, appendToBody, onOpenFocus, datepickerPopupTemplateUrl, datepickerTemplateUrl, popupEl, datepickerEl, scrollParentEl, ngModel, ngModelOptions, $popup, altInputFormats, watchListeners = [], timezone;
            this.init = function (_ngModel_) {
                ngModel = _ngModel_;
                ngModelOptions = _ngModel_.$options;
                closeOnDateSelection = angular.isDefined($attrs.closeOnDateSelection) ? $scope.$parent.$eval($attrs.closeOnDateSelection) : datepickerPopupConfig.closeOnDateSelection;
                appendToBody = angular.isDefined($attrs.datepickerAppendToBody) ? $scope.$parent.$eval($attrs.datepickerAppendToBody) : datepickerPopupConfig.appendToBody;
                onOpenFocus = angular.isDefined($attrs.onOpenFocus) ? $scope.$parent.$eval($attrs.onOpenFocus) : datepickerPopupConfig.onOpenFocus;
                datepickerPopupTemplateUrl = angular.isDefined($attrs.datepickerPopupTemplateUrl) ? $attrs.datepickerPopupTemplateUrl : datepickerPopupConfig.datepickerPopupTemplateUrl;
                datepickerTemplateUrl = angular.isDefined($attrs.datepickerTemplateUrl) ? $attrs.datepickerTemplateUrl : datepickerPopupConfig.datepickerTemplateUrl;
                altInputFormats = angular.isDefined($attrs.altInputFormats) ? $scope.$parent.$eval($attrs.altInputFormats) : datepickerPopupConfig.altInputFormats;
                $scope.showButtonBar = angular.isDefined($attrs.showButtonBar) ? $scope.$parent.$eval($attrs.showButtonBar) : datepickerPopupConfig.showButtonBar;
                if (datepickerPopupConfig.html5Types[$attrs.type]) {
                    dateFormat = datepickerPopupConfig.html5Types[$attrs.type];
                    isHtml5DateInput = true;
                } else {
                    dateFormat = $attrs.uibDatepickerPopup || datepickerPopupConfig.datepickerPopup;
                    $attrs.$observe('uibDatepickerPopup', function (value, oldValue) {
                        var newDateFormat = value || datepickerPopupConfig.datepickerPopup;
                        if (newDateFormat !== dateFormat) {
                            dateFormat = newDateFormat;
                            ngModel.$modelValue = null;
                            if (!dateFormat) {
                                throw new Error('uibDatepickerPopup must have a date format specified.');
                            }
                        }
                    });
                }
                if (!dateFormat) {
                    throw new Error('uibDatepickerPopup must have a date format specified.');
                }
                if (isHtml5DateInput && $attrs.uibDatepickerPopup) {
                    throw new Error('HTML5 date input types do not support custom formats.');
                }
                popupEl = angular.element('<div uib-datepicker-popup-wrap><div uib-datepicker></div></div>');
                if (ngModelOptions) {
                    timezone = ngModelOptions.timezone;
                    $scope.ngModelOptions = angular.copy(ngModelOptions);
                    $scope.ngModelOptions.timezone = null;
                    if ($scope.ngModelOptions.updateOnDefault === true) {
                        $scope.ngModelOptions.updateOn = $scope.ngModelOptions.updateOn ? $scope.ngModelOptions.updateOn + ' default' : 'default';
                    }
                    popupEl.attr('ng-model-options', 'ngModelOptions');
                } else {
                    timezone = null;
                }
                popupEl.attr({
                    'ng-model': 'date',
                    'ng-change': 'dateSelection(date)',
                    'template-url': datepickerPopupTemplateUrl
                });
                datepickerEl = angular.element(popupEl.children()[0]);
                datepickerEl.attr('template-url', datepickerTemplateUrl);
                if (!$scope.datepickerOptions) {
                    $scope.datepickerOptions = {};
                }
                if (isHtml5DateInput) {
                    if ($attrs.type === 'month') {
                        $scope.datepickerOptions.datepickerMode = 'month';
                        $scope.datepickerOptions.minMode = 'month';
                    }
                }
                datepickerEl.attr('datepicker-options', 'datepickerOptions');
                if (!isHtml5DateInput) {
                    ngModel.$$parserName = 'date';
                    ngModel.$validators.date = validator;
                    ngModel.$parsers.unshift(parseDate);
                    ngModel.$formatters.push(function (value) {
                        if (ngModel.$isEmpty(value)) {
                            $scope.date = value;
                            return value;
                        }
                        if (angular.isNumber(value)) {
                            value = new Date(value);
                        }
                        $scope.date = dateParser.fromTimezone(value, timezone);
                        return dateParser.filter($scope.date, dateFormat);
                    });
                } else {
                    ngModel.$formatters.push(function (value) {
                        $scope.date = dateParser.fromTimezone(value, timezone);
                        return value;
                    });
                }
                ngModel.$viewChangeListeners.push(function () {
                    $scope.date = parseDateString(ngModel.$viewValue);
                });
                $element.on('keydown', inputKeydownBind);
                $popup = $compile(popupEl)($scope);
                popupEl.remove();
                if (appendToBody) {
                    $document.find('body').append($popup);
                } else {
                    $element.after($popup);
                }
                $scope.$on('$destroy', function () {
                    if ($scope.isOpen === true) {
                        if (!$rootScope.$$phase) {
                            $scope.$apply(function () {
                                $scope.isOpen = false;
                            });
                        }
                    }
                    $popup.remove();
                    $element.off('keydown', inputKeydownBind);
                    $document.off('click', documentClickBind);
                    if (scrollParentEl) {
                        scrollParentEl.off('scroll', positionPopup);
                    }
                    angular.element($window).off('resize', positionPopup);
                    while (watchListeners.length) {
                        watchListeners.shift()();
                    }
                });
            };
            $scope.getText = function (key) {
                return $scope[key + 'Text'] || datepickerPopupConfig[key + 'Text'];
            };
            $scope.isDisabled = function (date) {
                if (date === 'today') {
                    date = dateParser.fromTimezone(new Date(), timezone);
                }
                var dates = {};
                angular.forEach([
                    'minDate',
                    'maxDate'
                ], function (key) {
                    if (!$scope.datepickerOptions[key]) {
                        dates[key] = null;
                    } else if (angular.isDate($scope.datepickerOptions[key])) {
                        dates[key] = dateParser.fromTimezone(new Date($scope.datepickerOptions[key]), timezone);
                    } else {
                        if ($datepickerPopupLiteralWarning) {
                            $log.warn('Literal date support has been deprecated, please switch to date object usage');
                        }
                        dates[key] = new Date(dateFilter($scope.datepickerOptions[key], 'medium'));
                    }
                });
                return $scope.datepickerOptions && dates.minDate && $scope.compare(date, dates.minDate) < 0 || dates.maxDate && $scope.compare(date, dates.maxDate) > 0;
            };
            $scope.compare = function (date1, date2) {
                return new Date(date1.getFullYear(), date1.getMonth(), date1.getDate()) - new Date(date2.getFullYear(), date2.getMonth(), date2.getDate());
            };
            $scope.dateSelection = function (dt) {
                if (angular.isDefined(dt)) {
                    $scope.date = dt;
                }
                var date = $scope.date ? dateParser.filter($scope.date, dateFormat) : null;
                $element.val(date);
                ngModel.$setViewValue(date);
                if (closeOnDateSelection) {
                    $scope.isOpen = false;
                    $element[0].focus();
                }
            };
            $scope.keydown = function (evt) {
                if (evt.which === 27) {
                    evt.stopPropagation();
                    $scope.isOpen = false;
                    $element[0].focus();
                }
            };
            $scope.select = function (date, evt) {
                evt.stopPropagation();
                if (date === 'today') {
                    var today = new Date();
                    if (angular.isDate($scope.date)) {
                        date = new Date($scope.date);
                        date.setFullYear(today.getFullYear(), today.getMonth(), today.getDate());
                    } else {
                        date = new Date(today.setHours(0, 0, 0, 0));
                    }
                }
                $scope.dateSelection(date);
            };
            $scope.close = function (evt) {
                evt.stopPropagation();
                $scope.isOpen = false;
                $element[0].focus();
            };
            $scope.disabled = angular.isDefined($attrs.disabled) || false;
            if ($attrs.ngDisabled) {
                watchListeners.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (disabled) {
                    $scope.disabled = disabled;
                }));
            }
            $scope.$watch('isOpen', function (value) {
                if (value) {
                    if (!$scope.disabled) {
                        $timeout(function () {
                            positionPopup();
                            if (onOpenFocus) {
                                $scope.$broadcast('uib:datepicker.focus');
                            }
                            $document.on('click', documentClickBind);
                            var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
                            if (appendToBody || $position.parsePlacement(placement)[2]) {
                                scrollParentEl = scrollParentEl || angular.element($position.scrollParent($element));
                                if (scrollParentEl) {
                                    scrollParentEl.on('scroll', positionPopup);
                                }
                            } else {
                                scrollParentEl = null;
                            }
                            angular.element($window).on('resize', positionPopup);
                        }, 0, false);
                    } else {
                        $scope.isOpen = false;
                    }
                } else {
                    $document.off('click', documentClickBind);
                    if (scrollParentEl) {
                        scrollParentEl.off('scroll', positionPopup);
                    }
                    angular.element($window).off('resize', positionPopup);
                }
            });
            function cameltoDash(string) {
                return string.replace(/([A-Z])/g, function ($1) {
                    return '-' + $1.toLowerCase();
                });
            }
            function parseDateString(viewValue) {
                var date = dateParser.parse(viewValue, dateFormat, $scope.date);
                if (isNaN(date)) {
                    for (var i = 0; i < altInputFormats.length; i++) {
                        date = dateParser.parse(viewValue, altInputFormats[i], $scope.date);
                        if (!isNaN(date)) {
                            return date;
                        }
                    }
                }
                return date;
            }
            function parseDate(viewValue) {
                if (angular.isNumber(viewValue)) {
                    viewValue = new Date(viewValue);
                }
                if (!viewValue) {
                    return null;
                }
                if (angular.isDate(viewValue) && !isNaN(viewValue)) {
                    return viewValue;
                }
                if (angular.isString(viewValue)) {
                    var date = parseDateString(viewValue);
                    if (!isNaN(date)) {
                        return dateParser.toTimezone(date, timezone);
                    }
                }
                return ngModel.$options && ngModel.$options.allowInvalid ? viewValue : undefined;
            }
            function validator(modelValue, viewValue) {
                var value = modelValue || viewValue;
                if (!$attrs.ngRequired && !value) {
                    return true;
                }
                if (angular.isNumber(value)) {
                    value = new Date(value);
                }
                if (!value) {
                    return true;
                }
                if (angular.isDate(value) && !isNaN(value)) {
                    return true;
                }
                if (angular.isString(value)) {
                    return !isNaN(parseDateString(viewValue));
                }
                return false;
            }
            function documentClickBind(event) {
                if (!$scope.isOpen && $scope.disabled) {
                    return;
                }
                var popup = $popup[0];
                var dpContainsTarget = $element[0].contains(event.target);
                var popupContainsTarget = popup.contains !== undefined && popup.contains(event.target);
                if ($scope.isOpen && !(dpContainsTarget || popupContainsTarget)) {
                    $scope.$apply(function () {
                        $scope.isOpen = false;
                    });
                }
            }
            function inputKeydownBind(evt) {
                if (evt.which === 27 && $scope.isOpen) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    $scope.$apply(function () {
                        $scope.isOpen = false;
                    });
                    $element[0].focus();
                } else if (evt.which === 40 && !$scope.isOpen) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    $scope.$apply(function () {
                        $scope.isOpen = true;
                    });
                }
            }
            function positionPopup() {
                if ($scope.isOpen) {
                    var dpElement = angular.element($popup[0].querySelector('.uib-datepicker-popup'));
                    var placement = $attrs.popupPlacement ? $attrs.popupPlacement : datepickerPopupConfig.placement;
                    var position = $position.positionElements($element, dpElement, placement, appendToBody);
                    dpElement.css({
                        top: position.top + 'px',
                        left: position.left + 'px'
                    });
                    if (dpElement.hasClass('uib-position-measure')) {
                        dpElement.removeClass('uib-position-measure');
                    }
                }
            }
            $scope.$on('uib:datepicker.mode', function () {
                $timeout(positionPopup, 0, false);
            });
        }
    ]).directive('uibDatepickerPopup', function () {
        return {
            require: [
                'ngModel',
                'uibDatepickerPopup'
            ],
            controller: 'UibDatepickerPopupController',
            scope: {
                datepickerOptions: '=?',
                isOpen: '=?',
                currentText: '@',
                clearText: '@',
                closeText: '@'
            },
            link: function (scope, element, attrs, ctrls) {
                var ngModel = ctrls[0], ctrl = ctrls[1];
                ctrl.init(ngModel);
            }
        };
    }).directive('uibDatepickerPopupWrap', function () {
        return {
            replace: true,
            transclude: true,
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/datepickerPopup/popup.html';
            }
        };
    });
    angular.module('ui.bootstrap.debounce', []).factory('$$debounce', [
        '$timeout',
        function ($timeout) {
            return function (callback, debounceTime) {
                var timeoutPromise;
                return function () {
                    var self = this;
                    var args = Array.prototype.slice.call(arguments);
                    if (timeoutPromise) {
                        $timeout.cancel(timeoutPromise);
                    }
                    timeoutPromise = $timeout(function () {
                        callback.apply(self, args);
                    }, debounceTime);
                };
            };
        }
    ]);
    angular.module('ui.bootstrap.dropdown', ['ui.bootstrap.position']).constant('uibDropdownConfig', {
        appendToOpenClass: 'uib-dropdown-open',
        openClass: 'open'
    }).service('uibDropdownService', [
        '$document',
        '$rootScope',
        function ($document, $rootScope) {
            var openScope = null;
            this.open = function (dropdownScope, element) {
                if (!openScope) {
                    $document.on('click', closeDropdown);
                    element.on('keydown', keybindFilter);
                }
                if (openScope && openScope !== dropdownScope) {
                    openScope.isOpen = false;
                }
                openScope = dropdownScope;
            };
            this.close = function (dropdownScope, element) {
                if (openScope === dropdownScope) {
                    openScope = null;
                    $document.off('click', closeDropdown);
                    element.off('keydown', keybindFilter);
                }
            };
            var closeDropdown = function (evt) {
                if (!openScope) {
                    return;
                }
                if (evt && openScope.getAutoClose() === 'disabled') {
                    return;
                }
                if (evt && evt.which === 3) {
                    return;
                }
                var toggleElement = openScope.getToggleElement();
                if (evt && toggleElement && toggleElement[0].contains(evt.target)) {
                    return;
                }
                var dropdownElement = openScope.getDropdownElement();
                if (evt && openScope.getAutoClose() === 'outsideClick' && dropdownElement && dropdownElement[0].contains(evt.target)) {
                    return;
                }
                openScope.isOpen = false;
                if (!$rootScope.$$phase) {
                    openScope.$apply();
                }
            };
            var keybindFilter = function (evt) {
                if (evt.which === 27) {
                    evt.stopPropagation();
                    openScope.focusToggleElement();
                    closeDropdown();
                } else if (openScope.isKeynavEnabled() && [
                        38,
                        40
                    ].indexOf(evt.which) !== -1 && openScope.isOpen) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    openScope.focusDropdownEntry(evt.which);
                }
            };
        }
    ]).controller('UibDropdownController', [
        '$scope',
        '$element',
        '$attrs',
        '$parse',
        'uibDropdownConfig',
        'uibDropdownService',
        '$animate',
        '$uibPosition',
        '$document',
        '$compile',
        '$templateRequest',
        function ($scope, $element, $attrs, $parse, dropdownConfig, uibDropdownService, $animate, $position, $document, $compile, $templateRequest) {
            var self = this, scope = $scope.$new(), templateScope, appendToOpenClass = dropdownConfig.appendToOpenClass, openClass = dropdownConfig.openClass, getIsOpen, setIsOpen = angular.noop, toggleInvoker = $attrs.onToggle ? $parse($attrs.onToggle) : angular.noop, appendToBody = false, appendTo = null, keynavEnabled = false, selectedOption = null, body = $document.find('body');
            $element.addClass('dropdown');
            this.init = function () {
                if ($attrs.isOpen) {
                    getIsOpen = $parse($attrs.isOpen);
                    setIsOpen = getIsOpen.assign;
                    $scope.$watch(getIsOpen, function (value) {
                        scope.isOpen = !!value;
                    });
                }
                if (angular.isDefined($attrs.dropdownAppendTo)) {
                    var appendToEl = $parse($attrs.dropdownAppendTo)(scope);
                    if (appendToEl) {
                        appendTo = angular.element(appendToEl);
                    }
                }
                appendToBody = angular.isDefined($attrs.dropdownAppendToBody);
                keynavEnabled = angular.isDefined($attrs.keyboardNav);
                if (appendToBody && !appendTo) {
                    appendTo = body;
                }
                if (appendTo && self.dropdownMenu) {
                    appendTo.append(self.dropdownMenu);
                    $element.on('$destroy', function handleDestroyEvent() {
                        self.dropdownMenu.remove();
                    });
                }
            };
            this.toggle = function (open) {
                scope.isOpen = arguments.length ? !!open : !scope.isOpen;
                if (angular.isFunction(setIsOpen)) {
                    setIsOpen(scope, scope.isOpen);
                }
                return scope.isOpen;
            };
            this.isOpen = function () {
                return scope.isOpen;
            };
            scope.getToggleElement = function () {
                return self.toggleElement;
            };
            scope.getAutoClose = function () {
                return $attrs.autoClose || 'always';
            };
            scope.getElement = function () {
                return $element;
            };
            scope.isKeynavEnabled = function () {
                return keynavEnabled;
            };
            scope.focusDropdownEntry = function (keyCode) {
                var elems = self.dropdownMenu ? angular.element(self.dropdownMenu).find('a') : $element.find('ul').eq(0).find('a');
                switch (keyCode) {
                case 40: {
                        if (!angular.isNumber(self.selectedOption)) {
                            self.selectedOption = 0;
                        } else {
                            self.selectedOption = self.selectedOption === elems.length - 1 ? self.selectedOption : self.selectedOption + 1;
                        }
                        break;
                    }
                case 38: {
                        if (!angular.isNumber(self.selectedOption)) {
                            self.selectedOption = elems.length - 1;
                        } else {
                            self.selectedOption = self.selectedOption === 0 ? 0 : self.selectedOption - 1;
                        }
                        break;
                    }
                }
                elems[self.selectedOption].focus();
            };
            scope.getDropdownElement = function () {
                return self.dropdownMenu;
            };
            scope.focusToggleElement = function () {
                if (self.toggleElement) {
                    self.toggleElement[0].focus();
                }
            };
            scope.$watch('isOpen', function (isOpen, wasOpen) {
                if (appendTo && self.dropdownMenu) {
                    var pos = $position.positionElements($element, self.dropdownMenu, 'bottom-left', true), css, rightalign, scrollbarWidth;
                    css = {
                        top: pos.top + 'px',
                        display: isOpen ? 'block' : 'none'
                    };
                    rightalign = self.dropdownMenu.hasClass('dropdown-menu-right');
                    if (!rightalign) {
                        css.left = pos.left + 'px';
                        css.right = 'auto';
                    } else {
                        css.left = 'auto';
                        scrollbarWidth = $position.scrollbarWidth(true);
                        css.right = window.innerWidth - scrollbarWidth - (pos.left + $element.prop('offsetWidth')) + 'px';
                    }
                    if (!appendToBody) {
                        var appendOffset = $position.offset(appendTo);
                        css.top = pos.top - appendOffset.top + 'px';
                        if (!rightalign) {
                            css.left = pos.left - appendOffset.left + 'px';
                        } else {
                            css.right = window.innerWidth - (pos.left - appendOffset.left + $element.prop('offsetWidth')) + 'px';
                        }
                    }
                    self.dropdownMenu.css(css);
                }
                var openContainer = appendTo ? appendTo : $element;
                var hasOpenClass = openContainer.hasClass(appendTo ? appendToOpenClass : openClass);
                if (hasOpenClass === !isOpen) {
                    $animate[isOpen ? 'addClass' : 'removeClass'](openContainer, appendTo ? appendToOpenClass : openClass).then(function () {
                        if (angular.isDefined(isOpen) && isOpen !== wasOpen) {
                            toggleInvoker($scope, { open: !!isOpen });
                        }
                    });
                }
                if (isOpen) {
                    if (self.dropdownMenuTemplateUrl) {
                        $templateRequest(self.dropdownMenuTemplateUrl).then(function (tplContent) {
                            templateScope = scope.$new();
                            $compile(tplContent.trim())(templateScope, function (dropdownElement) {
                                var newEl = dropdownElement;
                                self.dropdownMenu.replaceWith(newEl);
                                self.dropdownMenu = newEl;
                            });
                        });
                    }
                    scope.focusToggleElement();
                    uibDropdownService.open(scope, $element);
                } else {
                    if (self.dropdownMenuTemplateUrl) {
                        if (templateScope) {
                            templateScope.$destroy();
                        }
                        var newEl = angular.element('<ul class="dropdown-menu"></ul>');
                        self.dropdownMenu.replaceWith(newEl);
                        self.dropdownMenu = newEl;
                    }
                    uibDropdownService.close(scope, $element);
                    self.selectedOption = null;
                }
                if (angular.isFunction(setIsOpen)) {
                    setIsOpen($scope, isOpen);
                }
            });
        }
    ]).directive('uibDropdown', function () {
        return {
            controller: 'UibDropdownController',
            link: function (scope, element, attrs, dropdownCtrl) {
                dropdownCtrl.init();
            }
        };
    }).directive('uibDropdownMenu', function () {
        return {
            restrict: 'A',
            require: '?^uibDropdown',
            link: function (scope, element, attrs, dropdownCtrl) {
                if (!dropdownCtrl || angular.isDefined(attrs.dropdownNested)) {
                    return;
                }
                element.addClass('dropdown-menu');
                var tplUrl = attrs.templateUrl;
                if (tplUrl) {
                    dropdownCtrl.dropdownMenuTemplateUrl = tplUrl;
                }
                if (!dropdownCtrl.dropdownMenu) {
                    dropdownCtrl.dropdownMenu = element;
                }
            }
        };
    }).directive('uibDropdownToggle', function () {
        return {
            require: '?^uibDropdown',
            link: function (scope, element, attrs, dropdownCtrl) {
                if (!dropdownCtrl) {
                    return;
                }
                element.addClass('dropdown-toggle');
                dropdownCtrl.toggleElement = element;
                var toggleDropdown = function (event) {
                    event.preventDefault();
                    if (!element.hasClass('disabled') && !attrs.disabled) {
                        scope.$apply(function () {
                            dropdownCtrl.toggle();
                        });
                    }
                };
                element.bind('click', toggleDropdown);
                element.attr({
                    'aria-haspopup': true,
                    'aria-expanded': false
                });
                scope.$watch(dropdownCtrl.isOpen, function (isOpen) {
                    element.attr('aria-expanded', !!isOpen);
                });
                scope.$on('$destroy', function () {
                    element.unbind('click', toggleDropdown);
                });
            }
        };
    });
    angular.module('ui.bootstrap.stackedMap', []).factory('$$stackedMap', function () {
        return {
            createNew: function () {
                var stack = [];
                return {
                    add: function (key, value) {
                        stack.push({
                            key: key,
                            value: value
                        });
                    },
                    get: function (key) {
                        for (var i = 0; i < stack.length; i++) {
                            if (key === stack[i].key) {
                                return stack[i];
                            }
                        }
                    },
                    keys: function () {
                        var keys = [];
                        for (var i = 0; i < stack.length; i++) {
                            keys.push(stack[i].key);
                        }
                        return keys;
                    },
                    top: function () {
                        return stack[stack.length - 1];
                    },
                    remove: function (key) {
                        var idx = -1;
                        for (var i = 0; i < stack.length; i++) {
                            if (key === stack[i].key) {
                                idx = i;
                                break;
                            }
                        }
                        return stack.splice(idx, 1)[0];
                    },
                    removeTop: function () {
                        return stack.splice(stack.length - 1, 1)[0];
                    },
                    length: function () {
                        return stack.length;
                    }
                };
            }
        };
    });
    angular.module('ui.bootstrap.modal', [
        'ui.bootstrap.stackedMap',
        'ui.bootstrap.position'
    ]).factory('$$multiMap', function () {
        return {
            createNew: function () {
                var map = {};
                return {
                    entries: function () {
                        return Object.keys(map).map(function (key) {
                            return {
                                key: key,
                                value: map[key]
                            };
                        });
                    },
                    get: function (key) {
                        return map[key];
                    },
                    hasKey: function (key) {
                        return !!map[key];
                    },
                    keys: function () {
                        return Object.keys(map);
                    },
                    put: function (key, value) {
                        if (!map[key]) {
                            map[key] = [];
                        }
                        map[key].push(value);
                    },
                    remove: function (key, value) {
                        var values = map[key];
                        if (!values) {
                            return;
                        }
                        var idx = values.indexOf(value);
                        if (idx !== -1) {
                            values.splice(idx, 1);
                        }
                        if (!values.length) {
                            delete map[key];
                        }
                    }
                };
            }
        };
    }).provider('$uibResolve', function () {
        var resolve = this;
        this.resolver = null;
        this.setResolver = function (resolver) {
            this.resolver = resolver;
        };
        this.$get = [
            '$injector',
            '$q',
            function ($injector, $q) {
                var resolver = resolve.resolver ? $injector.get(resolve.resolver) : null;
                return {
                    resolve: function (invocables, locals, parent, self) {
                        if (resolver) {
                            return resolver.resolve(invocables, locals, parent, self);
                        }
                        var promises = [];
                        angular.forEach(invocables, function (value) {
                            if (angular.isFunction(value) || angular.isArray(value)) {
                                promises.push($q.resolve($injector.invoke(value)));
                            } else if (angular.isString(value)) {
                                promises.push($q.resolve($injector.get(value)));
                            } else {
                                promises.push($q.resolve(value));
                            }
                        });
                        return $q.all(promises).then(function (resolves) {
                            var resolveObj = {};
                            var resolveIter = 0;
                            angular.forEach(invocables, function (value, key) {
                                resolveObj[key] = resolves[resolveIter++];
                            });
                            return resolveObj;
                        });
                    }
                };
            }
        ];
    }).directive('uibModalBackdrop', [
        '$animate',
        '$injector',
        '$uibModalStack',
        function ($animate, $injector, $modalStack) {
            return {
                replace: true,
                templateUrl: 'uib/template/modal/backdrop.html',
                compile: function (tElement, tAttrs) {
                    tElement.addClass(tAttrs.backdropClass);
                    return linkFn;
                }
            };
            function linkFn(scope, element, attrs) {
                if (attrs.modalInClass) {
                    $animate.addClass(element, attrs.modalInClass);
                    scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
                        var done = setIsAsync();
                        if (scope.modalOptions.animation) {
                            $animate.removeClass(element, attrs.modalInClass).then(done);
                        } else {
                            done();
                        }
                    });
                }
            }
        }
    ]).directive('uibModalWindow', [
        '$uibModalStack',
        '$q',
        '$animateCss',
        '$document',
        function ($modalStack, $q, $animateCss, $document) {
            return {
                scope: { index: '@' },
                replace: true,
                transclude: true,
                templateUrl: function (tElement, tAttrs) {
                    return tAttrs.templateUrl || 'uib/template/modal/window.html';
                },
                link: function (scope, element, attrs) {
                    element.addClass(attrs.windowClass || '');
                    element.addClass(attrs.windowTopClass || '');
                    scope.size = attrs.size;
                    scope.close = function (evt) {
                        var modal = $modalStack.getTop();
                        if (modal && modal.value.backdrop && modal.value.backdrop !== 'static' && evt.target === evt.currentTarget) {
                            evt.preventDefault();
                            evt.stopPropagation();
                            $modalStack.dismiss(modal.key, 'backdrop click');
                        }
                    };
                    element.on('click', scope.close);
                    scope.$isRendered = true;
                    var modalRenderDeferObj = $q.defer();
                    attrs.$observe('modalRender', function (value) {
                        if (value === 'true') {
                            modalRenderDeferObj.resolve();
                        }
                    });
                    modalRenderDeferObj.promise.then(function () {
                        var animationPromise = null;
                        if (attrs.modalInClass) {
                            animationPromise = $animateCss(element, { addClass: attrs.modalInClass }).start();
                            scope.$on($modalStack.NOW_CLOSING_EVENT, function (e, setIsAsync) {
                                var done = setIsAsync();
                                $animateCss(element, { removeClass: attrs.modalInClass }).start().then(done);
                            });
                        }
                        $q.when(animationPromise).then(function () {
                            var modal = $modalStack.getTop();
                            if (modal) {
                                $modalStack.modalRendered(modal.key);
                            }
                            if (!($document[0].activeElement && element[0].contains($document[0].activeElement))) {
                                var inputWithAutofocus = element[0].querySelector('[autofocus]');
                                if (inputWithAutofocus) {
                                    inputWithAutofocus.focus();
                                } else {
                                    element[0].focus();
                                }
                            }
                        });
                    });
                }
            };
        }
    ]).directive('uibModalAnimationClass', function () {
        return {
            compile: function (tElement, tAttrs) {
                if (tAttrs.modalAnimation) {
                    tElement.addClass(tAttrs.uibModalAnimationClass);
                }
            }
        };
    }).directive('uibModalTransclude', function () {
        return {
            link: function (scope, element, attrs, controller, transclude) {
                transclude(scope.$parent, function (clone) {
                    element.empty();
                    element.append(clone);
                });
            }
        };
    }).factory('$uibModalStack', [
        '$animate',
        '$animateCss',
        '$document',
        '$compile',
        '$rootScope',
        '$q',
        '$$multiMap',
        '$$stackedMap',
        '$uibPosition',
        function ($animate, $animateCss, $document, $compile, $rootScope, $q, $$multiMap, $$stackedMap, $uibPosition) {
            var OPENED_MODAL_CLASS = 'modal-open';
            var backdropDomEl, backdropScope;
            var openedWindows = $$stackedMap.createNew();
            var openedClasses = $$multiMap.createNew();
            var $modalStack = { NOW_CLOSING_EVENT: 'modal.stack.now-closing' };
            var topModalIndex = 0;
            var previousTopOpenedModal = null;
            var tabableSelector = 'a[href], area[href], input:not([disabled]), ' + 'button:not([disabled]),select:not([disabled]), textarea:not([disabled]), ' + 'iframe, object, embed, *[tabindex], *[contenteditable=true]';
            var scrollbarPadding;
            function isVisible(element) {
                return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);
            }
            function backdropIndex() {
                var topBackdropIndex = -1;
                var opened = openedWindows.keys();
                for (var i = 0; i < opened.length; i++) {
                    if (openedWindows.get(opened[i]).value.backdrop) {
                        topBackdropIndex = i;
                    }
                }
                if (topBackdropIndex > -1 && topBackdropIndex < topModalIndex) {
                    topBackdropIndex = topModalIndex;
                }
                return topBackdropIndex;
            }
            $rootScope.$watch(backdropIndex, function (newBackdropIndex) {
                if (backdropScope) {
                    backdropScope.index = newBackdropIndex;
                }
            });
            function removeModalWindow(modalInstance, elementToReceiveFocus) {
                var modalWindow = openedWindows.get(modalInstance).value;
                var appendToElement = modalWindow.appendTo;
                openedWindows.remove(modalInstance);
                previousTopOpenedModal = openedWindows.top();
                if (previousTopOpenedModal) {
                    topModalIndex = parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10);
                }
                removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, function () {
                    var modalBodyClass = modalWindow.openedClass || OPENED_MODAL_CLASS;
                    openedClasses.remove(modalBodyClass, modalInstance);
                    var areAnyOpen = openedClasses.hasKey(modalBodyClass);
                    appendToElement.toggleClass(modalBodyClass, areAnyOpen);
                    if (!areAnyOpen && scrollbarPadding && scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
                        if (scrollbarPadding.originalRight) {
                            appendToElement.css({ paddingRight: scrollbarPadding.originalRight + 'px' });
                        } else {
                            appendToElement.css({ paddingRight: '' });
                        }
                        scrollbarPadding = null;
                    }
                    toggleTopWindowClass(true);
                }, modalWindow.closedDeferred);
                checkRemoveBackdrop();
                if (elementToReceiveFocus && elementToReceiveFocus.focus) {
                    elementToReceiveFocus.focus();
                } else if (appendToElement.focus) {
                    appendToElement.focus();
                }
            }
            function toggleTopWindowClass(toggleSwitch) {
                var modalWindow;
                if (openedWindows.length() > 0) {
                    modalWindow = openedWindows.top().value;
                    modalWindow.modalDomEl.toggleClass(modalWindow.windowTopClass || '', toggleSwitch);
                }
            }
            function checkRemoveBackdrop() {
                if (backdropDomEl && backdropIndex() === -1) {
                    var backdropScopeRef = backdropScope;
                    removeAfterAnimate(backdropDomEl, backdropScope, function () {
                        backdropScopeRef = null;
                    });
                    backdropDomEl = undefined;
                    backdropScope = undefined;
                }
            }
            function removeAfterAnimate(domEl, scope, done, closedDeferred) {
                var asyncDeferred;
                var asyncPromise = null;
                var setIsAsync = function () {
                    if (!asyncDeferred) {
                        asyncDeferred = $q.defer();
                        asyncPromise = asyncDeferred.promise;
                    }
                    return function asyncDone() {
                        asyncDeferred.resolve();
                    };
                };
                scope.$broadcast($modalStack.NOW_CLOSING_EVENT, setIsAsync);
                return $q.when(asyncPromise).then(afterAnimating);
                function afterAnimating() {
                    if (afterAnimating.done) {
                        return;
                    }
                    afterAnimating.done = true;
                    $animate.leave(domEl).then(function () {
                        domEl.remove();
                        if (closedDeferred) {
                            closedDeferred.resolve();
                        }
                    });
                    scope.$destroy();
                    if (done) {
                        done();
                    }
                }
            }
            $document.on('keydown', keydownListener);
            $rootScope.$on('$destroy', function () {
                $document.off('keydown', keydownListener);
            });
            function keydownListener(evt) {
                if (evt.isDefaultPrevented()) {
                    return evt;
                }
                var modal = openedWindows.top();
                if (modal) {
                    switch (evt.which) {
                    case 27: {
                            if (modal.value.keyboard) {
                                evt.preventDefault();
                                $rootScope.$apply(function () {
                                    $modalStack.dismiss(modal.key, 'escape key press');
                                });
                            }
                            break;
                        }
                    case 9: {
                            var list = $modalStack.loadFocusElementList(modal);
                            var focusChanged = false;
                            if (evt.shiftKey) {
                                if ($modalStack.isFocusInFirstItem(evt, list) || $modalStack.isModalFocused(evt, modal)) {
                                    focusChanged = $modalStack.focusLastFocusableElement(list);
                                }
                            } else {
                                if ($modalStack.isFocusInLastItem(evt, list)) {
                                    focusChanged = $modalStack.focusFirstFocusableElement(list);
                                }
                            }
                            if (focusChanged) {
                                evt.preventDefault();
                                evt.stopPropagation();
                            }
                            break;
                        }
                    }
                }
            }
            $modalStack.open = function (modalInstance, modal) {
                var modalOpener = $document[0].activeElement, modalBodyClass = modal.openedClass || OPENED_MODAL_CLASS;
                toggleTopWindowClass(false);
                previousTopOpenedModal = openedWindows.top();
                openedWindows.add(modalInstance, {
                    deferred: modal.deferred,
                    renderDeferred: modal.renderDeferred,
                    closedDeferred: modal.closedDeferred,
                    modalScope: modal.scope,
                    backdrop: modal.backdrop,
                    keyboard: modal.keyboard,
                    openedClass: modal.openedClass,
                    windowTopClass: modal.windowTopClass,
                    animation: modal.animation,
                    appendTo: modal.appendTo
                });
                openedClasses.put(modalBodyClass, modalInstance);
                var appendToElement = modal.appendTo, currBackdropIndex = backdropIndex();
                if (!appendToElement.length) {
                    throw new Error('appendTo element not found. Make sure that the element passed is in DOM.');
                }
                if (currBackdropIndex >= 0 && !backdropDomEl) {
                    backdropScope = $rootScope.$new(true);
                    backdropScope.modalOptions = modal;
                    backdropScope.index = currBackdropIndex;
                    backdropDomEl = angular.element('<div uib-modal-backdrop="modal-backdrop"></div>');
                    backdropDomEl.attr('backdrop-class', modal.backdropClass);
                    if (modal.animation) {
                        backdropDomEl.attr('modal-animation', 'true');
                    }
                    $compile(backdropDomEl)(backdropScope);
                    $animate.enter(backdropDomEl, appendToElement);
                    scrollbarPadding = $uibPosition.scrollbarPadding(appendToElement);
                    if (scrollbarPadding.heightOverflow && scrollbarPadding.scrollbarWidth) {
                        appendToElement.css({ paddingRight: scrollbarPadding.right + 'px' });
                    }
                }
                topModalIndex = previousTopOpenedModal ? parseInt(previousTopOpenedModal.value.modalDomEl.attr('index'), 10) + 1 : 0;
                var angularDomEl = angular.element('<div uib-modal-window="modal-window"></div>');
                angularDomEl.attr({
                    'template-url': modal.windowTemplateUrl,
                    'window-class': modal.windowClass,
                    'window-top-class': modal.windowTopClass,
                    'size': modal.size,
                    'index': topModalIndex,
                    'animate': 'animate'
                }).html(modal.content);
                if (modal.animation) {
                    angularDomEl.attr('modal-animation', 'true');
                }
                appendToElement.addClass(modalBodyClass);
                $animate.enter($compile(angularDomEl)(modal.scope), appendToElement);
                openedWindows.top().value.modalDomEl = angularDomEl;
                openedWindows.top().value.modalOpener = modalOpener;
            };
            function broadcastClosing(modalWindow, resultOrReason, closing) {
                return !modalWindow.value.modalScope.$broadcast('modal.closing', resultOrReason, closing).defaultPrevented;
            }
            $modalStack.close = function (modalInstance, result) {
                var modalWindow = openedWindows.get(modalInstance);
                if (modalWindow && broadcastClosing(modalWindow, result, true)) {
                    modalWindow.value.modalScope.$$uibDestructionScheduled = true;
                    modalWindow.value.deferred.resolve(result);
                    removeModalWindow(modalInstance, modalWindow.value.modalOpener);
                    return true;
                }
                return !modalWindow;
            };
            $modalStack.dismiss = function (modalInstance, reason) {
                var modalWindow = openedWindows.get(modalInstance);
                if (modalWindow && broadcastClosing(modalWindow, reason, false)) {
                    modalWindow.value.modalScope.$$uibDestructionScheduled = true;
                    modalWindow.value.deferred.reject(reason);
                    removeModalWindow(modalInstance, modalWindow.value.modalOpener);
                    return true;
                }
                return !modalWindow;
            };
            $modalStack.dismissAll = function (reason) {
                var topModal = this.getTop();
                while (topModal && this.dismiss(topModal.key, reason)) {
                    topModal = this.getTop();
                }
            };
            $modalStack.getTop = function () {
                return openedWindows.top();
            };
            $modalStack.modalRendered = function (modalInstance) {
                var modalWindow = openedWindows.get(modalInstance);
                if (modalWindow) {
                    modalWindow.value.renderDeferred.resolve();
                }
            };
            $modalStack.focusFirstFocusableElement = function (list) {
                if (list.length > 0) {
                    list[0].focus();
                    return true;
                }
                return false;
            };
            $modalStack.focusLastFocusableElement = function (list) {
                if (list.length > 0) {
                    list[list.length - 1].focus();
                    return true;
                }
                return false;
            };
            $modalStack.isModalFocused = function (evt, modalWindow) {
                if (evt && modalWindow) {
                    var modalDomEl = modalWindow.value.modalDomEl;
                    if (modalDomEl && modalDomEl.length) {
                        return (evt.target || evt.srcElement) === modalDomEl[0];
                    }
                }
                return false;
            };
            $modalStack.isFocusInFirstItem = function (evt, list) {
                if (list.length > 0) {
                    return (evt.target || evt.srcElement) === list[0];
                }
                return false;
            };
            $modalStack.isFocusInLastItem = function (evt, list) {
                if (list.length > 0) {
                    return (evt.target || evt.srcElement) === list[list.length - 1];
                }
                return false;
            };
            $modalStack.loadFocusElementList = function (modalWindow) {
                if (modalWindow) {
                    var modalDomE1 = modalWindow.value.modalDomEl;
                    if (modalDomE1 && modalDomE1.length) {
                        var elements = modalDomE1[0].querySelectorAll(tabableSelector);
                        return elements ? Array.prototype.filter.call(elements, function (element) {
                            return isVisible(element);
                        }) : elements;
                    }
                }
            };
            return $modalStack;
        }
    ]).provider('$uibModal', function () {
        var $modalProvider = {
            options: {
                animation: true,
                backdrop: true,
                keyboard: true
            },
            $get: [
                '$rootScope',
                '$q',
                '$document',
                '$templateRequest',
                '$controller',
                '$uibResolve',
                '$uibModalStack',
                function ($rootScope, $q, $document, $templateRequest, $controller, $uibResolve, $modalStack) {
                    var $modal = {};
                    function getTemplatePromise(options) {
                        return options.template ? $q.when(options.template) : $templateRequest(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl);
                    }
                    var promiseChain = null;
                    $modal.getPromiseChain = function () {
                        return promiseChain;
                    };
                    $modal.open = function (modalOptions) {
                        var modalResultDeferred = $q.defer();
                        var modalOpenedDeferred = $q.defer();
                        var modalClosedDeferred = $q.defer();
                        var modalRenderDeferred = $q.defer();
                        var modalInstance = {
                            result: modalResultDeferred.promise,
                            opened: modalOpenedDeferred.promise,
                            closed: modalClosedDeferred.promise,
                            rendered: modalRenderDeferred.promise,
                            close: function (result) {
                                return $modalStack.close(modalInstance, result);
                            },
                            dismiss: function (reason) {
                                return $modalStack.dismiss(modalInstance, reason);
                            }
                        };
                        modalOptions = angular.extend({}, $modalProvider.options, modalOptions);
                        modalOptions.resolve = modalOptions.resolve || {};
                        modalOptions.appendTo = modalOptions.appendTo || $document.find('body').eq(0);
                        if (!modalOptions.template && !modalOptions.templateUrl) {
                            throw new Error('One of template or templateUrl options is required.');
                        }
                        var templateAndResolvePromise = $q.all([
                            getTemplatePromise(modalOptions),
                            $uibResolve.resolve(modalOptions.resolve, {}, null, null)
                        ]);
                        function resolveWithTemplate() {
                            return templateAndResolvePromise;
                        }
                        var samePromise;
                        samePromise = promiseChain = $q.all([promiseChain]).then(resolveWithTemplate, resolveWithTemplate).then(function resolveSuccess(tplAndVars) {
                            var providedScope = modalOptions.scope || $rootScope;
                            var modalScope = providedScope.$new();
                            modalScope.$close = modalInstance.close;
                            modalScope.$dismiss = modalInstance.dismiss;
                            modalScope.$on('$destroy', function () {
                                if (!modalScope.$$uibDestructionScheduled) {
                                    modalScope.$dismiss('$uibUnscheduledDestruction');
                                }
                            });
                            var ctrlInstance, ctrlInstantiate, ctrlLocals = {};
                            if (modalOptions.controller) {
                                ctrlLocals.$scope = modalScope;
                                ctrlLocals.$scope.$resolve = {};
                                ctrlLocals.$uibModalInstance = modalInstance;
                                angular.forEach(tplAndVars[1], function (value, key) {
                                    ctrlLocals[key] = value;
                                    ctrlLocals.$scope.$resolve[key] = value;
                                });
                                ctrlInstantiate = $controller(modalOptions.controller, ctrlLocals, true, modalOptions.controllerAs);
                                if (modalOptions.controllerAs && modalOptions.bindToController) {
                                    ctrlInstance = ctrlInstantiate.instance;
                                    ctrlInstance.$close = modalScope.$close;
                                    ctrlInstance.$dismiss = modalScope.$dismiss;
                                    angular.extend(ctrlInstance, { $resolve: ctrlLocals.$scope.$resolve }, providedScope);
                                }
                                ctrlInstance = ctrlInstantiate();
                                if (angular.isFunction(ctrlInstance.$onInit)) {
                                    ctrlInstance.$onInit();
                                }
                            }
                            $modalStack.open(modalInstance, {
                                scope: modalScope,
                                deferred: modalResultDeferred,
                                renderDeferred: modalRenderDeferred,
                                closedDeferred: modalClosedDeferred,
                                content: tplAndVars[0],
                                animation: modalOptions.animation,
                                backdrop: modalOptions.backdrop,
                                keyboard: modalOptions.keyboard,
                                backdropClass: modalOptions.backdropClass,
                                windowTopClass: modalOptions.windowTopClass,
                                windowClass: modalOptions.windowClass,
                                windowTemplateUrl: modalOptions.windowTemplateUrl,
                                size: modalOptions.size,
                                openedClass: modalOptions.openedClass,
                                appendTo: modalOptions.appendTo
                            });
                            modalOpenedDeferred.resolve(true);
                        }, function resolveError(reason) {
                            modalOpenedDeferred.reject(reason);
                            modalResultDeferred.reject(reason);
                        })['finally'](function () {
                            if (promiseChain === samePromise) {
                                promiseChain = null;
                            }
                        });
                        return modalInstance;
                    };
                    return $modal;
                }
            ]
        };
        return $modalProvider;
    });
    angular.module('ui.bootstrap.paging', []).factory('uibPaging', [
        '$parse',
        function ($parse) {
            return {
                create: function (ctrl, $scope, $attrs) {
                    ctrl.setNumPages = $attrs.numPages ? $parse($attrs.numPages).assign : angular.noop;
                    ctrl.ngModelCtrl = { $setViewValue: angular.noop };
                    ctrl._watchers = [];
                    ctrl.init = function (ngModelCtrl, config) {
                        ctrl.ngModelCtrl = ngModelCtrl;
                        ctrl.config = config;
                        ngModelCtrl.$render = function () {
                            ctrl.render();
                        };
                        if ($attrs.itemsPerPage) {
                            ctrl._watchers.push($scope.$parent.$watch($attrs.itemsPerPage, function (value) {
                                ctrl.itemsPerPage = parseInt(value, 10);
                                $scope.totalPages = ctrl.calculateTotalPages();
                                ctrl.updatePage();
                            }));
                        } else {
                            ctrl.itemsPerPage = config.itemsPerPage;
                        }
                        $scope.$watch('totalItems', function (newTotal, oldTotal) {
                            if (angular.isDefined(newTotal) || newTotal !== oldTotal) {
                                $scope.totalPages = ctrl.calculateTotalPages();
                                ctrl.updatePage();
                            }
                        });
                    };
                    ctrl.calculateTotalPages = function () {
                        var totalPages = ctrl.itemsPerPage < 1 ? 1 : Math.ceil($scope.totalItems / ctrl.itemsPerPage);
                        return Math.max(totalPages || 0, 1);
                    };
                    ctrl.render = function () {
                        $scope.page = parseInt(ctrl.ngModelCtrl.$viewValue, 10) || 1;
                    };
                    $scope.selectPage = function (page, evt) {
                        if (evt) {
                            evt.preventDefault();
                        }
                        var clickAllowed = !$scope.ngDisabled || !evt;
                        if (clickAllowed && $scope.page !== page && page > 0 && page <= $scope.totalPages) {
                            if (evt && evt.target) {
                                evt.target.blur();
                            }
                            ctrl.ngModelCtrl.$setViewValue(page);
                            ctrl.ngModelCtrl.$render();
                        }
                    };
                    $scope.getText = function (key) {
                        return $scope[key + 'Text'] || ctrl.config[key + 'Text'];
                    };
                    $scope.noPrevious = function () {
                        return $scope.page === 1;
                    };
                    $scope.noNext = function () {
                        return $scope.page === $scope.totalPages;
                    };
                    ctrl.updatePage = function () {
                        ctrl.setNumPages($scope.$parent, $scope.totalPages);
                        if ($scope.page > $scope.totalPages) {
                            $scope.selectPage($scope.totalPages);
                        } else {
                            ctrl.ngModelCtrl.$render();
                        }
                    };
                    $scope.$on('$destroy', function () {
                        while (ctrl._watchers.length) {
                            ctrl._watchers.shift()();
                        }
                    });
                }
            };
        }
    ]);
    angular.module('ui.bootstrap.pager', ['ui.bootstrap.paging']).controller('UibPagerController', [
        '$scope',
        '$attrs',
        'uibPaging',
        'uibPagerConfig',
        function ($scope, $attrs, uibPaging, uibPagerConfig) {
            $scope.align = angular.isDefined($attrs.align) ? $scope.$parent.$eval($attrs.align) : uibPagerConfig.align;
            uibPaging.create(this, $scope, $attrs);
        }
    ]).constant('uibPagerConfig', {
        itemsPerPage: 10,
        previousText: '\xAB Previous',
        nextText: 'Next \xBB',
        align: true
    }).directive('uibPager', [
        'uibPagerConfig',
        function (uibPagerConfig) {
            return {
                scope: {
                    totalItems: '=',
                    previousText: '@',
                    nextText: '@',
                    ngDisabled: '='
                },
                require: [
                    'uibPager',
                    '?ngModel'
                ],
                controller: 'UibPagerController',
                controllerAs: 'pager',
                templateUrl: function (element, attrs) {
                    return attrs.templateUrl || 'uib/template/pager/pager.html';
                },
                replace: true,
                link: function (scope, element, attrs, ctrls) {
                    var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                    if (!ngModelCtrl) {
                        return;
                    }
                    paginationCtrl.init(ngModelCtrl, uibPagerConfig);
                }
            };
        }
    ]);
    angular.module('ui.bootstrap.pagination', ['ui.bootstrap.paging']).controller('UibPaginationController', [
        '$scope',
        '$attrs',
        '$parse',
        'uibPaging',
        'uibPaginationConfig',
        function ($scope, $attrs, $parse, uibPaging, uibPaginationConfig) {
            var ctrl = this;
            var maxSize = angular.isDefined($attrs.maxSize) ? $scope.$parent.$eval($attrs.maxSize) : uibPaginationConfig.maxSize, rotate = angular.isDefined($attrs.rotate) ? $scope.$parent.$eval($attrs.rotate) : uibPaginationConfig.rotate, forceEllipses = angular.isDefined($attrs.forceEllipses) ? $scope.$parent.$eval($attrs.forceEllipses) : uibPaginationConfig.forceEllipses, boundaryLinkNumbers = angular.isDefined($attrs.boundaryLinkNumbers) ? $scope.$parent.$eval($attrs.boundaryLinkNumbers) : uibPaginationConfig.boundaryLinkNumbers, pageLabel = angular.isDefined($attrs.pageLabel) ? function (idx) {
                    return $scope.$parent.$eval($attrs.pageLabel, { $page: idx });
                } : angular.identity;
            $scope.boundaryLinks = angular.isDefined($attrs.boundaryLinks) ? $scope.$parent.$eval($attrs.boundaryLinks) : uibPaginationConfig.boundaryLinks;
            $scope.directionLinks = angular.isDefined($attrs.directionLinks) ? $scope.$parent.$eval($attrs.directionLinks) : uibPaginationConfig.directionLinks;
            uibPaging.create(this, $scope, $attrs);
            if ($attrs.maxSize) {
                ctrl._watchers.push($scope.$parent.$watch($parse($attrs.maxSize), function (value) {
                    maxSize = parseInt(value, 10);
                    ctrl.render();
                }));
            }
            function makePage(number, text, isActive) {
                return {
                    number: number,
                    text: text,
                    active: isActive
                };
            }
            function getPages(currentPage, totalPages) {
                var pages = [];
                var startPage = 1, endPage = totalPages;
                var isMaxSized = angular.isDefined(maxSize) && maxSize < totalPages;
                if (isMaxSized) {
                    if (rotate) {
                        startPage = Math.max(currentPage - Math.floor(maxSize / 2), 1);
                        endPage = startPage + maxSize - 1;
                        if (endPage > totalPages) {
                            endPage = totalPages;
                            startPage = endPage - maxSize + 1;
                        }
                    } else {
                        startPage = (Math.ceil(currentPage / maxSize) - 1) * maxSize + 1;
                        endPage = Math.min(startPage + maxSize - 1, totalPages);
                    }
                }
                for (var number = startPage; number <= endPage; number++) {
                    var page = makePage(number, pageLabel(number), number === currentPage);
                    pages.push(page);
                }
                if (isMaxSized && maxSize > 0 && (!rotate || forceEllipses || boundaryLinkNumbers)) {
                    if (startPage > 1) {
                        if (!boundaryLinkNumbers || startPage > 3) {
                            var previousPageSet = makePage(startPage - 1, '...', false);
                            pages.unshift(previousPageSet);
                        }
                        if (boundaryLinkNumbers) {
                            if (startPage === 3) {
                                var secondPageLink = makePage(2, '2', false);
                                pages.unshift(secondPageLink);
                            }
                            var firstPageLink = makePage(1, '1', false);
                            pages.unshift(firstPageLink);
                        }
                    }
                    if (endPage < totalPages) {
                        if (!boundaryLinkNumbers || endPage < totalPages - 2) {
                            var nextPageSet = makePage(endPage + 1, '...', false);
                            pages.push(nextPageSet);
                        }
                        if (boundaryLinkNumbers) {
                            if (endPage === totalPages - 2) {
                                var secondToLastPageLink = makePage(totalPages - 1, totalPages - 1, false);
                                pages.push(secondToLastPageLink);
                            }
                            var lastPageLink = makePage(totalPages, totalPages, false);
                            pages.push(lastPageLink);
                        }
                    }
                }
                return pages;
            }
            var originalRender = this.render;
            this.render = function () {
                originalRender();
                if ($scope.page > 0 && $scope.page <= $scope.totalPages) {
                    $scope.pages = getPages($scope.page, $scope.totalPages);
                }
            };
        }
    ]).constant('uibPaginationConfig', {
        itemsPerPage: 10,
        boundaryLinks: false,
        boundaryLinkNumbers: false,
        directionLinks: true,
        firstText: 'First',
        previousText: 'Previous',
        nextText: 'Next',
        lastText: 'Last',
        rotate: true,
        forceEllipses: false
    }).directive('uibPagination', [
        '$parse',
        'uibPaginationConfig',
        function ($parse, uibPaginationConfig) {
            return {
                scope: {
                    totalItems: '=',
                    firstText: '@',
                    previousText: '@',
                    nextText: '@',
                    lastText: '@',
                    ngDisabled: '='
                },
                require: [
                    'uibPagination',
                    '?ngModel'
                ],
                controller: 'UibPaginationController',
                controllerAs: 'pagination',
                templateUrl: function (element, attrs) {
                    return attrs.templateUrl || 'uib/template/pagination/pagination.html';
                },
                replace: true,
                link: function (scope, element, attrs, ctrls) {
                    var paginationCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                    if (!ngModelCtrl) {
                        return;
                    }
                    paginationCtrl.init(ngModelCtrl, uibPaginationConfig);
                }
            };
        }
    ]);
    angular.module('ui.bootstrap.tooltip', [
        'ui.bootstrap.position',
        'ui.bootstrap.stackedMap'
    ]).provider('$uibTooltip', function () {
        var defaultOptions = {
            placement: 'top',
            placementClassPrefix: '',
            animation: true,
            popupDelay: 0,
            popupCloseDelay: 0,
            useContentExp: false
        };
        var triggerMap = {
            'mouseenter': 'mouseleave',
            'click': 'click',
            'outsideClick': 'outsideClick',
            'focus': 'blur',
            'none': ''
        };
        var globalOptions = {};
        this.options = function (value) {
            angular.extend(globalOptions, value);
        };
        this.setTriggers = function setTriggers(triggers) {
            angular.extend(triggerMap, triggers);
        };
        function snake_case(name) {
            var regexp = /[A-Z]/g;
            var separator = '-';
            return name.replace(regexp, function (letter, pos) {
                return (pos ? separator : '') + letter.toLowerCase();
            });
        }
        this.$get = [
            '$window',
            '$compile',
            '$timeout',
            '$document',
            '$uibPosition',
            '$interpolate',
            '$rootScope',
            '$parse',
            '$$stackedMap',
            function ($window, $compile, $timeout, $document, $position, $interpolate, $rootScope, $parse, $$stackedMap) {
                var openedTooltips = $$stackedMap.createNew();
                $document.on('keypress', keypressListener);
                $rootScope.$on('$destroy', function () {
                    $document.off('keypress', keypressListener);
                });
                function keypressListener(e) {
                    if (e.which === 27) {
                        var last = openedTooltips.top();
                        if (last) {
                            last.value.close();
                            openedTooltips.removeTop();
                            last = null;
                        }
                    }
                }
                return function $tooltip(ttType, prefix, defaultTriggerShow, options) {
                    options = angular.extend({}, defaultOptions, globalOptions, options);
                    function getTriggers(trigger) {
                        var show = (trigger || options.trigger || defaultTriggerShow).split(' ');
                        var hide = show.map(function (trigger) {
                            return triggerMap[trigger] || trigger;
                        });
                        return {
                            show: show,
                            hide: hide
                        };
                    }
                    var directiveName = snake_case(ttType);
                    var startSym = $interpolate.startSymbol();
                    var endSym = $interpolate.endSymbol();
                    var template = '<div ' + directiveName + '-popup ' + 'uib-title="' + startSym + 'title' + endSym + '" ' + (options.useContentExp ? 'content-exp="contentExp()" ' : 'content="' + startSym + 'content' + endSym + '" ') + 'placement="' + startSym + 'placement' + endSym + '" ' + 'popup-class="' + startSym + 'popupClass' + endSym + '" ' + 'animation="animation" ' + 'is-open="isOpen" ' + 'origin-scope="origScope" ' + 'class="uib-position-measure"' + '>' + '</div>';
                    return {
                        compile: function (tElem, tAttrs) {
                            var tooltipLinker = $compile(template);
                            return function link(scope, element, attrs, tooltipCtrl) {
                                var tooltip;
                                var tooltipLinkedScope;
                                var transitionTimeout;
                                var showTimeout;
                                var hideTimeout;
                                var positionTimeout;
                                var appendToBody = angular.isDefined(options.appendToBody) ? options.appendToBody : false;
                                var triggers = getTriggers(undefined);
                                var hasEnableExp = angular.isDefined(attrs[prefix + 'Enable']);
                                var ttScope = scope.$new(true);
                                var repositionScheduled = false;
                                var isOpenParse = angular.isDefined(attrs[prefix + 'IsOpen']) ? $parse(attrs[prefix + 'IsOpen']) : false;
                                var contentParse = options.useContentExp ? $parse(attrs[ttType]) : false;
                                var observers = [];
                                var lastPlacement;
                                var positionTooltip = function () {
                                    if (!tooltip || !tooltip.html()) {
                                        return;
                                    }
                                    if (!positionTimeout) {
                                        positionTimeout = $timeout(function () {
                                            var ttPosition = $position.positionElements(element, tooltip, ttScope.placement, appendToBody);
                                            tooltip.css({
                                                top: ttPosition.top + 'px',
                                                left: ttPosition.left + 'px'
                                            });
                                            if (!tooltip.hasClass(ttPosition.placement.split('-')[0])) {
                                                tooltip.removeClass(lastPlacement.split('-')[0]);
                                                tooltip.addClass(ttPosition.placement.split('-')[0]);
                                            }
                                            if (!tooltip.hasClass(options.placementClassPrefix + ttPosition.placement)) {
                                                tooltip.removeClass(options.placementClassPrefix + lastPlacement);
                                                tooltip.addClass(options.placementClassPrefix + ttPosition.placement);
                                            }
                                            if (tooltip.hasClass('uib-position-measure')) {
                                                $position.positionArrow(tooltip, ttPosition.placement);
                                                tooltip.removeClass('uib-position-measure');
                                            } else if (lastPlacement !== ttPosition.placement) {
                                                $position.positionArrow(tooltip, ttPosition.placement);
                                            }
                                            lastPlacement = ttPosition.placement;
                                            positionTimeout = null;
                                        }, 0, false);
                                    }
                                };
                                ttScope.origScope = scope;
                                ttScope.isOpen = false;
                                openedTooltips.add(ttScope, { close: hide });
                                function toggleTooltipBind() {
                                    if (!ttScope.isOpen) {
                                        showTooltipBind();
                                    } else {
                                        hideTooltipBind();
                                    }
                                }
                                function showTooltipBind() {
                                    if (hasEnableExp && !scope.$eval(attrs[prefix + 'Enable'])) {
                                        return;
                                    }
                                    cancelHide();
                                    prepareTooltip();
                                    if (ttScope.popupDelay) {
                                        if (!showTimeout) {
                                            showTimeout = $timeout(show, ttScope.popupDelay, false);
                                        }
                                    } else {
                                        show();
                                    }
                                }
                                function hideTooltipBind() {
                                    cancelShow();
                                    if (ttScope.popupCloseDelay) {
                                        if (!hideTimeout) {
                                            hideTimeout = $timeout(hide, ttScope.popupCloseDelay, false);
                                        }
                                    } else {
                                        hide();
                                    }
                                }
                                function show() {
                                    cancelShow();
                                    cancelHide();
                                    if (!ttScope.content) {
                                        return angular.noop;
                                    }
                                    createTooltip();
                                    ttScope.$evalAsync(function () {
                                        ttScope.isOpen = true;
                                        assignIsOpen(true);
                                        positionTooltip();
                                    });
                                }
                                function cancelShow() {
                                    if (showTimeout) {
                                        $timeout.cancel(showTimeout);
                                        showTimeout = null;
                                    }
                                    if (positionTimeout) {
                                        $timeout.cancel(positionTimeout);
                                        positionTimeout = null;
                                    }
                                }
                                function hide() {
                                    if (!ttScope) {
                                        return;
                                    }
                                    ttScope.$evalAsync(function () {
                                        if (ttScope) {
                                            ttScope.isOpen = false;
                                            assignIsOpen(false);
                                            if (ttScope.animation) {
                                                if (!transitionTimeout) {
                                                    transitionTimeout = $timeout(removeTooltip, 150, false);
                                                }
                                            } else {
                                                removeTooltip();
                                            }
                                        }
                                    });
                                }
                                function cancelHide() {
                                    if (hideTimeout) {
                                        $timeout.cancel(hideTimeout);
                                        hideTimeout = null;
                                    }
                                    if (transitionTimeout) {
                                        $timeout.cancel(transitionTimeout);
                                        transitionTimeout = null;
                                    }
                                }
                                function createTooltip() {
                                    if (tooltip) {
                                        return;
                                    }
                                    tooltipLinkedScope = ttScope.$new();
                                    tooltip = tooltipLinker(tooltipLinkedScope, function (tooltip) {
                                        if (appendToBody) {
                                            $document.find('body').append(tooltip);
                                        } else {
                                            element.after(tooltip);
                                        }
                                    });
                                    prepObservers();
                                }
                                function removeTooltip() {
                                    cancelShow();
                                    cancelHide();
                                    unregisterObservers();
                                    if (tooltip) {
                                        tooltip.remove();
                                        tooltip = null;
                                    }
                                    if (tooltipLinkedScope) {
                                        tooltipLinkedScope.$destroy();
                                        tooltipLinkedScope = null;
                                    }
                                }
                                function prepareTooltip() {
                                    ttScope.title = attrs[prefix + 'Title'];
                                    if (contentParse) {
                                        ttScope.content = contentParse(scope);
                                    } else {
                                        ttScope.content = attrs[ttType];
                                    }
                                    ttScope.popupClass = attrs[prefix + 'Class'];
                                    ttScope.placement = angular.isDefined(attrs[prefix + 'Placement']) ? attrs[prefix + 'Placement'] : options.placement;
                                    var placement = $position.parsePlacement(ttScope.placement);
                                    lastPlacement = placement[1] ? placement[0] + '-' + placement[1] : placement[0];
                                    var delay = parseInt(attrs[prefix + 'PopupDelay'], 10);
                                    var closeDelay = parseInt(attrs[prefix + 'PopupCloseDelay'], 10);
                                    ttScope.popupDelay = !isNaN(delay) ? delay : options.popupDelay;
                                    ttScope.popupCloseDelay = !isNaN(closeDelay) ? closeDelay : options.popupCloseDelay;
                                }
                                function assignIsOpen(isOpen) {
                                    if (isOpenParse && angular.isFunction(isOpenParse.assign)) {
                                        isOpenParse.assign(scope, isOpen);
                                    }
                                }
                                ttScope.contentExp = function () {
                                    return ttScope.content;
                                };
                                attrs.$observe('disabled', function (val) {
                                    if (val) {
                                        cancelShow();
                                    }
                                    if (val && ttScope.isOpen) {
                                        hide();
                                    }
                                });
                                if (isOpenParse) {
                                    scope.$watch(isOpenParse, function (val) {
                                        if (ttScope && !val === ttScope.isOpen) {
                                            toggleTooltipBind();
                                        }
                                    });
                                }
                                function prepObservers() {
                                    observers.length = 0;
                                    if (contentParse) {
                                        observers.push(scope.$watch(contentParse, function (val) {
                                            ttScope.content = val;
                                            if (!val && ttScope.isOpen) {
                                                hide();
                                            }
                                        }));
                                        observers.push(tooltipLinkedScope.$watch(function () {
                                            if (!repositionScheduled) {
                                                repositionScheduled = true;
                                                tooltipLinkedScope.$$postDigest(function () {
                                                    repositionScheduled = false;
                                                    if (ttScope && ttScope.isOpen) {
                                                        positionTooltip();
                                                    }
                                                });
                                            }
                                        }));
                                    } else {
                                        observers.push(attrs.$observe(ttType, function (val) {
                                            ttScope.content = val;
                                            if (!val && ttScope.isOpen) {
                                                hide();
                                            } else {
                                                positionTooltip();
                                            }
                                        }));
                                    }
                                    observers.push(attrs.$observe(prefix + 'Title', function (val) {
                                        ttScope.title = val;
                                        if (ttScope.isOpen) {
                                            positionTooltip();
                                        }
                                    }));
                                    observers.push(attrs.$observe(prefix + 'Placement', function (val) {
                                        ttScope.placement = val ? val : options.placement;
                                        if (ttScope.isOpen) {
                                            positionTooltip();
                                        }
                                    }));
                                }
                                function unregisterObservers() {
                                    if (observers.length) {
                                        angular.forEach(observers, function (observer) {
                                            observer();
                                        });
                                        observers.length = 0;
                                    }
                                }
                                function bodyHideTooltipBind(e) {
                                    if (!ttScope || !ttScope.isOpen || !tooltip) {
                                        return;
                                    }
                                    if (!element[0].contains(e.target) && !tooltip[0].contains(e.target)) {
                                        hideTooltipBind();
                                    }
                                }
                                var unregisterTriggers = function () {
                                    triggers.show.forEach(function (trigger) {
                                        if (trigger === 'outsideClick') {
                                            element.off('click', toggleTooltipBind);
                                        } else {
                                            element.off(trigger, showTooltipBind);
                                            element.off(trigger, toggleTooltipBind);
                                        }
                                    });
                                    triggers.hide.forEach(function (trigger) {
                                        if (trigger === 'outsideClick') {
                                            $document.off('click', bodyHideTooltipBind);
                                        } else {
                                            element.off(trigger, hideTooltipBind);
                                        }
                                    });
                                };
                                function prepTriggers() {
                                    var val = attrs[prefix + 'Trigger'];
                                    unregisterTriggers();
                                    triggers = getTriggers(val);
                                    if (triggers.show !== 'none') {
                                        triggers.show.forEach(function (trigger, idx) {
                                            if (trigger === 'outsideClick') {
                                                element.on('click', toggleTooltipBind);
                                                $document.on('click', bodyHideTooltipBind);
                                            } else if (trigger === triggers.hide[idx]) {
                                                element.on(trigger, toggleTooltipBind);
                                            } else if (trigger) {
                                                element.on(trigger, showTooltipBind);
                                                element.on(triggers.hide[idx], hideTooltipBind);
                                            }
                                            element.on('keypress', function (e) {
                                                if (e.which === 27) {
                                                    hideTooltipBind();
                                                }
                                            });
                                        });
                                    }
                                }
                                prepTriggers();
                                var animation = scope.$eval(attrs[prefix + 'Animation']);
                                ttScope.animation = angular.isDefined(animation) ? !!animation : options.animation;
                                var appendToBodyVal;
                                var appendKey = prefix + 'AppendToBody';
                                if (appendKey in attrs && attrs[appendKey] === undefined) {
                                    appendToBodyVal = true;
                                } else {
                                    appendToBodyVal = scope.$eval(attrs[appendKey]);
                                }
                                appendToBody = angular.isDefined(appendToBodyVal) ? appendToBodyVal : appendToBody;
                                scope.$on('$destroy', function onDestroyTooltip() {
                                    unregisterTriggers();
                                    removeTooltip();
                                    openedTooltips.remove(ttScope);
                                    ttScope = null;
                                });
                            };
                        }
                    };
                };
            }
        ];
    }).directive('uibTooltipTemplateTransclude', [
        '$animate',
        '$sce',
        '$compile',
        '$templateRequest',
        function ($animate, $sce, $compile, $templateRequest) {
            return {
                link: function (scope, elem, attrs) {
                    var origScope = scope.$eval(attrs.tooltipTemplateTranscludeScope);
                    var changeCounter = 0, currentScope, previousElement, currentElement;
                    var cleanupLastIncludeContent = function () {
                        if (previousElement) {
                            previousElement.remove();
                            previousElement = null;
                        }
                        if (currentScope) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if (currentElement) {
                            $animate.leave(currentElement).then(function () {
                                previousElement = null;
                            });
                            previousElement = currentElement;
                            currentElement = null;
                        }
                    };
                    scope.$watch($sce.parseAsResourceUrl(attrs.uibTooltipTemplateTransclude), function (src) {
                        var thisChangeId = ++changeCounter;
                        if (src) {
                            $templateRequest(src, true).then(function (response) {
                                if (thisChangeId !== changeCounter) {
                                    return;
                                }
                                var newScope = origScope.$new();
                                var template = response;
                                var clone = $compile(template)(newScope, function (clone) {
                                    cleanupLastIncludeContent();
                                    $animate.enter(clone, elem);
                                });
                                currentScope = newScope;
                                currentElement = clone;
                                currentScope.$emit('$includeContentLoaded', src);
                            }, function () {
                                if (thisChangeId === changeCounter) {
                                    cleanupLastIncludeContent();
                                    scope.$emit('$includeContentError', src);
                                }
                            });
                            scope.$emit('$includeContentRequested', src);
                        } else {
                            cleanupLastIncludeContent();
                        }
                    });
                    scope.$on('$destroy', cleanupLastIncludeContent);
                }
            };
        }
    ]).directive('uibTooltipClasses', [
        '$uibPosition',
        function ($uibPosition) {
            return {
                restrict: 'A',
                link: function (scope, element, attrs) {
                    if (scope.placement) {
                        var position = $uibPosition.parsePlacement(scope.placement);
                        element.addClass(position[0]);
                    }
                    if (scope.popupClass) {
                        element.addClass(scope.popupClass);
                    }
                    if (scope.animation()) {
                        element.addClass(attrs.tooltipAnimationClass);
                    }
                }
            };
        }
    ]).directive('uibTooltipPopup', function () {
        return {
            replace: true,
            scope: {
                content: '@',
                placement: '@',
                popupClass: '@',
                animation: '&',
                isOpen: '&'
            },
            templateUrl: 'uib/template/tooltip/tooltip-popup.html'
        };
    }).directive('uibTooltip', [
        '$uibTooltip',
        function ($uibTooltip) {
            return $uibTooltip('uibTooltip', 'tooltip', 'mouseenter');
        }
    ]).directive('uibTooltipTemplatePopup', function () {
        return {
            replace: true,
            scope: {
                contentExp: '&',
                placement: '@',
                popupClass: '@',
                animation: '&',
                isOpen: '&',
                originScope: '&'
            },
            templateUrl: 'uib/template/tooltip/tooltip-template-popup.html'
        };
    }).directive('uibTooltipTemplate', [
        '$uibTooltip',
        function ($uibTooltip) {
            return $uibTooltip('uibTooltipTemplate', 'tooltip', 'mouseenter', { useContentExp: true });
        }
    ]).directive('uibTooltipHtmlPopup', function () {
        return {
            replace: true,
            scope: {
                contentExp: '&',
                placement: '@',
                popupClass: '@',
                animation: '&',
                isOpen: '&'
            },
            templateUrl: 'uib/template/tooltip/tooltip-html-popup.html'
        };
    }).directive('uibTooltipHtml', [
        '$uibTooltip',
        function ($uibTooltip) {
            return $uibTooltip('uibTooltipHtml', 'tooltip', 'mouseenter', { useContentExp: true });
        }
    ]);
    angular.module('ui.bootstrap.popover', ['ui.bootstrap.tooltip']).directive('uibPopoverTemplatePopup', function () {
        return {
            replace: true,
            scope: {
                uibTitle: '@',
                contentExp: '&',
                placement: '@',
                popupClass: '@',
                animation: '&',
                isOpen: '&',
                originScope: '&'
            },
            templateUrl: 'uib/template/popover/popover-template.html'
        };
    }).directive('uibPopoverTemplate', [
        '$uibTooltip',
        function ($uibTooltip) {
            return $uibTooltip('uibPopoverTemplate', 'popover', 'click', { useContentExp: true });
        }
    ]).directive('uibPopoverHtmlPopup', function () {
        return {
            replace: true,
            scope: {
                contentExp: '&',
                uibTitle: '@',
                placement: '@',
                popupClass: '@',
                animation: '&',
                isOpen: '&'
            },
            templateUrl: 'uib/template/popover/popover-html.html'
        };
    }).directive('uibPopoverHtml', [
        '$uibTooltip',
        function ($uibTooltip) {
            return $uibTooltip('uibPopoverHtml', 'popover', 'click', { useContentExp: true });
        }
    ]).directive('uibPopoverPopup', function () {
        return {
            replace: true,
            scope: {
                uibTitle: '@',
                content: '@',
                placement: '@',
                popupClass: '@',
                animation: '&',
                isOpen: '&'
            },
            templateUrl: 'uib/template/popover/popover.html'
        };
    }).directive('uibPopover', [
        '$uibTooltip',
        function ($uibTooltip) {
            return $uibTooltip('uibPopover', 'popover', 'click');
        }
    ]);
    angular.module('ui.bootstrap.progressbar', []).constant('uibProgressConfig', {
        animate: true,
        max: 100
    }).controller('UibProgressController', [
        '$scope',
        '$attrs',
        'uibProgressConfig',
        function ($scope, $attrs, progressConfig) {
            var self = this, animate = angular.isDefined($attrs.animate) ? $scope.$parent.$eval($attrs.animate) : progressConfig.animate;
            this.bars = [];
            $scope.max = getMaxOrDefault();
            this.addBar = function (bar, element, attrs) {
                if (!animate) {
                    element.css({ 'transition': 'none' });
                }
                this.bars.push(bar);
                bar.max = getMaxOrDefault();
                bar.title = attrs && angular.isDefined(attrs.title) ? attrs.title : 'progressbar';
                bar.$watch('value', function (value) {
                    bar.recalculatePercentage();
                });
                bar.recalculatePercentage = function () {
                    var totalPercentage = self.bars.reduce(function (total, bar) {
                        bar.percent = +(100 * bar.value / bar.max).toFixed(2);
                        return total + bar.percent;
                    }, 0);
                    if (totalPercentage > 100) {
                        bar.percent -= totalPercentage - 100;
                    }
                };
                bar.$on('$destroy', function () {
                    element = null;
                    self.removeBar(bar);
                });
            };
            this.removeBar = function (bar) {
                this.bars.splice(this.bars.indexOf(bar), 1);
                this.bars.forEach(function (bar) {
                    bar.recalculatePercentage();
                });
            };
            $scope.$watch('maxParam', function (maxParam) {
                self.bars.forEach(function (bar) {
                    bar.max = getMaxOrDefault();
                    bar.recalculatePercentage();
                });
            });
            function getMaxOrDefault() {
                return angular.isDefined($scope.maxParam) ? $scope.maxParam : progressConfig.max;
            }
        }
    ]).directive('uibProgress', function () {
        return {
            replace: true,
            transclude: true,
            controller: 'UibProgressController',
            require: 'uibProgress',
            scope: { maxParam: '=?max' },
            templateUrl: 'uib/template/progressbar/progress.html'
        };
    }).directive('uibBar', function () {
        return {
            replace: true,
            transclude: true,
            require: '^uibProgress',
            scope: {
                value: '=',
                type: '@'
            },
            templateUrl: 'uib/template/progressbar/bar.html',
            link: function (scope, element, attrs, progressCtrl) {
                progressCtrl.addBar(scope, element, attrs);
            }
        };
    }).directive('uibProgressbar', function () {
        return {
            replace: true,
            transclude: true,
            controller: 'UibProgressController',
            scope: {
                value: '=',
                maxParam: '=?max',
                type: '@'
            },
            templateUrl: 'uib/template/progressbar/progressbar.html',
            link: function (scope, element, attrs, progressCtrl) {
                progressCtrl.addBar(scope, angular.element(element.children()[0]), { title: attrs.title });
            }
        };
    });
    angular.module('ui.bootstrap.rating', []).constant('uibRatingConfig', {
        max: 5,
        stateOn: null,
        stateOff: null,
        enableReset: true,
        titles: [
            'one',
            'two',
            'three',
            'four',
            'five'
        ]
    }).controller('UibRatingController', [
        '$scope',
        '$attrs',
        'uibRatingConfig',
        function ($scope, $attrs, ratingConfig) {
            var ngModelCtrl = { $setViewValue: angular.noop }, self = this;
            this.init = function (ngModelCtrl_) {
                ngModelCtrl = ngModelCtrl_;
                ngModelCtrl.$render = this.render;
                ngModelCtrl.$formatters.push(function (value) {
                    if (angular.isNumber(value) && value << 0 !== value) {
                        value = Math.round(value);
                    }
                    return value;
                });
                this.stateOn = angular.isDefined($attrs.stateOn) ? $scope.$parent.$eval($attrs.stateOn) : ratingConfig.stateOn;
                this.stateOff = angular.isDefined($attrs.stateOff) ? $scope.$parent.$eval($attrs.stateOff) : ratingConfig.stateOff;
                this.enableReset = angular.isDefined($attrs.enableReset) ? $scope.$parent.$eval($attrs.enableReset) : ratingConfig.enableReset;
                var tmpTitles = angular.isDefined($attrs.titles) ? $scope.$parent.$eval($attrs.titles) : ratingConfig.titles;
                this.titles = angular.isArray(tmpTitles) && tmpTitles.length > 0 ? tmpTitles : ratingConfig.titles;
                var ratingStates = angular.isDefined($attrs.ratingStates) ? $scope.$parent.$eval($attrs.ratingStates) : new Array(angular.isDefined($attrs.max) ? $scope.$parent.$eval($attrs.max) : ratingConfig.max);
                $scope.range = this.buildTemplateObjects(ratingStates);
            };
            this.buildTemplateObjects = function (states) {
                for (var i = 0, n = states.length; i < n; i++) {
                    states[i] = angular.extend({ index: i }, {
                        stateOn: this.stateOn,
                        stateOff: this.stateOff,
                        title: this.getTitle(i)
                    }, states[i]);
                }
                return states;
            };
            this.getTitle = function (index) {
                if (index >= this.titles.length) {
                    return index + 1;
                }
                return this.titles[index];
            };
            $scope.rate = function (value) {
                if (!$scope.readonly && value >= 0 && value <= $scope.range.length) {
                    var newViewValue = self.enableReset && ngModelCtrl.$viewValue === value ? 0 : value;
                    ngModelCtrl.$setViewValue(newViewValue);
                    ngModelCtrl.$render();
                }
            };
            $scope.enter = function (value) {
                if (!$scope.readonly) {
                    $scope.value = value;
                }
                $scope.onHover({ value: value });
            };
            $scope.reset = function () {
                $scope.value = ngModelCtrl.$viewValue;
                $scope.onLeave();
            };
            $scope.onKeydown = function (evt) {
                if (/(37|38|39|40)/.test(evt.which)) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    $scope.rate($scope.value + (evt.which === 38 || evt.which === 39 ? 1 : -1));
                }
            };
            this.render = function () {
                $scope.value = ngModelCtrl.$viewValue;
                $scope.title = self.getTitle($scope.value - 1);
            };
        }
    ]).directive('uibRating', function () {
        return {
            require: [
                'uibRating',
                'ngModel'
            ],
            scope: {
                readonly: '=?readOnly',
                onHover: '&',
                onLeave: '&'
            },
            controller: 'UibRatingController',
            templateUrl: 'uib/template/rating/rating.html',
            replace: true,
            link: function (scope, element, attrs, ctrls) {
                var ratingCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                ratingCtrl.init(ngModelCtrl);
            }
        };
    });
    angular.module('ui.bootstrap.tabs', []).controller('UibTabsetController', [
        '$scope',
        function ($scope) {
            var ctrl = this, oldIndex;
            ctrl.tabs = [];
            ctrl.select = function (index, evt) {
                if (!destroyed) {
                    var previousIndex = findTabIndex(oldIndex);
                    var previousSelected = ctrl.tabs[previousIndex];
                    if (previousSelected) {
                        previousSelected.tab.onDeselect({
                            $event: evt,
                            $selectedIndex: index
                        });
                        if (evt && evt.isDefaultPrevented()) {
                            return;
                        }
                        previousSelected.tab.active = false;
                    }
                    var selected = ctrl.tabs[index];
                    if (selected) {
                        selected.tab.onSelect({ $event: evt });
                        selected.tab.active = true;
                        ctrl.active = selected.index;
                        oldIndex = selected.index;
                    } else if (!selected && angular.isDefined(oldIndex)) {
                        ctrl.active = null;
                        oldIndex = null;
                    }
                }
            };
            ctrl.addTab = function addTab(tab) {
                ctrl.tabs.push({
                    tab: tab,
                    index: tab.index
                });
                ctrl.tabs.sort(function (t1, t2) {
                    if (t1.index > t2.index) {
                        return 1;
                    }
                    if (t1.index < t2.index) {
                        return -1;
                    }
                    return 0;
                });
                if (tab.index === ctrl.active || !angular.isDefined(ctrl.active) && ctrl.tabs.length === 1) {
                    var newActiveIndex = findTabIndex(tab.index);
                    ctrl.select(newActiveIndex);
                }
            };
            ctrl.removeTab = function removeTab(tab) {
                var index;
                for (var i = 0; i < ctrl.tabs.length; i++) {
                    if (ctrl.tabs[i].tab === tab) {
                        index = i;
                        break;
                    }
                }
                if (ctrl.tabs[index].index === ctrl.active) {
                    var newActiveTabIndex = index === ctrl.tabs.length - 1 ? index - 1 : index + 1 % ctrl.tabs.length;
                    ctrl.select(newActiveTabIndex);
                }
                ctrl.tabs.splice(index, 1);
            };
            $scope.$watch('tabset.active', function (val) {
                if (angular.isDefined(val) && val !== oldIndex) {
                    ctrl.select(findTabIndex(val));
                }
            });
            var destroyed;
            $scope.$on('$destroy', function () {
                destroyed = true;
            });
            function findTabIndex(index) {
                for (var i = 0; i < ctrl.tabs.length; i++) {
                    if (ctrl.tabs[i].index === index) {
                        return i;
                    }
                }
            }
        }
    ]).directive('uibTabset', function () {
        return {
            transclude: true,
            replace: true,
            scope: {},
            bindToController: {
                active: '=?',
                type: '@'
            },
            controller: 'UibTabsetController',
            controllerAs: 'tabset',
            templateUrl: function (element, attrs) {
                return attrs.templateUrl || 'uib/template/tabs/tabset.html';
            },
            link: function (scope, element, attrs) {
                scope.vertical = angular.isDefined(attrs.vertical) ? scope.$parent.$eval(attrs.vertical) : false;
                scope.justified = angular.isDefined(attrs.justified) ? scope.$parent.$eval(attrs.justified) : false;
            }
        };
    }).directive('uibTab', [
        '$parse',
        function ($parse) {
            return {
                require: '^uibTabset',
                replace: true,
                templateUrl: function (element, attrs) {
                    return attrs.templateUrl || 'uib/template/tabs/tab.html';
                },
                transclude: true,
                scope: {
                    heading: '@',
                    index: '=?',
                    classes: '@?',
                    onSelect: '&select',
                    onDeselect: '&deselect'
                },
                controller: function () {
                },
                controllerAs: 'tab',
                link: function (scope, elm, attrs, tabsetCtrl, transclude) {
                    scope.disabled = false;
                    if (attrs.disable) {
                        scope.$parent.$watch($parse(attrs.disable), function (value) {
                            scope.disabled = !!value;
                        });
                    }
                    if (angular.isUndefined(attrs.index)) {
                        if (tabsetCtrl.tabs && tabsetCtrl.tabs.length) {
                            scope.index = Math.max.apply(null, tabsetCtrl.tabs.map(function (t) {
                                return t.index;
                            })) + 1;
                        } else {
                            scope.index = 0;
                        }
                    }
                    if (angular.isUndefined(attrs.classes)) {
                        scope.classes = '';
                    }
                    scope.select = function (evt) {
                        if (!scope.disabled) {
                            var index;
                            for (var i = 0; i < tabsetCtrl.tabs.length; i++) {
                                if (tabsetCtrl.tabs[i].tab === scope) {
                                    index = i;
                                    break;
                                }
                            }
                            tabsetCtrl.select(index, evt);
                        }
                    };
                    tabsetCtrl.addTab(scope);
                    scope.$on('$destroy', function () {
                        tabsetCtrl.removeTab(scope);
                    });
                    scope.$transcludeFn = transclude;
                }
            };
        }
    ]).directive('uibTabHeadingTransclude', function () {
        return {
            restrict: 'A',
            require: '^uibTab',
            link: function (scope, elm) {
                scope.$watch('headingElement', function updateHeadingElement(heading) {
                    if (heading) {
                        elm.html('');
                        elm.append(heading);
                    }
                });
            }
        };
    }).directive('uibTabContentTransclude', function () {
        return {
            restrict: 'A',
            require: '^uibTabset',
            link: function (scope, elm, attrs) {
                var tab = scope.$eval(attrs.uibTabContentTransclude).tab;
                tab.$transcludeFn(tab.$parent, function (contents) {
                    angular.forEach(contents, function (node) {
                        if (isTabHeading(node)) {
                            tab.headingElement = node;
                        } else {
                            elm.append(node);
                        }
                    });
                });
            }
        };
        function isTabHeading(node) {
            return node.tagName && (node.hasAttribute('uib-tab-heading') || node.hasAttribute('data-uib-tab-heading') || node.hasAttribute('x-uib-tab-heading') || node.tagName.toLowerCase() === 'uib-tab-heading' || node.tagName.toLowerCase() === 'data-uib-tab-heading' || node.tagName.toLowerCase() === 'x-uib-tab-heading' || node.tagName.toLowerCase() === 'uib:tab-heading');
        }
    });
    angular.module('ui.bootstrap.timepicker', []).constant('uibTimepickerConfig', {
        hourStep: 1,
        minuteStep: 1,
        secondStep: 1,
        showMeridian: true,
        showSeconds: false,
        meridians: null,
        readonlyInput: false,
        mousewheel: true,
        arrowkeys: true,
        showSpinners: true,
        templateUrl: 'uib/template/timepicker/timepicker.html'
    }).controller('UibTimepickerController', [
        '$scope',
        '$element',
        '$attrs',
        '$parse',
        '$log',
        '$locale',
        'uibTimepickerConfig',
        function ($scope, $element, $attrs, $parse, $log, $locale, timepickerConfig) {
            var selected = new Date(), watchers = [], ngModelCtrl = { $setViewValue: angular.noop }, meridians = angular.isDefined($attrs.meridians) ? $scope.$parent.$eval($attrs.meridians) : timepickerConfig.meridians || $locale.DATETIME_FORMATS.AMPMS, padHours = angular.isDefined($attrs.padHours) ? $scope.$parent.$eval($attrs.padHours) : true;
            $scope.tabindex = angular.isDefined($attrs.tabindex) ? $attrs.tabindex : 0;
            $element.removeAttr('tabindex');
            this.init = function (ngModelCtrl_, inputs) {
                ngModelCtrl = ngModelCtrl_;
                ngModelCtrl.$render = this.render;
                ngModelCtrl.$formatters.unshift(function (modelValue) {
                    return modelValue ? new Date(modelValue) : null;
                });
                var hoursInputEl = inputs.eq(0), minutesInputEl = inputs.eq(1), secondsInputEl = inputs.eq(2);
                var mousewheel = angular.isDefined($attrs.mousewheel) ? $scope.$parent.$eval($attrs.mousewheel) : timepickerConfig.mousewheel;
                if (mousewheel) {
                    this.setupMousewheelEvents(hoursInputEl, minutesInputEl, secondsInputEl);
                }
                var arrowkeys = angular.isDefined($attrs.arrowkeys) ? $scope.$parent.$eval($attrs.arrowkeys) : timepickerConfig.arrowkeys;
                if (arrowkeys) {
                    this.setupArrowkeyEvents(hoursInputEl, minutesInputEl, secondsInputEl);
                }
                $scope.readonlyInput = angular.isDefined($attrs.readonlyInput) ? $scope.$parent.$eval($attrs.readonlyInput) : timepickerConfig.readonlyInput;
                this.setupInputEvents(hoursInputEl, minutesInputEl, secondsInputEl);
            };
            var hourStep = timepickerConfig.hourStep;
            if ($attrs.hourStep) {
                watchers.push($scope.$parent.$watch($parse($attrs.hourStep), function (value) {
                    hourStep = +value;
                }));
            }
            var minuteStep = timepickerConfig.minuteStep;
            if ($attrs.minuteStep) {
                watchers.push($scope.$parent.$watch($parse($attrs.minuteStep), function (value) {
                    minuteStep = +value;
                }));
            }
            var min;
            watchers.push($scope.$parent.$watch($parse($attrs.min), function (value) {
                var dt = new Date(value);
                min = isNaN(dt) ? undefined : dt;
            }));
            var max;
            watchers.push($scope.$parent.$watch($parse($attrs.max), function (value) {
                var dt = new Date(value);
                max = isNaN(dt) ? undefined : dt;
            }));
            var disabled = false;
            if ($attrs.ngDisabled) {
                watchers.push($scope.$parent.$watch($parse($attrs.ngDisabled), function (value) {
                    disabled = value;
                }));
            }
            $scope.noIncrementHours = function () {
                var incrementedSelected = addMinutes(selected, hourStep * 60);
                return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
            };
            $scope.noDecrementHours = function () {
                var decrementedSelected = addMinutes(selected, -hourStep * 60);
                return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
            };
            $scope.noIncrementMinutes = function () {
                var incrementedSelected = addMinutes(selected, minuteStep);
                return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
            };
            $scope.noDecrementMinutes = function () {
                var decrementedSelected = addMinutes(selected, -minuteStep);
                return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
            };
            $scope.noIncrementSeconds = function () {
                var incrementedSelected = addSeconds(selected, secondStep);
                return disabled || incrementedSelected > max || incrementedSelected < selected && incrementedSelected < min;
            };
            $scope.noDecrementSeconds = function () {
                var decrementedSelected = addSeconds(selected, -secondStep);
                return disabled || decrementedSelected < min || decrementedSelected > selected && decrementedSelected > max;
            };
            $scope.noToggleMeridian = function () {
                if (selected.getHours() < 12) {
                    return disabled || addMinutes(selected, 12 * 60) > max;
                }
                return disabled || addMinutes(selected, -12 * 60) < min;
            };
            var secondStep = timepickerConfig.secondStep;
            if ($attrs.secondStep) {
                watchers.push($scope.$parent.$watch($parse($attrs.secondStep), function (value) {
                    secondStep = +value;
                }));
            }
            $scope.showSeconds = timepickerConfig.showSeconds;
            if ($attrs.showSeconds) {
                watchers.push($scope.$parent.$watch($parse($attrs.showSeconds), function (value) {
                    $scope.showSeconds = !!value;
                }));
            }
            $scope.showMeridian = timepickerConfig.showMeridian;
            if ($attrs.showMeridian) {
                watchers.push($scope.$parent.$watch($parse($attrs.showMeridian), function (value) {
                    $scope.showMeridian = !!value;
                    if (ngModelCtrl.$error.time) {
                        var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
                        if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                            selected.setHours(hours);
                            refresh();
                        }
                    } else {
                        updateTemplate();
                    }
                }));
            }
            function getHoursFromTemplate() {
                var hours = +$scope.hours;
                var valid = $scope.showMeridian ? hours > 0 && hours < 13 : hours >= 0 && hours < 24;
                if (!valid || $scope.hours === '') {
                    return undefined;
                }
                if ($scope.showMeridian) {
                    if (hours === 12) {
                        hours = 0;
                    }
                    if ($scope.meridian === meridians[1]) {
                        hours = hours + 12;
                    }
                }
                return hours;
            }
            function getMinutesFromTemplate() {
                var minutes = +$scope.minutes;
                var valid = minutes >= 0 && minutes < 60;
                if (!valid || $scope.minutes === '') {
                    return undefined;
                }
                return minutes;
            }
            function getSecondsFromTemplate() {
                var seconds = +$scope.seconds;
                return seconds >= 0 && seconds < 60 ? seconds : undefined;
            }
            function pad(value, noPad) {
                if (value === null) {
                    return '';
                }
                return angular.isDefined(value) && value.toString().length < 2 && !noPad ? '0' + value : value.toString();
            }
            this.setupMousewheelEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
                var isScrollingUp = function (e) {
                    if (e.originalEvent) {
                        e = e.originalEvent;
                    }
                    var delta = e.wheelDelta ? e.wheelDelta : -e.deltaY;
                    return e.detail || delta > 0;
                };
                hoursInputEl.bind('mousewheel wheel', function (e) {
                    if (!disabled) {
                        $scope.$apply(isScrollingUp(e) ? $scope.incrementHours() : $scope.decrementHours());
                    }
                    e.preventDefault();
                });
                minutesInputEl.bind('mousewheel wheel', function (e) {
                    if (!disabled) {
                        $scope.$apply(isScrollingUp(e) ? $scope.incrementMinutes() : $scope.decrementMinutes());
                    }
                    e.preventDefault();
                });
                secondsInputEl.bind('mousewheel wheel', function (e) {
                    if (!disabled) {
                        $scope.$apply(isScrollingUp(e) ? $scope.incrementSeconds() : $scope.decrementSeconds());
                    }
                    e.preventDefault();
                });
            };
            this.setupArrowkeyEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
                hoursInputEl.bind('keydown', function (e) {
                    if (!disabled) {
                        if (e.which === 38) {
                            e.preventDefault();
                            $scope.incrementHours();
                            $scope.$apply();
                        } else if (e.which === 40) {
                            e.preventDefault();
                            $scope.decrementHours();
                            $scope.$apply();
                        }
                    }
                });
                minutesInputEl.bind('keydown', function (e) {
                    if (!disabled) {
                        if (e.which === 38) {
                            e.preventDefault();
                            $scope.incrementMinutes();
                            $scope.$apply();
                        } else if (e.which === 40) {
                            e.preventDefault();
                            $scope.decrementMinutes();
                            $scope.$apply();
                        }
                    }
                });
                secondsInputEl.bind('keydown', function (e) {
                    if (!disabled) {
                        if (e.which === 38) {
                            e.preventDefault();
                            $scope.incrementSeconds();
                            $scope.$apply();
                        } else if (e.which === 40) {
                            e.preventDefault();
                            $scope.decrementSeconds();
                            $scope.$apply();
                        }
                    }
                });
            };
            this.setupInputEvents = function (hoursInputEl, minutesInputEl, secondsInputEl) {
                if ($scope.readonlyInput) {
                    $scope.updateHours = angular.noop;
                    $scope.updateMinutes = angular.noop;
                    $scope.updateSeconds = angular.noop;
                    return;
                }
                var invalidate = function (invalidHours, invalidMinutes, invalidSeconds) {
                    ngModelCtrl.$setViewValue(null);
                    ngModelCtrl.$setValidity('time', false);
                    if (angular.isDefined(invalidHours)) {
                        $scope.invalidHours = invalidHours;
                    }
                    if (angular.isDefined(invalidMinutes)) {
                        $scope.invalidMinutes = invalidMinutes;
                    }
                    if (angular.isDefined(invalidSeconds)) {
                        $scope.invalidSeconds = invalidSeconds;
                    }
                };
                $scope.updateHours = function () {
                    var hours = getHoursFromTemplate(), minutes = getMinutesFromTemplate();
                    ngModelCtrl.$setDirty();
                    if (angular.isDefined(hours) && angular.isDefined(minutes)) {
                        selected.setHours(hours);
                        selected.setMinutes(minutes);
                        if (selected < min || selected > max) {
                            invalidate(true);
                        } else {
                            refresh('h');
                        }
                    } else {
                        invalidate(true);
                    }
                };
                hoursInputEl.bind('blur', function (e) {
                    ngModelCtrl.$setTouched();
                    if (modelIsEmpty()) {
                        makeValid();
                    } else if ($scope.hours === null || $scope.hours === '') {
                        invalidate(true);
                    } else if (!$scope.invalidHours && $scope.hours < 10) {
                        $scope.$apply(function () {
                            $scope.hours = pad($scope.hours, !padHours);
                        });
                    }
                });
                $scope.updateMinutes = function () {
                    var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
                    ngModelCtrl.$setDirty();
                    if (angular.isDefined(minutes) && angular.isDefined(hours)) {
                        selected.setHours(hours);
                        selected.setMinutes(minutes);
                        if (selected < min || selected > max) {
                            invalidate(undefined, true);
                        } else {
                            refresh('m');
                        }
                    } else {
                        invalidate(undefined, true);
                    }
                };
                minutesInputEl.bind('blur', function (e) {
                    ngModelCtrl.$setTouched();
                    if (modelIsEmpty()) {
                        makeValid();
                    } else if ($scope.minutes === null) {
                        invalidate(undefined, true);
                    } else if (!$scope.invalidMinutes && $scope.minutes < 10) {
                        $scope.$apply(function () {
                            $scope.minutes = pad($scope.minutes);
                        });
                    }
                });
                $scope.updateSeconds = function () {
                    var seconds = getSecondsFromTemplate();
                    ngModelCtrl.$setDirty();
                    if (angular.isDefined(seconds)) {
                        selected.setSeconds(seconds);
                        refresh('s');
                    } else {
                        invalidate(undefined, undefined, true);
                    }
                };
                secondsInputEl.bind('blur', function (e) {
                    if (modelIsEmpty()) {
                        makeValid();
                    } else if (!$scope.invalidSeconds && $scope.seconds < 10) {
                        $scope.$apply(function () {
                            $scope.seconds = pad($scope.seconds);
                        });
                    }
                });
            };
            this.render = function () {
                var date = ngModelCtrl.$viewValue;
                if (isNaN(date)) {
                    ngModelCtrl.$setValidity('time', false);
                    $log.error('Timepicker directive: "ng-model" value must be a Date object, a number of milliseconds since 01.01.1970 or a string representing an RFC2822 or ISO 8601 date.');
                } else {
                    if (date) {
                        selected = date;
                    }
                    if (selected < min || selected > max) {
                        ngModelCtrl.$setValidity('time', false);
                        $scope.invalidHours = true;
                        $scope.invalidMinutes = true;
                    } else {
                        makeValid();
                    }
                    updateTemplate();
                }
            };
            function refresh(keyboardChange) {
                makeValid();
                ngModelCtrl.$setViewValue(new Date(selected));
                updateTemplate(keyboardChange);
            }
            function makeValid() {
                ngModelCtrl.$setValidity('time', true);
                $scope.invalidHours = false;
                $scope.invalidMinutes = false;
                $scope.invalidSeconds = false;
            }
            function updateTemplate(keyboardChange) {
                if (!ngModelCtrl.$modelValue) {
                    $scope.hours = null;
                    $scope.minutes = null;
                    $scope.seconds = null;
                    $scope.meridian = meridians[0];
                } else {
                    var hours = selected.getHours(), minutes = selected.getMinutes(), seconds = selected.getSeconds();
                    if ($scope.showMeridian) {
                        hours = hours === 0 || hours === 12 ? 12 : hours % 12;
                    }
                    $scope.hours = keyboardChange === 'h' ? hours : pad(hours, !padHours);
                    if (keyboardChange !== 'm') {
                        $scope.minutes = pad(minutes);
                    }
                    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
                    if (keyboardChange !== 's') {
                        $scope.seconds = pad(seconds);
                    }
                    $scope.meridian = selected.getHours() < 12 ? meridians[0] : meridians[1];
                }
            }
            function addSecondsToSelected(seconds) {
                selected = addSeconds(selected, seconds);
                refresh();
            }
            function addMinutes(selected, minutes) {
                return addSeconds(selected, minutes * 60);
            }
            function addSeconds(date, seconds) {
                var dt = new Date(date.getTime() + seconds * 1000);
                var newDate = new Date(date);
                newDate.setHours(dt.getHours(), dt.getMinutes(), dt.getSeconds());
                return newDate;
            }
            function modelIsEmpty() {
                return ($scope.hours === null || $scope.hours === '') && ($scope.minutes === null || $scope.minutes === '') && (!$scope.showSeconds || $scope.showSeconds && ($scope.seconds === null || $scope.seconds === ''));
            }
            $scope.showSpinners = angular.isDefined($attrs.showSpinners) ? $scope.$parent.$eval($attrs.showSpinners) : timepickerConfig.showSpinners;
            $scope.incrementHours = function () {
                if (!$scope.noIncrementHours()) {
                    addSecondsToSelected(hourStep * 60 * 60);
                }
            };
            $scope.decrementHours = function () {
                if (!$scope.noDecrementHours()) {
                    addSecondsToSelected(-hourStep * 60 * 60);
                }
            };
            $scope.incrementMinutes = function () {
                if (!$scope.noIncrementMinutes()) {
                    addSecondsToSelected(minuteStep * 60);
                }
            };
            $scope.decrementMinutes = function () {
                if (!$scope.noDecrementMinutes()) {
                    addSecondsToSelected(-minuteStep * 60);
                }
            };
            $scope.incrementSeconds = function () {
                if (!$scope.noIncrementSeconds()) {
                    addSecondsToSelected(secondStep);
                }
            };
            $scope.decrementSeconds = function () {
                if (!$scope.noDecrementSeconds()) {
                    addSecondsToSelected(-secondStep);
                }
            };
            $scope.toggleMeridian = function () {
                var minutes = getMinutesFromTemplate(), hours = getHoursFromTemplate();
                if (!$scope.noToggleMeridian()) {
                    if (angular.isDefined(minutes) && angular.isDefined(hours)) {
                        addSecondsToSelected(12 * 60 * (selected.getHours() < 12 ? 60 : -60));
                    } else {
                        $scope.meridian = $scope.meridian === meridians[0] ? meridians[1] : meridians[0];
                    }
                }
            };
            $scope.blur = function () {
                ngModelCtrl.$setTouched();
            };
            $scope.$on('$destroy', function () {
                while (watchers.length) {
                    watchers.shift()();
                }
            });
        }
    ]).directive('uibTimepicker', [
        'uibTimepickerConfig',
        function (uibTimepickerConfig) {
            return {
                require: [
                    'uibTimepicker',
                    '?^ngModel'
                ],
                controller: 'UibTimepickerController',
                controllerAs: 'timepicker',
                replace: true,
                scope: {},
                templateUrl: function (element, attrs) {
                    return attrs.templateUrl || uibTimepickerConfig.templateUrl;
                },
                link: function (scope, element, attrs, ctrls) {
                    var timepickerCtrl = ctrls[0], ngModelCtrl = ctrls[1];
                    if (ngModelCtrl) {
                        timepickerCtrl.init(ngModelCtrl, element.find('input'));
                    }
                }
            };
        }
    ]);
    angular.module('ui.bootstrap.typeahead', [
        'ui.bootstrap.debounce',
        'ui.bootstrap.position'
    ]).factory('uibTypeaheadParser', [
        '$parse',
        function ($parse) {
            var TYPEAHEAD_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w\d]*))\s+in\s+([\s\S]+?)$/;
            return {
                parse: function (input) {
                    var match = input.match(TYPEAHEAD_REGEXP);
                    if (!match) {
                        throw new Error('Expected typeahead specification in form of "_modelValue_ (as _label_)? for _item_ in _collection_"' + ' but got "' + input + '".');
                    }
                    return {
                        itemName: match[3],
                        source: $parse(match[4]),
                        viewMapper: $parse(match[2] || match[1]),
                        modelMapper: $parse(match[1])
                    };
                }
            };
        }
    ]).controller('UibTypeaheadController', [
        '$scope',
        '$element',
        '$attrs',
        '$compile',
        '$parse',
        '$q',
        '$timeout',
        '$document',
        '$window',
        '$rootScope',
        '$$debounce',
        '$uibPosition',
        'uibTypeaheadParser',
        function (originalScope, element, attrs, $compile, $parse, $q, $timeout, $document, $window, $rootScope, $$debounce, $position, typeaheadParser) {
            var HOT_KEYS = [
                9,
                13,
                27,
                38,
                40
            ];
            var eventDebounceTime = 200;
            var modelCtrl, ngModelOptions;
            var minLength = originalScope.$eval(attrs.typeaheadMinLength);
            if (!minLength && minLength !== 0) {
                minLength = 1;
            }
            originalScope.$watch(attrs.typeaheadMinLength, function (newVal) {
                minLength = !newVal && newVal !== 0 ? 1 : newVal;
            });
            var waitTime = originalScope.$eval(attrs.typeaheadWaitMs) || 0;
            var isEditable = originalScope.$eval(attrs.typeaheadEditable) !== false;
            originalScope.$watch(attrs.typeaheadEditable, function (newVal) {
                isEditable = newVal !== false;
            });
            var isLoadingSetter = $parse(attrs.typeaheadLoading).assign || angular.noop;
            var isSelectEvent = attrs.typeaheadShouldSelect ? $parse(attrs.typeaheadShouldSelect) : function (scope, vals) {
                var evt = vals.$event;
                return evt.which === 13 || evt.which === 9;
            };
            var onSelectCallback = $parse(attrs.typeaheadOnSelect);
            var isSelectOnBlur = angular.isDefined(attrs.typeaheadSelectOnBlur) ? originalScope.$eval(attrs.typeaheadSelectOnBlur) : false;
            var isNoResultsSetter = $parse(attrs.typeaheadNoResults).assign || angular.noop;
            var inputFormatter = attrs.typeaheadInputFormatter ? $parse(attrs.typeaheadInputFormatter) : undefined;
            var appendToBody = attrs.typeaheadAppendToBody ? originalScope.$eval(attrs.typeaheadAppendToBody) : false;
            var appendTo = attrs.typeaheadAppendTo ? originalScope.$eval(attrs.typeaheadAppendTo) : null;
            var focusFirst = originalScope.$eval(attrs.typeaheadFocusFirst) !== false;
            var selectOnExact = attrs.typeaheadSelectOnExact ? originalScope.$eval(attrs.typeaheadSelectOnExact) : false;
            var isOpenSetter = $parse(attrs.typeaheadIsOpen).assign || angular.noop;
            var showHint = originalScope.$eval(attrs.typeaheadShowHint) || false;
            var parsedModel = $parse(attrs.ngModel);
            var invokeModelSetter = $parse(attrs.ngModel + '($$$p)');
            var $setModelValue = function (scope, newValue) {
                if (angular.isFunction(parsedModel(originalScope)) && ngModelOptions && ngModelOptions.$options && ngModelOptions.$options.getterSetter) {
                    return invokeModelSetter(scope, { $$$p: newValue });
                }
                return parsedModel.assign(scope, newValue);
            };
            var parserResult = typeaheadParser.parse(attrs.uibTypeahead);
            var hasFocus;
            var selected;
            var scope = originalScope.$new();
            var offDestroy = originalScope.$on('$destroy', function () {
                scope.$destroy();
            });
            scope.$on('$destroy', offDestroy);
            var popupId = 'typeahead-' + scope.$id + '-' + Math.floor(Math.random() * 10000);
            element.attr({
                'aria-autocomplete': 'list',
                'aria-expanded': false,
                'aria-owns': popupId
            });
            var inputsContainer, hintInputElem;
            if (showHint) {
                inputsContainer = angular.element('<div></div>');
                inputsContainer.css('position', 'relative');
                element.after(inputsContainer);
                hintInputElem = element.clone();
                hintInputElem.attr('placeholder', '');
                hintInputElem.attr('tabindex', '-1');
                hintInputElem.val('');
                hintInputElem.css({
                    'position': 'absolute',
                    'top': '0px',
                    'left': '0px',
                    'border-color': 'transparent',
                    'box-shadow': 'none',
                    'opacity': 1,
                    'background': 'none 0% 0% / auto repeat scroll padding-box border-box rgb(255, 255, 255)',
                    'color': '#999'
                });
                element.css({
                    'position': 'relative',
                    'vertical-align': 'top',
                    'background-color': 'transparent'
                });
                inputsContainer.append(hintInputElem);
                hintInputElem.after(element);
            }
            var popUpEl = angular.element('<div uib-typeahead-popup></div>');
            popUpEl.attr({
                id: popupId,
                matches: 'matches',
                active: 'activeIdx',
                select: 'select(activeIdx, evt)',
                'move-in-progress': 'moveInProgress',
                query: 'query',
                position: 'position',
                'assign-is-open': 'assignIsOpen(isOpen)',
                debounce: 'debounceUpdate'
            });
            if (angular.isDefined(attrs.typeaheadTemplateUrl)) {
                popUpEl.attr('template-url', attrs.typeaheadTemplateUrl);
            }
            if (angular.isDefined(attrs.typeaheadPopupTemplateUrl)) {
                popUpEl.attr('popup-template-url', attrs.typeaheadPopupTemplateUrl);
            }
            var resetHint = function () {
                if (showHint) {
                    hintInputElem.val('');
                }
            };
            var resetMatches = function () {
                scope.matches = [];
                scope.activeIdx = -1;
                element.attr('aria-expanded', false);
                resetHint();
            };
            var getMatchId = function (index) {
                return popupId + '-option-' + index;
            };
            scope.$watch('activeIdx', function (index) {
                if (index < 0) {
                    element.removeAttr('aria-activedescendant');
                } else {
                    element.attr('aria-activedescendant', getMatchId(index));
                }
            });
            var inputIsExactMatch = function (inputValue, index) {
                if (scope.matches.length > index && inputValue) {
                    return inputValue.toUpperCase() === scope.matches[index].label.toUpperCase();
                }
                return false;
            };
            var getMatchesAsync = function (inputValue, evt) {
                var locals = { $viewValue: inputValue };
                isLoadingSetter(originalScope, true);
                isNoResultsSetter(originalScope, false);
                $q.when(parserResult.source(originalScope, locals)).then(function (matches) {
                    var onCurrentRequest = inputValue === modelCtrl.$viewValue;
                    if (onCurrentRequest && hasFocus) {
                        if (matches && matches.length > 0) {
                            scope.activeIdx = focusFirst ? 0 : -1;
                            isNoResultsSetter(originalScope, false);
                            scope.matches.length = 0;
                            for (var i = 0; i < matches.length; i++) {
                                locals[parserResult.itemName] = matches[i];
                                scope.matches.push({
                                    id: getMatchId(i),
                                    label: parserResult.viewMapper(scope, locals),
                                    model: matches[i]
                                });
                            }
                            scope.query = inputValue;
                            recalculatePosition();
                            element.attr('aria-expanded', true);
                            if (selectOnExact && scope.matches.length === 1 && inputIsExactMatch(inputValue, 0)) {
                                if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                                    $$debounce(function () {
                                        scope.select(0, evt);
                                    }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                                } else {
                                    scope.select(0, evt);
                                }
                            }
                            if (showHint) {
                                var firstLabel = scope.matches[0].label;
                                if (angular.isString(inputValue) && inputValue.length > 0 && firstLabel.slice(0, inputValue.length).toUpperCase() === inputValue.toUpperCase()) {
                                    hintInputElem.val(inputValue + firstLabel.slice(inputValue.length));
                                } else {
                                    hintInputElem.val('');
                                }
                            }
                        } else {
                            resetMatches();
                            isNoResultsSetter(originalScope, true);
                        }
                    }
                    if (onCurrentRequest) {
                        isLoadingSetter(originalScope, false);
                    }
                }, function () {
                    resetMatches();
                    isLoadingSetter(originalScope, false);
                    isNoResultsSetter(originalScope, true);
                });
            };
            if (appendToBody) {
                angular.element($window).on('resize', fireRecalculating);
                $document.find('body').on('scroll', fireRecalculating);
            }
            var debouncedRecalculate = $$debounce(function () {
                if (scope.matches.length) {
                    recalculatePosition();
                }
                scope.moveInProgress = false;
            }, eventDebounceTime);
            scope.moveInProgress = false;
            function fireRecalculating() {
                if (!scope.moveInProgress) {
                    scope.moveInProgress = true;
                    scope.$digest();
                }
                debouncedRecalculate();
            }
            function recalculatePosition() {
                scope.position = appendToBody ? $position.offset(element) : $position.position(element);
                scope.position.top += element.prop('offsetHeight');
            }
            scope.query = undefined;
            var timeoutPromise;
            var scheduleSearchWithTimeout = function (inputValue) {
                timeoutPromise = $timeout(function () {
                    getMatchesAsync(inputValue);
                }, waitTime);
            };
            var cancelPreviousTimeout = function () {
                if (timeoutPromise) {
                    $timeout.cancel(timeoutPromise);
                }
            };
            resetMatches();
            scope.assignIsOpen = function (isOpen) {
                isOpenSetter(originalScope, isOpen);
            };
            scope.select = function (activeIdx, evt) {
                var locals = {};
                var model, item;
                selected = true;
                locals[parserResult.itemName] = item = scope.matches[activeIdx].model;
                model = parserResult.modelMapper(originalScope, locals);
                $setModelValue(originalScope, model);
                modelCtrl.$setValidity('editable', true);
                modelCtrl.$setValidity('parse', true);
                onSelectCallback(originalScope, {
                    $item: item,
                    $model: model,
                    $label: parserResult.viewMapper(originalScope, locals),
                    $event: evt
                });
                resetMatches();
                if (scope.$eval(attrs.typeaheadFocusOnSelect) !== false) {
                    $timeout(function () {
                        element[0].focus();
                    }, 0, false);
                }
            };
            element.on('keydown', function (evt) {
                if (scope.matches.length === 0 || HOT_KEYS.indexOf(evt.which) === -1) {
                    return;
                }
                var shouldSelect = isSelectEvent(originalScope, { $event: evt });
                if (scope.activeIdx === -1 && shouldSelect || evt.which === 9 && !!evt.shiftKey) {
                    resetMatches();
                    scope.$digest();
                    return;
                }
                evt.preventDefault();
                var target;
                switch (evt.which) {
                case 27:
                    evt.stopPropagation();
                    resetMatches();
                    originalScope.$digest();
                    break;
                case 38:
                    scope.activeIdx = (scope.activeIdx > 0 ? scope.activeIdx : scope.matches.length) - 1;
                    scope.$digest();
                    target = popUpEl.find('li')[scope.activeIdx];
                    target.parentNode.scrollTop = target.offsetTop;
                    break;
                case 40:
                    scope.activeIdx = (scope.activeIdx + 1) % scope.matches.length;
                    scope.$digest();
                    target = popUpEl.find('li')[scope.activeIdx];
                    target.parentNode.scrollTop = target.offsetTop;
                    break;
                default:
                    if (shouldSelect) {
                        scope.$apply(function () {
                            if (angular.isNumber(scope.debounceUpdate) || angular.isObject(scope.debounceUpdate)) {
                                $$debounce(function () {
                                    scope.select(scope.activeIdx, evt);
                                }, angular.isNumber(scope.debounceUpdate) ? scope.debounceUpdate : scope.debounceUpdate['default']);
                            } else {
                                scope.select(scope.activeIdx, evt);
                            }
                        });
                    }
                }
            });
            element.bind('focus', function (evt) {
                hasFocus = true;
                if (minLength === 0 && !modelCtrl.$viewValue) {
                    $timeout(function () {
                        getMatchesAsync(modelCtrl.$viewValue, evt);
                    }, 0);
                }
            });
            element.bind('blur', function (evt) {
                if (isSelectOnBlur && scope.matches.length && scope.activeIdx !== -1 && !selected) {
                    selected = true;
                    scope.$apply(function () {
                        if (angular.isObject(scope.debounceUpdate) && angular.isNumber(scope.debounceUpdate.blur)) {
                            $$debounce(function () {
                                scope.select(scope.activeIdx, evt);
                            }, scope.debounceUpdate.blur);
                        } else {
                            scope.select(scope.activeIdx, evt);
                        }
                    });
                }
                if (!isEditable && modelCtrl.$error.editable) {
                    modelCtrl.$setViewValue();
                    modelCtrl.$setValidity('editable', true);
                    modelCtrl.$setValidity('parse', true);
                    element.val('');
                }
                hasFocus = false;
                selected = false;
            });
            var dismissClickHandler = function (evt) {
                if (element[0] !== evt.target && evt.which !== 3 && scope.matches.length !== 0) {
                    resetMatches();
                    if (!$rootScope.$$phase) {
                        originalScope.$digest();
                    }
                }
            };
            $document.on('click', dismissClickHandler);
            originalScope.$on('$destroy', function () {
                $document.off('click', dismissClickHandler);
                if (appendToBody || appendTo) {
                    $popup.remove();
                }
                if (appendToBody) {
                    angular.element($window).off('resize', fireRecalculating);
                    $document.find('body').off('scroll', fireRecalculating);
                }
                popUpEl.remove();
                if (showHint) {
                    inputsContainer.remove();
                }
            });
            var $popup = $compile(popUpEl)(scope);
            if (appendToBody) {
                $document.find('body').append($popup);
            } else if (appendTo) {
                angular.element(appendTo).eq(0).append($popup);
            } else {
                element.after($popup);
            }
            this.init = function (_modelCtrl, _ngModelOptions) {
                modelCtrl = _modelCtrl;
                ngModelOptions = _ngModelOptions;
                scope.debounceUpdate = modelCtrl.$options && $parse(modelCtrl.$options.debounce)(originalScope);
                modelCtrl.$parsers.unshift(function (inputValue) {
                    hasFocus = true;
                    if (minLength === 0 || inputValue && inputValue.length >= minLength) {
                        if (waitTime > 0) {
                            cancelPreviousTimeout();
                            scheduleSearchWithTimeout(inputValue);
                        } else {
                            getMatchesAsync(inputValue);
                        }
                    } else {
                        isLoadingSetter(originalScope, false);
                        cancelPreviousTimeout();
                        resetMatches();
                    }
                    if (isEditable) {
                        return inputValue;
                    }
                    if (!inputValue) {
                        modelCtrl.$setValidity('editable', true);
                        return null;
                    }
                    modelCtrl.$setValidity('editable', false);
                    return undefined;
                });
                modelCtrl.$formatters.push(function (modelValue) {
                    var candidateViewValue, emptyViewValue;
                    var locals = {};
                    if (!isEditable) {
                        modelCtrl.$setValidity('editable', true);
                    }
                    if (inputFormatter) {
                        locals.$model = modelValue;
                        return inputFormatter(originalScope, locals);
                    }
                    locals[parserResult.itemName] = modelValue;
                    candidateViewValue = parserResult.viewMapper(originalScope, locals);
                    locals[parserResult.itemName] = undefined;
                    emptyViewValue = parserResult.viewMapper(originalScope, locals);
                    return candidateViewValue !== emptyViewValue ? candidateViewValue : modelValue;
                });
            };
        }
    ]).directive('uibTypeahead', function () {
        return {
            controller: 'UibTypeaheadController',
            require: [
                'ngModel',
                '^?ngModelOptions',
                'uibTypeahead'
            ],
            link: function (originalScope, element, attrs, ctrls) {
                ctrls[2].init(ctrls[0], ctrls[1]);
            }
        };
    }).directive('uibTypeaheadPopup', [
        '$$debounce',
        function ($$debounce) {
            return {
                scope: {
                    matches: '=',
                    query: '=',
                    active: '=',
                    position: '&',
                    moveInProgress: '=',
                    select: '&',
                    assignIsOpen: '&',
                    debounce: '&'
                },
                replace: true,
                templateUrl: function (element, attrs) {
                    return attrs.popupTemplateUrl || 'uib/template/typeahead/typeahead-popup.html';
                },
                link: function (scope, element, attrs) {
                    scope.templateUrl = attrs.templateUrl;
                    scope.isOpen = function () {
                        var isDropdownOpen = scope.matches.length > 0;
                        scope.assignIsOpen({ isOpen: isDropdownOpen });
                        return isDropdownOpen;
                    };
                    scope.isActive = function (matchIdx) {
                        return scope.active === matchIdx;
                    };
                    scope.selectActive = function (matchIdx) {
                        scope.active = matchIdx;
                    };
                    scope.selectMatch = function (activeIdx, evt) {
                        var debounce = scope.debounce();
                        if (angular.isNumber(debounce) || angular.isObject(debounce)) {
                            $$debounce(function () {
                                scope.select({
                                    activeIdx: activeIdx,
                                    evt: evt
                                });
                            }, angular.isNumber(debounce) ? debounce : debounce['default']);
                        } else {
                            scope.select({
                                activeIdx: activeIdx,
                                evt: evt
                            });
                        }
                    };
                }
            };
        }
    ]).directive('uibTypeaheadMatch', [
        '$templateRequest',
        '$compile',
        '$parse',
        function ($templateRequest, $compile, $parse) {
            return {
                scope: {
                    index: '=',
                    match: '=',
                    query: '='
                },
                link: function (scope, element, attrs) {
                    var tplUrl = $parse(attrs.templateUrl)(scope.$parent) || 'uib/template/typeahead/typeahead-match.html';
                    $templateRequest(tplUrl).then(function (tplContent) {
                        var tplEl = angular.element(tplContent.trim());
                        element.replaceWith(tplEl);
                        $compile(tplEl)(scope);
                    });
                }
            };
        }
    ]).filter('uibTypeaheadHighlight', [
        '$sce',
        '$injector',
        '$log',
        function ($sce, $injector, $log) {
            var isSanitizePresent;
            isSanitizePresent = $injector.has('$sanitize');
            function escapeRegexp(queryToEscape) {
                return queryToEscape.replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
            }
            function containsHtml(matchItem) {
                return /<.*>/g.test(matchItem);
            }
            return function (matchItem, query) {
                if (!isSanitizePresent && containsHtml(matchItem)) {
                    $log.warn('Unsafe use of typeahead please use ngSanitize');
                }
                matchItem = query ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<strong>$&</strong>') : matchItem;
                if (!isSanitizePresent) {
                    matchItem = $sce.trustAsHtml(matchItem);
                }
                return matchItem;
            };
        }
    ]);
    angular.module('uib/template/accordion/accordion-group.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/accordion/accordion-group.html', '<div class="panel" ng-class="panelClass || \'panel-default\'">\n' + '  <div role="tab" id="{{::headingId}}" aria-selected="{{isOpen}}" class="panel-heading" ng-keypress="toggleOpen($event)">\n' + '    <h4 class="panel-title">\n' + '      <a role="button" data-toggle="collapse" href aria-expanded="{{isOpen}}" aria-controls="{{::panelId}}" tabindex="0" class="accordion-toggle" ng-click="toggleOpen()" uib-accordion-transclude="heading"><span uib-accordion-header ng-class="{\'text-muted\': isDisabled}">{{heading}}</span></a>\n' + '    </h4>\n' + '  </div>\n' + '  <div id="{{::panelId}}" aria-labelledby="{{::headingId}}" aria-hidden="{{!isOpen}}" role="tabpanel" class="panel-collapse collapse" uib-collapse="!isOpen">\n' + '    <div class="panel-body" ng-transclude></div>\n' + '  </div>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/accordion/accordion.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/accordion/accordion.html', '<div role="tablist" class="panel-group" ng-transclude></div>');
        }
    ]);
    angular.module('uib/template/alert/alert.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/alert/alert.html', '<div class="alert" ng-class="[\'alert-\' + (type || \'warning\'), closeable ? \'alert-dismissible\' : null]" role="alert">\n' + '    <button ng-show="closeable" type="button" class="close" ng-click="close({$event: $event})">\n' + '        <span aria-hidden="true">&times;</span>\n' + '        <span class="sr-only">Close</span>\n' + '    </button>\n' + '    <div ng-transclude></div>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/carousel/carousel.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/carousel/carousel.html', '<div ng-mouseenter="pause()" ng-mouseleave="play()" class="carousel" ng-swipe-right="prev()" ng-swipe-left="next()">\n' + '  <div class="carousel-inner" ng-transclude></div>\n' + '  <a role="button" href class="left carousel-control" ng-click="prev()" ng-class="{ disabled: isPrevDisabled() }" ng-show="slides.length > 1">\n' + '    <span aria-hidden="true" class="glyphicon glyphicon-chevron-left"></span>\n' + '    <span class="sr-only">previous</span>\n' + '  </a>\n' + '  <a role="button" href class="right carousel-control" ng-click="next()" ng-class="{ disabled: isNextDisabled() }" ng-show="slides.length > 1">\n' + '    <span aria-hidden="true" class="glyphicon glyphicon-chevron-right"></span>\n' + '    <span class="sr-only">next</span>\n' + '  </a>\n' + '  <ol class="carousel-indicators" ng-show="slides.length > 1">\n' + '    <li ng-repeat="slide in slides | orderBy:indexOfSlide track by $index" ng-class="{ active: isActive(slide) }" ng-click="select(slide)">\n' + '      <span class="sr-only">slide {{ $index + 1 }} of {{ slides.length }}<span ng-if="isActive(slide)">, currently active</span></span>\n' + '    </li>\n' + '  </ol>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/carousel/slide.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/carousel/slide.html', '<div ng-class="{\n' + '    \'active\': active\n' + '  }" class="item text-center" ng-transclude></div>\n' + '');
        }
    ]);
    angular.module('uib/template/datepicker/datepicker.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/datepicker/datepicker.html', '<div class="uib-datepicker" ng-switch="datepickerMode" role="application" ng-keydown="keydown($event)">\n' + '  <uib-daypicker ng-switch-when="day" tabindex="0"></uib-daypicker>\n' + '  <uib-monthpicker ng-switch-when="month" tabindex="0"></uib-monthpicker>\n' + '  <uib-yearpicker ng-switch-when="year" tabindex="0"></uib-yearpicker>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/datepicker/day.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/datepicker/day.html', '<table class="uib-daypicker" role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' + '  <thead>\n' + '    <tr>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n' + '      <th colspan="{{::5 + showWeeks}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n' + '    </tr>\n' + '    <tr>\n' + '      <th ng-if="showWeeks" class="text-center"></th>\n' + '      <th ng-repeat="label in ::labels track by $index" class="text-center"><small aria-label="{{::label.full}}">{{::label.abbr}}</small></th>\n' + '    </tr>\n' + '  </thead>\n' + '  <tbody>\n' + '    <tr class="uib-weeks" ng-repeat="row in rows track by $index">\n' + '      <td ng-if="showWeeks" class="text-center h6"><em>{{ weekNumbers[$index] }}</em></td>\n' + '      <td ng-repeat="dt in row" class="uib-day text-center" role="gridcell"\n' + '        id="{{::dt.uid}}"\n' + '        ng-class="::dt.customClass">\n' + '        <button type="button" class="btn btn-default btn-sm"\n' + '          uib-is-class="\n' + '            \'btn-info\' for selectedDt,\n' + '            \'active\' for activeDt\n' + '            on dt"\n' + '          ng-click="select(dt.date)"\n' + '          ng-disabled="::dt.disabled"\n' + '          tabindex="-1"><span ng-class="::{\'text-muted\': dt.secondary, \'text-info\': dt.current}">{{::dt.label}}</span></button>\n' + '      </td>\n' + '    </tr>\n' + '  </tbody>\n' + '</table>\n' + '');
        }
    ]);
    angular.module('uib/template/datepicker/month.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/datepicker/month.html', '<table class="uib-monthpicker" role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' + '  <thead>\n' + '    <tr>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n' + '      <th><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n' + '    </tr>\n' + '  </thead>\n' + '  <tbody>\n' + '    <tr class="uib-months" ng-repeat="row in rows track by $index">\n' + '      <td ng-repeat="dt in row" class="uib-month text-center" role="gridcell"\n' + '        id="{{::dt.uid}}"\n' + '        ng-class="::dt.customClass">\n' + '        <button type="button" class="btn btn-default"\n' + '          uib-is-class="\n' + '            \'btn-info\' for selectedDt,\n' + '            \'active\' for activeDt\n' + '            on dt"\n' + '          ng-click="select(dt.date)"\n' + '          ng-disabled="::dt.disabled"\n' + '          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n' + '      </td>\n' + '    </tr>\n' + '  </tbody>\n' + '</table>\n' + '');
        }
    ]);
    angular.module('uib/template/datepicker/year.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/datepicker/year.html', '<table class="uib-yearpicker" role="grid" aria-labelledby="{{::uniqueId}}-title" aria-activedescendant="{{activeDateId}}">\n' + '  <thead>\n' + '    <tr>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-left uib-left" ng-click="move(-1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-left"></i></button></th>\n' + '      <th colspan="{{::columns - 2}}"><button id="{{::uniqueId}}-title" role="heading" aria-live="assertive" aria-atomic="true" type="button" class="btn btn-default btn-sm uib-title" ng-click="toggleMode()" ng-disabled="datepickerMode === maxMode" tabindex="-1"><strong>{{title}}</strong></button></th>\n' + '      <th><button type="button" class="btn btn-default btn-sm pull-right uib-right" ng-click="move(1)" tabindex="-1"><i class="glyphicon glyphicon-chevron-right"></i></button></th>\n' + '    </tr>\n' + '  </thead>\n' + '  <tbody>\n' + '    <tr class="uib-years" ng-repeat="row in rows track by $index">\n' + '      <td ng-repeat="dt in row" class="uib-year text-center" role="gridcell"\n' + '        id="{{::dt.uid}}"\n' + '        ng-class="::dt.customClass">\n' + '        <button type="button" class="btn btn-default"\n' + '          uib-is-class="\n' + '            \'btn-info\' for selectedDt,\n' + '            \'active\' for activeDt\n' + '            on dt"\n' + '          ng-click="select(dt.date)"\n' + '          ng-disabled="::dt.disabled"\n' + '          tabindex="-1"><span ng-class="::{\'text-info\': dt.current}">{{::dt.label}}</span></button>\n' + '      </td>\n' + '    </tr>\n' + '  </tbody>\n' + '</table>\n' + '');
        }
    ]);
    angular.module('uib/template/datepickerPopup/popup.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/datepickerPopup/popup.html', '<div>\n' + '  <ul class="uib-datepicker-popup dropdown-menu uib-position-measure" dropdown-nested ng-if="isOpen" ng-keydown="keydown($event)" ng-click="$event.stopPropagation()">\n' + '    <li ng-transclude></li>\n' + '    <li ng-if="showButtonBar" class="uib-button-bar">\n' + '      <span class="btn-group pull-left">\n' + '        <button type="button" class="btn btn-sm btn-info uib-datepicker-current" ng-click="select(\'today\', $event)" ng-disabled="isDisabled(\'today\')">{{ getText(\'current\') }}</button>\n' + '        <button type="button" class="btn btn-sm btn-danger uib-clear" ng-click="select(null, $event)">{{ getText(\'clear\') }}</button>\n' + '      </span>\n' + '      <button type="button" class="btn btn-sm btn-success pull-right uib-close" ng-click="close($event)">{{ getText(\'close\') }}</button>\n' + '    </li>\n' + '  </ul>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/modal/backdrop.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/modal/backdrop.html', '<div class="modal-backdrop"\n' + '     uib-modal-animation-class="fade"\n' + '     modal-in-class="in"\n' + '     ng-style="{\'z-index\': 1040 + (index && 1 || 0) + index*10}"\n' + '></div>\n' + '');
        }
    ]);
    angular.module('uib/template/modal/window.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/modal/window.html', '<div modal-render="{{$isRendered}}" tabindex="-1" role="dialog" class="modal"\n' + '    uib-modal-animation-class="fade"\n' + '    modal-in-class="in"\n' + '    ng-style="{\'z-index\': 1050 + index*10, display: \'block\'}">\n' + '    <div class="modal-dialog {{size ? \'modal-\' + size : \'\'}}"><div class="modal-content" uib-modal-transclude></div></div>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/pager/pager.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/pager/pager.html', '<ul class="pager">\n' + '  <li ng-class="{disabled: noPrevious()||ngDisabled, previous: align}"><a href ng-click="selectPage(page - 1, $event)">{{::getText(\'previous\')}}</a></li>\n' + '  <li ng-class="{disabled: noNext()||ngDisabled, next: align}"><a href ng-click="selectPage(page + 1, $event)">{{::getText(\'next\')}}</a></li>\n' + '</ul>\n' + '');
        }
    ]);
    angular.module('uib/template/pagination/pagination.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/pagination/pagination.html', '<ul class="pagination">\n' + '  <li ng-if="::boundaryLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-first"><a href ng-click="selectPage(1, $event)">{{::getText(\'first\')}}</a></li>\n' + '  <li ng-if="::directionLinks" ng-class="{disabled: noPrevious()||ngDisabled}" class="pagination-prev"><a href ng-click="selectPage(page - 1, $event)">{{::getText(\'previous\')}}</a></li>\n' + '  <li ng-repeat="page in pages track by $index" ng-class="{active: page.active,disabled: ngDisabled&&!page.active}" class="pagination-page"><a href ng-click="selectPage(page.number, $event)">{{page.text}}</a></li>\n' + '  <li ng-if="::directionLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-next"><a href ng-click="selectPage(page + 1, $event)">{{::getText(\'next\')}}</a></li>\n' + '  <li ng-if="::boundaryLinks" ng-class="{disabled: noNext()||ngDisabled}" class="pagination-last"><a href ng-click="selectPage(totalPages, $event)">{{::getText(\'last\')}}</a></li>\n' + '</ul>\n' + '');
        }
    ]);
    angular.module('uib/template/tooltip/tooltip-html-popup.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/tooltip/tooltip-html-popup.html', '<div class="tooltip"\n' + '  tooltip-animation-class="fade"\n' + '  uib-tooltip-classes\n' + '  ng-class="{ in: isOpen() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner" ng-bind-html="contentExp()"></div>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/tooltip/tooltip-popup.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/tooltip/tooltip-popup.html', '<div class="tooltip"\n' + '  tooltip-animation-class="fade"\n' + '  uib-tooltip-classes\n' + '  ng-class="{ in: isOpen() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner" ng-bind="content"></div>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/tooltip/tooltip-template-popup.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/tooltip/tooltip-template-popup.html', '<div class="tooltip"\n' + '  tooltip-animation-class="fade"\n' + '  uib-tooltip-classes\n' + '  ng-class="{ in: isOpen() }">\n' + '  <div class="tooltip-arrow"></div>\n' + '  <div class="tooltip-inner"\n' + '    uib-tooltip-template-transclude="contentExp()"\n' + '    tooltip-template-transclude-scope="originScope()"></div>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/popover/popover-html.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/popover/popover-html.html', '<div class="popover"\n' + '  tooltip-animation-class="fade"\n' + '  uib-tooltip-classes\n' + '  ng-class="{ in: isOpen() }">\n' + '  <div class="arrow"></div>\n' + '\n' + '  <div class="popover-inner">\n' + '      <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n' + '      <div class="popover-content" ng-bind-html="contentExp()"></div>\n' + '  </div>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/popover/popover-template.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/popover/popover-template.html', '<div class="popover"\n' + '  tooltip-animation-class="fade"\n' + '  uib-tooltip-classes\n' + '  ng-class="{ in: isOpen() }">\n' + '  <div class="arrow"></div>\n' + '\n' + '  <div class="popover-inner">\n' + '      <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n' + '      <div class="popover-content"\n' + '        uib-tooltip-template-transclude="contentExp()"\n' + '        tooltip-template-transclude-scope="originScope()"></div>\n' + '  </div>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/popover/popover.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/popover/popover.html', '<div class="popover"\n' + '  tooltip-animation-class="fade"\n' + '  uib-tooltip-classes\n' + '  ng-class="{ in: isOpen() }">\n' + '  <div class="arrow"></div>\n' + '\n' + '  <div class="popover-inner">\n' + '      <h3 class="popover-title" ng-bind="uibTitle" ng-if="uibTitle"></h3>\n' + '      <div class="popover-content" ng-bind="content"></div>\n' + '  </div>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/progressbar/bar.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/progressbar/bar.html', '<div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n' + '');
        }
    ]);
    angular.module('uib/template/progressbar/progress.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/progressbar/progress.html', '<div class="progress" ng-transclude aria-labelledby="{{::title}}"></div>');
        }
    ]);
    angular.module('uib/template/progressbar/progressbar.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/progressbar/progressbar.html', '<div class="progress">\n' + '  <div class="progress-bar" ng-class="type && \'progress-bar-\' + type" role="progressbar" aria-valuenow="{{value}}" aria-valuemin="0" aria-valuemax="{{max}}" ng-style="{width: (percent < 100 ? percent : 100) + \'%\'}" aria-valuetext="{{percent | number:0}}%" aria-labelledby="{{::title}}" ng-transclude></div>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/rating/rating.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/rating/rating.html', '<span ng-mouseleave="reset()" ng-keydown="onKeydown($event)" tabindex="0" role="slider" aria-valuemin="0" aria-valuemax="{{range.length}}" aria-valuenow="{{value}}" aria-valuetext="{{title}}">\n' + '    <span ng-repeat-start="r in range track by $index" class="sr-only">({{ $index < value ? \'*\' : \' \' }})</span>\n' + '    <i ng-repeat-end ng-mouseenter="enter($index + 1)" ng-click="rate($index + 1)" class="glyphicon" ng-class="$index < value && (r.stateOn || \'glyphicon-star\') || (r.stateOff || \'glyphicon-star-empty\')" ng-attr-title="{{r.title}}"></i>\n' + '</span>\n' + '');
        }
    ]);
    angular.module('uib/template/tabs/tab.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/tabs/tab.html', '<li ng-class="[{active: active, disabled: disabled}, classes]" class="uib-tab nav-item">\n' + '  <a href ng-click="select($event)" class="nav-link" uib-tab-heading-transclude>{{heading}}</a>\n' + '</li>\n' + '');
        }
    ]);
    angular.module('uib/template/tabs/tabset.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/tabs/tabset.html', '<div>\n' + '  <ul class="nav nav-{{tabset.type || \'tabs\'}}" ng-class="{\'nav-stacked\': vertical, \'nav-justified\': justified}" ng-transclude></ul>\n' + '  <div class="tab-content">\n' + '    <div class="tab-pane"\n' + '         ng-repeat="tab in tabset.tabs"\n' + '         ng-class="{active: tabset.active === tab.index}"\n' + '         uib-tab-content-transclude="tab">\n' + '    </div>\n' + '  </div>\n' + '</div>\n' + '');
        }
    ]);
    angular.module('uib/template/timepicker/timepicker.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/timepicker/timepicker.html', '<table class="uib-timepicker">\n' + '  <tbody>\n' + '    <tr class="text-center" ng-show="::showSpinners">\n' + '      <td class="uib-increment hours"><a ng-click="incrementHours()" ng-class="{disabled: noIncrementHours()}" class="btn btn-link" ng-disabled="noIncrementHours()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' + '      <td>&nbsp;</td>\n' + '      <td class="uib-increment minutes"><a ng-click="incrementMinutes()" ng-class="{disabled: noIncrementMinutes()}" class="btn btn-link" ng-disabled="noIncrementMinutes()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' + '      <td ng-show="showSeconds">&nbsp;</td>\n' + '      <td ng-show="showSeconds" class="uib-increment seconds"><a ng-click="incrementSeconds()" ng-class="{disabled: noIncrementSeconds()}" class="btn btn-link" ng-disabled="noIncrementSeconds()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-up"></span></a></td>\n' + '      <td ng-show="showMeridian"></td>\n' + '    </tr>\n' + '    <tr>\n' + '      <td class="form-group uib-time hours" ng-class="{\'has-error\': invalidHours}">\n' + '        <input type="text" placeholder="HH" ng-model="hours" ng-change="updateHours()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementHours()" ng-blur="blur()">\n' + '      </td>\n' + '      <td class="uib-separator">:</td>\n' + '      <td class="form-group uib-time minutes" ng-class="{\'has-error\': invalidMinutes}">\n' + '        <input type="text" placeholder="MM" ng-model="minutes" ng-change="updateMinutes()" class="form-control text-center" ng-readonly="::readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementMinutes()" ng-blur="blur()">\n' + '      </td>\n' + '      <td ng-show="showSeconds" class="uib-separator">:</td>\n' + '      <td class="form-group uib-time seconds" ng-class="{\'has-error\': invalidSeconds}" ng-show="showSeconds">\n' + '        <input type="text" placeholder="SS" ng-model="seconds" ng-change="updateSeconds()" class="form-control text-center" ng-readonly="readonlyInput" maxlength="2" tabindex="{{::tabindex}}" ng-disabled="noIncrementSeconds()" ng-blur="blur()">\n' + '      </td>\n' + '      <td ng-show="showMeridian" class="uib-time am-pm"><button type="button" ng-class="{disabled: noToggleMeridian()}" class="btn btn-default text-center" ng-click="toggleMeridian()" ng-disabled="noToggleMeridian()" tabindex="{{::tabindex}}">{{meridian}}</button></td>\n' + '    </tr>\n' + '    <tr class="text-center" ng-show="::showSpinners">\n' + '      <td class="uib-decrement hours"><a ng-click="decrementHours()" ng-class="{disabled: noDecrementHours()}" class="btn btn-link" ng-disabled="noDecrementHours()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' + '      <td>&nbsp;</td>\n' + '      <td class="uib-decrement minutes"><a ng-click="decrementMinutes()" ng-class="{disabled: noDecrementMinutes()}" class="btn btn-link" ng-disabled="noDecrementMinutes()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' + '      <td ng-show="showSeconds">&nbsp;</td>\n' + '      <td ng-show="showSeconds" class="uib-decrement seconds"><a ng-click="decrementSeconds()" ng-class="{disabled: noDecrementSeconds()}" class="btn btn-link" ng-disabled="noDecrementSeconds()" tabindex="{{::tabindex}}"><span class="glyphicon glyphicon-chevron-down"></span></a></td>\n' + '      <td ng-show="showMeridian"></td>\n' + '    </tr>\n' + '  </tbody>\n' + '</table>\n' + '');
        }
    ]);
    angular.module('uib/template/typeahead/typeahead-match.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/typeahead/typeahead-match.html', '<a href\n' + '   tabindex="-1"\n' + '   ng-bind-html="match.label | uibTypeaheadHighlight:query"\n' + '   ng-attr-title="{{match.label}}"></a>\n' + '');
        }
    ]);
    angular.module('uib/template/typeahead/typeahead-popup.html', []).run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('uib/template/typeahead/typeahead-popup.html', '<ul class="dropdown-menu" ng-show="isOpen() && !moveInProgress" ng-style="{top: position().top+\'px\', left: position().left+\'px\'}" role="listbox" aria-hidden="{{!isOpen()}}">\n' + '    <li ng-repeat="match in matches track by $index" ng-class="{active: isActive($index) }" ng-mouseenter="selectActive($index)" ng-click="selectMatch($index, $event)" role="option" id="{{::match.id}}">\n' + '        <div uib-typeahead-match index="$index" match="match" query="query" template-url="templateUrl"></div>\n' + '    </li>\n' + '</ul>\n' + '');
        }
    ]);
    angular.module('ui.bootstrap.carousel').run(function () {
        !angular.$$csp().noInlineStyle && !angular.$$uibCarouselCss && angular.element(document).find('head').prepend('<style type="text/css">.ng-animate.item:not(.left):not(.right){-webkit-transition:0s ease-in-out left;transition:0s ease-in-out left}</style>');
        angular.$$uibCarouselCss = true;
    });
    angular.module('ui.bootstrap.datepicker').run(function () {
        !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker .uib-title{width:100%;}.uib-day button,.uib-month button,.uib-year button{min-width:100%;}.uib-left,.uib-right{width:100%}</style>');
        angular.$$uibDatepickerCss = true;
    });
    angular.module('ui.bootstrap.position').run(function () {
        !angular.$$csp().noInlineStyle && !angular.$$uibPositionCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-position-measure{display:block !important;visibility:hidden !important;position:absolute !important;top:-9999px !important;left:-9999px !important;}.uib-position-scrollbar-measure{position:absolute !important;top:-9999px !important;width:50px !important;height:50px !important;overflow:scroll !important;}.uib-position-body-scrollbar-measure{overflow:scroll !important;}</style>');
        angular.$$uibPositionCss = true;
    });
    angular.module('ui.bootstrap.datepickerPopup').run(function () {
        !angular.$$csp().noInlineStyle && !angular.$$uibDatepickerpopupCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-datepicker-popup.dropdown-menu{display:block;float:none;margin:0;}.uib-button-bar{padding:10px 9px 2px;}</style>');
        angular.$$uibDatepickerpopupCss = true;
    });
    angular.module('ui.bootstrap.tooltip').run(function () {
        !angular.$$csp().noInlineStyle && !angular.$$uibTooltipCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-tooltip-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-html-popup].tooltip.right-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.top-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-left > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.bottom-right > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.left-bottom > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-top > .tooltip-arrow,[uib-tooltip-template-popup].tooltip.right-bottom > .tooltip-arrow,[uib-popover-popup].popover.top-left > .arrow,[uib-popover-popup].popover.top-right > .arrow,[uib-popover-popup].popover.bottom-left > .arrow,[uib-popover-popup].popover.bottom-right > .arrow,[uib-popover-popup].popover.left-top > .arrow,[uib-popover-popup].popover.left-bottom > .arrow,[uib-popover-popup].popover.right-top > .arrow,[uib-popover-popup].popover.right-bottom > .arrow,[uib-popover-html-popup].popover.top-left > .arrow,[uib-popover-html-popup].popover.top-right > .arrow,[uib-popover-html-popup].popover.bottom-left > .arrow,[uib-popover-html-popup].popover.bottom-right > .arrow,[uib-popover-html-popup].popover.left-top > .arrow,[uib-popover-html-popup].popover.left-bottom > .arrow,[uib-popover-html-popup].popover.right-top > .arrow,[uib-popover-html-popup].popover.right-bottom > .arrow,[uib-popover-template-popup].popover.top-left > .arrow,[uib-popover-template-popup].popover.top-right > .arrow,[uib-popover-template-popup].popover.bottom-left > .arrow,[uib-popover-template-popup].popover.bottom-right > .arrow,[uib-popover-template-popup].popover.left-top > .arrow,[uib-popover-template-popup].popover.left-bottom > .arrow,[uib-popover-template-popup].popover.right-top > .arrow,[uib-popover-template-popup].popover.right-bottom > .arrow{top:auto;bottom:auto;left:auto;right:auto;margin:0;}[uib-popover-popup].popover,[uib-popover-html-popup].popover,[uib-popover-template-popup].popover{display:block !important;}</style>');
        angular.$$uibTooltipCss = true;
    });
    angular.module('ui.bootstrap.timepicker').run(function () {
        !angular.$$csp().noInlineStyle && !angular.$$uibTimepickerCss && angular.element(document).find('head').prepend('<style type="text/css">.uib-time input{width:50px;}</style>');
        angular.$$uibTimepickerCss = true;
    });
    angular.module('ui.bootstrap.typeahead').run(function () {
        !angular.$$csp().noInlineStyle && !angular.$$uibTypeaheadCss && angular.element(document).find('head').prepend('<style type="text/css">[uib-typeahead-popup].dropdown-menu{display:block;}</style>');
        angular.$$uibTypeaheadCss = true;
    });
    return;
});
(function () {
    Date.prototype.format = function (format) {
        var o = {
            'M+': this.getMonth() + 1,
            'd+': this.getDate(),
            'h+': this.getHours(),
            'm+': this.getMinutes(),
            's+': this.getSeconds(),
            'q+': Math.floor((this.getMonth() + 3) / 3),
            'S': this.getMilliseconds()
        };
        if (/(y+)/.test(format))
            format = format.replace(RegExp.$1, (this.getFullYear() + '').substr(4 - RegExp.$1.length));
        for (var k in o) {
            if (o.hasOwnProperty(k) && new RegExp('(' + k + ')').test(format)) {
                format = format.replace(RegExp.$1, RegExp.$1.length === 1 ? o[k] : ('00' + o[k]).substr(('' + o[k]).length));
            }
        }
        return format;
    };
}());
define('DateUtils', [], function () {
    return;
});
define('bootstrap', ['jquery'], function () {
    if (typeof jQuery === 'undefined') {
        throw new Error('Bootstrap\'s JavaScript requires jQuery');
    }
    +function ($) {
        'use strict';
        var version = $.fn.jquery.split(' ')[0].split('.');
        if (version[0] < 2 && version[1] < 9 || version[0] == 1 && version[1] == 9 && version[2] < 1 || version[0] > 2) {
            throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3');
        }
    }(jQuery);
    +function ($) {
        'use strict';
        function transitionEnd() {
            var el = document.createElement('bootstrap');
            var transEndEventNames = {
                WebkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                OTransition: 'oTransitionEnd otransitionend',
                transition: 'transitionend'
            };
            for (var name in transEndEventNames) {
                if (el.style[name] !== undefined) {
                    return { end: transEndEventNames[name] };
                }
            }
            return false;
        }
        $.fn.emulateTransitionEnd = function (duration) {
            var called = false;
            var $el = this;
            $(this).one('bsTransitionEnd', function () {
                called = true;
            });
            var callback = function () {
                if (!called)
                    $($el).trigger($.support.transition.end);
            };
            setTimeout(callback, duration);
            return this;
        };
        $(function () {
            $.support.transition = transitionEnd();
            if (!$.support.transition)
                return;
            $.event.special.bsTransitionEnd = {
                bindType: $.support.transition.end,
                delegateType: $.support.transition.end,
                handle: function (e) {
                    if ($(e.target).is(this))
                        return e.handleObj.handler.apply(this, arguments);
                }
            };
        });
    }(jQuery);
    +function ($) {
        'use strict';
        var dismiss = '[data-dismiss="alert"]';
        var Alert = function (el) {
            $(el).on('click', dismiss, this.close);
        };
        Alert.VERSION = '3.3.6';
        Alert.TRANSITION_DURATION = 150;
        Alert.prototype.close = function (e) {
            var $this = $(this);
            var selector = $this.attr('data-target');
            if (!selector) {
                selector = $this.attr('href');
                selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
            }
            var $parent = $(selector);
            if (e)
                e.preventDefault();
            if (!$parent.length) {
                $parent = $this.closest('.alert');
            }
            $parent.trigger(e = $.Event('close.bs.alert'));
            if (e.isDefaultPrevented())
                return;
            $parent.removeClass('in');
            function removeElement() {
                $parent.detach().trigger('closed.bs.alert').remove();
            }
            $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
        };
        function Plugin(option) {
            return this.each(function () {
                var $this = $(this);
                var data = $this.data('bs.alert');
                if (!data)
                    $this.data('bs.alert', data = new Alert(this));
                if (typeof option == 'string')
                    data[option].call($this);
            });
        }
        var old = $.fn.alert;
        $.fn.alert = Plugin;
        $.fn.alert.Constructor = Alert;
        $.fn.alert.noConflict = function () {
            $.fn.alert = old;
            return this;
        };
        $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
    }(jQuery);
    +function ($) {
        'use strict';
        var Button = function (element, options) {
            this.$element = $(element);
            this.options = $.extend({}, Button.DEFAULTS, options);
            this.isLoading = false;
        };
        Button.VERSION = '3.3.6';
        Button.DEFAULTS = { loadingText: 'loading...' };
        Button.prototype.setState = function (state) {
            var d = 'disabled';
            var $el = this.$element;
            var val = $el.is('input') ? 'val' : 'html';
            var data = $el.data();
            state += 'Text';
            if (data.resetText == null)
                $el.data('resetText', $el[val]());
            setTimeout($.proxy(function () {
                $el[val](data[state] == null ? this.options[state] : data[state]);
                if (state == 'loadingText') {
                    this.isLoading = true;
                    $el.addClass(d).attr(d, d);
                } else if (this.isLoading) {
                    this.isLoading = false;
                    $el.removeClass(d).removeAttr(d);
                }
            }, this), 0);
        };
        Button.prototype.toggle = function () {
            var changed = true;
            var $parent = this.$element.closest('[data-toggle="buttons"]');
            if ($parent.length) {
                var $input = this.$element.find('input');
                if ($input.prop('type') == 'radio') {
                    if ($input.prop('checked'))
                        changed = false;
                    $parent.find('.active').removeClass('active');
                    this.$element.addClass('active');
                } else if ($input.prop('type') == 'checkbox') {
                    if ($input.prop('checked') !== this.$element.hasClass('active'))
                        changed = false;
                    this.$element.toggleClass('active');
                }
                $input.prop('checked', this.$element.hasClass('active'));
                if (changed)
                    $input.trigger('change');
            } else {
                this.$element.attr('aria-pressed', !this.$element.hasClass('active'));
                this.$element.toggleClass('active');
            }
        };
        function Plugin(option) {
            return this.each(function () {
                var $this = $(this);
                var data = $this.data('bs.button');
                var options = typeof option == 'object' && option;
                if (!data)
                    $this.data('bs.button', data = new Button(this, options));
                if (option == 'toggle')
                    data.toggle();
                else if (option)
                    data.setState(option);
            });
        }
        var old = $.fn.button;
        $.fn.button = Plugin;
        $.fn.button.Constructor = Button;
        $.fn.button.noConflict = function () {
            $.fn.button = old;
            return this;
        };
        $(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
            var $btn = $(e.target);
            if (!$btn.hasClass('btn'))
                $btn = $btn.closest('.btn');
            Plugin.call($btn, 'toggle');
            if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]')))
                e.preventDefault();
        }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
            $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));
        });
    }(jQuery);
    +function ($) {
        'use strict';
        var Carousel = function (element, options) {
            this.$element = $(element);
            this.$indicators = this.$element.find('.carousel-indicators');
            this.options = options;
            this.paused = null;
            this.sliding = null;
            this.interval = null;
            this.$active = null;
            this.$items = null;
            this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this));
            this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));
        };
        Carousel.VERSION = '3.3.6';
        Carousel.TRANSITION_DURATION = 600;
        Carousel.DEFAULTS = {
            interval: 5000,
            pause: 'hover',
            wrap: true,
            keyboard: true
        };
        Carousel.prototype.keydown = function (e) {
            if (/input|textarea/i.test(e.target.tagName))
                return;
            switch (e.which) {
            case 37:
                this.prev();
                break;
            case 39:
                this.next();
                break;
            default:
                return;
            }
            e.preventDefault();
        };
        Carousel.prototype.cycle = function (e) {
            e || (this.paused = false);
            this.interval && clearInterval(this.interval);
            this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
            return this;
        };
        Carousel.prototype.getItemIndex = function (item) {
            this.$items = item.parent().children('.item');
            return this.$items.index(item || this.$active);
        };
        Carousel.prototype.getItemForDirection = function (direction, active) {
            var activeIndex = this.getItemIndex(active);
            var willWrap = direction == 'prev' && activeIndex === 0 || direction == 'next' && activeIndex == this.$items.length - 1;
            if (willWrap && !this.options.wrap)
                return active;
            var delta = direction == 'prev' ? -1 : 1;
            var itemIndex = (activeIndex + delta) % this.$items.length;
            return this.$items.eq(itemIndex);
        };
        Carousel.prototype.to = function (pos) {
            var that = this;
            var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));
            if (pos > this.$items.length - 1 || pos < 0)
                return;
            if (this.sliding)
                return this.$element.one('slid.bs.carousel', function () {
                    that.to(pos);
                });
            if (activeIndex == pos)
                return this.pause().cycle();
            return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos));
        };
        Carousel.prototype.pause = function (e) {
            e || (this.paused = true);
            if (this.$element.find('.next, .prev').length && $.support.transition) {
                this.$element.trigger($.support.transition.end);
                this.cycle(true);
            }
            this.interval = clearInterval(this.interval);
            return this;
        };
        Carousel.prototype.next = function () {
            if (this.sliding)
                return;
            return this.slide('next');
        };
        Carousel.prototype.prev = function () {
            if (this.sliding)
                return;
            return this.slide('prev');
        };
        Carousel.prototype.slide = function (type, next) {
            var $active = this.$element.find('.item.active');
            var $next = next || this.getItemForDirection(type, $active);
            var isCycling = this.interval;
            var direction = type == 'next' ? 'left' : 'right';
            var that = this;
            if ($next.hasClass('active'))
                return this.sliding = false;
            var relatedTarget = $next[0];
            var slideEvent = $.Event('slide.bs.carousel', {
                relatedTarget: relatedTarget,
                direction: direction
            });
            this.$element.trigger(slideEvent);
            if (slideEvent.isDefaultPrevented())
                return;
            this.sliding = true;
            isCycling && this.pause();
            if (this.$indicators.length) {
                this.$indicators.find('.active').removeClass('active');
                var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
                $nextIndicator && $nextIndicator.addClass('active');
            }
            var slidEvent = $.Event('slid.bs.carousel', {
                relatedTarget: relatedTarget,
                direction: direction
            });
            if ($.support.transition && this.$element.hasClass('slide')) {
                $next.addClass(type);
                $next[0].offsetWidth;
                $active.addClass(direction);
                $next.addClass(direction);
                $active.one('bsTransitionEnd', function () {
                    $next.removeClass([
                        type,
                        direction
                    ].join(' ')).addClass('active');
                    $active.removeClass([
                        'active',
                        direction
                    ].join(' '));
                    that.sliding = false;
                    setTimeout(function () {
                        that.$element.trigger(slidEvent);
                    }, 0);
                }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
            } else {
                $active.removeClass('active');
                $next.addClass('active');
                this.sliding = false;
                this.$element.trigger(slidEvent);
            }
            isCycling && this.cycle();
            return this;
        };
        function Plugin(option) {
            return this.each(function () {
                var $this = $(this);
                var data = $this.data('bs.carousel');
                var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option);
                var action = typeof option == 'string' ? option : options.slide;
                if (!data)
                    $this.data('bs.carousel', data = new Carousel(this, options));
                if (typeof option == 'number')
                    data.to(option);
                else if (action)
                    data[action]();
                else if (options.interval)
                    data.pause().cycle();
            });
        }
        var old = $.fn.carousel;
        $.fn.carousel = Plugin;
        $.fn.carousel.Constructor = Carousel;
        $.fn.carousel.noConflict = function () {
            $.fn.carousel = old;
            return this;
        };
        var clickHandler = function (e) {
            var href;
            var $this = $(this);
            var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''));
            if (!$target.hasClass('carousel'))
                return;
            var options = $.extend({}, $target.data(), $this.data());
            var slideIndex = $this.attr('data-slide-to');
            if (slideIndex)
                options.interval = false;
            Plugin.call($target, options);
            if (slideIndex) {
                $target.data('bs.carousel').to(slideIndex);
            }
            e.preventDefault();
        };
        $(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler);
        $(window).on('load', function () {
            $('[data-ride="carousel"]').each(function () {
                var $carousel = $(this);
                Plugin.call($carousel, $carousel.data());
            });
        });
    }(jQuery);
    +function ($) {
        'use strict';
        var Collapse = function (element, options) {
            this.$element = $(element);
            this.options = $.extend({}, Collapse.DEFAULTS, options);
            this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
            this.transitioning = null;
            if (this.options.parent) {
                this.$parent = this.getParent();
            } else {
                this.addAriaAndCollapsedClass(this.$element, this.$trigger);
            }
            if (this.options.toggle)
                this.toggle();
        };
        Collapse.VERSION = '3.3.6';
        Collapse.TRANSITION_DURATION = 350;
        Collapse.DEFAULTS = { toggle: true };
        Collapse.prototype.dimension = function () {
            var hasWidth = this.$element.hasClass('width');
            return hasWidth ? 'width' : 'height';
        };
        Collapse.prototype.show = function () {
            if (this.transitioning || this.$element.hasClass('in'))
                return;
            var activesData;
            var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing');
            if (actives && actives.length) {
                activesData = actives.data('bs.collapse');
                if (activesData && activesData.transitioning)
                    return;
            }
            var startEvent = $.Event('show.bs.collapse');
            this.$element.trigger(startEvent);
            if (startEvent.isDefaultPrevented())
                return;
            if (actives && actives.length) {
                Plugin.call(actives, 'hide');
                activesData || actives.data('bs.collapse', null);
            }
            var dimension = this.dimension();
            this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true);
            this.$trigger.removeClass('collapsed').attr('aria-expanded', true);
            this.transitioning = 1;
            var complete = function () {
                this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');
                this.transitioning = 0;
                this.$element.trigger('shown.bs.collapse');
            };
            if (!$.support.transition)
                return complete.call(this);
            var scrollSize = $.camelCase([
                'scroll',
                dimension
            ].join('-'));
            this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
        };
        Collapse.prototype.hide = function () {
            if (this.transitioning || !this.$element.hasClass('in'))
                return;
            var startEvent = $.Event('hide.bs.collapse');
            this.$element.trigger(startEvent);
            if (startEvent.isDefaultPrevented())
                return;
            var dimension = this.dimension();
            this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
            this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false);
            this.$trigger.addClass('collapsed').attr('aria-expanded', false);
            this.transitioning = 1;
            var complete = function () {
                this.transitioning = 0;
                this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse');
            };
            if (!$.support.transition)
                return complete.call(this);
            this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
        };
        Collapse.prototype.toggle = function () {
            this[this.$element.hasClass('in') ? 'hide' : 'show']();
        };
        Collapse.prototype.getParent = function () {
            return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function (i, element) {
                var $element = $(element);
                this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
            }, this)).end();
        };
        Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
            var isOpen = $element.hasClass('in');
            $element.attr('aria-expanded', isOpen);
            $trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen);
        };
        function getTargetFromTrigger($trigger) {
            var href;
            var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '');
            return $(target);
        }
        function Plugin(option) {
            return this.each(function () {
                var $this = $(this);
                var data = $this.data('bs.collapse');
                var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option);
                if (!data && options.toggle && /show|hide/.test(option))
                    options.toggle = false;
                if (!data)
                    $this.data('bs.collapse', data = new Collapse(this, options));
                if (typeof option == 'string')
                    data[option]();
            });
        }
        var old = $.fn.collapse;
        $.fn.collapse = Plugin;
        $.fn.collapse.Constructor = Collapse;
        $.fn.collapse.noConflict = function () {
            $.fn.collapse = old;
            return this;
        };
        $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
            var $this = $(this);
            if (!$this.attr('data-target'))
                e.preventDefault();
            var $target = getTargetFromTrigger($this);
            var data = $target.data('bs.collapse');
            var option = data ? 'toggle' : $this.data();
            Plugin.call($target, option);
        });
    }(jQuery);
    +function ($) {
        'use strict';
        var backdrop = '.dropdown-backdrop';
        var toggle = '[data-toggle="dropdown"]';
        var Dropdown = function (element) {
            $(element).on('click.bs.dropdown', this.toggle);
        };
        Dropdown.VERSION = '3.3.6';
        function getParent($this) {
            var selector = $this.attr('data-target');
            if (!selector) {
                selector = $this.attr('href');
                selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '');
            }
            var $parent = selector && $(selector);
            return $parent && $parent.length ? $parent : $this.parent();
        }
        function clearMenus(e) {
            if (e && e.which === 3)
                return;
            $(backdrop).remove();
            $(toggle).each(function () {
                var $this = $(this);
                var $parent = getParent($this);
                var relatedTarget = { relatedTarget: this };
                if (!$parent.hasClass('open'))
                    return;
                if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target))
                    return;
                $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));
                if (e.isDefaultPrevented())
                    return;
                $this.attr('aria-expanded', 'false');
                $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget));
            });
        }
        Dropdown.prototype.toggle = function (e) {
            var $this = $(this);
            if ($this.is('.disabled, :disabled'))
                return;
            var $parent = getParent($this);
            var isActive = $parent.hasClass('open');
            clearMenus();
            if (!isActive) {
                if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
                    $(document.createElement('div')).addClass('dropdown-backdrop').insertAfter($(this)).on('click', clearMenus);
                }
                var relatedTarget = { relatedTarget: this };
                $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));
                if (e.isDefaultPrevented())
                    return;
                $this.trigger('focus').attr('aria-expanded', 'true');
                $parent.toggleClass('open').trigger($.Event('shown.bs.dropdown', relatedTarget));
            }
            return false;
        };
        Dropdown.prototype.keydown = function (e) {
            if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName))
                return;
            var $this = $(this);
            e.preventDefault();
            e.stopPropagation();
            if ($this.is('.disabled, :disabled'))
                return;
            var $parent = getParent($this);
            var isActive = $parent.hasClass('open');
            if (!isActive && e.which != 27 || isActive && e.which == 27) {
                if (e.which == 27)
                    $parent.find(toggle).trigger('focus');
                return $this.trigger('click');
            }
            var desc = ' li:not(.disabled):visible a';
            var $items = $parent.find('.dropdown-menu' + desc);
            if (!$items.length)
                return;
            var index = $items.index(e.target);
            if (e.which == 38 && index > 0)
                index--;
            if (e.which == 40 && index < $items.length - 1)
                index++;
            if (!~index)
                index = 0;
            $items.eq(index).trigger('focus');
        };
        function Plugin(option) {
            return this.each(function () {
                var $this = $(this);
                var data = $this.data('bs.dropdown');
                if (!data)
                    $this.data('bs.dropdown', data = new Dropdown(this));
                if (typeof option == 'string')
                    data[option].call($this);
            });
        }
        var old = $.fn.dropdown;
        $.fn.dropdown = Plugin;
        $.fn.dropdown.Constructor = Dropdown;
        $.fn.dropdown.noConflict = function () {
            $.fn.dropdown = old;
            return this;
        };
        $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function (e) {
            e.stopPropagation();
        }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown);
    }(jQuery);
    +function ($) {
        'use strict';
        var Modal = function (element, options) {
            this.options = options;
            this.$body = $(document.body);
            this.$element = $(element);
            this.$dialog = this.$element.find('.modal-dialog');
            this.$backdrop = null;
            this.isShown = null;
            this.originalBodyPad = null;
            this.scrollbarWidth = 0;
            this.ignoreBackdropClick = false;
            if (this.options.remote) {
                this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
                    this.$element.trigger('loaded.bs.modal');
                }, this));
            }
        };
        Modal.VERSION = '3.3.6';
        Modal.TRANSITION_DURATION = 300;
        Modal.BACKDROP_TRANSITION_DURATION = 150;
        Modal.DEFAULTS = {
            backdrop: true,
            keyboard: true,
            show: true
        };
        Modal.prototype.toggle = function (_relatedTarget) {
            return this.isShown ? this.hide() : this.show(_relatedTarget);
        };
        Modal.prototype.show = function (_relatedTarget) {
            var that = this;
            var e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget });
            this.$element.trigger(e);
            if (this.isShown || e.isDefaultPrevented())
                return;
            this.isShown = true;
            this.checkScrollbar();
            this.setScrollbar();
            this.$body.addClass('modal-open');
            this.escape();
            this.resize();
            this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));
            this.$dialog.on('mousedown.dismiss.bs.modal', function () {
                that.$element.one('mouseup.dismiss.bs.modal', function (e) {
                    if ($(e.target).is(that.$element))
                        that.ignoreBackdropClick = true;
                });
            });
            this.backdrop(function () {
                var transition = $.support.transition && that.$element.hasClass('fade');
                if (!that.$element.parent().length) {
                    that.$element.appendTo(that.$body);
                }
                that.$element.show().scrollTop(0);
                that.adjustDialog();
                if (transition) {
                    that.$element[0].offsetWidth;
                }
                that.$element.addClass('in');
                that.enforceFocus();
                var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget });
                transition ? that.$dialog.one('bsTransitionEnd', function () {
                    that.$element.trigger('focus').trigger(e);
                }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
            });
        };
        Modal.prototype.hide = function (e) {
            if (e)
                e.preventDefault();
            e = $.Event('hide.bs.modal');
            this.$element.trigger(e);
            if (!this.isShown || e.isDefaultPrevented())
                return;
            this.isShown = false;
            this.escape();
            this.resize();
            $(document).off('focusin.bs.modal');
            this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');
            this.$dialog.off('mousedown.dismiss.bs.modal');
            $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
        };
        Modal.prototype.enforceFocus = function () {
            $(document).off('focusin.bs.modal').on('focusin.bs.modal', $.proxy(function (e) {
                if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
                    this.$element.trigger('focus');
                }
            }, this));
        };
        Modal.prototype.escape = function () {
            if (this.isShown && this.options.keyboard) {
                this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
                    e.which == 27 && this.hide();
                }, this));
            } else if (!this.isShown) {
                this.$element.off('keydown.dismiss.bs.modal');
            }
        };
        Modal.prototype.resize = function () {
            if (this.isShown) {
                $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
            } else {
                $(window).off('resize.bs.modal');
            }
        };
        Modal.prototype.hideModal = function () {
            var that = this;
            this.$element.hide();
            this.backdrop(function () {
                that.$body.removeClass('modal-open');
                that.resetAdjustments();
                that.resetScrollbar();
                that.$element.trigger('hidden.bs.modal');
            });
        };
        Modal.prototype.removeBackdrop = function () {
            this.$backdrop && this.$backdrop.remove();
            this.$backdrop = null;
        };
        Modal.prototype.backdrop = function (callback) {
            var that = this;
            var animate = this.$element.hasClass('fade') ? 'fade' : '';
            if (this.isShown && this.options.backdrop) {
                var doAnimate = $.support.transition && animate;
                this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);
                this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
                    if (this.ignoreBackdropClick) {
                        this.ignoreBackdropClick = false;
                        return;
                    }
                    if (e.target !== e.currentTarget)
                        return;
                    this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
                }, this));
                if (doAnimate)
                    this.$backdrop[0].offsetWidth;
                this.$backdrop.addClass('in');
                if (!callback)
                    return;
                doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
            } else if (!this.isShown && this.$backdrop) {
                this.$backdrop.removeClass('in');
                var callbackRemove = function () {
                    that.removeBackdrop();
                    callback && callback();
                };
                $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
            } else if (callback) {
                callback();
            }
        };
        Modal.prototype.handleUpdate = function () {
            this.adjustDialog();
        };
        Modal.prototype.adjustDialog = function () {
            var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
            this.$element.css({
                paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
                paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
            });
        };
        Modal.prototype.resetAdjustments = function () {
            this.$element.css({
                paddingLeft: '',
                paddingRight: ''
            });
        };
        Modal.prototype.checkScrollbar = function () {
            var fullWindowWidth = window.innerWidth;
            if (!fullWindowWidth) {
                var documentElementRect = document.documentElement.getBoundingClientRect();
                fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
            }
            this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
            this.scrollbarWidth = this.measureScrollbar();
        };
        Modal.prototype.setScrollbar = function () {
            var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
            this.originalBodyPad = document.body.style.paddingRight || '';
            if (this.bodyIsOverflowing)
                this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
        };
        Modal.prototype.resetScrollbar = function () {
            this.$body.css('padding-right', this.originalBodyPad);
        };
        Modal.prototype.measureScrollbar = function () {
            var scrollDiv = document.createElement('div');
            scrollDiv.className = 'modal-scrollbar-measure';
            this.$body.append(scrollDiv);
            var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
            this.$body[0].removeChild(scrollDiv);
            return scrollbarWidth;
        };
        function Plugin(option, _relatedTarget) {
            return this.each(function () {
                var $this = $(this);
                var data = $this.data('bs.modal');
                var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option);
                if (!data)
                    $this.data('bs.modal', data = new Modal(this, options));
                if (typeof option == 'string')
                    data[option](_relatedTarget);
                else if (options.show)
                    data.show(_relatedTarget);
            });
        }
        var old = $.fn.modal;
        $.fn.modal = Plugin;
        $.fn.modal.Constructor = Modal;
        $.fn.modal.noConflict = function () {
            $.fn.modal = old;
            return this;
        };
        $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
            var $this = $(this);
            var href = $this.attr('href');
            var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, ''));
            var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());
            if ($this.is('a'))
                e.preventDefault();
            $target.one('show.bs.modal', function (showEvent) {
                if (showEvent.isDefaultPrevented())
                    return;
                $target.one('hidden.bs.modal', function () {
                    $this.is(':visible') && $this.trigger('focus');
                });
            });
            Plugin.call($target, option, this);
        });
    }(jQuery);
    +function ($) {
        'use strict';
        var Tooltip = function (element, options) {
            this.type = null;
            this.options = null;
            this.enabled = null;
            this.timeout = null;
            this.hoverState = null;
            this.$element = null;
            this.inState = null;
            this.init('tooltip', element, options);
        };
        Tooltip.VERSION = '3.3.6';
        Tooltip.TRANSITION_DURATION = 150;
        Tooltip.DEFAULTS = {
            animation: true,
            placement: 'top',
            selector: false,
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: 'hover focus',
            title: '',
            delay: 0,
            html: false,
            container: false,
            viewport: {
                selector: 'body',
                padding: 0
            }
        };
        Tooltip.prototype.init = function (type, element, options) {
            this.enabled = true;
            this.type = type;
            this.$element = $(element);
            this.options = this.getOptions(options);
            this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport);
            this.inState = {
                click: false,
                hover: false,
                focus: false
            };
            if (this.$element[0] instanceof document.constructor && !this.options.selector) {
                throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!');
            }
            var triggers = this.options.trigger.split(' ');
            for (var i = triggers.length; i--;) {
                var trigger = triggers[i];
                if (trigger == 'click') {
                    this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
                } else if (trigger != 'manual') {
                    var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
                    var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';
                    this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
                    this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
                }
            }
            this.options.selector ? this._options = $.extend({}, this.options, {
                trigger: 'manual',
                selector: ''
            }) : this.fixTitle();
        };
        Tooltip.prototype.getDefaults = function () {
            return Tooltip.DEFAULTS;
        };
        Tooltip.prototype.getOptions = function (options) {
            options = $.extend({}, this.getDefaults(), this.$element.data(), options);
            if (options.delay && typeof options.delay == 'number') {
                options.delay = {
                    show: options.delay,
                    hide: options.delay
                };
            }
            return options;
        };
        Tooltip.prototype.getDelegateOptions = function () {
            var options = {};
            var defaults = this.getDefaults();
            this._options && $.each(this._options, function (key, value) {
                if (defaults[key] != value)
                    options[key] = value;
            });
            return options;
        };
        Tooltip.prototype.enter = function (obj) {
            var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);
            if (!self) {
                self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
                $(obj.currentTarget).data('bs.' + this.type, self);
            }
            if (obj instanceof $.Event) {
                self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true;
            }
            if (self.tip().hasClass('in') || self.hoverState == 'in') {
                self.hoverState = 'in';
                return;
            }
            clearTimeout(self.timeout);
            self.hoverState = 'in';
            if (!self.options.delay || !self.options.delay.show)
                return self.show();
            self.timeout = setTimeout(function () {
                if (self.hoverState == 'in')
                    self.show();
            }, self.options.delay.show);
        };
        Tooltip.prototype.isInStateTrue = function () {
            for (var key in this.inState) {
                if (this.inState[key])
                    return true;
            }
            return false;
        };
        Tooltip.prototype.leave = function (obj) {
            var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);
            if (!self) {
                self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
                $(obj.currentTarget).data('bs.' + this.type, self);
            }
            if (obj instanceof $.Event) {
                self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false;
            }
            if (self.isInStateTrue())
                return;
            clearTimeout(self.timeout);
            self.hoverState = 'out';
            if (!self.options.delay || !self.options.delay.hide)
                return self.hide();
            self.timeout = setTimeout(function () {
                if (self.hoverState == 'out')
                    self.hide();
            }, self.options.delay.hide);
        };
        Tooltip.prototype.show = function () {
            var e = $.Event('show.bs.' + this.type);
            if (this.hasContent() && this.enabled) {
                this.$element.trigger(e);
                var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
                if (e.isDefaultPrevented() || !inDom)
                    return;
                var that = this;
                var $tip = this.tip();
                var tipId = this.getUID(this.type);
                this.setContent();
                $tip.attr('id', tipId);
                this.$element.attr('aria-describedby', tipId);
                if (this.options.animation)
                    $tip.addClass('fade');
                var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
                var autoToken = /\s?auto?\s?/i;
                var autoPlace = autoToken.test(placement);
                if (autoPlace)
                    placement = placement.replace(autoToken, '') || 'top';
                $tip.detach().css({
                    top: 0,
                    left: 0,
                    display: 'block'
                }).addClass(placement).data('bs.' + this.type, this);
                this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
                this.$element.trigger('inserted.bs.' + this.type);
                var pos = this.getPosition();
                var actualWidth = $tip[0].offsetWidth;
                var actualHeight = $tip[0].offsetHeight;
                if (autoPlace) {
                    var orgPlacement = placement;
                    var viewportDim = this.getPosition(this.$viewport);
                    placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement;
                    $tip.removeClass(orgPlacement).addClass(placement);
                }
                var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
                this.applyPlacement(calculatedOffset, placement);
                var complete = function () {
                    var prevHoverState = that.hoverState;
                    that.$element.trigger('shown.bs.' + that.type);
                    that.hoverState = null;
                    if (prevHoverState == 'out')
                        that.leave(that);
                };
                $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
            }
        };
        Tooltip.prototype.applyPlacement = function (offset, placement) {
            var $tip = this.tip();
            var width = $tip[0].offsetWidth;
            var height = $tip[0].offsetHeight;
            var marginTop = parseInt($tip.css('margin-top'), 10);
            var marginLeft = parseInt($tip.css('margin-left'), 10);
            if (isNaN(marginTop))
                marginTop = 0;
            if (isNaN(marginLeft))
                marginLeft = 0;
            offset.top += marginTop;
            offset.left += marginLeft;
            $.offset.setOffset($tip[0], $.extend({
                using: function (props) {
                    $tip.css({
                        top: Math.round(props.top),
                        left: Math.round(props.left)
                    });
                }
            }, offset), 0);
            $tip.addClass('in');
            var actualWidth = $tip[0].offsetWidth;
            var actualHeight = $tip[0].offsetHeight;
            if (placement == 'top' && actualHeight != height) {
                offset.top = offset.top + height - actualHeight;
            }
            var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
            if (delta.left)
                offset.left += delta.left;
            else
                offset.top += delta.top;
            var isVertical = /top|bottom/.test(placement);
            var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
            var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';
            $tip.offset(offset);
            this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
        };
        Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
            this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '');
        };
        Tooltip.prototype.setContent = function () {
            var $tip = this.tip();
            var title = this.getTitle();
            $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
            $tip.removeClass('fade in top bottom left right');
        };
        Tooltip.prototype.hide = function (callback) {
            var that = this;
            var $tip = $(this.$tip);
            var e = $.Event('hide.bs.' + this.type);
            function complete() {
                if (that.hoverState != 'in')
                    $tip.detach();
                that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
                callback && callback();
            }
            this.$element.trigger(e);
            if (e.isDefaultPrevented())
                return;
            $tip.removeClass('in');
            $.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
            this.hoverState = null;
            return this;
        };
        Tooltip.prototype.fixTitle = function () {
            var $e = this.$element;
            if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
                $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
            }
        };
        Tooltip.prototype.hasContent = function () {
            return this.getTitle();
        };
        Tooltip.prototype.getPosition = function ($element) {
            $element = $element || this.$element;
            var el = $element[0];
            var isBody = el.tagName == 'BODY';
            var elRect = el.getBoundingClientRect();
            if (elRect.width == null) {
                elRect = $.extend({}, elRect, {
                    width: elRect.right - elRect.left,
                    height: elRect.bottom - elRect.top
                });
            }
            var elOffset = isBody ? {
                top: 0,
                left: 0
            } : $element.offset();
            var scroll = { scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop() };
            var outerDims = isBody ? {
                width: $(window).width(),
                height: $(window).height()
            } : null;
            return $.extend({}, elRect, scroll, outerDims, elOffset);
        };
        Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
            return placement == 'bottom' ? {
                top: pos.top + pos.height,
                left: pos.left + pos.width / 2 - actualWidth / 2
            } : placement == 'top' ? {
                top: pos.top - actualHeight,
                left: pos.left + pos.width / 2 - actualWidth / 2
            } : placement == 'left' ? {
                top: pos.top + pos.height / 2 - actualHeight / 2,
                left: pos.left - actualWidth
            } : {
                top: pos.top + pos.height / 2 - actualHeight / 2,
                left: pos.left + pos.width
            };
        };
        Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
            var delta = {
                top: 0,
                left: 0
            };
            if (!this.$viewport)
                return delta;
            var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
            var viewportDimensions = this.getPosition(this.$viewport);
            if (/right|left/.test(placement)) {
                var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
                var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
                if (topEdgeOffset < viewportDimensions.top) {
                    delta.top = viewportDimensions.top - topEdgeOffset;
                } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
                    delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
                }
            } else {
                var leftEdgeOffset = pos.left - viewportPadding;
                var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
                if (leftEdgeOffset < viewportDimensions.left) {
                    delta.left = viewportDimensions.left - leftEdgeOffset;
                } else if (rightEdgeOffset > viewportDimensions.right) {
                    delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
                }
            }
            return delta;
        };
        Tooltip.prototype.getTitle = function () {
            var title;
            var $e = this.$element;
            var o = this.options;
            title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);
            return title;
        };
        Tooltip.prototype.getUID = function (prefix) {
            do
                prefix += ~~(Math.random() * 1000000);
            while (document.getElementById(prefix));
            return prefix;
        };
        Tooltip.prototype.tip = function () {
            if (!this.$tip) {
                this.$tip = $(this.options.template);
                if (this.$tip.length != 1) {
                    throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!');
                }
            }
            return this.$tip;
        };
        Tooltip.prototype.arrow = function () {
            return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');
        };
        Tooltip.prototype.enable = function () {
            this.enabled = true;
        };
        Tooltip.prototype.disable = function () {
            this.enabled = false;
        };
        Tooltip.prototype.toggleEnabled = function () {
            this.enabled = !this.enabled;
        };
        Tooltip.prototype.toggle = function (e) {
            var self = this;
            if (e) {
                self = $(e.currentTarget).data('bs.' + this.type);
                if (!self) {
                    self = new this.constructor(e.currentTarget, this.getDelegateOptions());
                    $(e.currentTarget).data('bs.' + this.type, self);
                }
            }
            if (e) {
                self.inState.click = !self.inState.click;
                if (self.isInStateTrue())
                    self.enter(self);
                else
                    self.leave(self);
            } else {
                self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
            }
        };
        Tooltip.prototype.destroy = function () {
            var that = this;
            clearTimeout(this.timeout);
            this.hide(function () {
                that.$element.off('.' + that.type).removeData('bs.' + that.type);
                if (that.$tip) {
                    that.$tip.detach();
                }
                that.$tip = null;
                that.$arrow = null;
                that.$viewport = null;
            });
        };
        function Plugin(option) {
            return this.each(function () {
                var $this = $(this);
                var data = $this.data('bs.tooltip');
                var options = typeof option == 'object' && option;
                if (!data && /destroy|hide/.test(option))
                    return;
                if (!data)
                    $this.data('bs.tooltip', data = new Tooltip(this, options));
                if (typeof option == 'string')
                    data[option]();
            });
        }
        var old = $.fn.tooltip;
        $.fn.tooltip = Plugin;
        $.fn.tooltip.Constructor = Tooltip;
        $.fn.tooltip.noConflict = function () {
            $.fn.tooltip = old;
            return this;
        };
    }(jQuery);
    +function ($) {
        'use strict';
        var Popover = function (element, options) {
            this.init('popover', element, options);
        };
        if (!$.fn.tooltip)
            throw new Error('Popover requires tooltip.js');
        Popover.VERSION = '3.3.6';
        Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
            placement: 'right',
            trigger: 'click',
            content: '',
            template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
        });
        Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
        Popover.prototype.constructor = Popover;
        Popover.prototype.getDefaults = function () {
            return Popover.DEFAULTS;
        };
        Popover.prototype.setContent = function () {
            var $tip = this.tip();
            var title = this.getTitle();
            var content = this.getContent();
            $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
            $tip.find('.popover-content').children().detach().end()[this.options.html ? typeof content == 'string' ? 'html' : 'append' : 'text'](content);
            $tip.removeClass('fade top bottom left right in');
            if (!$tip.find('.popover-title').html())
                $tip.find('.popover-title').hide();
        };
        Popover.prototype.hasContent = function () {
            return this.getTitle() || this.getContent();
        };
        Popover.prototype.getContent = function () {
            var $e = this.$element;
            var o = this.options;
            return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
        };
        Popover.prototype.arrow = function () {
            return this.$arrow = this.$arrow || this.tip().find('.arrow');
        };
        function Plugin(option) {
            return this.each(function () {
                var $this = $(this);
                var data = $this.data('bs.popover');
                var options = typeof option == 'object' && option;
                if (!data && /destroy|hide/.test(option))
                    return;
                if (!data)
                    $this.data('bs.popover', data = new Popover(this, options));
                if (typeof option == 'string')
                    data[option]();
            });
        }
        var old = $.fn.popover;
        $.fn.popover = Plugin;
        $.fn.popover.Constructor = Popover;
        $.fn.popover.noConflict = function () {
            $.fn.popover = old;
            return this;
        };
    }(jQuery);
    +function ($) {
        'use strict';
        function ScrollSpy(element, options) {
            this.$body = $(document.body);
            this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
            this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
            this.selector = (this.options.target || '') + ' .nav li > a';
            this.offsets = [];
            this.targets = [];
            this.activeTarget = null;
            this.scrollHeight = 0;
            this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this));
            this.refresh();
            this.process();
        }
        ScrollSpy.VERSION = '3.3.6';
        ScrollSpy.DEFAULTS = { offset: 10 };
        ScrollSpy.prototype.getScrollHeight = function () {
            return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
        };
        ScrollSpy.prototype.refresh = function () {
            var that = this;
            var offsetMethod = 'offset';
            var offsetBase = 0;
            this.offsets = [];
            this.targets = [];
            this.scrollHeight = this.getScrollHeight();
            if (!$.isWindow(this.$scrollElement[0])) {
                offsetMethod = 'position';
                offsetBase = this.$scrollElement.scrollTop();
            }
            this.$body.find(this.selector).map(function () {
                var $el = $(this);
                var href = $el.data('target') || $el.attr('href');
                var $href = /^#./.test(href) && $(href);
                return $href && $href.length && $href.is(':visible') && [[
                        $href[offsetMethod]().top + offsetBase,
                        href
                    ]] || null;
            }).sort(function (a, b) {
                return a[0] - b[0];
            }).each(function () {
                that.offsets.push(this[0]);
                that.targets.push(this[1]);
            });
        };
        ScrollSpy.prototype.process = function () {
            var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
            var scrollHeight = this.getScrollHeight();
            var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
            var offsets = this.offsets;
            var targets = this.targets;
            var activeTarget = this.activeTarget;
            var i;
            if (this.scrollHeight != scrollHeight) {
                this.refresh();
            }
            if (scrollTop >= maxScroll) {
                return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
            }
            if (activeTarget && scrollTop < offsets[0]) {
                this.activeTarget = null;
                return this.clear();
            }
            for (i = offsets.length; i--;) {
                activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
            }
        };
        ScrollSpy.prototype.activate = function (target) {
            this.activeTarget = target;
            this.clear();
            var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
            var active = $(selector).parents('li').addClass('active');
            if (active.parent('.dropdown-menu').length) {
                active = active.closest('li.dropdown').addClass('active');
            }
            active.trigger('activate.bs.scrollspy');
        };
        ScrollSpy.prototype.clear = function () {
            $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');
        };
        function Plugin(option) {
            return this.each(function () {
                var $this = $(this);
                var data = $this.data('bs.scrollspy');
                var options = typeof option == 'object' && option;
                if (!data)
                    $this.data('bs.scrollspy', data = new ScrollSpy(this, options));
                if (typeof option == 'string')
                    data[option]();
            });
        }
        var old = $.fn.scrollspy;
        $.fn.scrollspy = Plugin;
        $.fn.scrollspy.Constructor = ScrollSpy;
        $.fn.scrollspy.noConflict = function () {
            $.fn.scrollspy = old;
            return this;
        };
        $(window).on('load.bs.scrollspy.data-api', function () {
            $('[data-spy="scroll"]').each(function () {
                var $spy = $(this);
                Plugin.call($spy, $spy.data());
            });
        });
    }(jQuery);
    +function ($) {
        'use strict';
        var Tab = function (element) {
            this.element = $(element);
        };
        Tab.VERSION = '3.3.6';
        Tab.TRANSITION_DURATION = 150;
        Tab.prototype.show = function () {
            var $this = this.element;
            var $ul = $this.closest('ul:not(.dropdown-menu)');
            var selector = $this.data('target');
            if (!selector) {
                selector = $this.attr('href');
                selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
            }
            if ($this.parent('li').hasClass('active'))
                return;
            var $previous = $ul.find('.active:last a');
            var hideEvent = $.Event('hide.bs.tab', { relatedTarget: $this[0] });
            var showEvent = $.Event('show.bs.tab', { relatedTarget: $previous[0] });
            $previous.trigger(hideEvent);
            $this.trigger(showEvent);
            if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented())
                return;
            var $target = $(selector);
            this.activate($this.closest('li'), $ul);
            this.activate($target, $target.parent(), function () {
                $previous.trigger({
                    type: 'hidden.bs.tab',
                    relatedTarget: $this[0]
                });
                $this.trigger({
                    type: 'shown.bs.tab',
                    relatedTarget: $previous[0]
                });
            });
        };
        Tab.prototype.activate = function (element, container, callback) {
            var $active = container.find('> .active');
            var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);
            function next() {
                $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false);
                element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true);
                if (transition) {
                    element[0].offsetWidth;
                    element.addClass('in');
                } else {
                    element.removeClass('fade');
                }
                if (element.parent('.dropdown-menu').length) {
                    element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true);
                }
                callback && callback();
            }
            $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
            $active.removeClass('in');
        };
        function Plugin(option) {
            return this.each(function () {
                var $this = $(this);
                var data = $this.data('bs.tab');
                if (!data)
                    $this.data('bs.tab', data = new Tab(this));
                if (typeof option == 'string')
                    data[option]();
            });
        }
        var old = $.fn.tab;
        $.fn.tab = Plugin;
        $.fn.tab.Constructor = Tab;
        $.fn.tab.noConflict = function () {
            $.fn.tab = old;
            return this;
        };
        var clickHandler = function (e) {
            e.preventDefault();
            Plugin.call($(this), 'show');
        };
        $(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler);
    }(jQuery);
    +function ($) {
        'use strict';
        var Affix = function (element, options) {
            this.options = $.extend({}, Affix.DEFAULTS, options);
            this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));
            this.$element = $(element);
            this.affixed = null;
            this.unpin = null;
            this.pinnedOffset = null;
            this.checkPosition();
        };
        Affix.VERSION = '3.3.6';
        Affix.RESET = 'affix affix-top affix-bottom';
        Affix.DEFAULTS = {
            offset: 0,
            target: window
        };
        Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
            var scrollTop = this.$target.scrollTop();
            var position = this.$element.offset();
            var targetHeight = this.$target.height();
            if (offsetTop != null && this.affixed == 'top')
                return scrollTop < offsetTop ? 'top' : false;
            if (this.affixed == 'bottom') {
                if (offsetTop != null)
                    return scrollTop + this.unpin <= position.top ? false : 'bottom';
                return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : 'bottom';
            }
            var initializing = this.affixed == null;
            var colliderTop = initializing ? scrollTop : position.top;
            var colliderHeight = initializing ? targetHeight : height;
            if (offsetTop != null && scrollTop <= offsetTop)
                return 'top';
            if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom)
                return 'bottom';
            return false;
        };
        Affix.prototype.getPinnedOffset = function () {
            if (this.pinnedOffset)
                return this.pinnedOffset;
            this.$element.removeClass(Affix.RESET).addClass('affix');
            var scrollTop = this.$target.scrollTop();
            var position = this.$element.offset();
            return this.pinnedOffset = position.top - scrollTop;
        };
        Affix.prototype.checkPositionWithEventLoop = function () {
            setTimeout($.proxy(this.checkPosition, this), 1);
        };
        Affix.prototype.checkPosition = function () {
            if (!this.$element.is(':visible'))
                return;
            var height = this.$element.height();
            var offset = this.options.offset;
            var offsetTop = offset.top;
            var offsetBottom = offset.bottom;
            var scrollHeight = Math.max($(document).height(), $(document.body).height());
            if (typeof offset != 'object')
                offsetBottom = offsetTop = offset;
            if (typeof offsetTop == 'function')
                offsetTop = offset.top(this.$element);
            if (typeof offsetBottom == 'function')
                offsetBottom = offset.bottom(this.$element);
            var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
            if (this.affixed != affix) {
                if (this.unpin != null)
                    this.$element.css('top', '');
                var affixType = 'affix' + (affix ? '-' + affix : '');
                var e = $.Event(affixType + '.bs.affix');
                this.$element.trigger(e);
                if (e.isDefaultPrevented())
                    return;
                this.affixed = affix;
                this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;
                this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix');
            }
            if (affix == 'bottom') {
                this.$element.offset({ top: scrollHeight - height - offsetBottom });
            }
        };
        function Plugin(option) {
            return this.each(function () {
                var $this = $(this);
                var data = $this.data('bs.affix');
                var options = typeof option == 'object' && option;
                if (!data)
                    $this.data('bs.affix', data = new Affix(this, options));
                if (typeof option == 'string')
                    data[option]();
            });
        }
        var old = $.fn.affix;
        $.fn.affix = Plugin;
        $.fn.affix.Constructor = Affix;
        $.fn.affix.noConflict = function () {
            $.fn.affix = old;
            return this;
        };
        $(window).on('load', function () {
            $('[data-spy="affix"]').each(function () {
                var $spy = $(this);
                var data = $spy.data();
                data.offset = data.offset || {};
                if (data.offsetBottom != null)
                    data.offset.bottom = data.offsetBottom;
                if (data.offsetTop != null)
                    data.offset.top = data.offsetTop;
                Plugin.call($spy, data);
            });
        });
    }(jQuery);
    return;
});
define('ngAnimate', ['angular'], function () {
    (function (window, angular) {
        'use strict';
        var noop = angular.noop;
        var copy = angular.copy;
        var extend = angular.extend;
        var jqLite = angular.element;
        var forEach = angular.forEach;
        var isArray = angular.isArray;
        var isString = angular.isString;
        var isObject = angular.isObject;
        var isUndefined = angular.isUndefined;
        var isDefined = angular.isDefined;
        var isFunction = angular.isFunction;
        var isElement = angular.isElement;
        var ELEMENT_NODE = 1;
        var COMMENT_NODE = 8;
        var ADD_CLASS_SUFFIX = '-add';
        var REMOVE_CLASS_SUFFIX = '-remove';
        var EVENT_CLASS_PREFIX = 'ng-';
        var ACTIVE_CLASS_SUFFIX = '-active';
        var PREPARE_CLASS_SUFFIX = '-prepare';
        var NG_ANIMATE_CLASSNAME = 'ng-animate';
        var NG_ANIMATE_CHILDREN_DATA = '$$ngAnimateChildren';
        var CSS_PREFIX = '', TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
        if (isUndefined(window.ontransitionend) && isDefined(window.onwebkittransitionend)) {
            CSS_PREFIX = '-webkit-';
            TRANSITION_PROP = 'WebkitTransition';
            TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
        } else {
            TRANSITION_PROP = 'transition';
            TRANSITIONEND_EVENT = 'transitionend';
        }
        if (isUndefined(window.onanimationend) && isDefined(window.onwebkitanimationend)) {
            CSS_PREFIX = '-webkit-';
            ANIMATION_PROP = 'WebkitAnimation';
            ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
        } else {
            ANIMATION_PROP = 'animation';
            ANIMATIONEND_EVENT = 'animationend';
        }
        var DURATION_KEY = 'Duration';
        var PROPERTY_KEY = 'Property';
        var DELAY_KEY = 'Delay';
        var TIMING_KEY = 'TimingFunction';
        var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
        var ANIMATION_PLAYSTATE_KEY = 'PlayState';
        var SAFE_FAST_FORWARD_DURATION_VALUE = 9999;
        var ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY;
        var ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY;
        var TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY;
        var TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY;
        var isPromiseLike = function (p) {
            return p && p.then ? true : false;
        };
        var ngMinErr = angular.$$minErr('ng');
        function assertArg(arg, name, reason) {
            if (!arg) {
                throw ngMinErr('areq', 'Argument \'{0}\' is {1}', name || '?', reason || 'required');
            }
            return arg;
        }
        function mergeClasses(a, b) {
            if (!a && !b)
                return '';
            if (!a)
                return b;
            if (!b)
                return a;
            if (isArray(a))
                a = a.join(' ');
            if (isArray(b))
                b = b.join(' ');
            return a + ' ' + b;
        }
        function packageStyles(options) {
            var styles = {};
            if (options && (options.to || options.from)) {
                styles.to = options.to;
                styles.from = options.from;
            }
            return styles;
        }
        function pendClasses(classes, fix, isPrefix) {
            var className = '';
            classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [];
            forEach(classes, function (klass, i) {
                if (klass && klass.length > 0) {
                    className += i > 0 ? ' ' : '';
                    className += isPrefix ? fix + klass : klass + fix;
                }
            });
            return className;
        }
        function removeFromArray(arr, val) {
            var index = arr.indexOf(val);
            if (val >= 0) {
                arr.splice(index, 1);
            }
        }
        function stripCommentsFromElement(element) {
            if (element instanceof jqLite) {
                switch (element.length) {
                case 0:
                    return [];
                    break;
                case 1:
                    if (element[0].nodeType === ELEMENT_NODE) {
                        return element;
                    }
                    break;
                default:
                    return jqLite(extractElementNode(element));
                    break;
                }
            }
            if (element.nodeType === ELEMENT_NODE) {
                return jqLite(element);
            }
        }
        function extractElementNode(element) {
            if (!element[0])
                return element;
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType == ELEMENT_NODE) {
                    return elm;
                }
            }
        }
        function $$addClass($$jqLite, element, className) {
            forEach(element, function (elm) {
                $$jqLite.addClass(elm, className);
            });
        }
        function $$removeClass($$jqLite, element, className) {
            forEach(element, function (elm) {
                $$jqLite.removeClass(elm, className);
            });
        }
        function applyAnimationClassesFactory($$jqLite) {
            return function (element, options) {
                if (options.addClass) {
                    $$addClass($$jqLite, element, options.addClass);
                    options.addClass = null;
                }
                if (options.removeClass) {
                    $$removeClass($$jqLite, element, options.removeClass);
                    options.removeClass = null;
                }
            };
        }
        function prepareAnimationOptions(options) {
            options = options || {};
            if (!options.$$prepared) {
                var domOperation = options.domOperation || noop;
                options.domOperation = function () {
                    options.$$domOperationFired = true;
                    domOperation();
                    domOperation = noop;
                };
                options.$$prepared = true;
            }
            return options;
        }
        function applyAnimationStyles(element, options) {
            applyAnimationFromStyles(element, options);
            applyAnimationToStyles(element, options);
        }
        function applyAnimationFromStyles(element, options) {
            if (options.from) {
                element.css(options.from);
                options.from = null;
            }
        }
        function applyAnimationToStyles(element, options) {
            if (options.to) {
                element.css(options.to);
                options.to = null;
            }
        }
        function mergeAnimationDetails(element, oldAnimation, newAnimation) {
            var target = oldAnimation.options || {};
            var newOptions = newAnimation.options || {};
            var toAdd = (target.addClass || '') + ' ' + (newOptions.addClass || '');
            var toRemove = (target.removeClass || '') + ' ' + (newOptions.removeClass || '');
            var classes = resolveElementClasses(element.attr('class'), toAdd, toRemove);
            if (newOptions.preparationClasses) {
                target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses);
                delete newOptions.preparationClasses;
            }
            var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
            extend(target, newOptions);
            if (realDomOperation) {
                target.domOperation = realDomOperation;
            }
            if (classes.addClass) {
                target.addClass = classes.addClass;
            } else {
                target.addClass = null;
            }
            if (classes.removeClass) {
                target.removeClass = classes.removeClass;
            } else {
                target.removeClass = null;
            }
            oldAnimation.addClass = target.addClass;
            oldAnimation.removeClass = target.removeClass;
            return target;
        }
        function resolveElementClasses(existing, toAdd, toRemove) {
            var ADD_CLASS = 1;
            var REMOVE_CLASS = -1;
            var flags = {};
            existing = splitClassesToLookup(existing);
            toAdd = splitClassesToLookup(toAdd);
            forEach(toAdd, function (value, key) {
                flags[key] = ADD_CLASS;
            });
            toRemove = splitClassesToLookup(toRemove);
            forEach(toRemove, function (value, key) {
                flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS;
            });
            var classes = {
                addClass: '',
                removeClass: ''
            };
            forEach(flags, function (val, klass) {
                var prop, allow;
                if (val === ADD_CLASS) {
                    prop = 'addClass';
                    allow = !existing[klass];
                } else if (val === REMOVE_CLASS) {
                    prop = 'removeClass';
                    allow = existing[klass];
                }
                if (allow) {
                    if (classes[prop].length) {
                        classes[prop] += ' ';
                    }
                    classes[prop] += klass;
                }
            });
            function splitClassesToLookup(classes) {
                if (isString(classes)) {
                    classes = classes.split(' ');
                }
                var obj = {};
                forEach(classes, function (klass) {
                    if (klass.length) {
                        obj[klass] = true;
                    }
                });
                return obj;
            }
            return classes;
        }
        function getDomNode(element) {
            return element instanceof angular.element ? element[0] : element;
        }
        function applyGeneratedPreparationClasses(element, event, options) {
            var classes = '';
            if (event) {
                classes = pendClasses(event, EVENT_CLASS_PREFIX, true);
            }
            if (options.addClass) {
                classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX));
            }
            if (options.removeClass) {
                classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX));
            }
            if (classes.length) {
                options.preparationClasses = classes;
                element.addClass(classes);
            }
        }
        function clearGeneratedClasses(element, options) {
            if (options.preparationClasses) {
                element.removeClass(options.preparationClasses);
                options.preparationClasses = null;
            }
            if (options.activeClasses) {
                element.removeClass(options.activeClasses);
                options.activeClasses = null;
            }
        }
        function blockTransitions(node, duration) {
            var value = duration ? '-' + duration + 's' : '';
            applyInlineStyle(node, [
                TRANSITION_DELAY_PROP,
                value
            ]);
            return [
                TRANSITION_DELAY_PROP,
                value
            ];
        }
        function blockKeyframeAnimations(node, applyBlock) {
            var value = applyBlock ? 'paused' : '';
            var key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
            applyInlineStyle(node, [
                key,
                value
            ]);
            return [
                key,
                value
            ];
        }
        function applyInlineStyle(node, styleTuple) {
            var prop = styleTuple[0];
            var value = styleTuple[1];
            node.style[prop] = value;
        }
        function concatWithSpace(a, b) {
            if (!a)
                return b;
            if (!b)
                return a;
            return a + ' ' + b;
        }
        var $$rAFSchedulerFactory = [
            '$$rAF',
            function ($$rAF) {
                var queue, cancelFn;
                function scheduler(tasks) {
                    queue = queue.concat(tasks);
                    nextTick();
                }
                queue = scheduler.queue = [];
                scheduler.waitUntilQuiet = function (fn) {
                    if (cancelFn)
                        cancelFn();
                    cancelFn = $$rAF(function () {
                        cancelFn = null;
                        fn();
                        nextTick();
                    });
                };
                return scheduler;
                function nextTick() {
                    if (!queue.length)
                        return;
                    var items = queue.shift();
                    for (var i = 0; i < items.length; i++) {
                        items[i]();
                    }
                    if (!cancelFn) {
                        $$rAF(function () {
                            if (!cancelFn)
                                nextTick();
                        });
                    }
                }
            }
        ];
        var $$AnimateChildrenDirective = [
            '$interpolate',
            function ($interpolate) {
                return {
                    link: function (scope, element, attrs) {
                        var val = attrs.ngAnimateChildren;
                        if (angular.isString(val) && val.length === 0) {
                            element.data(NG_ANIMATE_CHILDREN_DATA, true);
                        } else {
                            setData($interpolate(val)(scope));
                            attrs.$observe('ngAnimateChildren', setData);
                        }
                        function setData(value) {
                            value = value === 'on' || value === 'true';
                            element.data(NG_ANIMATE_CHILDREN_DATA, value);
                        }
                    }
                };
            }
        ];
        var ANIMATE_TIMER_KEY = '$$animateCss';
        var ONE_SECOND = 1000;
        var BASE_TEN = 10;
        var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
        var CLOSING_TIME_BUFFER = 1.5;
        var DETECT_CSS_PROPERTIES = {
            transitionDuration: TRANSITION_DURATION_PROP,
            transitionDelay: TRANSITION_DELAY_PROP,
            transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
            animationDuration: ANIMATION_DURATION_PROP,
            animationDelay: ANIMATION_DELAY_PROP,
            animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
        };
        var DETECT_STAGGER_CSS_PROPERTIES = {
            transitionDuration: TRANSITION_DURATION_PROP,
            transitionDelay: TRANSITION_DELAY_PROP,
            animationDuration: ANIMATION_DURATION_PROP,
            animationDelay: ANIMATION_DELAY_PROP
        };
        function getCssKeyframeDurationStyle(duration) {
            return [
                ANIMATION_DURATION_PROP,
                duration + 's'
            ];
        }
        function getCssDelayStyle(delay, isKeyframeAnimation) {
            var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
            return [
                prop,
                delay + 's'
            ];
        }
        function computeCssStyles($window, element, properties) {
            var styles = Object.create(null);
            var detectedStyles = $window.getComputedStyle(element) || {};
            forEach(properties, function (formalStyleName, actualStyleName) {
                var val = detectedStyles[formalStyleName];
                if (val) {
                    var c = val.charAt(0);
                    if (c === '-' || c === '+' || c >= 0) {
                        val = parseMaxTime(val);
                    }
                    if (val === 0) {
                        val = null;
                    }
                    styles[actualStyleName] = val;
                }
            });
            return styles;
        }
        function parseMaxTime(str) {
            var maxValue = 0;
            var values = str.split(/\s*,\s*/);
            forEach(values, function (value) {
                if (value.charAt(value.length - 1) == 's') {
                    value = value.substring(0, value.length - 1);
                }
                value = parseFloat(value) || 0;
                maxValue = maxValue ? Math.max(value, maxValue) : value;
            });
            return maxValue;
        }
        function truthyTimingValue(val) {
            return val === 0 || val != null;
        }
        function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
            var style = TRANSITION_PROP;
            var value = duration + 's';
            if (applyOnlyDuration) {
                style += DURATION_KEY;
            } else {
                value += ' linear all';
            }
            return [
                style,
                value
            ];
        }
        function createLocalCacheLookup() {
            var cache = Object.create(null);
            return {
                flush: function () {
                    cache = Object.create(null);
                },
                count: function (key) {
                    var entry = cache[key];
                    return entry ? entry.total : 0;
                },
                get: function (key) {
                    var entry = cache[key];
                    return entry && entry.value;
                },
                put: function (key, value) {
                    if (!cache[key]) {
                        cache[key] = {
                            total: 1,
                            value: value
                        };
                    } else {
                        cache[key].total++;
                    }
                }
            };
        }
        function registerRestorableStyles(backup, node, properties) {
            forEach(properties, function (prop) {
                backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop);
            });
        }
        var $AnimateCssProvider = [
            '$animateProvider',
            function ($animateProvider) {
                var gcsLookup = createLocalCacheLookup();
                var gcsStaggerLookup = createLocalCacheLookup();
                this.$get = [
                    '$window',
                    '$$jqLite',
                    '$$AnimateRunner',
                    '$timeout',
                    '$$forceReflow',
                    '$sniffer',
                    '$$rAFScheduler',
                    '$$animateQueue',
                    function ($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
                        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                        var parentCounter = 0;
                        function gcsHashFn(node, extraClasses) {
                            var KEY = '$$ngAnimateParentKey';
                            var parentNode = node.parentNode;
                            var parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
                            return parentID + '-' + node.getAttribute('class') + '-' + extraClasses;
                        }
                        function computeCachedCssStyles(node, className, cacheKey, properties) {
                            var timings = gcsLookup.get(cacheKey);
                            if (!timings) {
                                timings = computeCssStyles($window, node, properties);
                                if (timings.animationIterationCount === 'infinite') {
                                    timings.animationIterationCount = 1;
                                }
                            }
                            gcsLookup.put(cacheKey, timings);
                            return timings;
                        }
                        function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
                            var stagger;
                            if (gcsLookup.count(cacheKey) > 0) {
                                stagger = gcsStaggerLookup.get(cacheKey);
                                if (!stagger) {
                                    var staggerClassName = pendClasses(className, '-stagger');
                                    $$jqLite.addClass(node, staggerClassName);
                                    stagger = computeCssStyles($window, node, properties);
                                    stagger.animationDuration = Math.max(stagger.animationDuration, 0);
                                    stagger.transitionDuration = Math.max(stagger.transitionDuration, 0);
                                    $$jqLite.removeClass(node, staggerClassName);
                                    gcsStaggerLookup.put(cacheKey, stagger);
                                }
                            }
                            return stagger || {};
                        }
                        var cancelLastRAFRequest;
                        var rafWaitQueue = [];
                        function waitUntilQuiet(callback) {
                            rafWaitQueue.push(callback);
                            $$rAFScheduler.waitUntilQuiet(function () {
                                gcsLookup.flush();
                                gcsStaggerLookup.flush();
                                var pageWidth = $$forceReflow();
                                for (var i = 0; i < rafWaitQueue.length; i++) {
                                    rafWaitQueue[i](pageWidth);
                                }
                                rafWaitQueue.length = 0;
                            });
                        }
                        function computeTimings(node, className, cacheKey) {
                            var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES);
                            var aD = timings.animationDelay;
                            var tD = timings.transitionDelay;
                            timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD;
                            timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration);
                            return timings;
                        }
                        return function init(element, initialOptions) {
                            var options = initialOptions || {};
                            if (!options.$$prepared) {
                                options = prepareAnimationOptions(copy(options));
                            }
                            var restoreStyles = {};
                            var node = getDomNode(element);
                            if (!node || !node.parentNode || !$$animateQueue.enabled()) {
                                return closeAndReturnNoopAnimator();
                            }
                            var temporaryStyles = [];
                            var classes = element.attr('class');
                            var styles = packageStyles(options);
                            var animationClosed;
                            var animationPaused;
                            var animationCompleted;
                            var runner;
                            var runnerHost;
                            var maxDelay;
                            var maxDelayTime;
                            var maxDuration;
                            var maxDurationTime;
                            var startTime;
                            var events = [];
                            if (options.duration === 0 || !$sniffer.animations && !$sniffer.transitions) {
                                return closeAndReturnNoopAnimator();
                            }
                            var method = options.event && isArray(options.event) ? options.event.join(' ') : options.event;
                            var isStructural = method && options.structural;
                            var structuralClassName = '';
                            var addRemoveClassName = '';
                            if (isStructural) {
                                structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, true);
                            } else if (method) {
                                structuralClassName = method;
                            }
                            if (options.addClass) {
                                addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX);
                            }
                            if (options.removeClass) {
                                if (addRemoveClassName.length) {
                                    addRemoveClassName += ' ';
                                }
                                addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX);
                            }
                            if (options.applyClassesEarly && addRemoveClassName.length) {
                                applyAnimationClasses(element, options);
                            }
                            var preparationClasses = [
                                structuralClassName,
                                addRemoveClassName
                            ].join(' ').trim();
                            var fullClassName = classes + ' ' + preparationClasses;
                            var activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX);
                            var hasToStyles = styles.to && Object.keys(styles.to).length > 0;
                            var containsKeyframeAnimation = (options.keyframeStyle || '').length > 0;
                            if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses) {
                                return closeAndReturnNoopAnimator();
                            }
                            var cacheKey, stagger;
                            if (options.stagger > 0) {
                                var staggerVal = parseFloat(options.stagger);
                                stagger = {
                                    transitionDelay: staggerVal,
                                    animationDelay: staggerVal,
                                    transitionDuration: 0,
                                    animationDuration: 0
                                };
                            } else {
                                cacheKey = gcsHashFn(node, fullClassName);
                                stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
                            }
                            if (!options.$$skipPreparationClasses) {
                                $$jqLite.addClass(element, preparationClasses);
                            }
                            var applyOnlyDuration;
                            if (options.transitionStyle) {
                                var transitionStyle = [
                                    TRANSITION_PROP,
                                    options.transitionStyle
                                ];
                                applyInlineStyle(node, transitionStyle);
                                temporaryStyles.push(transitionStyle);
                            }
                            if (options.duration >= 0) {
                                applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                                var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
                                applyInlineStyle(node, durationStyle);
                                temporaryStyles.push(durationStyle);
                            }
                            if (options.keyframeStyle) {
                                var keyframeStyle = [
                                    ANIMATION_PROP,
                                    options.keyframeStyle
                                ];
                                applyInlineStyle(node, keyframeStyle);
                                temporaryStyles.push(keyframeStyle);
                            }
                            var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0;
                            var isFirst = itemIndex === 0;
                            if (isFirst && !options.skipBlocking) {
                                blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
                            }
                            var timings = computeTimings(node, fullClassName, cacheKey);
                            var relativeDelay = timings.maxDelay;
                            maxDelay = Math.max(relativeDelay, 0);
                            maxDuration = timings.maxDuration;
                            var flags = {};
                            flags.hasTransitions = timings.transitionDuration > 0;
                            flags.hasAnimations = timings.animationDuration > 0;
                            flags.hasTransitionAll = flags.hasTransitions && timings.transitionProperty == 'all';
                            flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions);
                            flags.applyAnimationDuration = options.duration && flags.hasAnimations;
                            flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions);
                            flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations;
                            flags.recalculateTimingStyles = addRemoveClassName.length > 0;
                            if (flags.applyTransitionDuration || flags.applyAnimationDuration) {
                                maxDuration = options.duration ? parseFloat(options.duration) : maxDuration;
                                if (flags.applyTransitionDuration) {
                                    flags.hasTransitions = true;
                                    timings.transitionDuration = maxDuration;
                                    applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0;
                                    temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration));
                                }
                                if (flags.applyAnimationDuration) {
                                    flags.hasAnimations = true;
                                    timings.animationDuration = maxDuration;
                                    temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration));
                                }
                            }
                            if (maxDuration === 0 && !flags.recalculateTimingStyles) {
                                return closeAndReturnNoopAnimator();
                            }
                            if (options.delay != null) {
                                var delayStyle;
                                if (typeof options.delay !== 'boolean') {
                                    delayStyle = parseFloat(options.delay);
                                    maxDelay = Math.max(delayStyle, 0);
                                }
                                if (flags.applyTransitionDelay) {
                                    temporaryStyles.push(getCssDelayStyle(delayStyle));
                                }
                                if (flags.applyAnimationDelay) {
                                    temporaryStyles.push(getCssDelayStyle(delayStyle, true));
                                }
                            }
                            if (options.duration == null && timings.transitionDuration > 0) {
                                flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst;
                            }
                            maxDelayTime = maxDelay * ONE_SECOND;
                            maxDurationTime = maxDuration * ONE_SECOND;
                            if (!options.skipBlocking) {
                                flags.blockTransition = timings.transitionDuration > 0;
                                flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
                            }
                            if (options.from) {
                                if (options.cleanupStyles) {
                                    registerRestorableStyles(restoreStyles, node, Object.keys(options.from));
                                }
                                applyAnimationFromStyles(element, options);
                            }
                            if (flags.blockTransition || flags.blockKeyframeAnimation) {
                                applyBlocking(maxDuration);
                            } else if (!options.skipBlocking) {
                                blockTransitions(node, false);
                            }
                            return {
                                $$willAnimate: true,
                                end: endFn,
                                start: function () {
                                    if (animationClosed)
                                        return;
                                    runnerHost = {
                                        end: endFn,
                                        cancel: cancelFn,
                                        resume: null,
                                        pause: null
                                    };
                                    runner = new $$AnimateRunner(runnerHost);
                                    waitUntilQuiet(start);
                                    return runner;
                                }
                            };
                            function endFn() {
                                close();
                            }
                            function cancelFn() {
                                close(true);
                            }
                            function close(rejected) {
                                if (animationClosed || animationCompleted && animationPaused)
                                    return;
                                animationClosed = true;
                                animationPaused = false;
                                if (!options.$$skipPreparationClasses) {
                                    $$jqLite.removeClass(element, preparationClasses);
                                }
                                $$jqLite.removeClass(element, activeClasses);
                                blockKeyframeAnimations(node, false);
                                blockTransitions(node, false);
                                forEach(temporaryStyles, function (entry) {
                                    node.style[entry[0]] = '';
                                });
                                applyAnimationClasses(element, options);
                                applyAnimationStyles(element, options);
                                if (Object.keys(restoreStyles).length) {
                                    forEach(restoreStyles, function (value, prop) {
                                        value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop);
                                    });
                                }
                                if (options.onDone) {
                                    options.onDone();
                                }
                                if (events && events.length) {
                                    element.off(events.join(' '), onAnimationProgress);
                                }
                                var animationTimerData = element.data(ANIMATE_TIMER_KEY);
                                if (animationTimerData) {
                                    $timeout.cancel(animationTimerData[0].timer);
                                    element.removeData(ANIMATE_TIMER_KEY);
                                }
                                if (runner) {
                                    runner.complete(!rejected);
                                }
                            }
                            function applyBlocking(duration) {
                                if (flags.blockTransition) {
                                    blockTransitions(node, duration);
                                }
                                if (flags.blockKeyframeAnimation) {
                                    blockKeyframeAnimations(node, !!duration);
                                }
                            }
                            function closeAndReturnNoopAnimator() {
                                runner = new $$AnimateRunner({
                                    end: endFn,
                                    cancel: cancelFn
                                });
                                waitUntilQuiet(noop);
                                close();
                                return {
                                    $$willAnimate: false,
                                    start: function () {
                                        return runner;
                                    },
                                    end: endFn
                                };
                            }
                            function onAnimationProgress(event) {
                                event.stopPropagation();
                                var ev = event.originalEvent || event;
                                var timeStamp = ev.$manualTimeStamp || Date.now();
                                var elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                                if (Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration) {
                                    animationCompleted = true;
                                    close();
                                }
                            }
                            function start() {
                                if (animationClosed)
                                    return;
                                if (!node.parentNode) {
                                    close();
                                    return;
                                }
                                var playPause = function (playAnimation) {
                                    if (!animationCompleted) {
                                        animationPaused = !playAnimation;
                                        if (timings.animationDuration) {
                                            var value = blockKeyframeAnimations(node, animationPaused);
                                            animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value);
                                        }
                                    } else if (animationPaused && playAnimation) {
                                        animationPaused = false;
                                        close();
                                    }
                                };
                                var maxStagger = itemIndex > 0 && (timings.transitionDuration && stagger.transitionDuration === 0 || timings.animationDuration && stagger.animationDuration === 0) && Math.max(stagger.animationDelay, stagger.transitionDelay);
                                if (maxStagger) {
                                    $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), false);
                                } else {
                                    triggerAnimationStart();
                                }
                                runnerHost.resume = function () {
                                    playPause(true);
                                };
                                runnerHost.pause = function () {
                                    playPause(false);
                                };
                                function triggerAnimationStart() {
                                    if (animationClosed)
                                        return;
                                    applyBlocking(false);
                                    forEach(temporaryStyles, function (entry) {
                                        var key = entry[0];
                                        var value = entry[1];
                                        node.style[key] = value;
                                    });
                                    applyAnimationClasses(element, options);
                                    $$jqLite.addClass(element, activeClasses);
                                    if (flags.recalculateTimingStyles) {
                                        fullClassName = node.className + ' ' + preparationClasses;
                                        cacheKey = gcsHashFn(node, fullClassName);
                                        timings = computeTimings(node, fullClassName, cacheKey);
                                        relativeDelay = timings.maxDelay;
                                        maxDelay = Math.max(relativeDelay, 0);
                                        maxDuration = timings.maxDuration;
                                        if (maxDuration === 0) {
                                            close();
                                            return;
                                        }
                                        flags.hasTransitions = timings.transitionDuration > 0;
                                        flags.hasAnimations = timings.animationDuration > 0;
                                    }
                                    if (flags.applyAnimationDelay) {
                                        relativeDelay = typeof options.delay !== 'boolean' && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay;
                                        maxDelay = Math.max(relativeDelay, 0);
                                        timings.animationDelay = relativeDelay;
                                        delayStyle = getCssDelayStyle(relativeDelay, true);
                                        temporaryStyles.push(delayStyle);
                                        node.style[delayStyle[0]] = delayStyle[1];
                                    }
                                    maxDelayTime = maxDelay * ONE_SECOND;
                                    maxDurationTime = maxDuration * ONE_SECOND;
                                    if (options.easing) {
                                        var easeProp, easeVal = options.easing;
                                        if (flags.hasTransitions) {
                                            easeProp = TRANSITION_PROP + TIMING_KEY;
                                            temporaryStyles.push([
                                                easeProp,
                                                easeVal
                                            ]);
                                            node.style[easeProp] = easeVal;
                                        }
                                        if (flags.hasAnimations) {
                                            easeProp = ANIMATION_PROP + TIMING_KEY;
                                            temporaryStyles.push([
                                                easeProp,
                                                easeVal
                                            ]);
                                            node.style[easeProp] = easeVal;
                                        }
                                    }
                                    if (timings.transitionDuration) {
                                        events.push(TRANSITIONEND_EVENT);
                                    }
                                    if (timings.animationDuration) {
                                        events.push(ANIMATIONEND_EVENT);
                                    }
                                    startTime = Date.now();
                                    var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime;
                                    var endTime = startTime + timerTime;
                                    var animationsData = element.data(ANIMATE_TIMER_KEY) || [];
                                    var setupFallbackTimer = true;
                                    if (animationsData.length) {
                                        var currentTimerData = animationsData[0];
                                        setupFallbackTimer = endTime > currentTimerData.expectedEndTime;
                                        if (setupFallbackTimer) {
                                            $timeout.cancel(currentTimerData.timer);
                                        } else {
                                            animationsData.push(close);
                                        }
                                    }
                                    if (setupFallbackTimer) {
                                        var timer = $timeout(onAnimationExpired, timerTime, false);
                                        animationsData[0] = {
                                            timer: timer,
                                            expectedEndTime: endTime
                                        };
                                        animationsData.push(close);
                                        element.data(ANIMATE_TIMER_KEY, animationsData);
                                    }
                                    if (events.length) {
                                        element.on(events.join(' '), onAnimationProgress);
                                    }
                                    if (options.to) {
                                        if (options.cleanupStyles) {
                                            registerRestorableStyles(restoreStyles, node, Object.keys(options.to));
                                        }
                                        applyAnimationToStyles(element, options);
                                    }
                                }
                                function onAnimationExpired() {
                                    var animationsData = element.data(ANIMATE_TIMER_KEY);
                                    if (animationsData) {
                                        for (var i = 1; i < animationsData.length; i++) {
                                            animationsData[i]();
                                        }
                                        element.removeData(ANIMATE_TIMER_KEY);
                                    }
                                }
                            }
                        };
                    }
                ];
            }
        ];
        var $$AnimateCssDriverProvider = [
            '$$animationProvider',
            function ($$animationProvider) {
                $$animationProvider.drivers.push('$$animateCssDriver');
                var NG_ANIMATE_SHIM_CLASS_NAME = 'ng-animate-shim';
                var NG_ANIMATE_ANCHOR_CLASS_NAME = 'ng-anchor';
                var NG_OUT_ANCHOR_CLASS_NAME = 'ng-anchor-out';
                var NG_IN_ANCHOR_CLASS_NAME = 'ng-anchor-in';
                function isDocumentFragment(node) {
                    return node.parentNode && node.parentNode.nodeType === 11;
                }
                this.$get = [
                    '$animateCss',
                    '$rootScope',
                    '$$AnimateRunner',
                    '$rootElement',
                    '$sniffer',
                    '$$jqLite',
                    '$document',
                    function ($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
                        if (!$sniffer.animations && !$sniffer.transitions)
                            return noop;
                        var bodyNode = $document[0].body;
                        var rootNode = getDomNode($rootElement);
                        var rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
                        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                        return function initDriverFn(animationDetails) {
                            return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails);
                        };
                        function filterCssClasses(classes) {
                            return classes.replace(/\bng-\S+\b/g, '');
                        }
                        function getUniqueValues(a, b) {
                            if (isString(a))
                                a = a.split(' ');
                            if (isString(b))
                                b = b.split(' ');
                            return a.filter(function (val) {
                                return b.indexOf(val) === -1;
                            }).join(' ');
                        }
                        function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
                            var clone = jqLite(getDomNode(outAnchor).cloneNode(true));
                            var startingClasses = filterCssClasses(getClassVal(clone));
                            outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
                            inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME);
                            clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME);
                            rootBodyElement.append(clone);
                            var animatorIn, animatorOut = prepareOutAnimation();
                            if (!animatorOut) {
                                animatorIn = prepareInAnimation();
                                if (!animatorIn) {
                                    return end();
                                }
                            }
                            var startingAnimator = animatorOut || animatorIn;
                            return {
                                start: function () {
                                    var runner;
                                    var currentAnimation = startingAnimator.start();
                                    currentAnimation.done(function () {
                                        currentAnimation = null;
                                        if (!animatorIn) {
                                            animatorIn = prepareInAnimation();
                                            if (animatorIn) {
                                                currentAnimation = animatorIn.start();
                                                currentAnimation.done(function () {
                                                    currentAnimation = null;
                                                    end();
                                                    runner.complete();
                                                });
                                                return currentAnimation;
                                            }
                                        }
                                        end();
                                        runner.complete();
                                    });
                                    runner = new $$AnimateRunner({
                                        end: endFn,
                                        cancel: endFn
                                    });
                                    return runner;
                                    function endFn() {
                                        if (currentAnimation) {
                                            currentAnimation.end();
                                        }
                                    }
                                }
                            };
                            function calculateAnchorStyles(anchor) {
                                var styles = {};
                                var coords = getDomNode(anchor).getBoundingClientRect();
                                forEach([
                                    'width',
                                    'height',
                                    'top',
                                    'left'
                                ], function (key) {
                                    var value = coords[key];
                                    switch (key) {
                                    case 'top':
                                        value += bodyNode.scrollTop;
                                        break;
                                    case 'left':
                                        value += bodyNode.scrollLeft;
                                        break;
                                    }
                                    styles[key] = Math.floor(value) + 'px';
                                });
                                return styles;
                            }
                            function prepareOutAnimation() {
                                var animator = $animateCss(clone, {
                                    addClass: NG_OUT_ANCHOR_CLASS_NAME,
                                    delay: true,
                                    from: calculateAnchorStyles(outAnchor)
                                });
                                return animator.$$willAnimate ? animator : null;
                            }
                            function getClassVal(element) {
                                return element.attr('class') || '';
                            }
                            function prepareInAnimation() {
                                var endingClasses = filterCssClasses(getClassVal(inAnchor));
                                var toAdd = getUniqueValues(endingClasses, startingClasses);
                                var toRemove = getUniqueValues(startingClasses, endingClasses);
                                var animator = $animateCss(clone, {
                                    to: calculateAnchorStyles(inAnchor),
                                    addClass: NG_IN_ANCHOR_CLASS_NAME + ' ' + toAdd,
                                    removeClass: NG_OUT_ANCHOR_CLASS_NAME + ' ' + toRemove,
                                    delay: true
                                });
                                return animator.$$willAnimate ? animator : null;
                            }
                            function end() {
                                clone.remove();
                                outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                                inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME);
                            }
                        }
                        function prepareFromToAnchorAnimation(from, to, classes, anchors) {
                            var fromAnimation = prepareRegularAnimation(from, noop);
                            var toAnimation = prepareRegularAnimation(to, noop);
                            var anchorAnimations = [];
                            forEach(anchors, function (anchor) {
                                var outElement = anchor['out'];
                                var inElement = anchor['in'];
                                var animator = prepareAnchoredAnimation(classes, outElement, inElement);
                                if (animator) {
                                    anchorAnimations.push(animator);
                                }
                            });
                            if (!fromAnimation && !toAnimation && anchorAnimations.length === 0)
                                return;
                            return {
                                start: function () {
                                    var animationRunners = [];
                                    if (fromAnimation) {
                                        animationRunners.push(fromAnimation.start());
                                    }
                                    if (toAnimation) {
                                        animationRunners.push(toAnimation.start());
                                    }
                                    forEach(anchorAnimations, function (animation) {
                                        animationRunners.push(animation.start());
                                    });
                                    var runner = new $$AnimateRunner({
                                        end: endFn,
                                        cancel: endFn
                                    });
                                    $$AnimateRunner.all(animationRunners, function (status) {
                                        runner.complete(status);
                                    });
                                    return runner;
                                    function endFn() {
                                        forEach(animationRunners, function (runner) {
                                            runner.end();
                                        });
                                    }
                                }
                            };
                        }
                        function prepareRegularAnimation(animationDetails) {
                            var element = animationDetails.element;
                            var options = animationDetails.options || {};
                            if (animationDetails.structural) {
                                options.event = animationDetails.event;
                                options.structural = true;
                                options.applyClassesEarly = true;
                                if (animationDetails.event === 'leave') {
                                    options.onDone = options.domOperation;
                                }
                            }
                            if (options.preparationClasses) {
                                options.event = concatWithSpace(options.event, options.preparationClasses);
                            }
                            var animator = $animateCss(element, options);
                            return animator.$$willAnimate ? animator : null;
                        }
                    }
                ];
            }
        ];
        var $$AnimateJsProvider = [
            '$animateProvider',
            function ($animateProvider) {
                this.$get = [
                    '$injector',
                    '$$AnimateRunner',
                    '$$jqLite',
                    function ($injector, $$AnimateRunner, $$jqLite) {
                        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                        return function (element, event, classes, options) {
                            var animationClosed = false;
                            if (arguments.length === 3 && isObject(classes)) {
                                options = classes;
                                classes = null;
                            }
                            options = prepareAnimationOptions(options);
                            if (!classes) {
                                classes = element.attr('class') || '';
                                if (options.addClass) {
                                    classes += ' ' + options.addClass;
                                }
                                if (options.removeClass) {
                                    classes += ' ' + options.removeClass;
                                }
                            }
                            var classesToAdd = options.addClass;
                            var classesToRemove = options.removeClass;
                            var animations = lookupAnimations(classes);
                            var before, after;
                            if (animations.length) {
                                var afterFn, beforeFn;
                                if (event == 'leave') {
                                    beforeFn = 'leave';
                                    afterFn = 'afterLeave';
                                } else {
                                    beforeFn = 'before' + event.charAt(0).toUpperCase() + event.substr(1);
                                    afterFn = event;
                                }
                                if (event !== 'enter' && event !== 'move') {
                                    before = packageAnimations(element, event, options, animations, beforeFn);
                                }
                                after = packageAnimations(element, event, options, animations, afterFn);
                            }
                            if (!before && !after)
                                return;
                            function applyOptions() {
                                options.domOperation();
                                applyAnimationClasses(element, options);
                            }
                            function close() {
                                animationClosed = true;
                                applyOptions();
                                applyAnimationStyles(element, options);
                            }
                            var runner;
                            return {
                                $$willAnimate: true,
                                end: function () {
                                    if (runner) {
                                        runner.end();
                                    } else {
                                        close();
                                        runner = new $$AnimateRunner();
                                        runner.complete(true);
                                    }
                                    return runner;
                                },
                                start: function () {
                                    if (runner) {
                                        return runner;
                                    }
                                    runner = new $$AnimateRunner();
                                    var closeActiveAnimations;
                                    var chain = [];
                                    if (before) {
                                        chain.push(function (fn) {
                                            closeActiveAnimations = before(fn);
                                        });
                                    }
                                    if (chain.length) {
                                        chain.push(function (fn) {
                                            applyOptions();
                                            fn(true);
                                        });
                                    } else {
                                        applyOptions();
                                    }
                                    if (after) {
                                        chain.push(function (fn) {
                                            closeActiveAnimations = after(fn);
                                        });
                                    }
                                    runner.setHost({
                                        end: function () {
                                            endAnimations();
                                        },
                                        cancel: function () {
                                            endAnimations(true);
                                        }
                                    });
                                    $$AnimateRunner.chain(chain, onComplete);
                                    return runner;
                                    function onComplete(success) {
                                        close(success);
                                        runner.complete(success);
                                    }
                                    function endAnimations(cancelled) {
                                        if (!animationClosed) {
                                            (closeActiveAnimations || noop)(cancelled);
                                            onComplete(cancelled);
                                        }
                                    }
                                }
                            };
                            function executeAnimationFn(fn, element, event, options, onDone) {
                                var args;
                                switch (event) {
                                case 'animate':
                                    args = [
                                        element,
                                        options.from,
                                        options.to,
                                        onDone
                                    ];
                                    break;
                                case 'setClass':
                                    args = [
                                        element,
                                        classesToAdd,
                                        classesToRemove,
                                        onDone
                                    ];
                                    break;
                                case 'addClass':
                                    args = [
                                        element,
                                        classesToAdd,
                                        onDone
                                    ];
                                    break;
                                case 'removeClass':
                                    args = [
                                        element,
                                        classesToRemove,
                                        onDone
                                    ];
                                    break;
                                default:
                                    args = [
                                        element,
                                        onDone
                                    ];
                                    break;
                                }
                                args.push(options);
                                var value = fn.apply(fn, args);
                                if (value) {
                                    if (isFunction(value.start)) {
                                        value = value.start();
                                    }
                                    if (value instanceof $$AnimateRunner) {
                                        value.done(onDone);
                                    } else if (isFunction(value)) {
                                        return value;
                                    }
                                }
                                return noop;
                            }
                            function groupEventedAnimations(element, event, options, animations, fnName) {
                                var operations = [];
                                forEach(animations, function (ani) {
                                    var animation = ani[fnName];
                                    if (!animation)
                                        return;
                                    operations.push(function () {
                                        var runner;
                                        var endProgressCb;
                                        var resolved = false;
                                        var onAnimationComplete = function (rejected) {
                                            if (!resolved) {
                                                resolved = true;
                                                (endProgressCb || noop)(rejected);
                                                runner.complete(!rejected);
                                            }
                                        };
                                        runner = new $$AnimateRunner({
                                            end: function () {
                                                onAnimationComplete();
                                            },
                                            cancel: function () {
                                                onAnimationComplete(true);
                                            }
                                        });
                                        endProgressCb = executeAnimationFn(animation, element, event, options, function (result) {
                                            var cancelled = result === false;
                                            onAnimationComplete(cancelled);
                                        });
                                        return runner;
                                    });
                                });
                                return operations;
                            }
                            function packageAnimations(element, event, options, animations, fnName) {
                                var operations = groupEventedAnimations(element, event, options, animations, fnName);
                                if (operations.length === 0) {
                                    var a, b;
                                    if (fnName === 'beforeSetClass') {
                                        a = groupEventedAnimations(element, 'removeClass', options, animations, 'beforeRemoveClass');
                                        b = groupEventedAnimations(element, 'addClass', options, animations, 'beforeAddClass');
                                    } else if (fnName === 'setClass') {
                                        a = groupEventedAnimations(element, 'removeClass', options, animations, 'removeClass');
                                        b = groupEventedAnimations(element, 'addClass', options, animations, 'addClass');
                                    }
                                    if (a) {
                                        operations = operations.concat(a);
                                    }
                                    if (b) {
                                        operations = operations.concat(b);
                                    }
                                }
                                if (operations.length === 0)
                                    return;
                                return function startAnimation(callback) {
                                    var runners = [];
                                    if (operations.length) {
                                        forEach(operations, function (animateFn) {
                                            runners.push(animateFn());
                                        });
                                    }
                                    runners.length ? $$AnimateRunner.all(runners, callback) : callback();
                                    return function endFn(reject) {
                                        forEach(runners, function (runner) {
                                            reject ? runner.cancel() : runner.end();
                                        });
                                    };
                                };
                            }
                        };
                        function lookupAnimations(classes) {
                            classes = isArray(classes) ? classes : classes.split(' ');
                            var matches = [], flagMap = {};
                            for (var i = 0; i < classes.length; i++) {
                                var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass];
                                if (animationFactory && !flagMap[klass]) {
                                    matches.push($injector.get(animationFactory));
                                    flagMap[klass] = true;
                                }
                            }
                            return matches;
                        }
                    }
                ];
            }
        ];
        var $$AnimateJsDriverProvider = [
            '$$animationProvider',
            function ($$animationProvider) {
                $$animationProvider.drivers.push('$$animateJsDriver');
                this.$get = [
                    '$$animateJs',
                    '$$AnimateRunner',
                    function ($$animateJs, $$AnimateRunner) {
                        return function initDriverFn(animationDetails) {
                            if (animationDetails.from && animationDetails.to) {
                                var fromAnimation = prepareAnimation(animationDetails.from);
                                var toAnimation = prepareAnimation(animationDetails.to);
                                if (!fromAnimation && !toAnimation)
                                    return;
                                return {
                                    start: function () {
                                        var animationRunners = [];
                                        if (fromAnimation) {
                                            animationRunners.push(fromAnimation.start());
                                        }
                                        if (toAnimation) {
                                            animationRunners.push(toAnimation.start());
                                        }
                                        $$AnimateRunner.all(animationRunners, done);
                                        var runner = new $$AnimateRunner({
                                            end: endFnFactory(),
                                            cancel: endFnFactory()
                                        });
                                        return runner;
                                        function endFnFactory() {
                                            return function () {
                                                forEach(animationRunners, function (runner) {
                                                    runner.end();
                                                });
                                            };
                                        }
                                        function done(status) {
                                            runner.complete(status);
                                        }
                                    }
                                };
                            } else {
                                return prepareAnimation(animationDetails);
                            }
                        };
                        function prepareAnimation(animationDetails) {
                            var element = animationDetails.element;
                            var event = animationDetails.event;
                            var options = animationDetails.options;
                            var classes = animationDetails.classes;
                            return $$animateJs(element, event, classes, options);
                        }
                    }
                ];
            }
        ];
        var NG_ANIMATE_ATTR_NAME = 'data-ng-animate';
        var NG_ANIMATE_PIN_DATA = '$ngAnimatePin';
        var $$AnimateQueueProvider = [
            '$animateProvider',
            function ($animateProvider) {
                var PRE_DIGEST_STATE = 1;
                var RUNNING_STATE = 2;
                var ONE_SPACE = ' ';
                var rules = this.rules = {
                    skip: [],
                    cancel: [],
                    join: []
                };
                function makeTruthyCssClassMap(classString) {
                    if (!classString) {
                        return null;
                    }
                    var keys = classString.split(ONE_SPACE);
                    var map = Object.create(null);
                    forEach(keys, function (key) {
                        map[key] = true;
                    });
                    return map;
                }
                function hasMatchingClasses(newClassString, currentClassString) {
                    if (newClassString && currentClassString) {
                        var currentClassMap = makeTruthyCssClassMap(currentClassString);
                        return newClassString.split(ONE_SPACE).some(function (className) {
                            return currentClassMap[className];
                        });
                    }
                }
                function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
                    return rules[ruleType].some(function (fn) {
                        return fn(element, currentAnimation, previousAnimation);
                    });
                }
                function hasAnimationClasses(animation, and) {
                    var a = (animation.addClass || '').length > 0;
                    var b = (animation.removeClass || '').length > 0;
                    return and ? a && b : a || b;
                }
                rules.join.push(function (element, newAnimation, currentAnimation) {
                    return !newAnimation.structural && hasAnimationClasses(newAnimation);
                });
                rules.skip.push(function (element, newAnimation, currentAnimation) {
                    return !newAnimation.structural && !hasAnimationClasses(newAnimation);
                });
                rules.skip.push(function (element, newAnimation, currentAnimation) {
                    return currentAnimation.event == 'leave' && newAnimation.structural;
                });
                rules.skip.push(function (element, newAnimation, currentAnimation) {
                    return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural;
                });
                rules.cancel.push(function (element, newAnimation, currentAnimation) {
                    return currentAnimation.structural && newAnimation.structural;
                });
                rules.cancel.push(function (element, newAnimation, currentAnimation) {
                    return currentAnimation.state === RUNNING_STATE && newAnimation.structural;
                });
                rules.cancel.push(function (element, newAnimation, currentAnimation) {
                    if (currentAnimation.structural)
                        return false;
                    var nA = newAnimation.addClass;
                    var nR = newAnimation.removeClass;
                    var cA = currentAnimation.addClass;
                    var cR = currentAnimation.removeClass;
                    if (isUndefined(nA) && isUndefined(nR) || isUndefined(cA) && isUndefined(cR)) {
                        return false;
                    }
                    return hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA);
                });
                this.$get = [
                    '$$rAF',
                    '$rootScope',
                    '$rootElement',
                    '$document',
                    '$$HashMap',
                    '$$animation',
                    '$$AnimateRunner',
                    '$templateRequest',
                    '$$jqLite',
                    '$$forceReflow',
                    function ($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
                        var activeAnimationsLookup = new $$HashMap();
                        var disabledElementsLookup = new $$HashMap();
                        var animationsEnabled = null;
                        function postDigestTaskFactory() {
                            var postDigestCalled = false;
                            return function (fn) {
                                if (postDigestCalled) {
                                    fn();
                                } else {
                                    $rootScope.$$postDigest(function () {
                                        postDigestCalled = true;
                                        fn();
                                    });
                                }
                            };
                        }
                        var deregisterWatch = $rootScope.$watch(function () {
                            return $templateRequest.totalPendingRequests === 0;
                        }, function (isEmpty) {
                            if (!isEmpty)
                                return;
                            deregisterWatch();
                            $rootScope.$$postDigest(function () {
                                $rootScope.$$postDigest(function () {
                                    if (animationsEnabled === null) {
                                        animationsEnabled = true;
                                    }
                                });
                            });
                        });
                        var callbackRegistry = {};
                        var classNameFilter = $animateProvider.classNameFilter();
                        var isAnimatableClassName = !classNameFilter ? function () {
                            return true;
                        } : function (className) {
                            return classNameFilter.test(className);
                        };
                        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                        function normalizeAnimationDetails(element, animation) {
                            return mergeAnimationDetails(element, animation, {});
                        }
                        var contains = window.Node.prototype.contains || function (arg) {
                            return this === arg || !!(this.compareDocumentPosition(arg) & 16);
                        };
                        function findCallbacks(parent, element, event) {
                            var targetNode = getDomNode(element);
                            var targetParentNode = getDomNode(parent);
                            var matches = [];
                            var entries = callbackRegistry[event];
                            if (entries) {
                                forEach(entries, function (entry) {
                                    if (contains.call(entry.node, targetNode)) {
                                        matches.push(entry.callback);
                                    } else if (event === 'leave' && contains.call(entry.node, targetParentNode)) {
                                        matches.push(entry.callback);
                                    }
                                });
                            }
                            return matches;
                        }
                        function filterFromRegistry(list, matchContainer, matchCallback) {
                            var containerNode = extractElementNode(matchContainer);
                            return list.filter(function (entry) {
                                var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                                return !isMatch;
                            });
                        }
                        function cleanupEventListeners(phase, element) {
                            if (phase === 'close' && !element[0].parentNode) {
                                $animate.off(element);
                            }
                        }
                        var $animate = {
                            on: function (event, container, callback) {
                                var node = extractElementNode(container);
                                callbackRegistry[event] = callbackRegistry[event] || [];
                                callbackRegistry[event].push({
                                    node: node,
                                    callback: callback
                                });
                                jqLite(container).on('$destroy', function () {
                                    var animationDetails = activeAnimationsLookup.get(node);
                                    if (!animationDetails) {
                                        $animate.off(event, container, callback);
                                    }
                                });
                            },
                            off: function (event, container, callback) {
                                if (arguments.length === 1 && !angular.isString(arguments[0])) {
                                    container = arguments[0];
                                    for (var eventType in callbackRegistry) {
                                        callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container);
                                    }
                                    return;
                                }
                                var entries = callbackRegistry[event];
                                if (!entries)
                                    return;
                                callbackRegistry[event] = arguments.length === 1 ? null : filterFromRegistry(entries, container, callback);
                            },
                            pin: function (element, parentElement) {
                                assertArg(isElement(element), 'element', 'not an element');
                                assertArg(isElement(parentElement), 'parentElement', 'not an element');
                                element.data(NG_ANIMATE_PIN_DATA, parentElement);
                            },
                            push: function (element, event, options, domOperation) {
                                options = options || {};
                                options.domOperation = domOperation;
                                return queueAnimation(element, event, options);
                            },
                            enabled: function (element, bool) {
                                var argCount = arguments.length;
                                if (argCount === 0) {
                                    bool = !!animationsEnabled;
                                } else {
                                    var hasElement = isElement(element);
                                    if (!hasElement) {
                                        bool = animationsEnabled = !!element;
                                    } else {
                                        var node = getDomNode(element);
                                        var recordExists = disabledElementsLookup.get(node);
                                        if (argCount === 1) {
                                            bool = !recordExists;
                                        } else {
                                            disabledElementsLookup.put(node, !bool);
                                        }
                                    }
                                }
                                return bool;
                            }
                        };
                        return $animate;
                        function queueAnimation(element, event, initialOptions) {
                            var options = copy(initialOptions);
                            var node, parent;
                            element = stripCommentsFromElement(element);
                            if (element) {
                                node = getDomNode(element);
                                parent = element.parent();
                            }
                            options = prepareAnimationOptions(options);
                            var runner = new $$AnimateRunner();
                            var runInNextPostDigestOrNow = postDigestTaskFactory();
                            if (isArray(options.addClass)) {
                                options.addClass = options.addClass.join(' ');
                            }
                            if (options.addClass && !isString(options.addClass)) {
                                options.addClass = null;
                            }
                            if (isArray(options.removeClass)) {
                                options.removeClass = options.removeClass.join(' ');
                            }
                            if (options.removeClass && !isString(options.removeClass)) {
                                options.removeClass = null;
                            }
                            if (options.from && !isObject(options.from)) {
                                options.from = null;
                            }
                            if (options.to && !isObject(options.to)) {
                                options.to = null;
                            }
                            if (!node) {
                                close();
                                return runner;
                            }
                            var className = [
                                node.className,
                                options.addClass,
                                options.removeClass
                            ].join(' ');
                            if (!isAnimatableClassName(className)) {
                                close();
                                return runner;
                            }
                            var isStructural = [
                                'enter',
                                'move',
                                'leave'
                            ].indexOf(event) >= 0;
                            var documentHidden = $document[0].hidden;
                            var skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node);
                            var existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {};
                            var hasExistingAnimation = !!existingAnimation.state;
                            if (!skipAnimations && (!hasExistingAnimation || existingAnimation.state != PRE_DIGEST_STATE)) {
                                skipAnimations = !areAnimationsAllowed(element, parent, event);
                            }
                            if (skipAnimations) {
                                if (documentHidden)
                                    notifyProgress(runner, event, 'start');
                                close();
                                if (documentHidden)
                                    notifyProgress(runner, event, 'close');
                                return runner;
                            }
                            if (isStructural) {
                                closeChildAnimations(element);
                            }
                            var newAnimation = {
                                structural: isStructural,
                                element: element,
                                event: event,
                                addClass: options.addClass,
                                removeClass: options.removeClass,
                                close: close,
                                options: options,
                                runner: runner
                            };
                            if (hasExistingAnimation) {
                                var skipAnimationFlag = isAllowed('skip', element, newAnimation, existingAnimation);
                                if (skipAnimationFlag) {
                                    if (existingAnimation.state === RUNNING_STATE) {
                                        close();
                                        return runner;
                                    } else {
                                        mergeAnimationDetails(element, existingAnimation, newAnimation);
                                        return existingAnimation.runner;
                                    }
                                }
                                var cancelAnimationFlag = isAllowed('cancel', element, newAnimation, existingAnimation);
                                if (cancelAnimationFlag) {
                                    if (existingAnimation.state === RUNNING_STATE) {
                                        existingAnimation.runner.end();
                                    } else if (existingAnimation.structural) {
                                        existingAnimation.close();
                                    } else {
                                        mergeAnimationDetails(element, existingAnimation, newAnimation);
                                        return existingAnimation.runner;
                                    }
                                } else {
                                    var joinAnimationFlag = isAllowed('join', element, newAnimation, existingAnimation);
                                    if (joinAnimationFlag) {
                                        if (existingAnimation.state === RUNNING_STATE) {
                                            normalizeAnimationDetails(element, newAnimation);
                                        } else {
                                            applyGeneratedPreparationClasses(element, isStructural ? event : null, options);
                                            event = newAnimation.event = existingAnimation.event;
                                            options = mergeAnimationDetails(element, existingAnimation, newAnimation);
                                            return existingAnimation.runner;
                                        }
                                    }
                                }
                            } else {
                                normalizeAnimationDetails(element, newAnimation);
                            }
                            var isValidAnimation = newAnimation.structural;
                            if (!isValidAnimation) {
                                isValidAnimation = newAnimation.event === 'animate' && Object.keys(newAnimation.options.to || {}).length > 0 || hasAnimationClasses(newAnimation);
                            }
                            if (!isValidAnimation) {
                                close();
                                clearElementAnimationState(element);
                                return runner;
                            }
                            var counter = (existingAnimation.counter || 0) + 1;
                            newAnimation.counter = counter;
                            markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation);
                            $rootScope.$$postDigest(function () {
                                var animationDetails = activeAnimationsLookup.get(node);
                                var animationCancelled = !animationDetails;
                                animationDetails = animationDetails || {};
                                var parentElement = element.parent() || [];
                                var isValidAnimation = parentElement.length > 0 && (animationDetails.event === 'animate' || animationDetails.structural || hasAnimationClasses(animationDetails));
                                if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation) {
                                    if (animationCancelled) {
                                        applyAnimationClasses(element, options);
                                        applyAnimationStyles(element, options);
                                    }
                                    if (animationCancelled || isStructural && animationDetails.event !== event) {
                                        options.domOperation();
                                        runner.end();
                                    }
                                    if (!isValidAnimation) {
                                        clearElementAnimationState(element);
                                    }
                                    return;
                                }
                                event = !animationDetails.structural && hasAnimationClasses(animationDetails, true) ? 'setClass' : animationDetails.event;
                                markElementAnimationState(element, RUNNING_STATE);
                                var realRunner = $$animation(element, event, animationDetails.options);
                                runner.setHost(realRunner);
                                notifyProgress(runner, event, 'start', {});
                                realRunner.done(function (status) {
                                    close(!status);
                                    var animationDetails = activeAnimationsLookup.get(node);
                                    if (animationDetails && animationDetails.counter === counter) {
                                        clearElementAnimationState(getDomNode(element));
                                    }
                                    notifyProgress(runner, event, 'close', {});
                                });
                            });
                            return runner;
                            function notifyProgress(runner, event, phase, data) {
                                runInNextPostDigestOrNow(function () {
                                    var callbacks = findCallbacks(parent, element, event);
                                    if (callbacks.length) {
                                        $$rAF(function () {
                                            forEach(callbacks, function (callback) {
                                                callback(element, phase, data);
                                            });
                                            cleanupEventListeners(phase, element);
                                        });
                                    } else {
                                        cleanupEventListeners(phase, element);
                                    }
                                });
                                runner.progress(event, phase, data);
                            }
                            function close(reject) {
                                clearGeneratedClasses(element, options);
                                applyAnimationClasses(element, options);
                                applyAnimationStyles(element, options);
                                options.domOperation();
                                runner.complete(!reject);
                            }
                        }
                        function closeChildAnimations(element) {
                            var node = getDomNode(element);
                            var children = node.querySelectorAll('[' + NG_ANIMATE_ATTR_NAME + ']');
                            forEach(children, function (child) {
                                var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME));
                                var animationDetails = activeAnimationsLookup.get(child);
                                if (animationDetails) {
                                    switch (state) {
                                    case RUNNING_STATE:
                                        animationDetails.runner.end();
                                    case PRE_DIGEST_STATE:
                                        activeAnimationsLookup.remove(child);
                                        break;
                                    }
                                }
                            });
                        }
                        function clearElementAnimationState(element) {
                            var node = getDomNode(element);
                            node.removeAttribute(NG_ANIMATE_ATTR_NAME);
                            activeAnimationsLookup.remove(node);
                        }
                        function isMatchingElement(nodeOrElmA, nodeOrElmB) {
                            return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB);
                        }
                        function areAnimationsAllowed(element, parentElement, event) {
                            var bodyElement = jqLite($document[0].body);
                            var bodyElementDetected = isMatchingElement(element, bodyElement) || element[0].nodeName === 'HTML';
                            var rootElementDetected = isMatchingElement(element, $rootElement);
                            var parentAnimationDetected = false;
                            var animateChildren;
                            var elementDisabled = disabledElementsLookup.get(getDomNode(element));
                            var parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
                            if (parentHost) {
                                parentElement = parentHost;
                            }
                            parentElement = getDomNode(parentElement);
                            while (parentElement) {
                                if (!rootElementDetected) {
                                    rootElementDetected = isMatchingElement(parentElement, $rootElement);
                                }
                                if (parentElement.nodeType !== ELEMENT_NODE) {
                                    break;
                                }
                                var details = activeAnimationsLookup.get(parentElement) || {};
                                if (!parentAnimationDetected) {
                                    var parentElementDisabled = disabledElementsLookup.get(parentElement);
                                    if (parentElementDisabled === true && elementDisabled !== false) {
                                        elementDisabled = true;
                                        break;
                                    } else if (parentElementDisabled === false) {
                                        elementDisabled = false;
                                    }
                                    parentAnimationDetected = details.structural;
                                }
                                if (isUndefined(animateChildren) || animateChildren === true) {
                                    var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
                                    if (isDefined(value)) {
                                        animateChildren = value;
                                    }
                                }
                                if (parentAnimationDetected && animateChildren === false)
                                    break;
                                if (!bodyElementDetected) {
                                    bodyElementDetected = isMatchingElement(parentElement, bodyElement);
                                }
                                if (bodyElementDetected && rootElementDetected) {
                                    break;
                                }
                                if (!rootElementDetected) {
                                    parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA);
                                    if (parentHost) {
                                        parentElement = getDomNode(parentHost);
                                        continue;
                                    }
                                }
                                parentElement = parentElement.parentNode;
                            }
                            var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== true;
                            return allowAnimation && rootElementDetected && bodyElementDetected;
                        }
                        function markElementAnimationState(element, state, details) {
                            details = details || {};
                            details.state = state;
                            var node = getDomNode(element);
                            node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
                            var oldValue = activeAnimationsLookup.get(node);
                            var newValue = oldValue ? extend(oldValue, details) : details;
                            activeAnimationsLookup.put(node, newValue);
                        }
                    }
                ];
            }
        ];
        var $$AnimationProvider = [
            '$animateProvider',
            function ($animateProvider) {
                var NG_ANIMATE_REF_ATTR = 'ng-animate-ref';
                var drivers = this.drivers = [];
                var RUNNER_STORAGE_KEY = '$$animationRunner';
                function setRunner(element, runner) {
                    element.data(RUNNER_STORAGE_KEY, runner);
                }
                function removeRunner(element) {
                    element.removeData(RUNNER_STORAGE_KEY);
                }
                function getRunner(element) {
                    return element.data(RUNNER_STORAGE_KEY);
                }
                this.$get = [
                    '$$jqLite',
                    '$rootScope',
                    '$injector',
                    '$$AnimateRunner',
                    '$$HashMap',
                    '$$rAFScheduler',
                    function ($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
                        var animationQueue = [];
                        var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
                        function sortAnimations(animations) {
                            var tree = { children: [] };
                            var i, lookup = new $$HashMap();
                            for (i = 0; i < animations.length; i++) {
                                var animation = animations[i];
                                lookup.put(animation.domNode, animations[i] = {
                                    domNode: animation.domNode,
                                    fn: animation.fn,
                                    children: []
                                });
                            }
                            for (i = 0; i < animations.length; i++) {
                                processNode(animations[i]);
                            }
                            return flatten(tree);
                            function processNode(entry) {
                                if (entry.processed)
                                    return entry;
                                entry.processed = true;
                                var elementNode = entry.domNode;
                                var parentNode = elementNode.parentNode;
                                lookup.put(elementNode, entry);
                                var parentEntry;
                                while (parentNode) {
                                    parentEntry = lookup.get(parentNode);
                                    if (parentEntry) {
                                        if (!parentEntry.processed) {
                                            parentEntry = processNode(parentEntry);
                                        }
                                        break;
                                    }
                                    parentNode = parentNode.parentNode;
                                }
                                (parentEntry || tree).children.push(entry);
                                return entry;
                            }
                            function flatten(tree) {
                                var result = [];
                                var queue = [];
                                var i;
                                for (i = 0; i < tree.children.length; i++) {
                                    queue.push(tree.children[i]);
                                }
                                var remainingLevelEntries = queue.length;
                                var nextLevelEntries = 0;
                                var row = [];
                                for (i = 0; i < queue.length; i++) {
                                    var entry = queue[i];
                                    if (remainingLevelEntries <= 0) {
                                        remainingLevelEntries = nextLevelEntries;
                                        nextLevelEntries = 0;
                                        result.push(row);
                                        row = [];
                                    }
                                    row.push(entry.fn);
                                    entry.children.forEach(function (childEntry) {
                                        nextLevelEntries++;
                                        queue.push(childEntry);
                                    });
                                    remainingLevelEntries--;
                                }
                                if (row.length) {
                                    result.push(row);
                                }
                                return result;
                            }
                        }
                        return function (element, event, options) {
                            options = prepareAnimationOptions(options);
                            var isStructural = [
                                'enter',
                                'move',
                                'leave'
                            ].indexOf(event) >= 0;
                            var runner = new $$AnimateRunner({
                                end: function () {
                                    close();
                                },
                                cancel: function () {
                                    close(true);
                                }
                            });
                            if (!drivers.length) {
                                close();
                                return runner;
                            }
                            setRunner(element, runner);
                            var classes = mergeClasses(element.attr('class'), mergeClasses(options.addClass, options.removeClass));
                            var tempClasses = options.tempClasses;
                            if (tempClasses) {
                                classes += ' ' + tempClasses;
                                options.tempClasses = null;
                            }
                            var prepareClassName;
                            if (isStructural) {
                                prepareClassName = 'ng-' + event + PREPARE_CLASS_SUFFIX;
                                $$jqLite.addClass(element, prepareClassName);
                            }
                            animationQueue.push({
                                element: element,
                                classes: classes,
                                event: event,
                                structural: isStructural,
                                options: options,
                                beforeStart: beforeStart,
                                close: close
                            });
                            element.on('$destroy', handleDestroyedElement);
                            if (animationQueue.length > 1)
                                return runner;
                            $rootScope.$$postDigest(function () {
                                var animations = [];
                                forEach(animationQueue, function (entry) {
                                    if (getRunner(entry.element)) {
                                        animations.push(entry);
                                    } else {
                                        entry.close();
                                    }
                                });
                                animationQueue.length = 0;
                                var groupedAnimations = groupAnimations(animations);
                                var toBeSortedAnimations = [];
                                forEach(groupedAnimations, function (animationEntry) {
                                    toBeSortedAnimations.push({
                                        domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                                        fn: function triggerAnimationStart() {
                                            animationEntry.beforeStart();
                                            var startAnimationFn, closeFn = animationEntry.close;
                                            var targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element;
                                            if (getRunner(targetElement)) {
                                                var operation = invokeFirstDriver(animationEntry);
                                                if (operation) {
                                                    startAnimationFn = operation.start;
                                                }
                                            }
                                            if (!startAnimationFn) {
                                                closeFn();
                                            } else {
                                                var animationRunner = startAnimationFn();
                                                animationRunner.done(function (status) {
                                                    closeFn(!status);
                                                });
                                                updateAnimationRunners(animationEntry, animationRunner);
                                            }
                                        }
                                    });
                                });
                                $$rAFScheduler(sortAnimations(toBeSortedAnimations));
                            });
                            return runner;
                            function getAnchorNodes(node) {
                                var SELECTOR = '[' + NG_ANIMATE_REF_ATTR + ']';
                                var items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR);
                                var anchors = [];
                                forEach(items, function (node) {
                                    var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                                    if (attr && attr.length) {
                                        anchors.push(node);
                                    }
                                });
                                return anchors;
                            }
                            function groupAnimations(animations) {
                                var preparedAnimations = [];
                                var refLookup = {};
                                forEach(animations, function (animation, index) {
                                    var element = animation.element;
                                    var node = getDomNode(element);
                                    var event = animation.event;
                                    var enterOrMove = [
                                        'enter',
                                        'move'
                                    ].indexOf(event) >= 0;
                                    var anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                                    if (anchorNodes.length) {
                                        var direction = enterOrMove ? 'to' : 'from';
                                        forEach(anchorNodes, function (anchor) {
                                            var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                                            refLookup[key] = refLookup[key] || {};
                                            refLookup[key][direction] = {
                                                animationID: index,
                                                element: jqLite(anchor)
                                            };
                                        });
                                    } else {
                                        preparedAnimations.push(animation);
                                    }
                                });
                                var usedIndicesLookup = {};
                                var anchorGroups = {};
                                forEach(refLookup, function (operations, key) {
                                    var from = operations.from;
                                    var to = operations.to;
                                    if (!from || !to) {
                                        var index = from ? from.animationID : to.animationID;
                                        var indexKey = index.toString();
                                        if (!usedIndicesLookup[indexKey]) {
                                            usedIndicesLookup[indexKey] = true;
                                            preparedAnimations.push(animations[index]);
                                        }
                                        return;
                                    }
                                    var fromAnimation = animations[from.animationID];
                                    var toAnimation = animations[to.animationID];
                                    var lookupKey = from.animationID.toString();
                                    if (!anchorGroups[lookupKey]) {
                                        var group = anchorGroups[lookupKey] = {
                                            structural: true,
                                            beforeStart: function () {
                                                fromAnimation.beforeStart();
                                                toAnimation.beforeStart();
                                            },
                                            close: function () {
                                                fromAnimation.close();
                                                toAnimation.close();
                                            },
                                            classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                                            from: fromAnimation,
                                            to: toAnimation,
                                            anchors: []
                                        };
                                        if (group.classes.length) {
                                            preparedAnimations.push(group);
                                        } else {
                                            preparedAnimations.push(fromAnimation);
                                            preparedAnimations.push(toAnimation);
                                        }
                                    }
                                    anchorGroups[lookupKey].anchors.push({
                                        'out': from.element,
                                        'in': to.element
                                    });
                                });
                                return preparedAnimations;
                            }
                            function cssClassesIntersection(a, b) {
                                a = a.split(' ');
                                b = b.split(' ');
                                var matches = [];
                                for (var i = 0; i < a.length; i++) {
                                    var aa = a[i];
                                    if (aa.substring(0, 3) === 'ng-')
                                        continue;
                                    for (var j = 0; j < b.length; j++) {
                                        if (aa === b[j]) {
                                            matches.push(aa);
                                            break;
                                        }
                                    }
                                }
                                return matches.join(' ');
                            }
                            function invokeFirstDriver(animationDetails) {
                                for (var i = drivers.length - 1; i >= 0; i--) {
                                    var driverName = drivers[i];
                                    if (!$injector.has(driverName))
                                        continue;
                                    var factory = $injector.get(driverName);
                                    var driver = factory(animationDetails);
                                    if (driver) {
                                        return driver;
                                    }
                                }
                            }
                            function beforeStart() {
                                element.addClass(NG_ANIMATE_CLASSNAME);
                                if (tempClasses) {
                                    $$jqLite.addClass(element, tempClasses);
                                }
                                if (prepareClassName) {
                                    $$jqLite.removeClass(element, prepareClassName);
                                    prepareClassName = null;
                                }
                            }
                            function updateAnimationRunners(animation, newRunner) {
                                if (animation.from && animation.to) {
                                    update(animation.from.element);
                                    update(animation.to.element);
                                } else {
                                    update(animation.element);
                                }
                                function update(element) {
                                    getRunner(element).setHost(newRunner);
                                }
                            }
                            function handleDestroyedElement() {
                                var runner = getRunner(element);
                                if (runner && (event !== 'leave' || !options.$$domOperationFired)) {
                                    runner.end();
                                }
                            }
                            function close(rejected) {
                                element.off('$destroy', handleDestroyedElement);
                                removeRunner(element);
                                applyAnimationClasses(element, options);
                                applyAnimationStyles(element, options);
                                options.domOperation();
                                if (tempClasses) {
                                    $$jqLite.removeClass(element, tempClasses);
                                }
                                element.removeClass(NG_ANIMATE_CLASSNAME);
                                runner.complete(!rejected);
                            }
                        };
                    }
                ];
            }
        ];
        var ngAnimateSwapDirective = [
            '$animate',
            '$rootScope',
            function ($animate, $rootScope) {
                return {
                    restrict: 'A',
                    transclude: 'element',
                    terminal: true,
                    priority: 600,
                    link: function (scope, $element, attrs, ctrl, $transclude) {
                        var previousElement, previousScope;
                        scope.$watchCollection(attrs.ngAnimateSwap || attrs['for'], function (value) {
                            if (previousElement) {
                                $animate.leave(previousElement);
                            }
                            if (previousScope) {
                                previousScope.$destroy();
                                previousScope = null;
                            }
                            if (value || value === 0) {
                                previousScope = scope.$new();
                                $transclude(previousScope, function (element) {
                                    previousElement = element;
                                    $animate.enter(element, null, $element);
                                });
                            }
                        });
                    }
                };
            }
        ];
        angular.module('ngAnimate', []).directive('ngAnimateSwap', ngAnimateSwapDirective).directive('ngAnimateChildren', $$AnimateChildrenDirective).factory('$$rAFScheduler', $$rAFSchedulerFactory).provider('$$animateQueue', $$AnimateQueueProvider).provider('$$animation', $$AnimationProvider).provider('$animateCss', $AnimateCssProvider).provider('$$animateCssDriver', $$AnimateCssDriverProvider).provider('$$animateJs', $$AnimateJsProvider).provider('$$animateJsDriver', $$AnimateJsDriverProvider);
    }(window, window.angular));
    return;
});
define('uiRoute', ['angular'], function () {
    if (typeof module !== 'undefined' && typeof exports !== 'undefined' && module.exports === exports) {
        module.exports = 'ui.router';
    }
    (function (window, angular, undefined) {
        'use strict';
        var isDefined = angular.isDefined, isFunction = angular.isFunction, isString = angular.isString, isObject = angular.isObject, isArray = angular.isArray, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, toJson = angular.toJson;
        function inherit(parent, extra) {
            return extend(new (extend(function () {
            }, { prototype: parent }))(), extra);
        }
        function merge(dst) {
            forEach(arguments, function (obj) {
                if (obj !== dst) {
                    forEach(obj, function (value, key) {
                        if (!dst.hasOwnProperty(key))
                            dst[key] = value;
                    });
                }
            });
            return dst;
        }
        function ancestors(first, second) {
            var path = [];
            for (var n in first.path) {
                if (first.path[n] !== second.path[n])
                    break;
                path.push(first.path[n]);
            }
            return path;
        }
        function objectKeys(object) {
            if (Object.keys) {
                return Object.keys(object);
            }
            var result = [];
            forEach(object, function (val, key) {
                result.push(key);
            });
            return result;
        }
        function indexOf(array, value) {
            if (Array.prototype.indexOf) {
                return array.indexOf(value, Number(arguments[2]) || 0);
            }
            var len = array.length >>> 0, from = Number(arguments[2]) || 0;
            from = from < 0 ? Math.ceil(from) : Math.floor(from);
            if (from < 0)
                from += len;
            for (; from < len; from++) {
                if (from in array && array[from] === value)
                    return from;
            }
            return -1;
        }
        function inheritParams(currentParams, newParams, $current, $to) {
            var parents = ancestors($current, $to), parentParams, inherited = {}, inheritList = [];
            for (var i in parents) {
                if (!parents[i] || !parents[i].params)
                    continue;
                parentParams = objectKeys(parents[i].params);
                if (!parentParams.length)
                    continue;
                for (var j in parentParams) {
                    if (indexOf(inheritList, parentParams[j]) >= 0)
                        continue;
                    inheritList.push(parentParams[j]);
                    inherited[parentParams[j]] = currentParams[parentParams[j]];
                }
            }
            return extend({}, inherited, newParams);
        }
        function equalForKeys(a, b, keys) {
            if (!keys) {
                keys = [];
                for (var n in a)
                    keys.push(n);
            }
            for (var i = 0; i < keys.length; i++) {
                var k = keys[i];
                if (a[k] != b[k])
                    return false;
            }
            return true;
        }
        function filterByKeys(keys, values) {
            var filtered = {};
            forEach(keys, function (name) {
                filtered[name] = values[name];
            });
            return filtered;
        }
        function indexBy(array, propName) {
            var result = {};
            forEach(array, function (item) {
                result[item[propName]] = item;
            });
            return result;
        }
        function pick(obj) {
            var copy = {};
            var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
            forEach(keys, function (key) {
                if (key in obj)
                    copy[key] = obj[key];
            });
            return copy;
        }
        function omit(obj) {
            var copy = {};
            var keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
            for (var key in obj) {
                if (indexOf(keys, key) == -1)
                    copy[key] = obj[key];
            }
            return copy;
        }
        function pluck(collection, key) {
            var result = isArray(collection) ? [] : {};
            forEach(collection, function (val, i) {
                result[i] = isFunction(key) ? key(val) : val[key];
            });
            return result;
        }
        function filter(collection, callback) {
            var array = isArray(collection);
            var result = array ? [] : {};
            forEach(collection, function (val, i) {
                if (callback(val, i)) {
                    result[array ? result.length : i] = val;
                }
            });
            return result;
        }
        function map(collection, callback) {
            var result = isArray(collection) ? [] : {};
            forEach(collection, function (val, i) {
                result[i] = callback(val, i);
            });
            return result;
        }
        angular.module('ui.router.util', ['ng']);
        angular.module('ui.router.router', ['ui.router.util']);
        angular.module('ui.router.state', [
            'ui.router.router',
            'ui.router.util'
        ]);
        angular.module('ui.router', ['ui.router.state']);
        angular.module('ui.router.compat', ['ui.router']);
        $Resolve.$inject = [
            '$q',
            '$injector'
        ];
        function $Resolve($q, $injector) {
            var VISIT_IN_PROGRESS = 1, VISIT_DONE = 2, NOTHING = {}, NO_DEPENDENCIES = [], NO_LOCALS = NOTHING, NO_PARENT = extend($q.when(NOTHING), {
                    $$promises: NOTHING,
                    $$values: NOTHING
                });
            this.study = function (invocables) {
                if (!isObject(invocables))
                    throw new Error('\'invocables\' must be an object');
                var invocableKeys = objectKeys(invocables || {});
                var plan = [], cycle = [], visited = {};
                function visit(value, key) {
                    if (visited[key] === VISIT_DONE)
                        return;
                    cycle.push(key);
                    if (visited[key] === VISIT_IN_PROGRESS) {
                        cycle.splice(0, indexOf(cycle, key));
                        throw new Error('Cyclic dependency: ' + cycle.join(' -> '));
                    }
                    visited[key] = VISIT_IN_PROGRESS;
                    if (isString(value)) {
                        plan.push(key, [function () {
                                return $injector.get(value);
                            }], NO_DEPENDENCIES);
                    } else {
                        var params = $injector.annotate(value);
                        forEach(params, function (param) {
                            if (param !== key && invocables.hasOwnProperty(param))
                                visit(invocables[param], param);
                        });
                        plan.push(key, value, params);
                    }
                    cycle.pop();
                    visited[key] = VISIT_DONE;
                }
                forEach(invocables, visit);
                invocables = cycle = visited = null;
                function isResolve(value) {
                    return isObject(value) && value.then && value.$$promises;
                }
                return function (locals, parent, self) {
                    if (isResolve(locals) && self === undefined) {
                        self = parent;
                        parent = locals;
                        locals = null;
                    }
                    if (!locals)
                        locals = NO_LOCALS;
                    else if (!isObject(locals)) {
                        throw new Error('\'locals\' must be an object');
                    }
                    if (!parent)
                        parent = NO_PARENT;
                    else if (!isResolve(parent)) {
                        throw new Error('\'parent\' must be a promise returned by $resolve.resolve()');
                    }
                    var resolution = $q.defer(), result = resolution.promise, promises = result.$$promises = {}, values = extend({}, locals), wait = 1 + plan.length / 3, merged = false;
                    function done() {
                        if (!--wait) {
                            if (!merged)
                                merge(values, parent.$$values);
                            result.$$values = values;
                            result.$$promises = result.$$promises || true;
                            delete result.$$inheritedValues;
                            resolution.resolve(values);
                        }
                    }
                    function fail(reason) {
                        result.$$failure = reason;
                        resolution.reject(reason);
                    }
                    if (isDefined(parent.$$failure)) {
                        fail(parent.$$failure);
                        return result;
                    }
                    if (parent.$$inheritedValues) {
                        merge(values, omit(parent.$$inheritedValues, invocableKeys));
                    }
                    extend(promises, parent.$$promises);
                    if (parent.$$values) {
                        merged = merge(values, omit(parent.$$values, invocableKeys));
                        result.$$inheritedValues = omit(parent.$$values, invocableKeys);
                        done();
                    } else {
                        if (parent.$$inheritedValues) {
                            result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys);
                        }
                        parent.then(done, fail);
                    }
                    for (var i = 0, ii = plan.length; i < ii; i += 3) {
                        if (locals.hasOwnProperty(plan[i]))
                            done();
                        else
                            invoke(plan[i], plan[i + 1], plan[i + 2]);
                    }
                    function invoke(key, invocable, params) {
                        var invocation = $q.defer(), waitParams = 0;
                        function onfailure(reason) {
                            invocation.reject(reason);
                            fail(reason);
                        }
                        forEach(params, function (dep) {
                            if (promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep)) {
                                waitParams++;
                                promises[dep].then(function (result) {
                                    values[dep] = result;
                                    if (!--waitParams)
                                        proceed();
                                }, onfailure);
                            }
                        });
                        if (!waitParams)
                            proceed();
                        function proceed() {
                            if (isDefined(result.$$failure))
                                return;
                            try {
                                invocation.resolve($injector.invoke(invocable, self, values));
                                invocation.promise.then(function (result) {
                                    values[key] = result;
                                    done();
                                }, onfailure);
                            } catch (e) {
                                onfailure(e);
                            }
                        }
                        promises[key] = invocation.promise;
                    }
                    return result;
                };
            };
            this.resolve = function (invocables, locals, parent, self) {
                return this.study(invocables)(locals, parent, self);
            };
        }
        angular.module('ui.router.util').service('$resolve', $Resolve);
        $TemplateFactory.$inject = [
            '$http',
            '$templateCache',
            '$injector'
        ];
        function $TemplateFactory($http, $templateCache, $injector) {
            this.fromConfig = function (config, params, locals) {
                return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null;
            };
            this.fromString = function (template, params) {
                return isFunction(template) ? template(params) : template;
            };
            this.fromUrl = function (url, params) {
                if (isFunction(url))
                    url = url(params);
                if (url == null)
                    return null;
                else
                    return $http.get(url, {
                        cache: $templateCache,
                        headers: { Accept: 'text/html' }
                    }).then(function (response) {
                        return response.data;
                    });
            };
            this.fromProvider = function (provider, params, locals) {
                return $injector.invoke(provider, null, locals || { params: params });
            };
        }
        angular.module('ui.router.util').service('$templateFactory', $TemplateFactory);
        var $$UMFP;
        function UrlMatcher(pattern, config, parentMatcher) {
            config = extend({ params: {} }, isObject(config) ? config : {});
            var placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, compiled = '^', last = 0, m, segments = this.segments = [], parentParams = parentMatcher ? parentMatcher.params : {}, params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet(), paramNames = [];
            function addParameter(id, type, config, location) {
                paramNames.push(id);
                if (parentParams[id])
                    return parentParams[id];
                if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id))
                    throw new Error('Invalid parameter name \'' + id + '\' in pattern \'' + pattern + '\'');
                if (params[id])
                    throw new Error('Duplicate parameter name \'' + id + '\' in pattern \'' + pattern + '\'');
                params[id] = new $$UMFP.Param(id, type, config, location);
                return params[id];
            }
            function quoteRegExp(string, pattern, squash, optional) {
                var surroundPattern = [
                        '',
                        ''
                    ], result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, '\\$&');
                if (!pattern)
                    return result;
                switch (squash) {
                case false:
                    surroundPattern = [
                        '(',
                        ')' + (optional ? '?' : '')
                    ];
                    break;
                case true:
                    result = result.replace(/\/$/, '');
                    surroundPattern = [
                        '(?:/(',
                        ')|/)?'
                    ];
                    break;
                default:
                    surroundPattern = [
                        '(' + squash + '|',
                        ')?'
                    ];
                    break;
                }
                return result + surroundPattern[0] + pattern + surroundPattern[1];
            }
            this.source = pattern;
            function matchDetails(m, isSearch) {
                var id, regexp, segment, type, cfg, arrayMode;
                id = m[2] || m[3];
                cfg = config.params[id];
                segment = pattern.substring(last, m.index);
                regexp = isSearch ? m[4] : m[4] || (m[1] == '*' ? '.*' : null);
                if (regexp) {
                    type = $$UMFP.type(regexp) || inherit($$UMFP.type('string'), { pattern: new RegExp(regexp, config.caseInsensitive ? 'i' : undefined) });
                }
                return {
                    id: id,
                    regexp: regexp,
                    segment: segment,
                    type: type,
                    cfg: cfg
                };
            }
            var p, param, segment;
            while (m = placeholder.exec(pattern)) {
                p = matchDetails(m, false);
                if (p.segment.indexOf('?') >= 0)
                    break;
                param = addParameter(p.id, p.type, p.cfg, 'path');
                compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional);
                segments.push(p.segment);
                last = placeholder.lastIndex;
            }
            segment = pattern.substring(last);
            var i = segment.indexOf('?');
            if (i >= 0) {
                var search = this.sourceSearch = segment.substring(i);
                segment = segment.substring(0, i);
                this.sourcePath = pattern.substring(0, last + i);
                if (search.length > 0) {
                    last = 0;
                    while (m = searchPlaceholder.exec(search)) {
                        p = matchDetails(m, true);
                        param = addParameter(p.id, p.type, p.cfg, 'search');
                        last = placeholder.lastIndex;
                    }
                }
            } else {
                this.sourcePath = pattern;
                this.sourceSearch = '';
            }
            compiled += quoteRegExp(segment) + (config.strict === false ? '/?' : '') + '$';
            segments.push(segment);
            this.regexp = new RegExp(compiled, config.caseInsensitive ? 'i' : undefined);
            this.prefix = segments[0];
            this.$$paramNames = paramNames;
        }
        UrlMatcher.prototype.concat = function (pattern, config) {
            var defaultConfig = {
                caseInsensitive: $$UMFP.caseInsensitive(),
                strict: $$UMFP.strictMode(),
                squash: $$UMFP.defaultSquashPolicy()
            };
            return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this);
        };
        UrlMatcher.prototype.toString = function () {
            return this.source;
        };
        UrlMatcher.prototype.exec = function (path, searchParams) {
            var m = this.regexp.exec(path);
            if (!m)
                return null;
            searchParams = searchParams || {};
            var paramNames = this.parameters(), nTotal = paramNames.length, nPath = this.segments.length - 1, values = {}, i, j, cfg, paramName;
            if (nPath !== m.length - 1)
                throw new Error('Unbalanced capture group in route \'' + this.source + '\'');
            function decodePathArray(string) {
                function reverseString(str) {
                    return str.split('').reverse().join('');
                }
                function unquoteDashes(str) {
                    return str.replace(/\\-/g, '-');
                }
                var split = reverseString(string).split(/-(?!\\)/);
                var allReversed = map(split, reverseString);
                return map(allReversed, unquoteDashes).reverse();
            }
            var param, paramVal;
            for (i = 0; i < nPath; i++) {
                paramName = paramNames[i];
                param = this.params[paramName];
                paramVal = m[i + 1];
                for (j = 0; j < param.replace.length; j++) {
                    if (param.replace[j].from === paramVal)
                        paramVal = param.replace[j].to;
                }
                if (paramVal && param.array === true)
                    paramVal = decodePathArray(paramVal);
                if (isDefined(paramVal))
                    paramVal = param.type.decode(paramVal);
                values[paramName] = param.value(paramVal);
            }
            for (; i < nTotal; i++) {
                paramName = paramNames[i];
                values[paramName] = this.params[paramName].value(searchParams[paramName]);
                param = this.params[paramName];
                paramVal = searchParams[paramName];
                for (j = 0; j < param.replace.length; j++) {
                    if (param.replace[j].from === paramVal)
                        paramVal = param.replace[j].to;
                }
                if (isDefined(paramVal))
                    paramVal = param.type.decode(paramVal);
                values[paramName] = param.value(paramVal);
            }
            return values;
        };
        UrlMatcher.prototype.parameters = function (param) {
            if (!isDefined(param))
                return this.$$paramNames;
            return this.params[param] || null;
        };
        UrlMatcher.prototype.validates = function (params) {
            return this.params.$$validates(params);
        };
        UrlMatcher.prototype.format = function (values) {
            values = values || {};
            var segments = this.segments, params = this.parameters(), paramset = this.params;
            if (!this.validates(values))
                return null;
            var i, search = false, nPath = segments.length - 1, nTotal = params.length, result = segments[0];
            function encodeDashes(str) {
                return encodeURIComponent(str).replace(/-/g, function (c) {
                    return '%5C%' + c.charCodeAt(0).toString(16).toUpperCase();
                });
            }
            for (i = 0; i < nTotal; i++) {
                var isPathParam = i < nPath;
                var name = params[i], param = paramset[name], value = param.value(values[name]);
                var isDefaultValue = param.isOptional && param.type.equals(param.value(), value);
                var squash = isDefaultValue ? param.squash : false;
                var encoded = param.type.encode(value);
                if (isPathParam) {
                    var nextSegment = segments[i + 1];
                    var isFinalPathParam = i + 1 === nPath;
                    if (squash === false) {
                        if (encoded != null) {
                            if (isArray(encoded)) {
                                result += map(encoded, encodeDashes).join('-');
                            } else {
                                result += encodeURIComponent(encoded);
                            }
                        }
                        result += nextSegment;
                    } else if (squash === true) {
                        var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                        result += nextSegment.match(capture)[1];
                    } else if (isString(squash)) {
                        result += squash + nextSegment;
                    }
                    if (isFinalPathParam && param.squash === true && result.slice(-1) === '/')
                        result = result.slice(0, -1);
                } else {
                    if (encoded == null || isDefaultValue && squash !== false)
                        continue;
                    if (!isArray(encoded))
                        encoded = [encoded];
                    if (encoded.length === 0)
                        continue;
                    encoded = map(encoded, encodeURIComponent).join('&' + name + '=');
                    result += (search ? '&' : '?') + (name + '=' + encoded);
                    search = true;
                }
            }
            return result;
        };
        function Type(config) {
            extend(this, config);
        }
        Type.prototype.is = function (val, key) {
            return true;
        };
        Type.prototype.encode = function (val, key) {
            return val;
        };
        Type.prototype.decode = function (val, key) {
            return val;
        };
        Type.prototype.equals = function (a, b) {
            return a == b;
        };
        Type.prototype.$subPattern = function () {
            var sub = this.pattern.toString();
            return sub.substr(1, sub.length - 2);
        };
        Type.prototype.pattern = /.*/;
        Type.prototype.toString = function () {
            return '{Type:' + this.name + '}';
        };
        Type.prototype.$normalize = function (val) {
            return this.is(val) ? val : this.decode(val);
        };
        Type.prototype.$asArray = function (mode, isSearch) {
            if (!mode)
                return this;
            if (mode === 'auto' && !isSearch)
                throw new Error('\'auto\' array mode is for query parameters only');
            function ArrayType(type, mode) {
                function bindTo(type, callbackName) {
                    return function () {
                        return type[callbackName].apply(type, arguments);
                    };
                }
                function arrayWrap(val) {
                    return isArray(val) ? val : isDefined(val) ? [val] : [];
                }
                function arrayUnwrap(val) {
                    switch (val.length) {
                    case 0:
                        return undefined;
                    case 1:
                        return mode === 'auto' ? val[0] : val;
                    default:
                        return val;
                    }
                }
                function falsey(val) {
                    return !val;
                }
                function arrayHandler(callback, allTruthyMode) {
                    return function handleArray(val) {
                        if (isArray(val) && val.length === 0)
                            return val;
                        val = arrayWrap(val);
                        var result = map(val, callback);
                        if (allTruthyMode === true)
                            return filter(result, falsey).length === 0;
                        return arrayUnwrap(result);
                    };
                }
                function arrayEqualsHandler(callback) {
                    return function handleArray(val1, val2) {
                        var left = arrayWrap(val1), right = arrayWrap(val2);
                        if (left.length !== right.length)
                            return false;
                        for (var i = 0; i < left.length; i++) {
                            if (!callback(left[i], right[i]))
                                return false;
                        }
                        return true;
                    };
                }
                this.encode = arrayHandler(bindTo(type, 'encode'));
                this.decode = arrayHandler(bindTo(type, 'decode'));
                this.is = arrayHandler(bindTo(type, 'is'), true);
                this.equals = arrayEqualsHandler(bindTo(type, 'equals'));
                this.pattern = type.pattern;
                this.$normalize = arrayHandler(bindTo(type, '$normalize'));
                this.name = type.name;
                this.$arrayMode = mode;
            }
            return new ArrayType(this, mode);
        };
        function $UrlMatcherFactory() {
            $$UMFP = this;
            var isCaseInsensitive = false, isStrictMode = true, defaultSquashPolicy = false;
            function valToString(val) {
                return val != null ? val.toString().replace(/~/g, '~~').replace(/\//g, '~2F') : val;
            }
            function valFromString(val) {
                return val != null ? val.toString().replace(/~2F/g, '/').replace(/~~/g, '~') : val;
            }
            var $types = {}, enqueue = true, typeQueue = [], injector, defaultTypes = {
                    'string': {
                        encode: valToString,
                        decode: valFromString,
                        is: function (val) {
                            return val == null || !isDefined(val) || typeof val === 'string';
                        },
                        pattern: /[^\/]*/
                    },
                    'int': {
                        encode: valToString,
                        decode: function (val) {
                            return parseInt(val, 10);
                        },
                        is: function (val) {
                            return isDefined(val) && this.decode(val.toString()) === val;
                        },
                        pattern: /\d+/
                    },
                    'bool': {
                        encode: function (val) {
                            return val ? 1 : 0;
                        },
                        decode: function (val) {
                            return parseInt(val, 10) !== 0;
                        },
                        is: function (val) {
                            return val === true || val === false;
                        },
                        pattern: /0|1/
                    },
                    'date': {
                        encode: function (val) {
                            if (!this.is(val))
                                return undefined;
                            return [
                                val.getFullYear(),
                                ('0' + (val.getMonth() + 1)).slice(-2),
                                ('0' + val.getDate()).slice(-2)
                            ].join('-');
                        },
                        decode: function (val) {
                            if (this.is(val))
                                return val;
                            var match = this.capture.exec(val);
                            return match ? new Date(match[1], match[2] - 1, match[3]) : undefined;
                        },
                        is: function (val) {
                            return val instanceof Date && !isNaN(val.valueOf());
                        },
                        equals: function (a, b) {
                            return this.is(a) && this.is(b) && a.toISOString() === b.toISOString();
                        },
                        pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                        capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
                    },
                    'json': {
                        encode: angular.toJson,
                        decode: angular.fromJson,
                        is: angular.isObject,
                        equals: angular.equals,
                        pattern: /[^\/]*/
                    },
                    'any': {
                        encode: angular.identity,
                        decode: angular.identity,
                        equals: angular.equals,
                        pattern: /.*/
                    }
                };
            function getDefaultConfig() {
                return {
                    strict: isStrictMode,
                    caseInsensitive: isCaseInsensitive
                };
            }
            function isInjectable(value) {
                return isFunction(value) || isArray(value) && isFunction(value[value.length - 1]);
            }
            $UrlMatcherFactory.$$getDefaultValue = function (config) {
                if (!isInjectable(config.value))
                    return config.value;
                if (!injector)
                    throw new Error('Injectable functions cannot be called at configuration time');
                return injector.invoke(config.value);
            };
            this.caseInsensitive = function (value) {
                if (isDefined(value))
                    isCaseInsensitive = value;
                return isCaseInsensitive;
            };
            this.strictMode = function (value) {
                if (isDefined(value))
                    isStrictMode = value;
                return isStrictMode;
            };
            this.defaultSquashPolicy = function (value) {
                if (!isDefined(value))
                    return defaultSquashPolicy;
                if (value !== true && value !== false && !isString(value))
                    throw new Error('Invalid squash policy: ' + value + '. Valid policies: false, true, arbitrary-string');
                defaultSquashPolicy = value;
                return value;
            };
            this.compile = function (pattern, config) {
                return new UrlMatcher(pattern, extend(getDefaultConfig(), config));
            };
            this.isMatcher = function (o) {
                if (!isObject(o))
                    return false;
                var result = true;
                forEach(UrlMatcher.prototype, function (val, name) {
                    if (isFunction(val)) {
                        result = result && (isDefined(o[name]) && isFunction(o[name]));
                    }
                });
                return result;
            };
            this.type = function (name, definition, definitionFn) {
                if (!isDefined(definition))
                    return $types[name];
                if ($types.hasOwnProperty(name))
                    throw new Error('A type named \'' + name + '\' has already been defined.');
                $types[name] = new Type(extend({ name: name }, definition));
                if (definitionFn) {
                    typeQueue.push({
                        name: name,
                        def: definitionFn
                    });
                    if (!enqueue)
                        flushTypeQueue();
                }
                return this;
            };
            function flushTypeQueue() {
                while (typeQueue.length) {
                    var type = typeQueue.shift();
                    if (type.pattern)
                        throw new Error('You cannot override a type\'s .pattern at runtime.');
                    angular.extend($types[type.name], injector.invoke(type.def));
                }
            }
            forEach(defaultTypes, function (type, name) {
                $types[name] = new Type(extend({ name: name }, type));
            });
            $types = inherit($types, {});
            this.$get = [
                '$injector',
                function ($injector) {
                    injector = $injector;
                    enqueue = false;
                    flushTypeQueue();
                    forEach(defaultTypes, function (type, name) {
                        if (!$types[name])
                            $types[name] = new Type(type);
                    });
                    return this;
                }
            ];
            this.Param = function Param(id, type, config, location) {
                var self = this;
                config = unwrapShorthand(config);
                type = getType(config, type, location);
                var arrayMode = getArrayMode();
                type = arrayMode ? type.$asArray(arrayMode, location === 'search') : type;
                if (type.name === 'string' && !arrayMode && location === 'path' && config.value === undefined)
                    config.value = '';
                var isOptional = config.value !== undefined;
                var squash = getSquashPolicy(config, isOptional);
                var replace = getReplace(config, arrayMode, isOptional, squash);
                function unwrapShorthand(config) {
                    var keys = isObject(config) ? objectKeys(config) : [];
                    var isShorthand = indexOf(keys, 'value') === -1 && indexOf(keys, 'type') === -1 && indexOf(keys, 'squash') === -1 && indexOf(keys, 'array') === -1;
                    if (isShorthand)
                        config = { value: config };
                    config.$$fn = isInjectable(config.value) ? config.value : function () {
                        return config.value;
                    };
                    return config;
                }
                function getType(config, urlType, location) {
                    if (config.type && urlType)
                        throw new Error('Param \'' + id + '\' has two type configurations.');
                    if (urlType)
                        return urlType;
                    if (!config.type)
                        return location === 'config' ? $types.any : $types.string;
                    if (angular.isString(config.type))
                        return $types[config.type];
                    if (config.type instanceof Type)
                        return config.type;
                    return new Type(config.type);
                }
                function getArrayMode() {
                    var arrayDefaults = { array: location === 'search' ? 'auto' : false };
                    var arrayParamNomenclature = id.match(/\[\]$/) ? { array: true } : {};
                    return extend(arrayDefaults, arrayParamNomenclature, config).array;
                }
                function getSquashPolicy(config, isOptional) {
                    var squash = config.squash;
                    if (!isOptional || squash === false)
                        return false;
                    if (!isDefined(squash) || squash == null)
                        return defaultSquashPolicy;
                    if (squash === true || isString(squash))
                        return squash;
                    throw new Error('Invalid squash policy: \'' + squash + '\'. Valid policies: false, true, or arbitrary string');
                }
                function getReplace(config, arrayMode, isOptional, squash) {
                    var replace, configuredKeys, defaultPolicy = [
                            {
                                from: '',
                                to: isOptional || arrayMode ? undefined : ''
                            },
                            {
                                from: null,
                                to: isOptional || arrayMode ? undefined : ''
                            }
                        ];
                    replace = isArray(config.replace) ? config.replace : [];
                    if (isString(squash))
                        replace.push({
                            from: squash,
                            to: undefined
                        });
                    configuredKeys = map(replace, function (item) {
                        return item.from;
                    });
                    return filter(defaultPolicy, function (item) {
                        return indexOf(configuredKeys, item.from) === -1;
                    }).concat(replace);
                }
                function $$getDefaultValue() {
                    if (!injector)
                        throw new Error('Injectable functions cannot be called at configuration time');
                    var defaultValue = injector.invoke(config.$$fn);
                    if (defaultValue !== null && defaultValue !== undefined && !self.type.is(defaultValue))
                        throw new Error('Default value (' + defaultValue + ') for parameter \'' + self.id + '\' is not an instance of Type (' + self.type.name + ')');
                    return defaultValue;
                }
                function $value(value) {
                    function hasReplaceVal(val) {
                        return function (obj) {
                            return obj.from === val;
                        };
                    }
                    function $replace(value) {
                        var replacement = map(filter(self.replace, hasReplaceVal(value)), function (obj) {
                            return obj.to;
                        });
                        return replacement.length ? replacement[0] : value;
                    }
                    value = $replace(value);
                    return !isDefined(value) ? $$getDefaultValue() : self.type.$normalize(value);
                }
                function toString() {
                    return '{Param:' + id + ' ' + type + ' squash: \'' + squash + '\' optional: ' + isOptional + '}';
                }
                extend(this, {
                    id: id,
                    type: type,
                    location: location,
                    array: arrayMode,
                    squash: squash,
                    replace: replace,
                    isOptional: isOptional,
                    value: $value,
                    dynamic: undefined,
                    config: config,
                    toString: toString
                });
            };
            function ParamSet(params) {
                extend(this, params || {});
            }
            ParamSet.prototype = {
                $$new: function () {
                    return inherit(this, extend(new ParamSet(), { $$parent: this }));
                },
                $$keys: function () {
                    var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype);
                    while (parent) {
                        chain.push(parent);
                        parent = parent.$$parent;
                    }
                    chain.reverse();
                    forEach(chain, function (paramset) {
                        forEach(objectKeys(paramset), function (key) {
                            if (indexOf(keys, key) === -1 && indexOf(ignore, key) === -1)
                                keys.push(key);
                        });
                    });
                    return keys;
                },
                $$values: function (paramValues) {
                    var values = {}, self = this;
                    forEach(self.$$keys(), function (key) {
                        values[key] = self[key].value(paramValues && paramValues[key]);
                    });
                    return values;
                },
                $$equals: function (paramValues1, paramValues2) {
                    var equal = true, self = this;
                    forEach(self.$$keys(), function (key) {
                        var left = paramValues1 && paramValues1[key], right = paramValues2 && paramValues2[key];
                        if (!self[key].type.equals(left, right))
                            equal = false;
                    });
                    return equal;
                },
                $$validates: function $$validate(paramValues) {
                    var keys = this.$$keys(), i, param, rawVal, normalized, encoded;
                    for (i = 0; i < keys.length; i++) {
                        param = this[keys[i]];
                        rawVal = paramValues[keys[i]];
                        if ((rawVal === undefined || rawVal === null) && param.isOptional)
                            break;
                        normalized = param.type.$normalize(rawVal);
                        if (!param.type.is(normalized))
                            return false;
                        encoded = param.type.encode(normalized);
                        if (angular.isString(encoded) && !param.type.pattern.exec(encoded))
                            return false;
                    }
                    return true;
                },
                $$parent: undefined
            };
            this.ParamSet = ParamSet;
        }
        angular.module('ui.router.util').provider('$urlMatcherFactory', $UrlMatcherFactory);
        angular.module('ui.router.util').run([
            '$urlMatcherFactory',
            function ($urlMatcherFactory) {
            }
        ]);
        $UrlRouterProvider.$inject = [
            '$locationProvider',
            '$urlMatcherFactoryProvider'
        ];
        function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
            var rules = [], otherwise = null, interceptDeferred = false, listener;
            function regExpPrefix(re) {
                var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
                return prefix != null ? prefix[1].replace(/\\(.)/g, '$1') : '';
            }
            function interpolate(pattern, match) {
                return pattern.replace(/\$(\$|\d{1,2})/, function (m, what) {
                    return match[what === '$' ? 0 : Number(what)];
                });
            }
            this.rule = function (rule) {
                if (!isFunction(rule))
                    throw new Error('\'rule\' must be a function');
                rules.push(rule);
                return this;
            };
            this.otherwise = function (rule) {
                if (isString(rule)) {
                    var redirect = rule;
                    rule = function () {
                        return redirect;
                    };
                } else if (!isFunction(rule))
                    throw new Error('\'rule\' must be a function');
                otherwise = rule;
                return this;
            };
            function handleIfMatch($injector, handler, match) {
                if (!match)
                    return false;
                var result = $injector.invoke(handler, handler, { $match: match });
                return isDefined(result) ? result : true;
            }
            this.when = function (what, handler) {
                var redirect, handlerIsString = isString(handler);
                if (isString(what))
                    what = $urlMatcherFactory.compile(what);
                if (!handlerIsString && !isFunction(handler) && !isArray(handler))
                    throw new Error('invalid \'handler\' in when()');
                var strategies = {
                    matcher: function (what, handler) {
                        if (handlerIsString) {
                            redirect = $urlMatcherFactory.compile(handler);
                            handler = [
                                '$match',
                                function ($match) {
                                    return redirect.format($match);
                                }
                            ];
                        }
                        return extend(function ($injector, $location) {
                            return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()));
                        }, { prefix: isString(what.prefix) ? what.prefix : '' });
                    },
                    regex: function (what, handler) {
                        if (what.global || what.sticky)
                            throw new Error('when() RegExp must not be global or sticky');
                        if (handlerIsString) {
                            redirect = handler;
                            handler = [
                                '$match',
                                function ($match) {
                                    return interpolate(redirect, $match);
                                }
                            ];
                        }
                        return extend(function ($injector, $location) {
                            return handleIfMatch($injector, handler, what.exec($location.path()));
                        }, { prefix: regExpPrefix(what) });
                    }
                };
                var check = {
                    matcher: $urlMatcherFactory.isMatcher(what),
                    regex: what instanceof RegExp
                };
                for (var n in check) {
                    if (check[n])
                        return this.rule(strategies[n](what, handler));
                }
                throw new Error('invalid \'what\' in when()');
            };
            this.deferIntercept = function (defer) {
                if (defer === undefined)
                    defer = true;
                interceptDeferred = defer;
            };
            this.$get = $get;
            $get.$inject = [
                '$location',
                '$rootScope',
                '$injector',
                '$browser',
                '$sniffer'
            ];
            function $get($location, $rootScope, $injector, $browser, $sniffer) {
                var baseHref = $browser.baseHref(), location = $location.url(), lastPushedUrl;
                function appendBasePath(url, isHtml5, absolute) {
                    if (baseHref === '/')
                        return url;
                    if (isHtml5)
                        return baseHref.slice(0, -1) + url;
                    if (absolute)
                        return baseHref.slice(1) + url;
                    return url;
                }
                function update(evt) {
                    if (evt && evt.defaultPrevented)
                        return;
                    var ignoreUpdate = lastPushedUrl && $location.url() === lastPushedUrl;
                    lastPushedUrl = undefined;
                    function check(rule) {
                        var handled = rule($injector, $location);
                        if (!handled)
                            return false;
                        if (isString(handled))
                            $location.replace().url(handled);
                        return true;
                    }
                    var n = rules.length, i;
                    for (i = 0; i < n; i++) {
                        if (check(rules[i]))
                            return;
                    }
                    if (otherwise)
                        check(otherwise);
                }
                function listen() {
                    listener = listener || $rootScope.$on('$locationChangeSuccess', update);
                    return listener;
                }
                if (!interceptDeferred)
                    listen();
                return {
                    sync: function () {
                        update();
                    },
                    listen: function () {
                        return listen();
                    },
                    update: function (read) {
                        if (read) {
                            location = $location.url();
                            return;
                        }
                        if ($location.url() === location)
                            return;
                        $location.url(location);
                        $location.replace();
                    },
                    push: function (urlMatcher, params, options) {
                        var url = urlMatcher.format(params || {});
                        if (url !== null && params && params['#']) {
                            url += '#' + params['#'];
                        }
                        $location.url(url);
                        lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined;
                        if (options && options.replace)
                            $location.replace();
                    },
                    href: function (urlMatcher, params, options) {
                        if (!urlMatcher.validates(params))
                            return null;
                        var isHtml5 = $locationProvider.html5Mode();
                        if (angular.isObject(isHtml5)) {
                            isHtml5 = isHtml5.enabled;
                        }
                        isHtml5 = isHtml5 && $sniffer.history;
                        var url = urlMatcher.format(params);
                        options = options || {};
                        if (!isHtml5 && url !== null) {
                            url = '#' + $locationProvider.hashPrefix() + url;
                        }
                        if (url !== null && params && params['#']) {
                            url += '#' + params['#'];
                        }
                        url = appendBasePath(url, isHtml5, options.absolute);
                        if (!options.absolute || !url) {
                            return url;
                        }
                        var slash = !isHtml5 && url ? '/' : '', port = $location.port();
                        port = port === 80 || port === 443 ? '' : ':' + port;
                        return [
                            $location.protocol(),
                            '://',
                            $location.host(),
                            port,
                            slash,
                            url
                        ].join('');
                    }
                };
            }
        }
        angular.module('ui.router.router').provider('$urlRouter', $UrlRouterProvider);
        $StateProvider.$inject = [
            '$urlRouterProvider',
            '$urlMatcherFactoryProvider'
        ];
        function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
            var root, states = {}, $state, queue = {}, abstractKey = 'abstract';
            var stateBuilder = {
                parent: function (state) {
                    if (isDefined(state.parent) && state.parent)
                        return findState(state.parent);
                    var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                    return compositeName ? findState(compositeName[1]) : root;
                },
                data: function (state) {
                    if (state.parent && state.parent.data) {
                        state.data = state.self.data = inherit(state.parent.data, state.data);
                    }
                    return state.data;
                },
                url: function (state) {
                    var url = state.url, config = { params: state.params || {} };
                    if (isString(url)) {
                        if (url.charAt(0) == '^')
                            return $urlMatcherFactory.compile(url.substring(1), config);
                        return (state.parent.navigable || root).url.concat(url, config);
                    }
                    if (!url || $urlMatcherFactory.isMatcher(url))
                        return url;
                    throw new Error('Invalid url \'' + url + '\' in state \'' + state + '\'');
                },
                navigable: function (state) {
                    return state.url ? state : state.parent ? state.parent.navigable : null;
                },
                ownParams: function (state) {
                    var params = state.url && state.url.params || new $$UMFP.ParamSet();
                    forEach(state.params || {}, function (config, id) {
                        if (!params[id])
                            params[id] = new $$UMFP.Param(id, null, config, 'config');
                    });
                    return params;
                },
                params: function (state) {
                    var ownParams = pick(state.ownParams, state.ownParams.$$keys());
                    return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet();
                },
                views: function (state) {
                    var views = {};
                    forEach(isDefined(state.views) ? state.views : { '': state }, function (view, name) {
                        if (name.indexOf('@') < 0)
                            name += '@' + state.parent.name;
                        views[name] = view;
                    });
                    return views;
                },
                path: function (state) {
                    return state.parent ? state.parent.path.concat(state) : [];
                },
                includes: function (state) {
                    var includes = state.parent ? extend({}, state.parent.includes) : {};
                    includes[state.name] = true;
                    return includes;
                },
                $delegates: {}
            };
            function isRelative(stateName) {
                return stateName.indexOf('.') === 0 || stateName.indexOf('^') === 0;
            }
            function findState(stateOrName, base) {
                if (!stateOrName)
                    return undefined;
                var isStr = isString(stateOrName), name = isStr ? stateOrName : stateOrName.name, path = isRelative(name);
                if (path) {
                    if (!base)
                        throw new Error('No reference point given for path \'' + name + '\'');
                    base = findState(base);
                    var rel = name.split('.'), i = 0, pathLength = rel.length, current = base;
                    for (; i < pathLength; i++) {
                        if (rel[i] === '' && i === 0) {
                            current = base;
                            continue;
                        }
                        if (rel[i] === '^') {
                            if (!current.parent)
                                throw new Error('Path \'' + name + '\' not valid for state \'' + base.name + '\'');
                            current = current.parent;
                            continue;
                        }
                        break;
                    }
                    rel = rel.slice(i).join('.');
                    name = current.name + (current.name && rel ? '.' : '') + rel;
                }
                var state = states[name];
                if (state && (isStr || !isStr && (state === stateOrName || state.self === stateOrName))) {
                    return state;
                }
                return undefined;
            }
            function queueState(parentName, state) {
                if (!queue[parentName]) {
                    queue[parentName] = [];
                }
                queue[parentName].push(state);
            }
            function flushQueuedChildren(parentName) {
                var queued = queue[parentName] || [];
                while (queued.length) {
                    registerState(queued.shift());
                }
            }
            function registerState(state) {
                state = inherit(state, {
                    self: state,
                    resolve: state.resolve || {},
                    toString: function () {
                        return this.name;
                    }
                });
                var name = state.name;
                if (!isString(name) || name.indexOf('@') >= 0)
                    throw new Error('State must have a valid name');
                if (states.hasOwnProperty(name))
                    throw new Error('State \'' + name + '\' is already defined');
                var parentName = name.indexOf('.') !== -1 ? name.substring(0, name.lastIndexOf('.')) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : '';
                if (parentName && !states[parentName]) {
                    return queueState(parentName, state.self);
                }
                for (var key in stateBuilder) {
                    if (isFunction(stateBuilder[key]))
                        state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]);
                }
                states[name] = state;
                if (!state[abstractKey] && state.url) {
                    $urlRouterProvider.when(state.url, [
                        '$match',
                        '$stateParams',
                        function ($match, $stateParams) {
                            if ($state.$current.navigable != state || !equalForKeys($match, $stateParams)) {
                                $state.transitionTo(state, $match, {
                                    inherit: true,
                                    location: false
                                });
                            }
                        }
                    ]);
                }
                flushQueuedChildren(name);
                return state;
            }
            function isGlob(text) {
                return text.indexOf('*') > -1;
            }
            function doesStateMatchGlob(glob) {
                var globSegments = glob.split('.'), segments = $state.$current.name.split('.');
                for (var i = 0, l = globSegments.length; i < l; i++) {
                    if (globSegments[i] === '*') {
                        segments[i] = '*';
                    }
                }
                if (globSegments[0] === '**') {
                    segments = segments.slice(indexOf(segments, globSegments[1]));
                    segments.unshift('**');
                }
                if (globSegments[globSegments.length - 1] === '**') {
                    segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE);
                    segments.push('**');
                }
                if (globSegments.length != segments.length) {
                    return false;
                }
                return segments.join('') === globSegments.join('');
            }
            root = registerState({
                name: '',
                url: '^',
                views: null,
                'abstract': true
            });
            root.navigable = null;
            this.decorator = decorator;
            function decorator(name, func) {
                if (isString(name) && !isDefined(func)) {
                    return stateBuilder[name];
                }
                if (!isFunction(func) || !isString(name)) {
                    return this;
                }
                if (stateBuilder[name] && !stateBuilder.$delegates[name]) {
                    stateBuilder.$delegates[name] = stateBuilder[name];
                }
                stateBuilder[name] = func;
                return this;
            }
            this.state = state;
            function state(name, definition) {
                if (isObject(name))
                    definition = name;
                else
                    definition.name = name;
                registerState(definition);
                return this;
            }
            this.$get = $get;
            $get.$inject = [
                '$rootScope',
                '$q',
                '$view',
                '$injector',
                '$resolve',
                '$stateParams',
                '$urlRouter',
                '$location',
                '$urlMatcherFactory'
            ];
            function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
                var TransitionSuperseded = $q.reject(new Error('transition superseded'));
                var TransitionPrevented = $q.reject(new Error('transition prevented'));
                var TransitionAborted = $q.reject(new Error('transition aborted'));
                var TransitionFailed = $q.reject(new Error('transition failed'));
                function handleRedirect(redirect, state, params, options) {
                    var evt = $rootScope.$broadcast('$stateNotFound', redirect, state, params);
                    if (evt.defaultPrevented) {
                        $urlRouter.update();
                        return TransitionAborted;
                    }
                    if (!evt.retry) {
                        return null;
                    }
                    if (options.$retry) {
                        $urlRouter.update();
                        return TransitionFailed;
                    }
                    var retryTransition = $state.transition = $q.when(evt.retry);
                    retryTransition.then(function () {
                        if (retryTransition !== $state.transition)
                            return TransitionSuperseded;
                        redirect.options.$retry = true;
                        return $state.transitionTo(redirect.to, redirect.toParams, redirect.options);
                    }, function () {
                        return TransitionAborted;
                    });
                    $urlRouter.update();
                    return retryTransition;
                }
                root.locals = {
                    resolve: null,
                    globals: { $stateParams: {} }
                };
                $state = {
                    params: {},
                    current: root.self,
                    $current: root,
                    transition: null
                };
                $state.reload = function reload(state) {
                    return $state.transitionTo($state.current, $stateParams, {
                        reload: state || true,
                        inherit: false,
                        notify: true
                    });
                };
                $state.go = function go(to, params, options) {
                    return $state.transitionTo(to, params, extend({
                        inherit: true,
                        relative: $state.$current
                    }, options));
                };
                $state.transitionTo = function transitionTo(to, toParams, options) {
                    toParams = toParams || {};
                    options = extend({
                        location: true,
                        inherit: false,
                        relative: null,
                        notify: true,
                        reload: false,
                        $retry: false
                    }, options || {});
                    var from = $state.$current, fromParams = $state.params, fromPath = from.path;
                    var evt, toState = findState(to, options.relative);
                    var hash = toParams['#'];
                    if (!isDefined(toState)) {
                        var redirect = {
                            to: to,
                            toParams: toParams,
                            options: options
                        };
                        var redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                        if (redirectResult) {
                            return redirectResult;
                        }
                        to = redirect.to;
                        toParams = redirect.toParams;
                        options = redirect.options;
                        toState = findState(to, options.relative);
                        if (!isDefined(toState)) {
                            if (!options.relative)
                                throw new Error('No such state \'' + to + '\'');
                            throw new Error('Could not resolve \'' + to + '\' from state \'' + options.relative + '\'');
                        }
                    }
                    if (toState[abstractKey])
                        throw new Error('Cannot transition to abstract state \'' + to + '\'');
                    if (options.inherit)
                        toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState);
                    if (!toState.params.$$validates(toParams))
                        return TransitionFailed;
                    toParams = toState.params.$$values(toParams);
                    to = toState;
                    var toPath = to.path;
                    var keep = 0, state = toPath[keep], locals = root.locals, toLocals = [];
                    if (!options.reload) {
                        while (state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams)) {
                            locals = toLocals[keep] = state.locals;
                            keep++;
                            state = toPath[keep];
                        }
                    } else if (isString(options.reload) || isObject(options.reload)) {
                        if (isObject(options.reload) && !options.reload.name) {
                            throw new Error('Invalid reload state object');
                        }
                        var reloadState = options.reload === true ? fromPath[0] : findState(options.reload);
                        if (options.reload && !reloadState) {
                            throw new Error('No such reload state \'' + (isString(options.reload) ? options.reload : options.reload.name) + '\'');
                        }
                        while (state && state === fromPath[keep] && state !== reloadState) {
                            locals = toLocals[keep] = state.locals;
                            keep++;
                            state = toPath[keep];
                        }
                    }
                    if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) {
                        if (hash)
                            toParams['#'] = hash;
                        $state.params = toParams;
                        copy($state.params, $stateParams);
                        copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams);
                        if (options.location && to.navigable && to.navigable.url) {
                            $urlRouter.push(to.navigable.url, toParams, {
                                $$avoidResync: true,
                                replace: options.location === 'replace'
                            });
                            $urlRouter.update(true);
                        }
                        $state.transition = null;
                        return $q.when($state.current);
                    }
                    toParams = filterByKeys(to.params.$$keys(), toParams || {});
                    if (hash)
                        toParams['#'] = hash;
                    if (options.notify) {
                        if ($rootScope.$broadcast('$stateChangeStart', to.self, toParams, from.self, fromParams, options).defaultPrevented) {
                            $rootScope.$broadcast('$stateChangeCancel', to.self, toParams, from.self, fromParams);
                            if ($state.transition == null)
                                $urlRouter.update();
                            return TransitionPrevented;
                        }
                    }
                    var resolved = $q.when(locals);
                    for (var l = keep; l < toPath.length; l++, state = toPath[l]) {
                        locals = toLocals[l] = inherit(locals);
                        resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                    }
                    var transition = $state.transition = resolved.then(function () {
                        var l, entering, exiting;
                        if ($state.transition !== transition)
                            return TransitionSuperseded;
                        for (l = fromPath.length - 1; l >= keep; l--) {
                            exiting = fromPath[l];
                            if (exiting.self.onExit) {
                                $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals);
                            }
                            exiting.locals = null;
                        }
                        for (l = keep; l < toPath.length; l++) {
                            entering = toPath[l];
                            entering.locals = toLocals[l];
                            if (entering.self.onEnter) {
                                $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                            }
                        }
                        if ($state.transition !== transition)
                            return TransitionSuperseded;
                        $state.$current = to;
                        $state.current = to.self;
                        $state.params = toParams;
                        copy($state.params, $stateParams);
                        $state.transition = null;
                        if (options.location && to.navigable) {
                            $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                                $$avoidResync: true,
                                replace: options.location === 'replace'
                            });
                        }
                        if (options.notify) {
                            $rootScope.$broadcast('$stateChangeSuccess', to.self, toParams, from.self, fromParams);
                        }
                        $urlRouter.update(true);
                        return $state.current;
                    }, function (error) {
                        if ($state.transition !== transition)
                            return TransitionSuperseded;
                        $state.transition = null;
                        evt = $rootScope.$broadcast('$stateChangeError', to.self, toParams, from.self, fromParams, error);
                        if (!evt.defaultPrevented) {
                            $urlRouter.update();
                        }
                        return $q.reject(error);
                    });
                    return transition;
                };
                $state.is = function is(stateOrName, params, options) {
                    options = extend({ relative: $state.$current }, options || {});
                    var state = findState(stateOrName, options.relative);
                    if (!isDefined(state)) {
                        return undefined;
                    }
                    if ($state.$current !== state) {
                        return false;
                    }
                    return params ? equalForKeys(state.params.$$values(params), $stateParams) : true;
                };
                $state.includes = function includes(stateOrName, params, options) {
                    options = extend({ relative: $state.$current }, options || {});
                    if (isString(stateOrName) && isGlob(stateOrName)) {
                        if (!doesStateMatchGlob(stateOrName)) {
                            return false;
                        }
                        stateOrName = $state.$current.name;
                    }
                    var state = findState(stateOrName, options.relative);
                    if (!isDefined(state)) {
                        return undefined;
                    }
                    if (!isDefined($state.$current.includes[state.name])) {
                        return false;
                    }
                    return params ? equalForKeys(state.params.$$values(params), $stateParams, objectKeys(params)) : true;
                };
                $state.href = function href(stateOrName, params, options) {
                    options = extend({
                        lossy: true,
                        inherit: true,
                        absolute: false,
                        relative: $state.$current
                    }, options || {});
                    var state = findState(stateOrName, options.relative);
                    if (!isDefined(state))
                        return null;
                    if (options.inherit)
                        params = inheritParams($stateParams, params || {}, $state.$current, state);
                    var nav = state && options.lossy ? state.navigable : state;
                    if (!nav || nav.url === undefined || nav.url === null) {
                        return null;
                    }
                    return $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat('#'), params || {}), { absolute: options.absolute });
                };
                $state.get = function (stateOrName, context) {
                    if (arguments.length === 0)
                        return map(objectKeys(states), function (name) {
                            return states[name].self;
                        });
                    var state = findState(stateOrName, context || $state.$current);
                    return state && state.self ? state.self : null;
                };
                function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                    var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params);
                    var locals = { $stateParams: $stateParams };
                    dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                    var promises = [dst.resolve.then(function (globals) {
                            dst.globals = globals;
                        })];
                    if (inherited)
                        promises.push(inherited);
                    function resolveViews() {
                        var viewsPromises = [];
                        forEach(state.views, function (view, name) {
                            var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                            injectables.$template = [function () {
                                    return $view.load(name, {
                                        view: view,
                                        locals: dst.globals,
                                        params: $stateParams,
                                        notify: options.notify
                                    }) || '';
                                }];
                            viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function (result) {
                                if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                                    var injectLocals = angular.extend({}, injectables, dst.globals);
                                    result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals);
                                } else {
                                    result.$$controller = view.controller;
                                }
                                result.$$state = state;
                                result.$$controllerAs = view.controllerAs;
                                dst[name] = result;
                            }));
                        });
                        return $q.all(viewsPromises).then(function () {
                            return dst.globals;
                        });
                    }
                    return $q.all(promises).then(resolveViews).then(function (values) {
                        return dst;
                    });
                }
                return $state;
            }
            function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
                function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
                    function notSearchParam(key) {
                        return fromAndToState.params[key].location != 'search';
                    }
                    var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam);
                    var nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys));
                    var nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
                    return nonQueryParamSet.$$equals(fromParams, toParams);
                }
                if (!options.reload && to === from && (locals === from.locals || to.self.reloadOnSearch === false && nonSearchParamsEqual(from, fromParams, toParams))) {
                    return true;
                }
            }
        }
        angular.module('ui.router.state').factory('$stateParams', function () {
            return {};
        }).provider('$state', $StateProvider);
        $ViewProvider.$inject = [];
        function $ViewProvider() {
            this.$get = $get;
            $get.$inject = [
                '$rootScope',
                '$templateFactory'
            ];
            function $get($rootScope, $templateFactory) {
                return {
                    load: function load(name, options) {
                        var result, defaults = {
                                template: null,
                                controller: null,
                                view: null,
                                locals: null,
                                notify: true,
                                async: true,
                                params: {}
                            };
                        options = extend(defaults, options);
                        if (options.view) {
                            result = $templateFactory.fromConfig(options.view, options.params, options.locals);
                        }
                        return result;
                    }
                };
            }
        }
        angular.module('ui.router.state').provider('$view', $ViewProvider);
        function $ViewScrollProvider() {
            var useAnchorScroll = false;
            this.useAnchorScroll = function () {
                useAnchorScroll = true;
            };
            this.$get = [
                '$anchorScroll',
                '$timeout',
                function ($anchorScroll, $timeout) {
                    if (useAnchorScroll) {
                        return $anchorScroll;
                    }
                    return function ($element) {
                        return $timeout(function () {
                            $element[0].scrollIntoView();
                        }, 0, false);
                    };
                }
            ];
        }
        angular.module('ui.router.state').provider('$uiViewScroll', $ViewScrollProvider);
        var ngMajorVer = angular.version.major;
        var ngMinorVer = angular.version.minor;
        $ViewDirective.$inject = [
            '$state',
            '$injector',
            '$uiViewScroll',
            '$interpolate'
        ];
        function $ViewDirective($state, $injector, $uiViewScroll, $interpolate) {
            function getService() {
                return $injector.has ? function (service) {
                    return $injector.has(service) ? $injector.get(service) : null;
                } : function (service) {
                    try {
                        return $injector.get(service);
                    } catch (e) {
                        return null;
                    }
                };
            }
            var service = getService(), $animator = service('$animator'), $animate = service('$animate');
            function getRenderer(attrs, scope) {
                var statics = {
                    enter: function (element, target, cb) {
                        target.after(element);
                        cb();
                    },
                    leave: function (element, cb) {
                        element.remove();
                        cb();
                    }
                };
                if (!!attrs.noanimation)
                    return statics;
                function animEnabled(element) {
                    if (ngMajorVer === 1 && ngMinorVer >= 4)
                        return !!$animate.enabled(element);
                    if (ngMajorVer === 1 && ngMinorVer >= 2)
                        return !!$animate.enabled();
                    return !!$animator;
                }
                if ($animate) {
                    return {
                        enter: function (element, target, cb) {
                            if (!animEnabled(element)) {
                                statics.enter(element, target, cb);
                            } else if (angular.version.minor > 2) {
                                $animate.enter(element, null, target).then(cb);
                            } else {
                                $animate.enter(element, null, target, cb);
                            }
                        },
                        leave: function (element, cb) {
                            if (!animEnabled(element)) {
                                statics.leave(element, cb);
                            } else if (angular.version.minor > 2) {
                                $animate.leave(element).then(cb);
                            } else {
                                $animate.leave(element, cb);
                            }
                        }
                    };
                }
                if ($animator) {
                    var animate = $animator && $animator(scope, attrs);
                    return {
                        enter: function (element, target, cb) {
                            animate.enter(element, null, target);
                            cb();
                        },
                        leave: function (element, cb) {
                            animate.leave(element);
                            cb();
                        }
                    };
                }
                return statics;
            }
            var directive = {
                restrict: 'ECA',
                terminal: true,
                priority: 400,
                transclude: 'element',
                compile: function (tElement, tAttrs, $transclude) {
                    return function (scope, $element, attrs) {
                        var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || '', autoScrollExp = attrs.autoscroll, renderer = getRenderer(attrs, scope);
                        scope.$on('$stateChangeSuccess', function () {
                            updateView(false);
                        });
                        updateView(true);
                        function cleanupLastView() {
                            var _previousEl = previousEl;
                            var _currentScope = currentScope;
                            if (_currentScope) {
                                _currentScope._willBeDestroyed = true;
                            }
                            function cleanOld() {
                                if (_previousEl) {
                                    _previousEl.remove();
                                }
                                if (_currentScope) {
                                    _currentScope.$destroy();
                                }
                            }
                            if (currentEl) {
                                renderer.leave(currentEl, function () {
                                    cleanOld();
                                    previousEl = null;
                                });
                                previousEl = currentEl;
                            } else {
                                cleanOld();
                                previousEl = null;
                            }
                            currentEl = null;
                            currentScope = null;
                        }
                        function updateView(firstTime) {
                            var newScope, name = getUiViewName(scope, attrs, $element, $interpolate), previousLocals = name && $state.$current && $state.$current.locals[name];
                            if (!firstTime && previousLocals === latestLocals || scope._willBeDestroyed)
                                return;
                            newScope = scope.$new();
                            latestLocals = $state.$current.locals[name];
                            newScope.$emit('$viewContentLoading', name);
                            var clone = $transclude(newScope, function (clone) {
                                renderer.enter(clone, $element, function onUiViewEnter() {
                                    if (currentScope) {
                                        currentScope.$emit('$viewContentAnimationEnded');
                                    }
                                    if (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) {
                                        $uiViewScroll(clone);
                                    }
                                });
                                cleanupLastView();
                            });
                            currentEl = clone;
                            currentScope = newScope;
                            currentScope.$emit('$viewContentLoaded', name);
                            currentScope.$eval(onloadExp);
                        }
                    };
                }
            };
            return directive;
        }
        $ViewDirectiveFill.$inject = [
            '$compile',
            '$controller',
            '$state',
            '$interpolate'
        ];
        function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
            return {
                restrict: 'ECA',
                priority: -400,
                compile: function (tElement) {
                    var initial = tElement.html();
                    return function (scope, $element, attrs) {
                        var current = $state.$current, name = getUiViewName(scope, attrs, $element, $interpolate), locals = current && current.locals[name];
                        if (!locals) {
                            return;
                        }
                        $element.data('$uiView', {
                            name: name,
                            state: locals.$$state
                        });
                        $element.html(locals.$template ? locals.$template : initial);
                        var link = $compile($element.contents());
                        if (locals.$$controller) {
                            locals.$scope = scope;
                            locals.$element = $element;
                            var controller = $controller(locals.$$controller, locals);
                            if (locals.$$controllerAs) {
                                scope[locals.$$controllerAs] = controller;
                            }
                            $element.data('$ngControllerController', controller);
                            $element.children().data('$ngControllerController', controller);
                        }
                        link(scope);
                    };
                }
            };
        }
        function getUiViewName(scope, attrs, element, $interpolate) {
            var name = $interpolate(attrs.uiView || attrs.name || '')(scope);
            var inherited = element.inheritedData('$uiView');
            return name.indexOf('@') >= 0 ? name : name + '@' + (inherited ? inherited.state.name : '');
        }
        angular.module('ui.router.state').directive('uiView', $ViewDirective);
        angular.module('ui.router.state').directive('uiView', $ViewDirectiveFill);
        function parseStateRef(ref, current) {
            var preparsed = ref.match(/^\s*({[^}]*})\s*$/), parsed;
            if (preparsed)
                ref = current + '(' + preparsed[1] + ')';
            parsed = ref.replace(/\n/g, ' ').match(/^([^(]+?)\s*(\((.*)\))?$/);
            if (!parsed || parsed.length !== 4)
                throw new Error('Invalid state ref \'' + ref + '\'');
            return {
                state: parsed[1],
                paramExpr: parsed[3] || null
            };
        }
        function stateContext(el) {
            var stateData = el.parent().inheritedData('$uiView');
            if (stateData && stateData.state && stateData.state.name) {
                return stateData.state;
            }
        }
        function getTypeInfo(el) {
            var isSvg = Object.prototype.toString.call(el.prop('href')) === '[object SVGAnimatedString]';
            var isForm = el[0].nodeName === 'FORM';
            return {
                attr: isForm ? 'action' : isSvg ? 'xlink:href' : 'href',
                isAnchor: el.prop('tagName').toUpperCase() === 'A',
                clickable: !isForm
            };
        }
        function clickHook(el, $state, $timeout, type, current) {
            return function (e) {
                var button = e.which || e.button, target = current();
                if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr('target'))) {
                    var transition = $timeout(function () {
                        $state.go(target.state, target.params, target.options);
                    });
                    e.preventDefault();
                    var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
                    e.preventDefault = function () {
                        if (ignorePreventDefaultCount-- <= 0)
                            $timeout.cancel(transition);
                    };
                }
            };
        }
        function defaultOpts(el, $state) {
            return {
                relative: stateContext(el) || $state.$current,
                inherit: true
            };
        }
        $StateRefDirective.$inject = [
            '$state',
            '$timeout'
        ];
        function $StateRefDirective($state, $timeout) {
            return {
                restrict: 'A',
                require: [
                    '?^uiSrefActive',
                    '?^uiSrefActiveEq'
                ],
                link: function (scope, element, attrs, uiSrefActive) {
                    var ref = parseStateRef(attrs.uiSref, $state.current.name);
                    var def = {
                        state: ref.state,
                        href: null,
                        params: null
                    };
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});
                    var update = function (val) {
                        if (val)
                            def.params = angular.copy(val);
                        def.href = $state.href(ref.state, def.params, def.options);
                        if (active)
                            active.$$addStateInfo(ref.state, def.params);
                        if (def.href !== null)
                            attrs.$set(type.attr, def.href);
                    };
                    if (ref.paramExpr) {
                        scope.$watch(ref.paramExpr, function (val) {
                            if (val !== def.params)
                                update(val);
                        }, true);
                        def.params = angular.copy(scope.$eval(ref.paramExpr));
                    }
                    update();
                    if (!type.clickable)
                        return;
                    element.bind('click', clickHook(element, $state, $timeout, type, function () {
                        return def;
                    }));
                }
            };
        }
        $StateRefDynamicDirective.$inject = [
            '$state',
            '$timeout'
        ];
        function $StateRefDynamicDirective($state, $timeout) {
            return {
                restrict: 'A',
                require: [
                    '?^uiSrefActive',
                    '?^uiSrefActiveEq'
                ],
                link: function (scope, element, attrs, uiSrefActive) {
                    var type = getTypeInfo(element);
                    var active = uiSrefActive[1] || uiSrefActive[0];
                    var group = [
                        attrs.uiState,
                        attrs.uiStateParams || null,
                        attrs.uiStateOpts || null
                    ];
                    var watch = '[' + group.map(function (val) {
                        return val || 'null';
                    }).join(', ') + ']';
                    var def = {
                        state: null,
                        params: null,
                        options: null,
                        href: null
                    };
                    function runStateRefLink(group) {
                        def.state = group[0];
                        def.params = group[1];
                        def.options = group[2];
                        def.href = $state.href(def.state, def.params, def.options);
                        if (active)
                            active.$$addStateInfo(def.state, def.params);
                        if (def.href)
                            attrs.$set(type.attr, def.href);
                    }
                    scope.$watch(watch, runStateRefLink, true);
                    runStateRefLink(scope.$eval(watch));
                    if (!type.clickable)
                        return;
                    element.bind('click', clickHook(element, $state, $timeout, type, function () {
                        return def;
                    }));
                }
            };
        }
        $StateRefActiveDirective.$inject = [
            '$state',
            '$stateParams',
            '$interpolate'
        ];
        function $StateRefActiveDirective($state, $stateParams, $interpolate) {
            return {
                restrict: 'A',
                controller: [
                    '$scope',
                    '$element',
                    '$attrs',
                    '$timeout',
                    function ($scope, $element, $attrs, $timeout) {
                        var states = [], activeClasses = {}, activeEqClass, uiSrefActive;
                        activeEqClass = $interpolate($attrs.uiSrefActiveEq || '', false)($scope);
                        try {
                            uiSrefActive = $scope.$eval($attrs.uiSrefActive);
                        } catch (e) {
                        }
                        uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || '', false)($scope);
                        if (isObject(uiSrefActive)) {
                            forEach(uiSrefActive, function (stateOrName, activeClass) {
                                if (isString(stateOrName)) {
                                    var ref = parseStateRef(stateOrName, $state.current.name);
                                    addState(ref.state, $scope.$eval(ref.paramExpr), activeClass);
                                }
                            });
                        }
                        this.$$addStateInfo = function (newState, newParams) {
                            if (isObject(uiSrefActive) && states.length > 0) {
                                return;
                            }
                            addState(newState, newParams, uiSrefActive);
                            update();
                        };
                        $scope.$on('$stateChangeSuccess', update);
                        function addState(stateName, stateParams, activeClass) {
                            var state = $state.get(stateName, stateContext($element));
                            var stateHash = createStateHash(stateName, stateParams);
                            states.push({
                                state: state || { name: stateName },
                                params: stateParams,
                                hash: stateHash
                            });
                            activeClasses[stateHash] = activeClass;
                        }
                        function createStateHash(state, params) {
                            if (!isString(state)) {
                                throw new Error('state should be a string');
                            }
                            if (isObject(params)) {
                                return state + toJson(params);
                            }
                            params = $scope.$eval(params);
                            if (isObject(params)) {
                                return state + toJson(params);
                            }
                            return state;
                        }
                        function update() {
                            for (var i = 0; i < states.length; i++) {
                                if (anyMatch(states[i].state, states[i].params)) {
                                    addClass($element, activeClasses[states[i].hash]);
                                } else {
                                    removeClass($element, activeClasses[states[i].hash]);
                                }
                                if (exactMatch(states[i].state, states[i].params)) {
                                    addClass($element, activeEqClass);
                                } else {
                                    removeClass($element, activeEqClass);
                                }
                            }
                        }
                        function addClass(el, className) {
                            $timeout(function () {
                                el.addClass(className);
                            });
                        }
                        function removeClass(el, className) {
                            el.removeClass(className);
                        }
                        function anyMatch(state, params) {
                            return $state.includes(state.name, params);
                        }
                        function exactMatch(state, params) {
                            return $state.is(state.name, params);
                        }
                        update();
                    }
                ]
            };
        }
        angular.module('ui.router.state').directive('uiSref', $StateRefDirective).directive('uiSrefActive', $StateRefActiveDirective).directive('uiSrefActiveEq', $StateRefActiveDirective).directive('uiState', $StateRefDynamicDirective);
        $IsStateFilter.$inject = ['$state'];
        function $IsStateFilter($state) {
            var isFilter = function (state, params) {
                return $state.is(state, params);
            };
            isFilter.$stateful = true;
            return isFilter;
        }
        $IncludedByStateFilter.$inject = ['$state'];
        function $IncludedByStateFilter($state) {
            var includesFilter = function (state, params, options) {
                return $state.includes(state, params, options);
            };
            includesFilter.$stateful = true;
            return includesFilter;
        }
        angular.module('ui.router.state').filter('isState', $IsStateFilter).filter('includedByState', $IncludedByStateFilter);
    }(window, window.angular));
    return;
});
(function () {
    (function (root, factory) {
        if (typeof module !== 'undefined' && module.exports) {
            if (typeof angular === 'undefined') {
                factory(require('angular'));
            } else {
                factory(angular);
            }
            module.exports = 'ngDialog';
        } else if (typeof define === 'function' && define.amd) {
            define('ngDialog', [
                'angular',
                'angular'
            ], factory);
        } else {
            factory(root.angular);
        }
    }(this, function (angular) {
        'use strict';
        var m = angular.module('ngDialog', []);
        var $el = angular.element;
        var isDef = angular.isDefined;
        var style = (document.body || document.documentElement).style;
        var animationEndSupport = isDef(style.animation) || isDef(style.WebkitAnimation) || isDef(style.MozAnimation) || isDef(style.MsAnimation) || isDef(style.OAnimation);
        var animationEndEvent = 'animationend webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend';
        var focusableElementSelector = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]';
        var disabledAnimationClass = 'ngdialog-disabled-animation';
        var forceElementsReload = {
            html: false,
            body: false
        };
        var scopes = {};
        var openIdStack = [];
        var keydownIsBound = false;
        var openOnePerName = false;
        m.provider('ngDialog', function () {
            var defaults = this.defaults = {
                className: 'ngdialog-theme-default',
                appendClassName: '',
                disableAnimation: false,
                plain: false,
                showClose: true,
                closeByDocument: true,
                closeByEscape: true,
                closeByNavigation: false,
                appendTo: false,
                preCloseCallback: false,
                overlay: true,
                cache: true,
                trapFocus: true,
                preserveFocus: true,
                ariaAuto: true,
                ariaRole: null,
                ariaLabelledById: null,
                ariaLabelledBySelector: null,
                ariaDescribedById: null,
                ariaDescribedBySelector: null,
                bodyClassName: 'ngdialog-open'
            };
            this.setForceHtmlReload = function (_useIt) {
                forceElementsReload.html = _useIt || false;
            };
            this.setForceBodyReload = function (_useIt) {
                forceElementsReload.body = _useIt || false;
            };
            this.setDefaults = function (newDefaults) {
                angular.extend(defaults, newDefaults);
            };
            this.setOpenOnePerName = function (isOpenOne) {
                openOnePerName = isOpenOne || false;
            };
            var globalID = 0, dialogsCount = 0, closeByDocumentHandler, defers = {};
            this.$get = [
                '$document',
                '$templateCache',
                '$compile',
                '$q',
                '$http',
                '$rootScope',
                '$timeout',
                '$window',
                '$controller',
                '$injector',
                function ($document, $templateCache, $compile, $q, $http, $rootScope, $timeout, $window, $controller, $injector) {
                    var $elements = [];
                    var privateMethods = {
                        onDocumentKeydown: function (event) {
                            if (event.keyCode === 27) {
                                publicMethods.close('$escape');
                            }
                        },
                        activate: function ($dialog) {
                            var options = $dialog.data('$ngDialogOptions');
                            if (options.trapFocus) {
                                $dialog.on('keydown', privateMethods.onTrapFocusKeydown);
                                $elements.body.on('keydown', privateMethods.onTrapFocusKeydown);
                            }
                        },
                        deactivate: function ($dialog) {
                            $dialog.off('keydown', privateMethods.onTrapFocusKeydown);
                            $elements.body.off('keydown', privateMethods.onTrapFocusKeydown);
                        },
                        deactivateAll: function (els) {
                            angular.forEach(els, function (el) {
                                var $dialog = angular.element(el);
                                privateMethods.deactivate($dialog);
                            });
                        },
                        setBodyPadding: function (width) {
                            var originalBodyPadding = parseInt($elements.body.css('padding-right') || 0, 10);
                            $elements.body.css('padding-right', originalBodyPadding + width + 'px');
                            $elements.body.data('ng-dialog-original-padding', originalBodyPadding);
                            $rootScope.$broadcast('ngDialog.setPadding', width);
                        },
                        resetBodyPadding: function () {
                            var originalBodyPadding = $elements.body.data('ng-dialog-original-padding');
                            if (originalBodyPadding) {
                                $elements.body.css('padding-right', originalBodyPadding + 'px');
                            } else {
                                $elements.body.css('padding-right', '');
                            }
                            $rootScope.$broadcast('ngDialog.setPadding', 0);
                        },
                        performCloseDialog: function ($dialog, value) {
                            var options = $dialog.data('$ngDialogOptions');
                            var id = $dialog.attr('id');
                            var scope = scopes[id];
                            if (!scope) {
                                return;
                            }
                            if (typeof $window.Hammer !== 'undefined') {
                                var hammerTime = scope.hammerTime;
                                hammerTime.off('tap', closeByDocumentHandler);
                                hammerTime.destroy && hammerTime.destroy();
                                delete scope.hammerTime;
                            } else {
                                $dialog.unbind('click');
                            }
                            if (dialogsCount === 1) {
                                $elements.body.unbind('keydown', privateMethods.onDocumentKeydown);
                            }
                            if (!$dialog.hasClass('ngdialog-closing')) {
                                dialogsCount -= 1;
                            }
                            var previousFocus = $dialog.data('$ngDialogPreviousFocus');
                            if (previousFocus && previousFocus.focus) {
                                previousFocus.focus();
                            }
                            $rootScope.$broadcast('ngDialog.closing', $dialog, value);
                            dialogsCount = dialogsCount < 0 ? 0 : dialogsCount;
                            if (animationEndSupport && !options.disableAnimation) {
                                scope.$destroy();
                                $dialog.unbind(animationEndEvent).bind(animationEndEvent, function () {
                                    privateMethods.closeDialogElement($dialog, value);
                                }).addClass('ngdialog-closing');
                            } else {
                                scope.$destroy();
                                privateMethods.closeDialogElement($dialog, value);
                            }
                            if (defers[id]) {
                                defers[id].resolve({
                                    id: id,
                                    value: value,
                                    $dialog: $dialog,
                                    remainingDialogs: dialogsCount
                                });
                                delete defers[id];
                            }
                            if (scopes[id]) {
                                delete scopes[id];
                            }
                            openIdStack.splice(openIdStack.indexOf(id), 1);
                            if (!openIdStack.length) {
                                $elements.body.unbind('keydown', privateMethods.onDocumentKeydown);
                                keydownIsBound = false;
                            }
                        },
                        closeDialogElement: function ($dialog, value) {
                            var options = $dialog.data('$ngDialogOptions');
                            $dialog.remove();
                            if (dialogsCount === 0) {
                                $elements.html.removeClass(options.bodyClassName);
                                $elements.body.removeClass(options.bodyClassName);
                                privateMethods.resetBodyPadding();
                            }
                            $rootScope.$broadcast('ngDialog.closed', $dialog, value);
                        },
                        closeDialog: function ($dialog, value) {
                            var preCloseCallback = $dialog.data('$ngDialogPreCloseCallback');
                            if (preCloseCallback && angular.isFunction(preCloseCallback)) {
                                var preCloseCallbackResult = preCloseCallback.call($dialog, value);
                                if (angular.isObject(preCloseCallbackResult)) {
                                    if (preCloseCallbackResult.closePromise) {
                                        preCloseCallbackResult.closePromise.then(function () {
                                            privateMethods.performCloseDialog($dialog, value);
                                        });
                                    } else {
                                        preCloseCallbackResult.then(function () {
                                            privateMethods.performCloseDialog($dialog, value);
                                        }, function () {
                                            return;
                                        });
                                    }
                                } else if (preCloseCallbackResult !== false) {
                                    privateMethods.performCloseDialog($dialog, value);
                                }
                            } else {
                                privateMethods.performCloseDialog($dialog, value);
                            }
                        },
                        onTrapFocusKeydown: function (ev) {
                            var el = angular.element(ev.currentTarget);
                            var $dialog;
                            if (el.hasClass('ngdialog')) {
                                $dialog = el;
                            } else {
                                $dialog = privateMethods.getActiveDialog();
                                if ($dialog === null) {
                                    return;
                                }
                            }
                            var isTab = ev.keyCode === 9;
                            var backward = ev.shiftKey === true;
                            if (isTab) {
                                privateMethods.handleTab($dialog, ev, backward);
                            }
                        },
                        handleTab: function ($dialog, ev, backward) {
                            var focusableElements = privateMethods.getFocusableElements($dialog);
                            if (focusableElements.length === 0) {
                                if (document.activeElement) {
                                    document.activeElement.blur();
                                }
                                return;
                            }
                            var currentFocus = document.activeElement;
                            var focusIndex = Array.prototype.indexOf.call(focusableElements, currentFocus);
                            var isFocusIndexUnknown = focusIndex === -1;
                            var isFirstElementFocused = focusIndex === 0;
                            var isLastElementFocused = focusIndex === focusableElements.length - 1;
                            var cancelEvent = false;
                            if (backward) {
                                if (isFocusIndexUnknown || isFirstElementFocused) {
                                    focusableElements[focusableElements.length - 1].focus();
                                    cancelEvent = true;
                                }
                            } else {
                                if (isFocusIndexUnknown || isLastElementFocused) {
                                    focusableElements[0].focus();
                                    cancelEvent = true;
                                }
                            }
                            if (cancelEvent) {
                                ev.preventDefault();
                                ev.stopPropagation();
                            }
                        },
                        autoFocus: function ($dialog) {
                            var dialogEl = $dialog[0];
                            var autoFocusEl = dialogEl.querySelector('*[autofocus]');
                            if (autoFocusEl !== null) {
                                autoFocusEl.focus();
                                if (document.activeElement === autoFocusEl) {
                                    return;
                                }
                            }
                            var focusableElements = privateMethods.getFocusableElements($dialog);
                            if (focusableElements.length > 0) {
                                focusableElements[0].focus();
                                return;
                            }
                            var contentElements = privateMethods.filterVisibleElements(dialogEl.querySelectorAll('h1,h2,h3,h4,h5,h6,p,span'));
                            if (contentElements.length > 0) {
                                var contentElement = contentElements[0];
                                $el(contentElement).attr('tabindex', '-1').css('outline', '0');
                                contentElement.focus();
                            }
                        },
                        getFocusableElements: function ($dialog) {
                            var dialogEl = $dialog[0];
                            var rawElements = dialogEl.querySelectorAll(focusableElementSelector);
                            var tabbableElements = privateMethods.filterTabbableElements(rawElements);
                            return privateMethods.filterVisibleElements(tabbableElements);
                        },
                        filterTabbableElements: function (els) {
                            var tabbableFocusableElements = [];
                            for (var i = 0; i < els.length; i++) {
                                var el = els[i];
                                if ($el(el).attr('tabindex') !== '-1') {
                                    tabbableFocusableElements.push(el);
                                }
                            }
                            return tabbableFocusableElements;
                        },
                        filterVisibleElements: function (els) {
                            var visibleFocusableElements = [];
                            for (var i = 0; i < els.length; i++) {
                                var el = els[i];
                                if (el.offsetWidth > 0 || el.offsetHeight > 0) {
                                    visibleFocusableElements.push(el);
                                }
                            }
                            return visibleFocusableElements;
                        },
                        getActiveDialog: function () {
                            var dialogs = document.querySelectorAll('.ngdialog');
                            if (dialogs.length === 0) {
                                return null;
                            }
                            return $el(dialogs[dialogs.length - 1]);
                        },
                        applyAriaAttributes: function ($dialog, options) {
                            if (options.ariaAuto) {
                                if (!options.ariaRole) {
                                    var detectedRole = privateMethods.getFocusableElements($dialog).length > 0 ? 'dialog' : 'alertdialog';
                                    options.ariaRole = detectedRole;
                                }
                                if (!options.ariaLabelledBySelector) {
                                    options.ariaLabelledBySelector = 'h1,h2,h3,h4,h5,h6';
                                }
                                if (!options.ariaDescribedBySelector) {
                                    options.ariaDescribedBySelector = 'article,section,p';
                                }
                            }
                            if (options.ariaRole) {
                                $dialog.attr('role', options.ariaRole);
                            }
                            privateMethods.applyAriaAttribute($dialog, 'aria-labelledby', options.ariaLabelledById, options.ariaLabelledBySelector);
                            privateMethods.applyAriaAttribute($dialog, 'aria-describedby', options.ariaDescribedById, options.ariaDescribedBySelector);
                        },
                        applyAriaAttribute: function ($dialog, attr, id, selector) {
                            if (id) {
                                $dialog.attr(attr, id);
                            }
                            if (selector) {
                                var dialogId = $dialog.attr('id');
                                var firstMatch = $dialog[0].querySelector(selector);
                                if (!firstMatch) {
                                    return;
                                }
                                var generatedId = dialogId + '-' + attr;
                                $el(firstMatch).attr('id', generatedId);
                                $dialog.attr(attr, generatedId);
                                return generatedId;
                            }
                        },
                        detectUIRouter: function () {
                            try {
                                angular.module('ui.router');
                                return true;
                            } catch (err) {
                                return false;
                            }
                        },
                        getRouterLocationEventName: function () {
                            if (privateMethods.detectUIRouter()) {
                                return '$stateChangeSuccess';
                            }
                            return '$locationChangeSuccess';
                        }
                    };
                    var publicMethods = {
                        __PRIVATE__: privateMethods,
                        open: function (opts) {
                            var dialogID = null;
                            opts = opts || {};
                            if (openOnePerName && opts.name) {
                                dialogID = opts.name + ' dialog';
                                if (this.isOpen(dialogID)) {
                                    return;
                                }
                            }
                            var options = angular.copy(defaults);
                            var localID = ++globalID;
                            dialogID = dialogID || 'ngdialog' + localID;
                            openIdStack.push(dialogID);
                            if (typeof options.data !== 'undefined') {
                                if (typeof opts.data === 'undefined') {
                                    opts.data = {};
                                }
                                opts.data = angular.merge(angular.copy(options.data), opts.data);
                            }
                            angular.extend(options, opts);
                            var defer;
                            defers[dialogID] = defer = $q.defer();
                            var scope;
                            scopes[dialogID] = scope = angular.isObject(options.scope) ? options.scope.$new() : $rootScope.$new();
                            var $dialog, $dialogParent;
                            var resolve = angular.extend({}, options.resolve);
                            angular.forEach(resolve, function (value, key) {
                                resolve[key] = angular.isString(value) ? $injector.get(value) : $injector.invoke(value, null, null, key);
                            });
                            $q.all({
                                template: loadTemplate(options.template || options.templateUrl),
                                locals: $q.all(resolve)
                            }).then(function (setup) {
                                var template = setup.template, locals = setup.locals;
                                if (options.showClose) {
                                    template += '<div class="ngdialog-close"></div>';
                                }
                                var hasOverlayClass = options.overlay ? '' : ' ngdialog-no-overlay';
                                $dialog = $el('<div id="' + dialogID + '" class="ngdialog' + hasOverlayClass + '"></div>');
                                $dialog.html(options.overlay ? '<div class="ngdialog-overlay"></div><div class="ngdialog-content" role="document">' + template + '</div>' : '<div class="ngdialog-content" role="document">' + template + '</div>');
                                $dialog.data('$ngDialogOptions', options);
                                scope.ngDialogId = dialogID;
                                if (options.data && angular.isString(options.data)) {
                                    var firstLetter = options.data.replace(/^\s*/, '')[0];
                                    scope.ngDialogData = firstLetter === '{' || firstLetter === '[' ? angular.fromJson(options.data) : new String(options.data);
                                    scope.ngDialogData.ngDialogId = dialogID;
                                } else if (options.data && angular.isObject(options.data)) {
                                    scope.ngDialogData = options.data;
                                    scope.ngDialogData.ngDialogId = dialogID;
                                }
                                if (options.className) {
                                    $dialog.addClass(options.className);
                                }
                                if (options.appendClassName) {
                                    $dialog.addClass(options.appendClassName);
                                }
                                if (options.disableAnimation) {
                                    $dialog.addClass(disabledAnimationClass);
                                }
                                if (options.appendTo && angular.isString(options.appendTo)) {
                                    $dialogParent = angular.element(document.querySelector(options.appendTo));
                                } else {
                                    $dialogParent = $elements.body;
                                }
                                privateMethods.applyAriaAttributes($dialog, options);
                                if (options.preCloseCallback) {
                                    var preCloseCallback;
                                    if (angular.isFunction(options.preCloseCallback)) {
                                        preCloseCallback = options.preCloseCallback;
                                    } else if (angular.isString(options.preCloseCallback)) {
                                        if (scope) {
                                            if (angular.isFunction(scope[options.preCloseCallback])) {
                                                preCloseCallback = scope[options.preCloseCallback];
                                            } else if (scope.$parent && angular.isFunction(scope.$parent[options.preCloseCallback])) {
                                                preCloseCallback = scope.$parent[options.preCloseCallback];
                                            } else if ($rootScope && angular.isFunction($rootScope[options.preCloseCallback])) {
                                                preCloseCallback = $rootScope[options.preCloseCallback];
                                            }
                                        }
                                    }
                                    if (preCloseCallback) {
                                        $dialog.data('$ngDialogPreCloseCallback', preCloseCallback);
                                    }
                                }
                                scope.closeThisDialog = function (value) {
                                    privateMethods.closeDialog($dialog, value);
                                };
                                if (options.controller && (angular.isString(options.controller) || angular.isArray(options.controller) || angular.isFunction(options.controller))) {
                                    var label;
                                    if (options.controllerAs && angular.isString(options.controllerAs)) {
                                        label = options.controllerAs;
                                    }
                                    var controllerInstance = $controller(options.controller, angular.extend(locals, {
                                        $scope: scope,
                                        $element: $dialog
                                    }), true, label);
                                    if (options.bindToController) {
                                        angular.extend(controllerInstance.instance, {
                                            ngDialogId: scope.ngDialogId,
                                            ngDialogData: scope.ngDialogData,
                                            closeThisDialog: scope.closeThisDialog
                                        });
                                    }
                                    $dialog.data('$ngDialogControllerController', controllerInstance());
                                }
                                $timeout(function () {
                                    var $activeDialogs = document.querySelectorAll('.ngdialog');
                                    privateMethods.deactivateAll($activeDialogs);
                                    $compile($dialog)(scope);
                                    var widthDiffs = $window.innerWidth - $elements.body.prop('clientWidth');
                                    $elements.html.addClass(options.bodyClassName);
                                    $elements.body.addClass(options.bodyClassName);
                                    var scrollBarWidth = widthDiffs - ($window.innerWidth - $elements.body.prop('clientWidth'));
                                    if (scrollBarWidth > 0) {
                                        privateMethods.setBodyPadding(scrollBarWidth);
                                    }
                                    $dialogParent.append($dialog);
                                    privateMethods.activate($dialog);
                                    if (options.trapFocus) {
                                        privateMethods.autoFocus($dialog);
                                    }
                                    if (options.name) {
                                        $rootScope.$broadcast('ngDialog.opened', {
                                            dialog: $dialog,
                                            name: options.name
                                        });
                                    } else {
                                        $rootScope.$broadcast('ngDialog.opened', $dialog);
                                    }
                                });
                                if (!keydownIsBound) {
                                    $elements.body.bind('keydown', privateMethods.onDocumentKeydown);
                                    keydownIsBound = true;
                                }
                                if (options.closeByNavigation) {
                                    var eventName = privateMethods.getRouterLocationEventName();
                                    $rootScope.$on(eventName, function () {
                                        privateMethods.closeDialog($dialog);
                                    });
                                }
                                if (options.preserveFocus) {
                                    $dialog.data('$ngDialogPreviousFocus', document.activeElement);
                                }
                                closeByDocumentHandler = function (event) {
                                    var isOverlay = options.closeByDocument ? $el(event.target).hasClass('ngdialog-overlay') : false;
                                    var isCloseBtn = $el(event.target).hasClass('ngdialog-close');
                                    if (isOverlay || isCloseBtn) {
                                        publicMethods.close($dialog.attr('id'), isCloseBtn ? '$closeButton' : '$document');
                                    }
                                };
                                if (typeof $window.Hammer !== 'undefined') {
                                    var hammerTime = scope.hammerTime = $window.Hammer($dialog[0]);
                                    hammerTime.on('tap', closeByDocumentHandler);
                                } else {
                                    $dialog.bind('click', closeByDocumentHandler);
                                }
                                dialogsCount += 1;
                                return publicMethods;
                            });
                            return {
                                id: dialogID,
                                closePromise: defer.promise,
                                close: function (value) {
                                    privateMethods.closeDialog($dialog, value);
                                }
                            };
                            function loadTemplateUrl(tmpl, config) {
                                $rootScope.$broadcast('ngDialog.templateLoading', tmpl);
                                return $http.get(tmpl, config || {}).then(function (res) {
                                    $rootScope.$broadcast('ngDialog.templateLoaded', tmpl);
                                    return res.data || '';
                                });
                            }
                            function loadTemplate(tmpl) {
                                if (!tmpl) {
                                    return 'Empty template';
                                }
                                if (angular.isString(tmpl) && options.plain) {
                                    return tmpl;
                                }
                                if (typeof options.cache === 'boolean' && !options.cache) {
                                    return loadTemplateUrl(tmpl, { cache: false });
                                }
                                return loadTemplateUrl(tmpl, { cache: $templateCache });
                            }
                        },
                        openConfirm: function (opts) {
                            var defer = $q.defer();
                            var options = angular.copy(defaults);
                            opts = opts || {};
                            if (typeof options.data !== 'undefined') {
                                if (typeof opts.data === 'undefined') {
                                    opts.data = {};
                                }
                                opts.data = angular.merge(angular.copy(options.data), opts.data);
                            }
                            angular.extend(options, opts);
                            options.scope = angular.isObject(options.scope) ? options.scope.$new() : $rootScope.$new();
                            options.scope.confirm = function (value) {
                                defer.resolve(value);
                                var $dialog = $el(document.getElementById(openResult.id));
                                privateMethods.performCloseDialog($dialog, value);
                            };
                            var openResult = publicMethods.open(options);
                            if (openResult) {
                                openResult.closePromise.then(function (data) {
                                    if (data) {
                                        return defer.reject(data.value);
                                    }
                                    return defer.reject();
                                });
                                return defer.promise;
                            }
                        },
                        isOpen: function (id) {
                            var $dialog = $el(document.getElementById(id));
                            return $dialog.length > 0;
                        },
                        close: function (id, value) {
                            var $dialog = $el(document.getElementById(id));
                            if ($dialog.length) {
                                privateMethods.closeDialog($dialog, value);
                            } else {
                                if (id === '$escape') {
                                    var topDialogId = openIdStack[openIdStack.length - 1];
                                    $dialog = $el(document.getElementById(topDialogId));
                                    if ($dialog.data('$ngDialogOptions').closeByEscape) {
                                        privateMethods.closeDialog($dialog, '$escape');
                                    }
                                } else {
                                    publicMethods.closeAll(value);
                                }
                            }
                            return publicMethods;
                        },
                        closeAll: function (value) {
                            var $all = document.querySelectorAll('.ngdialog');
                            for (var i = $all.length - 1; i >= 0; i--) {
                                var dialog = $all[i];
                                privateMethods.closeDialog($el(dialog), value);
                            }
                        },
                        getOpenDialogs: function () {
                            return openIdStack;
                        },
                        getDefaults: function () {
                            return defaults;
                        }
                    };
                    angular.forEach([
                        'html',
                        'body'
                    ], function (elementName) {
                        $elements[elementName] = $document.find(elementName);
                        if (forceElementsReload[elementName]) {
                            var eventName = privateMethods.getRouterLocationEventName();
                            $rootScope.$on(eventName, function () {
                                $elements[elementName] = $document.find(elementName);
                            });
                        }
                    });
                    return publicMethods;
                }
            ];
        });
        m.directive('ngDialog', [
            'ngDialog',
            function (ngDialog) {
                return {
                    restrict: 'A',
                    scope: { ngDialogScope: '=' },
                    link: function (scope, elem, attrs) {
                        elem.on('click', function (e) {
                            e.preventDefault();
                            var ngDialogScope = angular.isDefined(scope.ngDialogScope) ? scope.ngDialogScope : 'noScope';
                            angular.isDefined(attrs.ngDialogClosePrevious) && ngDialog.close(attrs.ngDialogClosePrevious);
                            var defaults = ngDialog.getDefaults();
                            ngDialog.open({
                                template: attrs.ngDialog,
                                className: attrs.ngDialogClass || defaults.className,
                                appendClassName: attrs.ngDialogAppendClass,
                                controller: attrs.ngDialogController,
                                controllerAs: attrs.ngDialogControllerAs,
                                bindToController: attrs.ngDialogBindToController,
                                scope: ngDialogScope,
                                data: attrs.ngDialogData,
                                showClose: attrs.ngDialogShowClose === 'false' ? false : attrs.ngDialogShowClose === 'true' ? true : defaults.showClose,
                                closeByDocument: attrs.ngDialogCloseByDocument === 'false' ? false : attrs.ngDialogCloseByDocument === 'true' ? true : defaults.closeByDocument,
                                closeByEscape: attrs.ngDialogCloseByEscape === 'false' ? false : attrs.ngDialogCloseByEscape === 'true' ? true : defaults.closeByEscape,
                                overlay: attrs.ngDialogOverlay === 'false' ? false : attrs.ngDialogOverlay === 'true' ? true : defaults.overlay,
                                preCloseCallback: attrs.ngDialogPreCloseCallback || defaults.preCloseCallback,
                                bodyClassName: attrs.ngDialogBodyClass || defaults.bodyClassName
                            });
                        });
                    }
                };
            }
        ]);
        return m;
    }));
}.call(this));
define('ngSelect', ['angular'], function () {
    (function () {
        'use strict';
        var KEY = {
            TAB: 9,
            ENTER: 13,
            ESC: 27,
            SPACE: 32,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40,
            SHIFT: 16,
            CTRL: 17,
            ALT: 18,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            HOME: 36,
            END: 35,
            BACKSPACE: 8,
            DELETE: 46,
            COMMAND: 91,
            MAP: {
                91: 'COMMAND',
                8: 'BACKSPACE',
                9: 'TAB',
                13: 'ENTER',
                16: 'SHIFT',
                17: 'CTRL',
                18: 'ALT',
                19: 'PAUSEBREAK',
                20: 'CAPSLOCK',
                27: 'ESC',
                32: 'SPACE',
                33: 'PAGE_UP',
                34: 'PAGE_DOWN',
                35: 'END',
                36: 'HOME',
                37: 'LEFT',
                38: 'UP',
                39: 'RIGHT',
                40: 'DOWN',
                43: '+',
                44: 'PRINTSCREEN',
                45: 'INSERT',
                46: 'DELETE',
                48: '0',
                49: '1',
                50: '2',
                51: '3',
                52: '4',
                53: '5',
                54: '6',
                55: '7',
                56: '8',
                57: '9',
                59: ';',
                61: '=',
                65: 'A',
                66: 'B',
                67: 'C',
                68: 'D',
                69: 'E',
                70: 'F',
                71: 'G',
                72: 'H',
                73: 'I',
                74: 'J',
                75: 'K',
                76: 'L',
                77: 'M',
                78: 'N',
                79: 'O',
                80: 'P',
                81: 'Q',
                82: 'R',
                83: 'S',
                84: 'T',
                85: 'U',
                86: 'V',
                87: 'W',
                88: 'X',
                89: 'Y',
                90: 'Z',
                96: '0',
                97: '1',
                98: '2',
                99: '3',
                100: '4',
                101: '5',
                102: '6',
                103: '7',
                104: '8',
                105: '9',
                106: '*',
                107: '+',
                109: '-',
                110: '.',
                111: '/',
                112: 'F1',
                113: 'F2',
                114: 'F3',
                115: 'F4',
                116: 'F5',
                117: 'F6',
                118: 'F7',
                119: 'F8',
                120: 'F9',
                121: 'F10',
                122: 'F11',
                123: 'F12',
                144: 'NUMLOCK',
                145: 'SCROLLLOCK',
                186: ';',
                187: '=',
                188: ',',
                189: '-',
                190: '.',
                191: '/',
                192: '`',
                219: '[',
                220: '\\',
                221: ']',
                222: '\''
            },
            isControl: function (e) {
                var k = e.which;
                switch (k) {
                case KEY.COMMAND:
                case KEY.SHIFT:
                case KEY.CTRL:
                case KEY.ALT:
                    return true;
                }
                if (e.metaKey)
                    return true;
                return false;
            },
            isFunctionKey: function (k) {
                k = k.which ? k.which : k;
                return k >= 112 && k <= 123;
            },
            isVerticalMovement: function (k) {
                return ~[
                    KEY.UP,
                    KEY.DOWN
                ].indexOf(k);
            },
            isHorizontalMovement: function (k) {
                return ~[
                    KEY.LEFT,
                    KEY.RIGHT,
                    KEY.BACKSPACE,
                    KEY.DELETE
                ].indexOf(k);
            },
            toSeparator: function (k) {
                var sep = {
                    ENTER: '\n',
                    TAB: '\t',
                    SPACE: ' '
                }[k];
                if (sep)
                    return sep;
                return KEY[k] ? undefined : k;
            }
        };
        if (angular.element.prototype.querySelectorAll === undefined) {
            angular.element.prototype.querySelectorAll = function (selector) {
                return angular.element(this[0].querySelectorAll(selector));
            };
        }
        if (angular.element.prototype.closest === undefined) {
            angular.element.prototype.closest = function (selector) {
                var elem = this[0];
                var matchesSelector = elem.matches || elem.webkitMatchesSelector || elem.mozMatchesSelector || elem.msMatchesSelector;
                while (elem) {
                    if (matchesSelector.bind(elem)(selector)) {
                        return elem;
                    } else {
                        elem = elem.parentElement;
                    }
                }
                return false;
            };
        }
        var latestId = 0;
        var uis = angular.module('ui.select', []).constant('uiSelectConfig', {
            theme: 'bootstrap',
            searchEnabled: true,
            sortable: false,
            placeholder: '',
            refreshDelay: 1000,
            closeOnSelect: true,
            skipFocusser: false,
            dropdownPosition: 'auto',
            generateId: function () {
                return latestId++;
            },
            appendToBody: false
        }).service('uiSelectMinErr', function () {
            var minErr = angular.$$minErr('ui.select');
            return function () {
                var error = minErr.apply(this, arguments);
                var message = error.message.replace(new RegExp('\nhttp://errors.angularjs.org/.*'), '');
                return new Error(message);
            };
        }).directive('uisTranscludeAppend', function () {
            return {
                link: function (scope, element, attrs, ctrl, transclude) {
                    transclude(scope, function (clone) {
                        element.append(clone);
                    });
                }
            };
        }).filter('highlight', function () {
            function escapeRegexp(queryToEscape) {
                return ('' + queryToEscape).replace(/([.?*+^$[\]\\(){}|-])/g, '\\$1');
            }
            return function (matchItem, query) {
                return query && matchItem ? ('' + matchItem).replace(new RegExp(escapeRegexp(query), 'gi'), '<span class="ui-select-highlight">$&</span>') : matchItem;
            };
        }).factory('uisOffset', [
            '$document',
            '$window',
            function ($document, $window) {
                return function (element) {
                    var boundingClientRect = element[0].getBoundingClientRect();
                    return {
                        width: boundingClientRect.width || element.prop('offsetWidth'),
                        height: boundingClientRect.height || element.prop('offsetHeight'),
                        top: boundingClientRect.top + ($window.pageYOffset || $document[0].documentElement.scrollTop),
                        left: boundingClientRect.left + ($window.pageXOffset || $document[0].documentElement.scrollLeft)
                    };
                };
            }
        ]);
        uis.directive('uiSelectChoices', [
            'uiSelectConfig',
            'uisRepeatParser',
            'uiSelectMinErr',
            '$compile',
            '$window',
            function (uiSelectConfig, RepeatParser, uiSelectMinErr, $compile, $window) {
                return {
                    restrict: 'EA',
                    require: '^uiSelect',
                    replace: true,
                    transclude: true,
                    templateUrl: function (tElement) {
                        tElement.addClass('ui-select-choices');
                        var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
                        return theme + '/choices.tpl.html';
                    },
                    compile: function (tElement, tAttrs) {
                        if (!tAttrs.repeat)
                            throw uiSelectMinErr('repeat', 'Expected \'repeat\' expression.');
                        return function link(scope, element, attrs, $select, transcludeFn) {
                            var groupByExp = attrs.groupBy;
                            var groupFilterExp = attrs.groupFilter;
                            $select.parseRepeatAttr(attrs.repeat, groupByExp, groupFilterExp);
                            $select.disableChoiceExpression = attrs.uiDisableChoice;
                            $select.onHighlightCallback = attrs.onHighlight;
                            $select.dropdownPosition = attrs.position ? attrs.position.toLowerCase() : uiSelectConfig.dropdownPosition;
                            if (groupByExp) {
                                var groups = element.querySelectorAll('.ui-select-choices-group');
                                if (groups.length !== 1)
                                    throw uiSelectMinErr('rows', 'Expected 1 .ui-select-choices-group but got \'{0}\'.', groups.length);
                                groups.attr('ng-repeat', RepeatParser.getGroupNgRepeatExpression());
                            }
                            var choices = element.querySelectorAll('.ui-select-choices-row');
                            if (choices.length !== 1) {
                                throw uiSelectMinErr('rows', 'Expected 1 .ui-select-choices-row but got \'{0}\'.', choices.length);
                            }
                            choices.attr('ng-repeat', $select.parserResult.repeatExpression(groupByExp)).attr('ng-if', '$select.open');
                            if ($window.document.addEventListener) {
                                choices.attr('ng-mouseenter', '$select.setActiveItem(' + $select.parserResult.itemName + ')').attr('ng-click', '$select.select(' + $select.parserResult.itemName + ',$select.skipFocusser,$event)');
                            }
                            var rowsInner = element.querySelectorAll('.ui-select-choices-row-inner');
                            if (rowsInner.length !== 1)
                                throw uiSelectMinErr('rows', 'Expected 1 .ui-select-choices-row-inner but got \'{0}\'.', rowsInner.length);
                            rowsInner.attr('uis-transclude-append', '');
                            if (!$window.document.addEventListener) {
                                rowsInner.attr('ng-mouseenter', '$select.setActiveItem(' + $select.parserResult.itemName + ')').attr('ng-click', '$select.select(' + $select.parserResult.itemName + ',$select.skipFocusser,$event)');
                            }
                            $compile(element, transcludeFn)(scope);
                            scope.$watch('$select.search', function (newValue) {
                                if (newValue && !$select.open && $select.multiple)
                                    $select.activate(false, true);
                                $select.activeIndex = $select.tagging.isActivated ? -1 : 0;
                                if (!attrs.minimumInputLength || $select.search.length >= attrs.minimumInputLength) {
                                    $select.refresh(attrs.refresh);
                                } else {
                                    $select.items = [];
                                }
                            });
                            attrs.$observe('refreshDelay', function () {
                                var refreshDelay = scope.$eval(attrs.refreshDelay);
                                $select.refreshDelay = refreshDelay !== undefined ? refreshDelay : uiSelectConfig.refreshDelay;
                            });
                        };
                    }
                };
            }
        ]);
        uis.controller('uiSelectCtrl', [
            '$scope',
            '$element',
            '$timeout',
            '$filter',
            'uisRepeatParser',
            'uiSelectMinErr',
            'uiSelectConfig',
            '$parse',
            '$injector',
            '$window',
            function ($scope, $element, $timeout, $filter, RepeatParser, uiSelectMinErr, uiSelectConfig, $parse, $injector, $window) {
                var ctrl = this;
                var EMPTY_SEARCH = '';
                ctrl.placeholder = uiSelectConfig.placeholder;
                ctrl.searchEnabled = uiSelectConfig.searchEnabled;
                ctrl.sortable = uiSelectConfig.sortable;
                ctrl.refreshDelay = uiSelectConfig.refreshDelay;
                ctrl.paste = uiSelectConfig.paste;
                ctrl.removeSelected = false;
                ctrl.closeOnSelect = true;
                ctrl.skipFocusser = false;
                ctrl.search = EMPTY_SEARCH;
                ctrl.activeIndex = 0;
                ctrl.items = [];
                ctrl.open = false;
                ctrl.focus = false;
                ctrl.disabled = false;
                ctrl.selected = undefined;
                ctrl.dropdownPosition = 'auto';
                ctrl.focusser = undefined;
                ctrl.resetSearchInput = true;
                ctrl.multiple = undefined;
                ctrl.disableChoiceExpression = undefined;
                ctrl.tagging = {
                    isActivated: false,
                    fct: undefined
                };
                ctrl.taggingTokens = {
                    isActivated: false,
                    tokens: undefined
                };
                ctrl.lockChoiceExpression = undefined;
                ctrl.clickTriggeredSelect = false;
                ctrl.$filter = $filter;
                ctrl.$animate = function () {
                    try {
                        return $injector.get('$animate');
                    } catch (err) {
                        return null;
                    }
                }();
                ctrl.searchInput = $element.querySelectorAll('input.ui-select-search');
                if (ctrl.searchInput.length !== 1) {
                    throw uiSelectMinErr('searchInput', 'Expected 1 input.ui-select-search but got \'{0}\'.', ctrl.searchInput.length);
                }
                ctrl.isEmpty = function () {
                    return angular.isUndefined(ctrl.selected) || ctrl.selected === null || ctrl.selected === '' || ctrl.multiple && ctrl.selected.length === 0;
                };
                function _findIndex(collection, predicate, thisArg) {
                    if (collection.findIndex) {
                        return collection.findIndex(predicate, thisArg);
                    } else {
                        var list = Object(collection);
                        var length = list.length >>> 0;
                        var value;
                        for (var i = 0; i < length; i++) {
                            value = list[i];
                            if (predicate.call(thisArg, value, i, list)) {
                                return i;
                            }
                        }
                        return -1;
                    }
                }
                function _resetSearchInput() {
                    if (ctrl.resetSearchInput || ctrl.resetSearchInput === undefined && uiSelectConfig.resetSearchInput) {
                        ctrl.search = EMPTY_SEARCH;
                        if (ctrl.selected && ctrl.items.length && !ctrl.multiple) {
                            ctrl.activeIndex = _findIndex(ctrl.items, function (item) {
                                return angular.equals(this, item);
                            }, ctrl.selected);
                        }
                    }
                }
                function _groupsFilter(groups, groupNames) {
                    var i, j, result = [];
                    for (i = 0; i < groupNames.length; i++) {
                        for (j = 0; j < groups.length; j++) {
                            if (groups[j].name == [groupNames[i]]) {
                                result.push(groups[j]);
                            }
                        }
                    }
                    return result;
                }
                ctrl.activate = function (initSearchValue, avoidReset) {
                    if (!ctrl.disabled && !ctrl.open) {
                        if (!avoidReset)
                            _resetSearchInput();
                        $scope.$broadcast('uis:activate');
                        ctrl.open = true;
                        ctrl.activeIndex = ctrl.activeIndex >= ctrl.items.length ? 0 : ctrl.activeIndex;
                        if (ctrl.activeIndex === -1 && ctrl.taggingLabel !== false) {
                            ctrl.activeIndex = 0;
                        }
                        var container = $element.querySelectorAll('.ui-select-choices-content');
                        if (ctrl.$animate && ctrl.$animate.on && ctrl.$animate.enabled(container[0])) {
                            ctrl.$animate.on('enter', container[0], function (elem, phase) {
                                if (phase === 'close') {
                                    $timeout(function () {
                                        ctrl.focusSearchInput(initSearchValue);
                                    });
                                }
                            });
                        } else {
                            $timeout(function () {
                                ctrl.focusSearchInput(initSearchValue);
                                if (!ctrl.tagging.isActivated && ctrl.items.length > 1) {
                                    _ensureHighlightVisible();
                                }
                            });
                        }
                    }
                };
                ctrl.focusSearchInput = function (initSearchValue) {
                    ctrl.search = initSearchValue || ctrl.search;
                    ctrl.searchInput[0].focus();
                };
                ctrl.findGroupByName = function (name) {
                    return ctrl.groups && ctrl.groups.filter(function (group) {
                        return group.name === name;
                    })[0];
                };
                ctrl.parseRepeatAttr = function (repeatAttr, groupByExp, groupFilterExp) {
                    function updateGroups(items) {
                        var groupFn = $scope.$eval(groupByExp);
                        ctrl.groups = [];
                        angular.forEach(items, function (item) {
                            var groupName = angular.isFunction(groupFn) ? groupFn(item) : item[groupFn];
                            var group = ctrl.findGroupByName(groupName);
                            if (group) {
                                group.items.push(item);
                            } else {
                                ctrl.groups.push({
                                    name: groupName,
                                    items: [item]
                                });
                            }
                        });
                        if (groupFilterExp) {
                            var groupFilterFn = $scope.$eval(groupFilterExp);
                            if (angular.isFunction(groupFilterFn)) {
                                ctrl.groups = groupFilterFn(ctrl.groups);
                            } else if (angular.isArray(groupFilterFn)) {
                                ctrl.groups = _groupsFilter(ctrl.groups, groupFilterFn);
                            }
                        }
                        ctrl.items = [];
                        ctrl.groups.forEach(function (group) {
                            ctrl.items = ctrl.items.concat(group.items);
                        });
                    }
                    function setPlainItems(items) {
                        ctrl.items = items;
                    }
                    ctrl.setItemsFn = groupByExp ? updateGroups : setPlainItems;
                    ctrl.parserResult = RepeatParser.parse(repeatAttr);
                    ctrl.isGrouped = !!groupByExp;
                    ctrl.itemProperty = ctrl.parserResult.itemName;
                    var originalSource = ctrl.parserResult.source;
                    var createArrayFromObject = function () {
                        var origSrc = originalSource($scope);
                        $scope.$uisSource = Object.keys(origSrc).map(function (v) {
                            var result = {};
                            result[ctrl.parserResult.keyName] = v;
                            result.value = origSrc[v];
                            return result;
                        });
                    };
                    if (ctrl.parserResult.keyName) {
                        createArrayFromObject();
                        ctrl.parserResult.source = $parse('$uisSource' + ctrl.parserResult.filters);
                        $scope.$watch(originalSource, function (newVal, oldVal) {
                            if (newVal !== oldVal)
                                createArrayFromObject();
                        }, true);
                    }
                    ctrl.refreshItems = function (data) {
                        data = data || ctrl.parserResult.source($scope);
                        var selectedItems = ctrl.selected;
                        if (ctrl.isEmpty() || angular.isArray(selectedItems) && !selectedItems.length || !ctrl.removeSelected) {
                            ctrl.setItemsFn(data);
                        } else {
                            if (data !== undefined) {
                                var filteredItems = data.filter(function (i) {
                                    return selectedItems.every(function (selectedItem) {
                                        return !angular.equals(i, selectedItem);
                                    });
                                });
                                ctrl.setItemsFn(filteredItems);
                            }
                        }
                        if (ctrl.dropdownPosition === 'auto' || ctrl.dropdownPosition === 'up') {
                            $scope.calculateDropdownPos();
                        }
                    };
                    $scope.$watchCollection(ctrl.parserResult.source, function (items) {
                        if (items === undefined || items === null) {
                            ctrl.items = [];
                        } else {
                            if (!angular.isArray(items)) {
                                throw uiSelectMinErr('items', 'Expected an array but got \'{0}\'.', items);
                            } else {
                                ctrl.refreshItems(items);
                                ctrl.ngModel.$modelValue = null;
                            }
                        }
                    });
                };
                var _refreshDelayPromise;
                ctrl.refresh = function (refreshAttr) {
                    if (refreshAttr !== undefined) {
                        if (_refreshDelayPromise) {
                            $timeout.cancel(_refreshDelayPromise);
                        }
                        _refreshDelayPromise = $timeout(function () {
                            $scope.$eval(refreshAttr);
                        }, ctrl.refreshDelay);
                    }
                };
                ctrl.isActive = function (itemScope) {
                    if (!ctrl.open) {
                        return false;
                    }
                    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
                    var isActive = itemIndex == ctrl.activeIndex;
                    if (!isActive || itemIndex < 0 && ctrl.taggingLabel !== false || itemIndex < 0 && ctrl.taggingLabel === false) {
                        return false;
                    }
                    if (isActive && !angular.isUndefined(ctrl.onHighlightCallback)) {
                        itemScope.$eval(ctrl.onHighlightCallback);
                    }
                    return isActive;
                };
                ctrl.isDisabled = function (itemScope) {
                    if (!ctrl.open)
                        return;
                    var itemIndex = ctrl.items.indexOf(itemScope[ctrl.itemProperty]);
                    var isDisabled = false;
                    var item;
                    if (itemIndex >= 0 && !angular.isUndefined(ctrl.disableChoiceExpression)) {
                        item = ctrl.items[itemIndex];
                        isDisabled = !!itemScope.$eval(ctrl.disableChoiceExpression);
                        item._uiSelectChoiceDisabled = isDisabled;
                    }
                    return isDisabled;
                };
                ctrl.select = function (item, skipFocusser, $event) {
                    if (item === undefined || !item._uiSelectChoiceDisabled) {
                        if (!ctrl.items && !ctrl.search && !ctrl.tagging.isActivated)
                            return;
                        if (!item || !item._uiSelectChoiceDisabled) {
                            if (ctrl.tagging.isActivated) {
                                if (ctrl.taggingLabel === false) {
                                    if (ctrl.activeIndex < 0) {
                                        item = ctrl.tagging.fct !== undefined ? ctrl.tagging.fct(ctrl.search) : ctrl.search;
                                        if (!item || angular.equals(ctrl.items[0], item)) {
                                            return;
                                        }
                                    } else {
                                        item = ctrl.items[ctrl.activeIndex];
                                    }
                                } else {
                                    if (ctrl.activeIndex === 0) {
                                        if (item === undefined)
                                            return;
                                        if (ctrl.tagging.fct !== undefined && typeof item === 'string') {
                                            item = ctrl.tagging.fct(item);
                                            if (!item)
                                                return;
                                        } else if (typeof item === 'string') {
                                            item = item.replace(ctrl.taggingLabel, '').trim();
                                        }
                                    }
                                }
                                if (ctrl.selected && angular.isArray(ctrl.selected) && ctrl.selected.filter(function (selection) {
                                        return angular.equals(selection, item);
                                    }).length > 0) {
                                    ctrl.close(skipFocusser);
                                    return;
                                }
                            }
                            $scope.$broadcast('uis:select', item);
                            var locals = {};
                            locals[ctrl.parserResult.itemName] = item;
                            $timeout(function () {
                                ctrl.onSelectCallback($scope, {
                                    $item: item,
                                    $model: ctrl.parserResult.modelMapper($scope, locals)
                                });
                            });
                            if (ctrl.closeOnSelect) {
                                ctrl.close(skipFocusser);
                            }
                            if ($event && $event.type === 'click') {
                                ctrl.clickTriggeredSelect = true;
                            }
                        }
                    }
                };
                ctrl.close = function (skipFocusser) {
                    if (!ctrl.open)
                        return;
                    if (ctrl.ngModel && ctrl.ngModel.$setTouched)
                        ctrl.ngModel.$setTouched();
                    _resetSearchInput();
                    ctrl.open = false;
                    $scope.$broadcast('uis:close', skipFocusser);
                };
                ctrl.setFocus = function () {
                    if (!ctrl.focus)
                        ctrl.focusInput[0].focus();
                };
                ctrl.clear = function ($event) {
                    ctrl.select(undefined);
                    $event.stopPropagation();
                    $timeout(function () {
                        ctrl.focusser[0].focus();
                    }, 0, false);
                };
                ctrl.toggle = function (e) {
                    if (ctrl.open) {
                        ctrl.close();
                        e.preventDefault();
                        e.stopPropagation();
                    } else {
                        ctrl.activate();
                    }
                };
                ctrl.isLocked = function (itemScope, itemIndex) {
                    var isLocked, item = ctrl.selected[itemIndex];
                    if (item && !angular.isUndefined(ctrl.lockChoiceExpression)) {
                        isLocked = !!itemScope.$eval(ctrl.lockChoiceExpression);
                        item._uiSelectChoiceLocked = isLocked;
                    }
                    return isLocked;
                };
                var sizeWatch = null;
                ctrl.sizeSearchInput = function () {
                    var input = ctrl.searchInput[0], container = ctrl.searchInput.parent().parent()[0], calculateContainerWidth = function () {
                            return container.clientWidth * !!input.offsetParent;
                        }, updateIfVisible = function (containerWidth) {
                            if (containerWidth === 0) {
                                return false;
                            }
                            var inputWidth = containerWidth - input.offsetLeft - 10;
                            if (inputWidth < 50)
                                inputWidth = containerWidth;
                            ctrl.searchInput.css('width', inputWidth + 'px');
                            return true;
                        };
                    ctrl.searchInput.css('width', '10px');
                    $timeout(function () {
                        if (sizeWatch === null && !updateIfVisible(calculateContainerWidth())) {
                            sizeWatch = $scope.$watch(calculateContainerWidth, function (containerWidth) {
                                if (updateIfVisible(containerWidth)) {
                                    sizeWatch();
                                    sizeWatch = null;
                                }
                            });
                        }
                    });
                };
                function _handleDropDownSelection(key) {
                    var processed = true;
                    switch (key) {
                    case KEY.DOWN:
                        if (!ctrl.open && ctrl.multiple)
                            ctrl.activate(false, true);
                        else if (ctrl.activeIndex < ctrl.items.length - 1) {
                            ctrl.activeIndex++;
                        }
                        break;
                    case KEY.UP:
                        if (!ctrl.open && ctrl.multiple)
                            ctrl.activate(false, true);
                        else if (ctrl.activeIndex > 0 || ctrl.search.length === 0 && ctrl.tagging.isActivated && ctrl.activeIndex > -1) {
                            ctrl.activeIndex--;
                        }
                        break;
                    case KEY.TAB:
                        if (!ctrl.multiple || ctrl.open)
                            ctrl.select(ctrl.items[ctrl.activeIndex], true);
                        break;
                    case KEY.ENTER:
                        if (ctrl.open && (ctrl.tagging.isActivated || ctrl.activeIndex >= 0)) {
                            ctrl.select(ctrl.items[ctrl.activeIndex], ctrl.skipFocusser);
                        } else {
                            ctrl.activate(false, true);
                        }
                        break;
                    case KEY.ESC:
                        ctrl.close();
                        break;
                    default:
                        processed = false;
                    }
                    return processed;
                }
                ctrl.searchInput.on('keydown', function (e) {
                    var key = e.which;
                    if (~[
                            KEY.ENTER,
                            KEY.ESC
                        ].indexOf(key)) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    $scope.$apply(function () {
                        var tagged = false;
                        if (ctrl.items.length > 0 || ctrl.tagging.isActivated) {
                            _handleDropDownSelection(key);
                            if (ctrl.taggingTokens.isActivated) {
                                for (var i = 0; i < ctrl.taggingTokens.tokens.length; i++) {
                                    if (ctrl.taggingTokens.tokens[i] === KEY.MAP[e.keyCode]) {
                                        if (ctrl.search.length > 0) {
                                            tagged = true;
                                        }
                                    }
                                }
                                if (tagged) {
                                    $timeout(function () {
                                        ctrl.searchInput.triggerHandler('tagged');
                                        var newItem = ctrl.search.replace(KEY.MAP[e.keyCode], '').trim();
                                        if (ctrl.tagging.fct) {
                                            newItem = ctrl.tagging.fct(newItem);
                                        }
                                        if (newItem)
                                            ctrl.select(newItem, true);
                                    });
                                }
                            }
                        }
                    });
                    if (KEY.isVerticalMovement(key) && ctrl.items.length > 0) {
                        _ensureHighlightVisible();
                    }
                    if (key === KEY.ENTER || key === KEY.ESC) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
                ctrl.searchInput.on('paste', function (e) {
                    var data;
                    if (window.clipboardData && window.clipboardData.getData) {
                        data = window.clipboardData.getData('Text');
                    } else {
                        data = (e.originalEvent || e).clipboardData.getData('text/plain');
                    }
                    data = ctrl.search + data;
                    if (data && data.length > 0) {
                        if (ctrl.taggingTokens.isActivated) {
                            var separator = KEY.toSeparator(ctrl.taggingTokens.tokens[0]);
                            var items = data.split(separator || ctrl.taggingTokens.tokens[0]);
                            if (items && items.length > 0) {
                                var oldsearch = ctrl.search;
                                angular.forEach(items, function (item) {
                                    var newItem = ctrl.tagging.fct ? ctrl.tagging.fct(item) : item;
                                    if (newItem) {
                                        ctrl.select(newItem, true);
                                    }
                                });
                                ctrl.search = oldsearch || EMPTY_SEARCH;
                                e.preventDefault();
                                e.stopPropagation();
                            }
                        } else if (ctrl.paste) {
                            ctrl.paste(data);
                            ctrl.search = EMPTY_SEARCH;
                            e.preventDefault();
                            e.stopPropagation();
                        }
                    }
                });
                ctrl.searchInput.on('tagged', function () {
                    $timeout(function () {
                        _resetSearchInput();
                    });
                });
                function _ensureHighlightVisible() {
                    var container = $element.querySelectorAll('.ui-select-choices-content');
                    var choices = container.querySelectorAll('.ui-select-choices-row');
                    if (choices.length < 1) {
                        throw uiSelectMinErr('choices', 'Expected multiple .ui-select-choices-row but got \'{0}\'.', choices.length);
                    }
                    if (ctrl.activeIndex < 0) {
                        return;
                    }
                    var highlighted = choices[ctrl.activeIndex];
                    var posY = highlighted.offsetTop + highlighted.clientHeight - container[0].scrollTop;
                    var height = container[0].offsetHeight;
                    if (posY > height) {
                        container[0].scrollTop += posY - height;
                    } else if (posY < highlighted.clientHeight) {
                        if (ctrl.isGrouped && ctrl.activeIndex === 0)
                            container[0].scrollTop = 0;
                        else
                            container[0].scrollTop -= highlighted.clientHeight - posY;
                    }
                }
                $scope.$on('$destroy', function () {
                    ctrl.searchInput.off('keyup keydown tagged blur paste');
                });
                angular.element($window).bind('resize', function () {
                    ctrl.sizeSearchInput();
                });
            }
        ]);
        uis.directive('uiSelect', [
            '$document',
            'uiSelectConfig',
            'uiSelectMinErr',
            'uisOffset',
            '$compile',
            '$parse',
            '$timeout',
            function ($document, uiSelectConfig, uiSelectMinErr, uisOffset, $compile, $parse, $timeout) {
                return {
                    restrict: 'EA',
                    templateUrl: function (tElement, tAttrs) {
                        var theme = tAttrs.theme || uiSelectConfig.theme;
                        return theme + (angular.isDefined(tAttrs.multiple) ? '/select-multiple.tpl.html' : '/select.tpl.html');
                    },
                    replace: true,
                    transclude: true,
                    require: [
                        'uiSelect',
                        '^ngModel'
                    ],
                    scope: true,
                    controller: 'uiSelectCtrl',
                    controllerAs: '$select',
                    compile: function (tElement, tAttrs) {
                        var match = /{(.*)}\s*{(.*)}/.exec(tAttrs.ngClass);
                        if (match) {
                            var combined = '{' + match[1] + ', ' + match[2] + '}';
                            tAttrs.ngClass = combined;
                            tElement.attr('ng-class', combined);
                        }
                        if (angular.isDefined(tAttrs.multiple))
                            tElement.append('<ui-select-multiple/>').removeAttr('multiple');
                        else
                            tElement.append('<ui-select-single/>');
                        if (tAttrs.inputId)
                            tElement.querySelectorAll('input.ui-select-search')[0].id = tAttrs.inputId;
                        return function (scope, element, attrs, ctrls, transcludeFn) {
                            var $select = ctrls[0];
                            var ngModel = ctrls[1];
                            $select.generatedId = uiSelectConfig.generateId();
                            $select.baseTitle = attrs.title || 'Select box';
                            $select.focusserTitle = $select.baseTitle + ' focus';
                            $select.focusserId = 'focusser-' + $select.generatedId;
                            $select.closeOnSelect = function () {
                                if (angular.isDefined(attrs.closeOnSelect)) {
                                    return $parse(attrs.closeOnSelect)();
                                } else {
                                    return uiSelectConfig.closeOnSelect;
                                }
                            }();
                            scope.$watch('skipFocusser', function () {
                                var skipFocusser = scope.$eval(attrs.skipFocusser);
                                $select.skipFocusser = skipFocusser !== undefined ? skipFocusser : uiSelectConfig.skipFocusser;
                            });
                            $select.onSelectCallback = $parse(attrs.onSelect);
                            $select.onRemoveCallback = $parse(attrs.onRemove);
                            $select.limit = angular.isDefined(attrs.limit) ? parseInt(attrs.limit, 10) : undefined;
                            $select.ngModel = ngModel;
                            $select.choiceGrouped = function (group) {
                                return $select.isGrouped && group && group.name;
                            };
                            if (attrs.tabindex) {
                                attrs.$observe('tabindex', function (value) {
                                    $select.focusInput.attr('tabindex', value);
                                    element.removeAttr('tabindex');
                                });
                            }
                            scope.$watch('searchEnabled', function () {
                                var searchEnabled = scope.$eval(attrs.searchEnabled);
                                $select.searchEnabled = searchEnabled !== undefined ? searchEnabled : uiSelectConfig.searchEnabled;
                            });
                            scope.$watch('sortable', function () {
                                var sortable = scope.$eval(attrs.sortable);
                                $select.sortable = sortable !== undefined ? sortable : uiSelectConfig.sortable;
                            });
                            attrs.$observe('disabled', function () {
                                $select.disabled = attrs.disabled !== undefined ? attrs.disabled : false;
                            });
                            attrs.$observe('resetSearchInput', function () {
                                var resetSearchInput = scope.$eval(attrs.resetSearchInput);
                                $select.resetSearchInput = resetSearchInput !== undefined ? resetSearchInput : true;
                            });
                            attrs.$observe('paste', function () {
                                $select.paste = scope.$eval(attrs.paste);
                            });
                            attrs.$observe('tagging', function () {
                                if (attrs.tagging !== undefined) {
                                    var taggingEval = scope.$eval(attrs.tagging);
                                    $select.tagging = {
                                        isActivated: true,
                                        fct: taggingEval !== true ? taggingEval : undefined
                                    };
                                } else {
                                    $select.tagging = {
                                        isActivated: false,
                                        fct: undefined
                                    };
                                }
                            });
                            attrs.$observe('taggingLabel', function () {
                                if (attrs.tagging !== undefined) {
                                    if (attrs.taggingLabel === 'false') {
                                        $select.taggingLabel = false;
                                    } else {
                                        $select.taggingLabel = attrs.taggingLabel !== undefined ? attrs.taggingLabel : '(new)';
                                    }
                                }
                            });
                            attrs.$observe('taggingTokens', function () {
                                if (attrs.tagging !== undefined) {
                                    var tokens = attrs.taggingTokens !== undefined ? attrs.taggingTokens.split('|') : [
                                        ',',
                                        'ENTER'
                                    ];
                                    $select.taggingTokens = {
                                        isActivated: true,
                                        tokens: tokens
                                    };
                                }
                            });
                            if (angular.isDefined(attrs.autofocus)) {
                                $timeout(function () {
                                    $select.setFocus();
                                });
                            }
                            if (angular.isDefined(attrs.focusOn)) {
                                scope.$on(attrs.focusOn, function () {
                                    $timeout(function () {
                                        $select.setFocus();
                                    });
                                });
                            }
                            function onDocumentClick(e) {
                                if (!$select.open)
                                    return;
                                var contains = false;
                                if (window.jQuery) {
                                    contains = window.jQuery.contains(element[0], e.target);
                                } else {
                                    contains = element[0].contains(e.target);
                                }
                                if (!contains && !$select.clickTriggeredSelect) {
                                    var skipFocusser;
                                    if (!$select.skipFocusser) {
                                        var focusableControls = [
                                            'input',
                                            'button',
                                            'textarea',
                                            'select'
                                        ];
                                        var targetController = angular.element(e.target).controller('uiSelect');
                                        skipFocusser = targetController && targetController !== $select;
                                        if (!skipFocusser)
                                            skipFocusser = ~focusableControls.indexOf(e.target.tagName.toLowerCase());
                                    } else {
                                        skipFocusser = true;
                                    }
                                    $select.close(skipFocusser);
                                    scope.$digest();
                                }
                                $select.clickTriggeredSelect = false;
                            }
                            $document.on('click', onDocumentClick);
                            scope.$on('$destroy', function () {
                                $document.off('click', onDocumentClick);
                            });
                            transcludeFn(scope, function (clone) {
                                var transcluded = angular.element('<div>').append(clone);
                                var transcludedMatch = transcluded.querySelectorAll('.ui-select-match');
                                transcludedMatch.removeAttr('ui-select-match');
                                transcludedMatch.removeAttr('data-ui-select-match');
                                if (transcludedMatch.length !== 1) {
                                    throw uiSelectMinErr('transcluded', 'Expected 1 .ui-select-match but got \'{0}\'.', transcludedMatch.length);
                                }
                                element.querySelectorAll('.ui-select-match').replaceWith(transcludedMatch);
                                var transcludedChoices = transcluded.querySelectorAll('.ui-select-choices');
                                transcludedChoices.removeAttr('ui-select-choices');
                                transcludedChoices.removeAttr('data-ui-select-choices');
                                if (transcludedChoices.length !== 1) {
                                    throw uiSelectMinErr('transcluded', 'Expected 1 .ui-select-choices but got \'{0}\'.', transcludedChoices.length);
                                }
                                element.querySelectorAll('.ui-select-choices').replaceWith(transcludedChoices);
                            });
                            var appendToBody = scope.$eval(attrs.appendToBody);
                            if (appendToBody !== undefined ? appendToBody : uiSelectConfig.appendToBody) {
                                scope.$watch('$select.open', function (isOpen) {
                                    if (isOpen) {
                                        positionDropdown();
                                    } else {
                                        resetDropdown();
                                    }
                                });
                                scope.$on('$destroy', function () {
                                    resetDropdown();
                                });
                            }
                            var placeholder = null, originalWidth = '';
                            function positionDropdown() {
                                var offset = uisOffset(element);
                                placeholder = angular.element('<div class="ui-select-placeholder"></div>');
                                placeholder[0].style.width = offset.width + 'px';
                                placeholder[0].style.height = offset.height + 'px';
                                element.after(placeholder);
                                originalWidth = element[0].style.width;
                                $document.find('body').append(element);
                                element[0].style.position = 'absolute';
                                element[0].style.left = offset.left + 'px';
                                element[0].style.top = offset.top + 'px';
                                element[0].style.width = offset.width + 'px';
                            }
                            function resetDropdown() {
                                if (placeholder === null) {
                                    return;
                                }
                                placeholder.replaceWith(element);
                                placeholder = null;
                                element[0].style.position = '';
                                element[0].style.left = '';
                                element[0].style.top = '';
                                element[0].style.width = originalWidth;
                                $select.setFocus();
                            }
                            var dropdown = null, directionUpClassName = 'direction-up';
                            scope.$watch('$select.open', function () {
                                if ($select.dropdownPosition === 'auto' || $select.dropdownPosition === 'up') {
                                    scope.calculateDropdownPos();
                                }
                            });
                            var setDropdownPosUp = function (offset, offsetDropdown) {
                                offset = offset || uisOffset(element);
                                offsetDropdown = offsetDropdown || uisOffset(dropdown);
                                dropdown[0].style.position = 'absolute';
                                dropdown[0].style.top = offsetDropdown.height * -1 + 'px';
                                element.addClass(directionUpClassName);
                            };
                            var setDropdownPosDown = function (offset, offsetDropdown) {
                                element.removeClass(directionUpClassName);
                                offset = offset || uisOffset(element);
                                offsetDropdown = offsetDropdown || uisOffset(dropdown);
                                dropdown[0].style.position = '';
                                dropdown[0].style.top = '';
                            };
                            scope.calculateDropdownPos = function () {
                                if ($select.open) {
                                    dropdown = angular.element(element).querySelectorAll('.ui-select-dropdown');
                                    if (dropdown.length === 0) {
                                        return;
                                    }
                                    dropdown[0].style.opacity = 0;
                                    $timeout(function () {
                                        if ($select.dropdownPosition === 'up') {
                                            setDropdownPosUp();
                                        } else {
                                            element.removeClass(directionUpClassName);
                                            var offset = uisOffset(element);
                                            var offsetDropdown = uisOffset(dropdown);
                                            var scrollTop = $document[0].documentElement.scrollTop || $document[0].body.scrollTop;
                                            if (offset.top + offset.height + offsetDropdown.height > scrollTop + $document[0].documentElement.clientHeight) {
                                                setDropdownPosUp(offset, offsetDropdown);
                                            } else {
                                                setDropdownPosDown(offset, offsetDropdown);
                                            }
                                        }
                                        dropdown[0].style.opacity = 1;
                                    });
                                } else {
                                    if (dropdown === null || dropdown.length === 0) {
                                        return;
                                    }
                                    dropdown[0].style.position = '';
                                    dropdown[0].style.top = '';
                                    element.removeClass(directionUpClassName);
                                }
                            };
                        };
                    }
                };
            }
        ]);
        uis.directive('uiSelectMatch', [
            'uiSelectConfig',
            function (uiSelectConfig) {
                return {
                    restrict: 'EA',
                    require: '^uiSelect',
                    replace: true,
                    transclude: true,
                    templateUrl: function (tElement) {
                        tElement.addClass('ui-select-match');
                        var theme = tElement.parent().attr('theme') || uiSelectConfig.theme;
                        var multi = tElement.parent().attr('multiple');
                        return theme + (multi ? '/match-multiple.tpl.html' : '/match.tpl.html');
                    },
                    link: function (scope, element, attrs, $select) {
                        $select.lockChoiceExpression = attrs.uiLockChoice;
                        attrs.$observe('placeholder', function (placeholder) {
                            $select.placeholder = placeholder !== undefined ? placeholder : uiSelectConfig.placeholder;
                        });
                        function setAllowClear(allow) {
                            $select.allowClear = angular.isDefined(allow) ? allow === '' ? true : allow.toLowerCase() === 'true' : false;
                        }
                        attrs.$observe('allowClear', setAllowClear);
                        setAllowClear(attrs.allowClear);
                        if ($select.multiple) {
                            $select.sizeSearchInput();
                        }
                    }
                };
            }
        ]);
        uis.directive('uiSelectMultiple', [
            'uiSelectMinErr',
            '$timeout',
            function (uiSelectMinErr, $timeout) {
                return {
                    restrict: 'EA',
                    require: [
                        '^uiSelect',
                        '^ngModel'
                    ],
                    controller: [
                        '$scope',
                        '$timeout',
                        function ($scope, $timeout) {
                            var ctrl = this, $select = $scope.$select, ngModel;
                            if (angular.isUndefined($select.selected))
                                $select.selected = [];
                            $scope.$evalAsync(function () {
                                ngModel = $scope.ngModel;
                            });
                            ctrl.activeMatchIndex = -1;
                            ctrl.updateModel = function () {
                                ngModel.$setViewValue(Date.now());
                                ctrl.refreshComponent();
                            };
                            ctrl.refreshComponent = function () {
                                $select.refreshItems();
                                $select.sizeSearchInput();
                            };
                            ctrl.removeChoice = function (index) {
                                var removedChoice = $select.selected[index];
                                if (removedChoice._uiSelectChoiceLocked)
                                    return;
                                var locals = {};
                                locals[$select.parserResult.itemName] = removedChoice;
                                $select.selected.splice(index, 1);
                                ctrl.activeMatchIndex = -1;
                                $select.sizeSearchInput();
                                $timeout(function () {
                                    $select.onRemoveCallback($scope, {
                                        $item: removedChoice,
                                        $model: $select.parserResult.modelMapper($scope, locals)
                                    });
                                });
                                ctrl.updateModel();
                            };
                            ctrl.getPlaceholder = function () {
                                if ($select.selected && $select.selected.length)
                                    return;
                                return $select.placeholder;
                            };
                        }
                    ],
                    controllerAs: '$selectMultiple',
                    link: function (scope, element, attrs, ctrls) {
                        var $select = ctrls[0];
                        var ngModel = scope.ngModel = ctrls[1];
                        var $selectMultiple = scope.$selectMultiple;
                        $select.multiple = true;
                        $select.removeSelected = true;
                        $select.focusInput = $select.searchInput;
                        ngModel.$isEmpty = function (value) {
                            return !value || value.length === 0;
                        };
                        ngModel.$parsers.unshift(function () {
                            var locals = {}, result, resultMultiple = [];
                            for (var j = $select.selected.length - 1; j >= 0; j--) {
                                locals = {};
                                locals[$select.parserResult.itemName] = $select.selected[j];
                                result = $select.parserResult.modelMapper(scope, locals);
                                resultMultiple.unshift(result);
                            }
                            return resultMultiple;
                        });
                        ngModel.$formatters.unshift(function (inputValue) {
                            var data = $select.parserResult.source(scope, { $select: { search: '' } }), locals = {}, result;
                            if (!data)
                                return inputValue;
                            var resultMultiple = [];
                            var checkFnMultiple = function (list, value) {
                                if (!list || !list.length)
                                    return;
                                for (var p = list.length - 1; p >= 0; p--) {
                                    locals[$select.parserResult.itemName] = list[p];
                                    result = $select.parserResult.modelMapper(scope, locals);
                                    if ($select.parserResult.trackByExp) {
                                        var propsItemNameMatches = /(\w*)\./.exec($select.parserResult.trackByExp);
                                        var matches = /\.([^\s]+)/.exec($select.parserResult.trackByExp);
                                        if (propsItemNameMatches && propsItemNameMatches.length > 0 && propsItemNameMatches[1] == $select.parserResult.itemName) {
                                            if (matches && matches.length > 0 && result[matches[1]] == value[matches[1]]) {
                                                resultMultiple.unshift(list[p]);
                                                return true;
                                            }
                                        }
                                    }
                                    if (angular.equals(result, value)) {
                                        resultMultiple.unshift(list[p]);
                                        return true;
                                    }
                                }
                                return false;
                            };
                            if (!inputValue)
                                return resultMultiple;
                            for (var k = inputValue.length - 1; k >= 0; k--) {
                                if (!checkFnMultiple($select.selected, inputValue[k])) {
                                    if (!checkFnMultiple(data, inputValue[k])) {
                                        resultMultiple.unshift(inputValue[k]);
                                    }
                                }
                            }
                            return resultMultiple;
                        });
                        scope.$watchCollection(function () {
                            return ngModel.$modelValue;
                        }, function (newValue, oldValue) {
                            if (oldValue != newValue) {
                                ngModel.$modelValue = null;
                                $selectMultiple.refreshComponent();
                            }
                        });
                        ngModel.$render = function () {
                            if (!angular.isArray(ngModel.$viewValue)) {
                                if (angular.isUndefined(ngModel.$viewValue) || ngModel.$viewValue === null) {
                                    $select.selected = [];
                                } else {
                                    throw uiSelectMinErr('multiarr', 'Expected model value to be array but got \'{0}\'', ngModel.$viewValue);
                                }
                            }
                            $select.selected = ngModel.$viewValue;
                            $selectMultiple.refreshComponent();
                            scope.$evalAsync();
                        };
                        scope.$on('uis:select', function (event, item) {
                            if ($select.selected.length >= $select.limit) {
                                return;
                            }
                            $select.selected.push(item);
                            $selectMultiple.updateModel();
                        });
                        scope.$on('uis:activate', function () {
                            $selectMultiple.activeMatchIndex = -1;
                        });
                        scope.$watch('$select.disabled', function (newValue, oldValue) {
                            if (oldValue && !newValue)
                                $select.sizeSearchInput();
                        });
                        $select.searchInput.on('keydown', function (e) {
                            var key = e.which;
                            scope.$apply(function () {
                                var processed = false;
                                if (KEY.isHorizontalMovement(key)) {
                                    processed = _handleMatchSelection(key);
                                }
                                if (processed && key != KEY.TAB) {
                                    e.preventDefault();
                                    e.stopPropagation();
                                }
                            });
                        });
                        function _getCaretPosition(el) {
                            if (angular.isNumber(el.selectionStart))
                                return el.selectionStart;
                            else
                                return el.value.length;
                        }
                        function _handleMatchSelection(key) {
                            var caretPosition = _getCaretPosition($select.searchInput[0]), length = $select.selected.length, first = 0, last = length - 1, curr = $selectMultiple.activeMatchIndex, next = $selectMultiple.activeMatchIndex + 1, prev = $selectMultiple.activeMatchIndex - 1, newIndex = curr;
                            if (caretPosition > 0 || $select.search.length && key == KEY.RIGHT)
                                return false;
                            $select.close();
                            function getNewActiveMatchIndex() {
                                switch (key) {
                                case KEY.LEFT:
                                    if (~$selectMultiple.activeMatchIndex)
                                        return prev;
                                    else
                                        return last;
                                    break;
                                case KEY.RIGHT:
                                    if (!~$selectMultiple.activeMatchIndex || curr === last) {
                                        $select.activate();
                                        return false;
                                    } else
                                        return next;
                                    break;
                                case KEY.BACKSPACE:
                                    if (~$selectMultiple.activeMatchIndex) {
                                        $selectMultiple.removeChoice(curr);
                                        return prev;
                                    } else
                                        return last;
                                    break;
                                case KEY.DELETE:
                                    if (~$selectMultiple.activeMatchIndex) {
                                        $selectMultiple.removeChoice($selectMultiple.activeMatchIndex);
                                        return curr;
                                    } else
                                        return false;
                                }
                            }
                            newIndex = getNewActiveMatchIndex();
                            if (!$select.selected.length || newIndex === false)
                                $selectMultiple.activeMatchIndex = -1;
                            else
                                $selectMultiple.activeMatchIndex = Math.min(last, Math.max(first, newIndex));
                            return true;
                        }
                        $select.searchInput.on('keyup', function (e) {
                            if (!KEY.isVerticalMovement(e.which)) {
                                scope.$evalAsync(function () {
                                    $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
                                });
                            }
                            if ($select.tagging.isActivated && $select.search.length > 0) {
                                if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || KEY.isVerticalMovement(e.which)) {
                                    return;
                                }
                                $select.activeIndex = $select.taggingLabel === false ? -1 : 0;
                                if ($select.taggingLabel === false)
                                    return;
                                var items = angular.copy($select.items);
                                var stashArr = angular.copy($select.items);
                                var newItem;
                                var item;
                                var hasTag = false;
                                var dupeIndex = -1;
                                var tagItems;
                                var tagItem;
                                if ($select.tagging.fct !== undefined) {
                                    tagItems = $select.$filter('filter')(items, { 'isTag': true });
                                    if (tagItems.length > 0) {
                                        tagItem = tagItems[0];
                                    }
                                    if (items.length > 0 && tagItem) {
                                        hasTag = true;
                                        items = items.slice(1, items.length);
                                        stashArr = stashArr.slice(1, stashArr.length);
                                    }
                                    newItem = $select.tagging.fct($select.search);
                                    if (stashArr.some(function (origItem) {
                                            return angular.equals(origItem, $select.tagging.fct($select.search));
                                        }) || $select.selected.some(function (origItem) {
                                            return angular.equals(origItem, newItem);
                                        })) {
                                        scope.$evalAsync(function () {
                                            $select.activeIndex = 0;
                                            $select.items = items;
                                        });
                                        return;
                                    }
                                    newItem.isTag = true;
                                } else {
                                    tagItems = $select.$filter('filter')(items, function (item) {
                                        return item.match($select.taggingLabel);
                                    });
                                    if (tagItems.length > 0) {
                                        tagItem = tagItems[0];
                                    }
                                    item = items[0];
                                    if (item !== undefined && items.length > 0 && tagItem) {
                                        hasTag = true;
                                        items = items.slice(1, items.length);
                                        stashArr = stashArr.slice(1, stashArr.length);
                                    }
                                    newItem = $select.search + ' ' + $select.taggingLabel;
                                    if (_findApproxDupe($select.selected, $select.search) > -1) {
                                        return;
                                    }
                                    if (_findCaseInsensitiveDupe(stashArr.concat($select.selected))) {
                                        if (hasTag) {
                                            items = stashArr;
                                            scope.$evalAsync(function () {
                                                $select.activeIndex = 0;
                                                $select.items = items;
                                            });
                                        }
                                        return;
                                    }
                                    if (_findCaseInsensitiveDupe(stashArr)) {
                                        if (hasTag) {
                                            $select.items = stashArr.slice(1, stashArr.length);
                                        }
                                        return;
                                    }
                                }
                                if (hasTag)
                                    dupeIndex = _findApproxDupe($select.selected, newItem);
                                if (dupeIndex > -1) {
                                    items = items.slice(dupeIndex + 1, items.length - 1);
                                } else {
                                    items = [];
                                    items.push(newItem);
                                    items = items.concat(stashArr);
                                }
                                scope.$evalAsync(function () {
                                    $select.activeIndex = 0;
                                    $select.items = items;
                                });
                            }
                        });
                        function _findCaseInsensitiveDupe(arr) {
                            if (arr === undefined || $select.search === undefined) {
                                return false;
                            }
                            var hasDupe = arr.filter(function (origItem) {
                                if ($select.search.toUpperCase() === undefined || origItem === undefined) {
                                    return false;
                                }
                                return origItem.toUpperCase() === $select.search.toUpperCase();
                            }).length > 0;
                            return hasDupe;
                        }
                        function _findApproxDupe(haystack, needle) {
                            var dupeIndex = -1;
                            if (angular.isArray(haystack)) {
                                var tempArr = angular.copy(haystack);
                                for (var i = 0; i < tempArr.length; i++) {
                                    if ($select.tagging.fct === undefined) {
                                        if (tempArr[i] + ' ' + $select.taggingLabel === needle) {
                                            dupeIndex = i;
                                        }
                                    } else {
                                        var mockObj = tempArr[i];
                                        if (angular.isObject(mockObj)) {
                                            mockObj.isTag = true;
                                        }
                                        if (angular.equals(mockObj, needle)) {
                                            dupeIndex = i;
                                        }
                                    }
                                }
                            }
                            return dupeIndex;
                        }
                        $select.searchInput.on('blur', function () {
                            $timeout(function () {
                                $selectMultiple.activeMatchIndex = -1;
                            });
                        });
                    }
                };
            }
        ]);
        uis.directive('uiSelectSingle', [
            '$timeout',
            '$compile',
            function ($timeout, $compile) {
                return {
                    restrict: 'EA',
                    require: [
                        '^uiSelect',
                        '^ngModel'
                    ],
                    link: function (scope, element, attrs, ctrls) {
                        var $select = ctrls[0];
                        var ngModel = ctrls[1];
                        ngModel.$parsers.unshift(function (inputValue) {
                            var locals = {}, result;
                            locals[$select.parserResult.itemName] = inputValue;
                            result = $select.parserResult.modelMapper(scope, locals);
                            return result;
                        });
                        ngModel.$formatters.unshift(function (inputValue) {
                            var data = $select.parserResult.source(scope, { $select: { search: '' } }), locals = {}, result;
                            if (data) {
                                var checkFnSingle = function (d) {
                                    locals[$select.parserResult.itemName] = d;
                                    result = $select.parserResult.modelMapper(scope, locals);
                                    return result == inputValue;
                                };
                                if ($select.selected && checkFnSingle($select.selected)) {
                                    return $select.selected;
                                }
                                for (var i = data.length - 1; i >= 0; i--) {
                                    if (checkFnSingle(data[i]))
                                        return data[i];
                                }
                            }
                            return inputValue;
                        });
                        scope.$watch('$select.selected', function (newValue) {
                            if (ngModel.$viewValue !== newValue) {
                                ngModel.$setViewValue(newValue);
                            }
                        });
                        ngModel.$render = function () {
                            $select.selected = ngModel.$viewValue;
                        };
                        scope.$on('uis:select', function (event, item) {
                            $select.selected = item;
                        });
                        scope.$on('uis:close', function (event, skipFocusser) {
                            $timeout(function () {
                                $select.focusser.prop('disabled', false);
                                if (!skipFocusser)
                                    $select.focusser[0].focus();
                            }, 0, false);
                        });
                        scope.$on('uis:activate', function () {
                            focusser.prop('disabled', true);
                        });
                        var focusser = angular.element('<input ng-disabled=\'$select.disabled\' class=\'ui-select-focusser ui-select-offscreen\' type=\'text\' id=\'{{ $select.focusserId }}\' aria-label=\'{{ $select.focusserTitle }}\' aria-haspopup=\'true\' role=\'button\' />');
                        $compile(focusser)(scope);
                        $select.focusser = focusser;
                        $select.focusInput = focusser;
                        element.parent().append(focusser);
                        focusser.bind('focus', function () {
                            scope.$evalAsync(function () {
                                $select.focus = true;
                            });
                        });
                        focusser.bind('blur', function () {
                            scope.$evalAsync(function () {
                                $select.focus = false;
                            });
                        });
                        focusser.bind('keydown', function (e) {
                            if (e.which === KEY.BACKSPACE) {
                                e.preventDefault();
                                e.stopPropagation();
                                $select.select(undefined);
                                scope.$apply();
                                return;
                            }
                            if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC) {
                                return;
                            }
                            if (e.which == KEY.DOWN || e.which == KEY.UP || e.which == KEY.ENTER || e.which == KEY.SPACE) {
                                e.preventDefault();
                                e.stopPropagation();
                                $select.activate();
                            }
                            scope.$digest();
                        });
                        focusser.bind('keyup input', function (e) {
                            if (e.which === KEY.TAB || KEY.isControl(e) || KEY.isFunctionKey(e) || e.which === KEY.ESC || e.which == KEY.ENTER || e.which === KEY.BACKSPACE) {
                                return;
                            }
                            $select.activate(focusser.val());
                            focusser.val('');
                            scope.$digest();
                        });
                    }
                };
            }
        ]);
        uis.directive('uiSelectSort', [
            '$timeout',
            'uiSelectConfig',
            'uiSelectMinErr',
            function ($timeout, uiSelectConfig, uiSelectMinErr) {
                return {
                    require: '^^uiSelect',
                    link: function (scope, element, attrs, $select) {
                        if (scope[attrs.uiSelectSort] === null) {
                            throw uiSelectMinErr('sort', 'Expected a list to sort');
                        }
                        var options = angular.extend({ axis: 'horizontal' }, scope.$eval(attrs.uiSelectSortOptions));
                        var axis = options.axis;
                        var draggingClassName = 'dragging';
                        var droppingClassName = 'dropping';
                        var droppingBeforeClassName = 'dropping-before';
                        var droppingAfterClassName = 'dropping-after';
                        scope.$watch(function () {
                            return $select.sortable;
                        }, function (newValue) {
                            if (newValue) {
                                element.attr('draggable', true);
                            } else {
                                element.removeAttr('draggable');
                            }
                        });
                        element.on('dragstart', function (event) {
                            element.addClass(draggingClassName);
                            (event.dataTransfer || event.originalEvent.dataTransfer).setData('text', scope.$index.toString());
                        });
                        element.on('dragend', function () {
                            element.removeClass(draggingClassName);
                        });
                        var move = function (from, to) {
                            this.splice(to, 0, this.splice(from, 1)[0]);
                        };
                        var dragOverHandler = function (event) {
                            event.preventDefault();
                            var offset = axis === 'vertical' ? event.offsetY || event.layerY || (event.originalEvent ? event.originalEvent.offsetY : 0) : event.offsetX || event.layerX || (event.originalEvent ? event.originalEvent.offsetX : 0);
                            if (offset < this[axis === 'vertical' ? 'offsetHeight' : 'offsetWidth'] / 2) {
                                element.removeClass(droppingAfterClassName);
                                element.addClass(droppingBeforeClassName);
                            } else {
                                element.removeClass(droppingBeforeClassName);
                                element.addClass(droppingAfterClassName);
                            }
                        };
                        var dropTimeout;
                        var dropHandler = function (event) {
                            event.preventDefault();
                            var droppedItemIndex = parseInt((event.dataTransfer || event.originalEvent.dataTransfer).getData('text'), 10);
                            $timeout.cancel(dropTimeout);
                            dropTimeout = $timeout(function () {
                                _dropHandler(droppedItemIndex);
                            }, 20);
                        };
                        var _dropHandler = function (droppedItemIndex) {
                            var theList = scope.$eval(attrs.uiSelectSort);
                            var itemToMove = theList[droppedItemIndex];
                            var newIndex = null;
                            if (element.hasClass(droppingBeforeClassName)) {
                                if (droppedItemIndex < scope.$index) {
                                    newIndex = scope.$index - 1;
                                } else {
                                    newIndex = scope.$index;
                                }
                            } else {
                                if (droppedItemIndex < scope.$index) {
                                    newIndex = scope.$index;
                                } else {
                                    newIndex = scope.$index + 1;
                                }
                            }
                            move.apply(theList, [
                                droppedItemIndex,
                                newIndex
                            ]);
                            scope.$apply(function () {
                                scope.$emit('uiSelectSort:change', {
                                    array: theList,
                                    item: itemToMove,
                                    from: droppedItemIndex,
                                    to: newIndex
                                });
                            });
                            element.removeClass(droppingClassName);
                            element.removeClass(droppingBeforeClassName);
                            element.removeClass(droppingAfterClassName);
                            element.off('drop', dropHandler);
                        };
                        element.on('dragenter', function () {
                            if (element.hasClass(draggingClassName)) {
                                return;
                            }
                            element.addClass(droppingClassName);
                            element.on('dragover', dragOverHandler);
                            element.on('drop', dropHandler);
                        });
                        element.on('dragleave', function (event) {
                            if (event.target != element) {
                                return;
                            }
                            element.removeClass(droppingClassName);
                            element.removeClass(droppingBeforeClassName);
                            element.removeClass(droppingAfterClassName);
                            element.off('dragover', dragOverHandler);
                            element.off('drop', dropHandler);
                        });
                    }
                };
            }
        ]);
        uis.service('uisRepeatParser', [
            'uiSelectMinErr',
            '$parse',
            function (uiSelectMinErr, $parse) {
                var self = this;
                self.parse = function (expression) {
                    var match;
                    match = expression.match(/^\s*(?:([\s\S]+?)\s+as\s+)?(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+(\s*[\s\S]+?)?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                    if (!match) {
                        throw uiSelectMinErr('iexp', 'Expected expression in form of \'_item_ in _collection_[ track by _id_]\' but got \'{0}\'.', expression);
                    }
                    var source = match[5], filters = '';
                    if (match[3]) {
                        source = match[5].replace(/(^\()|(\)$)/g, '');
                        var filterMatch = match[5].match(/^\s*(?:[\s\S]+?)(?:[^\|]|\|\|)+([\s\S]*)\s*$/);
                        if (filterMatch && filterMatch[1].trim()) {
                            filters = filterMatch[1];
                            source = source.replace(filters, '');
                        }
                    }
                    return {
                        itemName: match[4] || match[2],
                        keyName: match[3],
                        source: $parse(source),
                        filters: filters,
                        trackByExp: match[6],
                        modelMapper: $parse(match[1] || match[4] || match[2]),
                        repeatExpression: function (grouped) {
                            var expression = this.itemName + ' in ' + (grouped ? '$group.items' : '$select.items');
                            if (this.trackByExp) {
                                expression += ' track by ' + this.trackByExp;
                            }
                            return expression;
                        }
                    };
                };
                self.getGroupNgRepeatExpression = function () {
                    return '$group in $select.groups';
                };
            }
        ]);
    }());
    angular.module('ui.select').run([
        '$templateCache',
        function ($templateCache) {
            $templateCache.put('bootstrap/choices.tpl.html', '<ul class="ui-select-choices ui-select-choices-content ui-select-dropdown dropdown-menu" role="listbox" ng-show="$select.open"><li class="ui-select-choices-group" id="ui-select-choices-{{ $select.generatedId }}"><div class="divider" ng-show="$select.isGrouped && $index > 0"></div><div ng-show="$select.isGrouped" class="ui-select-choices-group-label dropdown-header" ng-bind="$group.name"></div><div id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}" role="option"><a href="" class="ui-select-choices-row-inner"></a></div></li></ul>');
            $templateCache.put('bootstrap/match-multiple.tpl.html', '<span class="ui-select-match"><span ng-repeat="$item in $select.selected"><span class="ui-select-match-item btn btn-default btn-xs" tabindex="-1" type="button" ng-disabled="$select.disabled" ng-click="$selectMultiple.activeMatchIndex = $index;" ng-class="{\'btn-primary\':$selectMultiple.activeMatchIndex === $index, \'select-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span class="close ui-select-match-close" ng-hide="$select.disabled" ng-click="$selectMultiple.removeChoice($index)">&nbsp;&times;</span> <span uis-transclude-append=""></span></span></span></span>');
            $templateCache.put('bootstrap/match.tpl.html', '<div class="ui-select-match" ng-hide="$select.open" ng-disabled="$select.disabled" ng-class="{\'btn-default-focus\':$select.focus}"><span tabindex="-1" class="btn btn-default form-control ui-select-toggle" aria-label="{{ $select.baseTitle }} activate" ng-disabled="$select.disabled" ng-click="$select.activate()" style="outline: 0;"><span ng-show="$select.isEmpty()" class="ui-select-placeholder text-muted">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="ui-select-match-text pull-left" ng-class="{\'ui-select-allow-clear\': $select.allowClear && !$select.isEmpty()}" ng-transclude=""></span> <i class="caret pull-right" ng-click="$select.toggle($event)"></i> <a ng-show="$select.allowClear && !$select.isEmpty()" aria-label="{{ $select.baseTitle }} clear" style="margin-right: 10px" ng-click="$select.clear($event)" class="btn btn-xs btn-link pull-right"><i class="glyphicon glyphicon-remove" aria-hidden="true"></i></a></span></div>');
            $templateCache.put('bootstrap/select-multiple.tpl.html', '<div class="ui-select-container ui-select-multiple ui-select-bootstrap dropdown form-control" ng-class="{open: $select.open}"><div><div class="ui-select-match"></div><input type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" class="ui-select-search input-xs" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-click="$select.activate()" ng-model="$select.search" role="combobox" aria-label="{{ $select.baseTitle }}" ondrop="return false;"></div><div class="ui-select-choices"></div></div>');
            $templateCache.put('bootstrap/select.tpl.html', '<div class="ui-select-container ui-select-bootstrap dropdown" ng-class="{open: $select.open}"><div class="ui-select-match"></div><input type="text" autocomplete="off" tabindex="-1" aria-expanded="true" aria-label="{{ $select.baseTitle }}" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="form-control ui-select-search" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-show="$select.searchEnabled && $select.open"><div class="ui-select-choices"></div></div>');
            $templateCache.put('select2/choices.tpl.html', '<ul class="ui-select-choices ui-select-choices-content select2-results"><li class="ui-select-choices-group" ng-class="{\'select2-result-with-children\': $select.choiceGrouped($group) }"><div ng-show="$select.choiceGrouped($group)" class="ui-select-choices-group-label select2-result-label" ng-bind="$group.name"></div><ul role="listbox" id="ui-select-choices-{{ $select.generatedId }}" ng-class="{\'select2-result-sub\': $select.choiceGrouped($group), \'select2-result-single\': !$select.choiceGrouped($group) }"><li role="option" id="ui-select-choices-row-{{ $select.generatedId }}-{{$index}}" class="ui-select-choices-row" ng-class="{\'select2-highlighted\': $select.isActive(this), \'select2-disabled\': $select.isDisabled(this)}"><div class="select2-result-label ui-select-choices-row-inner"></div></li></ul></li></ul>');
            $templateCache.put('select2/match-multiple.tpl.html', '<span class="ui-select-match"><li class="ui-select-match-item select2-search-choice" ng-repeat="$item in $select.selected" ng-class="{\'select2-search-choice-focus\':$selectMultiple.activeMatchIndex === $index, \'select2-locked\':$select.isLocked(this, $index)}" ui-select-sort="$select.selected"><span uis-transclude-append=""></span> <a href="javascript:;" class="ui-select-match-close select2-search-choice-close" ng-click="$selectMultiple.removeChoice($index)" tabindex="-1"></a></li></span>');
            $templateCache.put('select2/match.tpl.html', '<a class="select2-choice ui-select-match" ng-class="{\'select2-default\': $select.isEmpty()}" ng-click="$select.toggle($event)" aria-label="{{ $select.baseTitle }} select"><span ng-show="$select.isEmpty()" class="select2-chosen">{{$select.placeholder}}</span> <span ng-hide="$select.isEmpty()" class="select2-chosen" ng-transclude=""></span> <abbr ng-if="$select.allowClear && !$select.isEmpty()" class="select2-search-choice-close" ng-click="$select.clear($event)"></abbr> <span class="select2-arrow ui-select-toggle"><b></b></span></a>');
            $templateCache.put('select2/select-multiple.tpl.html', '<div class="ui-select-container ui-select-multiple select2 select2-container select2-container-multi" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled}"><ul class="select2-choices"><span class="ui-select-match"></span><li class="select2-search-field"><input type="text" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="select2-input ui-select-search" placeholder="{{$selectMultiple.getPlaceholder()}}" ng-disabled="$select.disabled" ng-hide="$select.disabled" ng-model="$select.search" ng-click="$select.activate()" style="width: 34px;" ondrop="return false;"></li></ul><div class="ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="ui-select-choices"></div></div></div>');
            $templateCache.put('select2/select.tpl.html', '<div class="ui-select-container select2 select2-container" ng-class="{\'select2-container-active select2-dropdown-open open\': $select.open, \'select2-container-disabled\': $select.disabled, \'select2-container-active\': $select.focus, \'select2-allowclear\': $select.allowClear && !$select.isEmpty()}"><div class="ui-select-match"></div><div class="ui-select-dropdown select2-drop select2-with-searchbox select2-drop-active" ng-class="{\'select2-display-none\': !$select.open}"><div class="select2-search" ng-show="$select.searchEnabled"><input type="text" autocomplete="off" autocorrect="false" autocapitalize="off" spellcheck="false" role="combobox" aria-expanded="true" aria-owns="ui-select-choices-{{ $select.generatedId }}" aria-label="{{ $select.baseTitle }}" aria-activedescendant="ui-select-choices-row-{{ $select.generatedId }}-{{ $select.activeIndex }}" class="ui-select-search select2-input" ng-model="$select.search"></div><div class="ui-select-choices"></div></div></div>');
            $templateCache.put('selectize/choices.tpl.html', '<div ng-show="$select.open" class="ui-select-choices ui-select-dropdown selectize-dropdown single"><div class="ui-select-choices-content selectize-dropdown-content"><div class="ui-select-choices-group optgroup" role="listbox"><div ng-show="$select.isGrouped" class="ui-select-choices-group-label optgroup-header" ng-bind="$group.name"></div><div role="option" class="ui-select-choices-row" ng-class="{active: $select.isActive(this), disabled: $select.isDisabled(this)}"><div class="option ui-select-choices-row-inner" data-selectable=""></div></div></div></div></div>');
            $templateCache.put('selectize/match.tpl.html', '<div ng-hide="($select.open || $select.isEmpty())" class="ui-select-match" ng-transclude=""></div>');
            $templateCache.put('selectize/select.tpl.html', '<div class="ui-select-container selectize-control single" ng-class="{\'open\': $select.open}"><div class="selectize-input" ng-class="{\'focus\': $select.open, \'disabled\': $select.disabled, \'selectize-focus\' : $select.focus}" ng-click="$select.open && !$select.searchEnabled ? $select.toggle($event) : $select.activate()"><div class="ui-select-match"></div><input type="text" autocomplete="off" tabindex="-1" class="ui-select-search ui-select-toggle" ng-click="$select.toggle($event)" placeholder="{{$select.placeholder}}" ng-model="$select.search" ng-hide="!$select.searchEnabled || ($select.selected && !$select.open)" ng-disabled="$select.disabled" aria-label="{{ $select.baseTitle }}"></div><div class="ui-select-choices"></div></div>');
        }
    ]);
    return;
});
define('ngNumberic', ['angular'], function () {
    (function () {
        'use strict';
        angular.module('purplefox.numeric', []).directive('numeric', numeric);
        numeric.$inject = ['$locale'];
        function numeric($locale) {
            var directive = {
                link: link,
                require: 'ngModel',
                restrict: 'A'
            };
            return directive;
            function link(scope, el, attrs, ngModelCtrl) {
                var decimalSeparator = $locale.NUMBER_FORMATS.DECIMAL_SEP;
                var groupSeparator = $locale.NUMBER_FORMATS.GROUP_SEP;
                var NUMBER_REGEXP = '^\\s*(\\-|\\+)?(\\d+|(\\d*(\\.\\d*)))\\s*$';
                var regex = new RegExp(NUMBER_REGEXP);
                var formatting = true;
                var maxInputLength = 16;
                var max;
                var min;
                var decimals = 2;
                var lastValidValue;
                ngModelCtrl.$parsers.push(parseViewValue);
                ngModelCtrl.$parsers.push(minValidator);
                ngModelCtrl.$parsers.push(maxValidator);
                ngModelCtrl.$formatters.push(formatViewValue);
                el.bind('blur', onBlur);
                el.bind('focus', onFocus);
                scope.$watch(attrs.min, onMinChanged);
                scope.$watch(attrs.max, onMaxChanged);
                scope.$watch(attrs.decimals, onDecimalsChanged);
                scope.$watch(attrs.formatting, onFormattingChanged);
                if (decimals > -1) {
                    ngModelCtrl.$parsers.push(function (value) {
                        return value ? round(value) : value;
                    });
                    ngModelCtrl.$formatters.push(function (value) {
                        return value ? formatPrecision(value) : value;
                    });
                }
                function onMinChanged(value) {
                    if (!angular.isUndefined(value)) {
                        min = parseFloat(value);
                        lastValidValue = minValidator(ngModelCtrl.$modelValue);
                        ngModelCtrl.$setViewValue(formatPrecision(lastValidValue));
                        ngModelCtrl.$render();
                    }
                }
                function onMaxChanged(value) {
                    if (!angular.isUndefined(value)) {
                        max = parseFloat(value);
                        maxInputLength = calculateMaxLength(max);
                        lastValidValue = maxValidator(ngModelCtrl.$modelValue);
                        ngModelCtrl.$setViewValue(formatPrecision(lastValidValue));
                        ngModelCtrl.$render();
                    }
                }
                function onDecimalsChanged(value) {
                    if (!angular.isUndefined(value)) {
                        decimals = parseFloat(value);
                        maxInputLength = calculateMaxLength(max);
                        if (lastValidValue !== undefined) {
                            ngModelCtrl.$setViewValue(formatPrecision(lastValidValue));
                            ngModelCtrl.$render();
                        }
                    }
                }
                function onFormattingChanged(value) {
                    if (!angular.isUndefined(value)) {
                        formatting = value !== false;
                        ngModelCtrl.$setViewValue(formatPrecision(lastValidValue));
                        ngModelCtrl.$render();
                    }
                }
                function round(value) {
                    var d = Math.pow(10, decimals);
                    return Math.round(value * d) / d;
                }
                function numberWithCommas(value) {
                    if (formatting) {
                        var parts = value.toString().split(decimalSeparator);
                        parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, groupSeparator);
                        return parts.join(decimalSeparator);
                    } else {
                        return value;
                    }
                }
                function formatPrecision(value) {
                    if (!(value || value === 0)) {
                        return '';
                    }
                    var formattedValue = parseFloat(value).toFixed(decimals);
                    formattedValue = formattedValue.replace('.', decimalSeparator);
                    return numberWithCommas(formattedValue);
                }
                function formatViewValue(value) {
                    return ngModelCtrl.$isEmpty(value) ? '' : '' + value;
                }
                function parseViewValue(value) {
                    if (angular.isUndefined(value)) {
                        value = '';
                    }
                    value = value.toString().replace(decimalSeparator, '.');
                    if (value.indexOf('.') === 0) {
                        value = '0' + value;
                    }
                    if (value.indexOf('-') === 0) {
                        if (min >= 0) {
                            value = null;
                            ngModelCtrl.$setViewValue(formatViewValue(lastValidValue));
                            ngModelCtrl.$render();
                        } else if (value === '-') {
                            value = '';
                        }
                    }
                    var empty = ngModelCtrl.$isEmpty(value);
                    if (empty) {
                        lastValidValue = '';
                    } else {
                        if (regex.test(value) && value.length <= maxInputLength) {
                            if (value > max) {
                                lastValidValue = max;
                            } else if (value < min) {
                                lastValidValue = min;
                            } else {
                                lastValidValue = value === '' ? null : parseFloat(value);
                            }
                        } else {
                            ngModelCtrl.$setViewValue(formatViewValue(lastValidValue));
                            ngModelCtrl.$render();
                        }
                    }
                    return lastValidValue;
                }
                function calculateMaxLength(value) {
                    var length = 16;
                    if (!angular.isUndefined(value)) {
                        length = Math.floor(value).toString().length;
                    }
                    if (decimals > 0) {
                        length += decimals + 1;
                    }
                    if (min < 0) {
                        length++;
                    }
                    return length;
                }
                function minValidator(value) {
                    if (!angular.isUndefined(min)) {
                        if (!ngModelCtrl.$isEmpty(value) && value < min) {
                            return min;
                        } else {
                            return value;
                        }
                    } else {
                        return value;
                    }
                }
                function maxValidator(value) {
                    if (!angular.isUndefined(max)) {
                        if (!ngModelCtrl.$isEmpty(value) && value > max) {
                            return max;
                        } else {
                            return value;
                        }
                    } else {
                        return value;
                    }
                }
                function onBlur() {
                    var value = ngModelCtrl.$modelValue;
                    if (!angular.isUndefined(value)) {
                        ngModelCtrl.$viewValue = formatPrecision(value);
                        ngModelCtrl.$render();
                    }
                }
                function onFocus() {
                    var value = ngModelCtrl.$modelValue;
                    if (!angular.isUndefined(value)) {
                        ngModelCtrl.$viewValue = value.toString().replace('.', decimalSeparator);
                        ngModelCtrl.$render();
                    }
                }
            }
        }
    }());
    return;
});
(function () {
    define('app', [
        'angular',
        'bootstrap',
        'ngAnimate',
        'uiRoute',
        'ngDialog',
        'ngSelect',
        'ui-bootstrap-tpls',
        'ngNumberic',
        'angular'
    ], function (angular) {
        'use strict';
        var module = angular.module('tfcalculator', [
            'ngAnimate',
            'ui.router',
            'ngDialog',
            'ui.select',
            'ui.bootstrap',
            'purplefox.numeric'
        ]).constant('servicePathConst', {
            ws_root: 'http://localhost:1337/dataPush',
            service_api_root: location.pathname + '/../../../tf/calculator',
            get_futures_contract_list: '/initial',
            post_futures_contract_list_by_tfId: '/initial/tfId',
            post_update_futures_price: '/futurePrice',
            post_do_calculator: '/param',
            post_yieldType_update: '/yieldType',
            post_bond_search: '/bond',
            post_bond_update: '/bondUpdate'
        });
        console.log('angular.module: tfcalculator created.');
        return module;
    });
}.call(this));
define('directiveUtilService', [
    'angular',
    'app'
], function (angular, appModule) {
    'use strict';
    appModule.service('directiveUtilService', [function () {
            this.check = function (name, element, targerNodeName) {
                if (!element[0] || element[0].nodeName !== targerNodeName) {
                    console.error('{0} only for element \'{1}\'.'.format(name, targerNodeName));
                    return false;
                }
                if (!$) {
                    console.error('{0}: jquery is not loaded.'.format(name));
                    return false;
                }
                if (!element.before) {
                    console.error('{0}: jquery must be loaded before angularJs.'.format(name));
                    return false;
                }
                return true;
            };
        }]);
});
define('percentFilter', [
    'angular',
    'app',
    'jquery',
    'directiveUtilService'
], function (angular, appModule) {
    appModule.filter('percentFilter', [
        '$filter',
        function ($filter) {
            var numberFilter = $filter('number');
            return function (number, symbol) {
                var value = undefined;
                try {
                    value = parseFloat(number);
                } catch (e) {
                    return '';
                }
                if (!value && value !== 0)
                    return '';
                var sym = symbol ? '%' : '';
                return numberFilter(value * 100, 4).toString() + sym;
            };
        }
    ]);
});
define('currencyUnitFilter', [
    'angular',
    'app',
    'jquery',
    'directiveUtilService'
], function (angular, appModule) {
    appModule.filter('currencyUnitFilter', [
        '$filter',
        function ($filter) {
            var currencyFilter = $filter('currency');
            return function (number) {
                var value = +number;
                if (!value && value !== 0)
                    return number + ' 元';
                if (value >= Math.pow(10, 8))
                    return currencyFilter(number * Math.pow(10, -8), '') + ' 亿元';
                if (value >= Math.pow(10, 4))
                    return currencyFilter(number * Math.pow(10, -4), '') + ' 万元';
                return currencyFilter(number, '') + ' 元';
            };
        }
    ]);
});
(function () {
    String.prototype.startWith = function (str) {
        var reg = new RegExp('^' + str);
        return reg.test(this);
    };
    String.prototype.endWith = function (str) {
        var reg = new RegExp(str + '$');
        return reg.test(this);
    };
    String.prototype.isNullOrWhitespace = function () {
        return this.length === 0 || this.replace(/\s+?/).length === 0;
    };
    String.prototype.format = function () {
        var args = arguments;
        return this.replace(/\{(\d+)\}/g, function (m, i) {
            return args[i];
        });
    };
}());
define('StringUtils', [], function () {
    return;
});
(function () {
    define('customSelect0Directive', [
        'angular',
        'app',
        'jquery',
        'directiveUtilService',
        'StringUtils'
    ], function (angular, appModule) {
        appModule.directive('customSelect0Directive', [
            '$sce',
            'directiveUtilService',
            function ($sce, directiveUtilService) {
                var seq = 0;
                var pointStr = '{0},{1}';
                function createJqWithNS(tagName) {
                    var element = $(document.createElementNS('http://www.w3.org/2000/svg', tagName));
                    if (tagName === 'svg') {
                        element.attr({
                            xmln: 'http://www.w3.org/2000/svg',
                            version: '1.1'
                        });
                    }
                    return element;
                }
                ;
                return {
                    restrict: 'A',
                    replace: true,
                    link: function (scope, el, attr) {
                    },
                    compile: function (el, attr) {
                        return {
                            pre: function preLink(scope, element, attributes) {
                                if (!directiveUtilService.check('customSelect0Directive', element, 'SELECT'))
                                    return;
                                var selectWidth = element[0].clientWidth;
                                var selectHeight = element[0].clientHeight;
                                var points = [
                                    pointStr.format(0, 0),
                                    pointStr.format(selectWidth - selectHeight, 0),
                                    pointStr.format(selectWidth - selectHeight, selectHeight),
                                    pointStr.format(0, selectHeight),
                                    pointStr.format(0, 0)
                                ];
                                var maskId = 'cut-off-select-' + seq++;
                                var maskSvg = createJqWithNS('svg').css({
                                    height: selectHeight,
                                    width: selectWidth,
                                    padding: 0
                                }).append(createJqWithNS('defs').append(createJqWithNS('clipPath').attr('id', maskId).append(createJqWithNS('polygon').css('fill-rule', 'evenodd').attr('points', points.join(' ')))));
                                var div = $('<div class=\'customSelect0_expend\' style=\'display:inline-flex;\'/>').attr('class', element.attr('class'));
                                element.parent().append(div.append(element));
                                maskSvg.append(createJqWithNS('foreignObject').attr('clip-path', 'url(#{0})'.format(maskId)).attr({
                                    height: selectHeight,
                                    width: selectWidth
                                }));
                                element.before(maskSvg);
                            },
                            post: function postLink(scope, element, attributes) {
                                if (!directiveUtilService.check('customSelect0Directive', element, 'SELECT'))
                                    return;
                                var height = parseFloat(element[0].clientHeight);
                                var width = function () {
                                    return parseFloat(element[0].clientWidth);
                                }();
                                var size = parseFloat(height);
                                var rate = 0.35;
                                var points = [
                                    pointStr.format(size * rate, size * rate),
                                    pointStr.format(size * 0.5, size * (1 - rate)),
                                    pointStr.format(size * (1 - rate), size * rate)
                                ];
                                element.prev().before($('<button class=\'button-dark\'/>').css({
                                    'margin-left': parseFloat(width) - size + 'px',
                                    'margin-right': '-' + width + 'px',
                                    'border-top-left-radius': 0,
                                    'border-bottom-left-radius': 0,
                                    border: 'none',
                                    height: height + 'px',
                                    width: height + 'px',
                                    padding: '0'
                                }).append(createJqWithNS('svg').css({
                                    height: height + 'px',
                                    width: height + 'px'
                                }).append(createJqWithNS('polygon').css({
                                    'fill-rule': 'evenodd',
                                    fill: 'white'
                                }).attr('version', '1.1').attr('points', points.join(' ')))));
                                element.parent().find('foreignObject').append(element);
                                element.attr('class', '');
                            }
                        };
                    }
                };
            }
        ]);
    });
}.call(this));
define('datePickerDirective', [
    'angular',
    'app',
    'jquery',
    'directiveUtilService'
], function (angular, appModule) {
    appModule.directive('datePickerDirective', [
        '$sce',
        '$filter',
        'directiveUtilService',
        function ($sce, $filter, directiveUtilService) {
            var dateFilter = $filter('date');
            return {
                restrict: 'A',
                replace: false,
                require: 'ngModel',
                link: function (scope, elm, attrs, ctrl) {
                    function formatter(value) {
                        return dateFilter(value, attrs.dateFormat);
                    }
                    function parser() {
                        return ctrl.$viewValue;
                    }
                    ctrl.$formatters.push(formatter);
                    ctrl.$parsers.unshift(parser);
                },
                compile: function (el, attr) {
                    return {
                        pre: function preLink(scope, element, attributes) {
                            if (!directiveUtilService.check('datePickerDirective', element, 'INPUT'))
                                return;
                            var datepicker = element.datepicker();
                            element.before($('<div style=\'white-space: nowrap; width:auto;\'/>').attr('class', element.attr('class').replace('hasDatepicker', ''))).attr('class', 'hasDatepicker').prev().append(element).append($('<span class=\'mif-calendar calendar-icon\'/>').off('click').on('click', function () {
                                try {
                                    if ($('#ui-datepicker-div').css('display') === 'none') {
                                        datepicker.datepicker('show');
                                    } else {
                                        datepicker.datepicker('hide');
                                    }
                                } catch (e) {
                                }
                            }));
                        },
                        post: function postLink(scope, element, attributes) {
                        }
                    };
                }
            };
        }
    ]);
});
define('percentValueDirective', [
    'angular',
    'app',
    'jquery',
    'directiveUtilService'
], function (angular, appModule) {
    appModule.directive('percentValueDirective', [
        '$filter',
        function ($filter) {
            var percentFilter = $filter('percentFilter'), number = $filter('number');
            return {
                require: 'ngModel',
                link: function (scope, elm, attrs, ctrl) {
                    function formatter(value) {
                        return +percentFilter(value, false);
                    }
                    function parser() {
                        return number(ctrl.$viewValue / 100, 6);
                    }
                    ctrl.$formatters.push(formatter);
                    ctrl.$parsers.unshift(parser);
                }
            };
        }
    ]);
});
define('currencyValueDirective', [
    'angular',
    'app',
    'jquery',
    'directiveUtilService'
], function (angular, appModule) {
    appModule.directive('currencyValueDirective', [
        '$filter',
        function ($filter) {
            var currency = $filter('currency');
            return {
                require: 'ngModel',
                link: function (scope, elm, attrs, ctrl) {
                    function formatter(value) {
                        return currency(value, '', 0);
                    }
                    function parser() {
                        return +ctrl.$viewValue.replace(/\,/g, '');
                    }
                    ctrl.$formatters.push(formatter);
                    ctrl.$parsers.unshift(parser);
                }
            };
        }
    ]);
});
(function () {
    define('commonService', [
        'angular',
        'app',
        'app'
    ], function (angular, appModule) {
        'use strict';
        appModule.service('commonService', [
            '$rootScope',
            '$location',
            'servicePathConst',
            'ngDialog',
            function ($rootScope, $location, servicePathConst, ngDialog) {
                this.commonConfirmDialog = function (scope, message, title, onClickOkBtnHandler, onClickCancelBtnHandler, hideBtns) {
                    var dialogScope = scope.$new(true);
                    dialogScope.message = message;
                    dialogScope.title = title ? title : ' ';
                    dialogScope.onClickOkBtnHandler = onClickOkBtnHandler;
                    dialogScope.onClickCancelBtnHandler = onClickCancelBtnHandler;
                    if (hideBtns) {
                        if (hideBtns.hideOk && hideBtns.hideOk === true)
                            dialogScope.hideOkBtn = true;
                        if (hideBtns.hideCancel && hideBtns.hideCancel === true)
                            dialogScope.hideCancelBtn = true;
                    }
                    dialogScope.confirmDialog = ngDialog.open({
                        template: 'common/templates/confirm_dialog.html',
                        controller: 'confirmDialogCtrl',
                        scope: dialogScope
                    });
                    return dialogScope.confirmDialog;
                };
                this.commonErrorDialog = function (scope, data, defaultMessage) {
                    var dialogScope = scope.$new(true);
                    dialogScope.message = '';
                    dialogScope.title = ' ';
                    if (data.return_message) {
                        if (data.return_message.exceptionCode)
                            dialogScope.title = data.return_message.exceptionCode;
                        if (data.return_message.exceptionName)
                            dialogScope.message += data.return_message.exceptionName + '\r\n';
                        if (data.return_message.exceptionMessage)
                            dialogScope.message += data.return_message.exceptionMessage + '\r\n';
                        if (data.return_message.stacktrace)
                            dialogScope.stacktrace = data.return_message.stacktrace;
                    }
                    if (dialogScope.message === '')
                        dialogScope.message = defaultMessage;
                    dialogScope.hideCancelBtn = true;
                    dialogScope.confirmDialog = ngDialog.open({
                        template: 'common/templates/confirm_dialog.html',
                        controller: 'confirmDialogCtrl',
                        scope: dialogScope
                    });
                    return dialogScope.confirmDialog;
                };
                this.getScrollBarWidth = function (element) {
                    var width = 0;
                    if (element) {
                        width = element.scrollWidth || element.scrollBarWidth;
                    }
                    return width;
                };
                this.convertDataToVM = function (e, dataDefine, convertor) {
                    dataDefine.forEach(function (item, index) {
                        if (!item.sourceField || item.sourceField.length === '') {
                            return;
                        }
                        e[item.field] = e[item.sourceField];
                    });
                    if (convertor)
                        e = convertor(e);
                    return e;
                };
                this.getDateDiff = function (startTime, endTime, diffType) {
                    try {
                        startTime = startTime ? startTime.replace(/\-/g, '/') : undefined;
                        endTime = endTime ? endTime.replace(/\-/g, '/') : undefined;
                        diffType = diffType.toLowerCase();
                        var sTime = startTime ? new Date(startTime) : new Date();
                        var eTime = endTime ? new Date(endTime) : new Date();
                        var divNum = 1;
                        switch (diffType) {
                        case 'second':
                            divNum = 1000;
                            break;
                        case 'minute':
                            divNum = 1000 * 60;
                            break;
                        case 'hour':
                            divNum = 1000 * 3600;
                            break;
                        case 'day':
                            divNum = 1000 * 3600 * 24;
                            break;
                        default:
                            break;
                        }
                        return parseInt((eTime.getTime() - sTime.getTime()) / parseInt(divNum));
                    } catch (ex) {
                        return '--';
                    }
                };
                this.findFromArrayBy = function (array, id, prop) {
                    if (!array || !(array instanceof Array) || !id)
                        return undefined;
                    if (!prop)
                        prop = 'id';
                    for (var i = 0; i < array.length; i++) {
                        if (array[i][prop] === id)
                            return array[i];
                    }
                    return undefined;
                };
                this.overwriteObject = function (sourceObj, targetObj) {
                    if (!targetObj)
                        targetObj = {};
                    if (!sourceObj)
                        return targetObj;
                    for (var prop in sourceObj) {
                        if (sourceObj.hasOwnProperty(prop)) {
                            targetObj[prop] = sourceObj[prop];
                        }
                    }
                    return targetObj;
                };
                this.safeApply = function (scope, fn) {
                    var phase = scope.$root.$$phase;
                    if (phase === '$apply' || phase === '$digest') {
                        if (fn && typeof fn === 'function') {
                            fn();
                        }
                    } else {
                        try {
                            scope.$apply(fn);
                        } catch (e) {
                        }
                    }
                };
                function cloneFunc(myObj) {
                    if (typeof myObj != 'object')
                        return myObj;
                    if (myObj == null)
                        return myObj;
                    var myNewObj = new Object();
                    for (var i in myObj)
                        if (myObj.hasOwnProperty(i))
                            myNewObj[i] = clone(myObj[i]);
                    return myNewObj;
                }
                ;
                this.cloneObj = cloneFunc;
                function getPropertyXFunc(obj, prop) {
                    if (!obj)
                        return undefined;
                    if (!prop || prop.indexOf('.') < 0)
                        return obj[prop];
                    var arr = prop.split('.');
                    var firstProp = arr.shift();
                    if (!obj.hasOwnProperty(firstProp))
                        return undefined;
                    return getPropertyXFuncArr(obj[firstProp], arr);
                }
                ;
                function getPropertyXFuncArr(obj, propArr) {
                    if (!propArr || !obj)
                        return obj;
                    var firstProp = propArr.shift();
                    if (propArr.length === 0)
                        return obj[firstProp];
                    return getPropertyXFuncArr(obj[firstProp], propArr);
                }
                ;
                this.getPropertyX = getPropertyXFunc;
                function setPropertyXFunc(obj, prop, value) {
                    if (!obj)
                        obj = {};
                    if (prop.indexOf('.') < 0)
                        return obj[prop] = value;
                    var arr = prop.split('.');
                    var firstProp = arr.shift();
                    if (!obj[firstProp])
                        obj[firstProp] = {};
                    setPropertyXFuncArr(obj[firstProp], arr, value);
                    return obj;
                }
                ;
                function setPropertyXFuncArr(obj, propArr, value) {
                    if (!propArr)
                        return;
                    var firstProp = propArr.shift();
                    if (propArr.length === 0)
                        obj[firstProp] = value;
                    else {
                        if (!obj[firstProp])
                            obj[firstProp] = {};
                        setPropertyXFuncArr(obj[firstProp], propArr, value);
                    }
                }
                ;
                this.setProppertyX = setPropertyXFunc;
            }
        ]);
    });
}.call(this));
define('httpService', [
    'angular',
    'app'
], function (angular, appModule) {
    var HTTP_SUCCESS = 'success';
    appModule.service('httpService', [
        '$http',
        '$location',
        'servicePathConst',
        function ($http, $location, servicePathConst) {
            this.http = function (method, url, params, succeedCallback, failedCallback) {
                var fullUrl = servicePathConst.service_api_root ? servicePathConst.service_api_root + url : url;
                $http({
                    method: method,
                    url: fullUrl,
                    dataType: 'JSON',
                    params: params
                }).then(function (data, status, headers, config) {
                    if (!data) {
                        if (failedCallback)
                            failedCallback(data, status);
                        return;
                    }
                    if (data.return_code === -1) {
                        console.log(JSON.stringify(data));
                        console.log(JSON.stringify(config));
                        if (failedCallback) {
                            failedCallback(data, status);
                        }
                        return;
                    }
                    if (succeedCallback) {
                        if (data.result && data.result instanceof Array && data.result.length === 1) {
                            succeedCallback(data.result[0], status, headers, config);
                        } else {
                            succeedCallback(data.result, status, headers, config);
                        }
                    }
                }, function (data, status, headers, config) {
                    console.log(JSON.stringify(data));
                    console.log(JSON.stringify(config));
                    if (failedCallback) {
                        failedCallback(data, status);
                    }
                });
            };
            this.getService = function (url, params, succeedCallback, failedCallback) {
                var config = { params: params };
                var fullUrl = servicePathConst.service_api_root ? servicePathConst.service_api_root + url : url;
                $http.get(fullUrl, config).success(function (data, status, headers, config) {
                    if (!data) {
                        if (failedCallback)
                            failedCallback(data, status);
                        return;
                    }
                    if (data.return_code === -1) {
                        console.log(JSON.stringify(data));
                        console.log(JSON.stringify(config));
                        if (failedCallback) {
                            failedCallback(data, status);
                        }
                        return;
                    }
                    if (succeedCallback) {
                        if (data.result && data.result instanceof Array && data.result.length === 1) {
                            succeedCallback(data.result[0], status, headers, config);
                        } else {
                            succeedCallback(data.result, status, headers, config);
                        }
                    }
                }).error(function (data, status, headers, config) {
                    console.log(JSON.stringify(data));
                    console.log(JSON.stringify(config));
                    if (failedCallback)
                        failedCallback(data, status);
                });
            };
            this.postService = function (url, params, succeedCallback, failedCallback) {
                var fullUrl = servicePathConst.service_api_root ? servicePathConst.service_api_root + url : url;
                $http.post(fullUrl, params).success(function (data, status, headers, config) {
                    if (!data) {
                        if (failedCallback)
                            failedCallback(data, status);
                        return;
                    }
                    if (data.return_code === -1) {
                        console.log(JSON.stringify(data));
                        console.log(JSON.stringify(config));
                        if (failedCallback) {
                            failedCallback(data, status);
                        }
                        return;
                    }
                    if (succeedCallback) {
                        if (data.result && data.result instanceof Array && data.result.length === 1) {
                            succeedCallback(data.result[0], status, headers, config);
                        } else {
                            succeedCallback(data.result, status, headers, config);
                        }
                    }
                }).error(function (data, status, headers, config) {
                    console.log(JSON.stringify(data));
                    console.log(JSON.stringify(config));
                    if (failedCallback)
                        failedCallback(data, status);
                });
            };
        }
    ]);
});
define('confirmDialogCtrl', [
    'angular',
    'app'
], function (angular, appModule) {
    'use strict';
    appModule.controller('confirmDialogCtrl', [
        '$scope',
        'ngDialog',
        function ($scope, ngDialog) {
            $scope.onOkButtonClick = function () {
                if ($scope.onClickOkBtnHandler) {
                    $scope.onClickOkBtnHandler();
                }
                ngDialog.close($scope.confirmDialog);
            };
            $scope.onCancelButtonClick = function () {
                if ($scope.onClickCancelBtnHandler) {
                    $scope.onClickCancelBtnHandler();
                }
                ngDialog.close($scope.confirmDialog);
            };
            $scope.onCopyStacktraceToClipboard = function () {
                if ($scope.stacktrace) {
                    document.oncopy = function (e) {
                        e.clipboardData.setData('text/plain', $scope.stacktrace);
                        e.preventDefault();
                    };
                    document.execCommand('copy');
                }
            };
        }
    ]);
});
define('tabViewCtrl', [
    'angular',
    'app'
], function (angular, appModule) {
    'use strict';
    appModule.controller('tabViewCtrl', [
        '$scope',
        '$location',
        '$state',
        '$urlRouter',
        'routeConst',
        function ($scope, $location, $state, $urlRouter, routeConst) {
            $scope.basis_pndl_analysis = routeConst.basis_pndl_analysis;
            $scope.tf_calculator = routeConst.tf_calculator;
            $scope.isActive = function (name) {
                return $state.current.name === name;
            };
            $scope.onbClickTab = function (e) {
                var ex = e || window.event;
                var obj = ex.target || ex.srcElement;
                if (obj && obj.tagName === 'A') {
                }
            };
        }
    ]);
});
require.config({
    baseUrl: '.',
    paths: {
        jquery: '../bower_components/jquery/dist/jquery',
        'jquery-ui/core': 'lib/jquery-ui/ui/core',
        'jquery-ui/datepicker': 'lib/jquery-ui/ui/datepicker',
        'jquery-ui/datepicker/zh-CN': 'lib/jquery-ui/ui/i18n/datepicker-zh-CN',
        metro: '../bower_components/metro/build/js/metro',
        bootstrap: '../bower_components/bootstrap/dist/js/bootstrap',
        echarts: 'common/scripts/echarts',
        spin: 'common/scripts/spin',
        angular: '../bower_components/angular/angular',
        uiRoute: '../bower_components/angular-ui-router/release/angular-ui-router',
        ngAnimate: '../bower_components/angular-animate/angular-animate',
        ngUiBootstrap: '../bower_components/angular-bootstrap/ui-bootstrap-tpls',
        ngDialog: '../bower_components/ng-dialog/js/ngDialog',
        ngSelect: '../bower_components/ui-select/dist/select',
        ngDate: '../bower_components/angular-ui-date/dist/date',
        ngNumberic: '../bower_components/angular-numeric-directive/src/numeric-directive',
        'ui-bootstrap-tpls': '../bower_components/angular-bootstrap/ui-bootstrap-tpls',
        DateUtils: 'common/scripts/DateUtils',
        StringUtils: 'common/scripts/StringUtils',
        app: 'app',
        percentFilter: 'common/filters/percentFilter',
        currencyUnitFilter: 'common/filters/currencyUnitFilter',
        customSelect0Directive: 'common/directives/customSelect0Directive',
        datePickerDirective: 'common/directives/datePickerDirective',
        percentValueDirective: 'common/directives/percentValueDirective',
        currencyValueDirective: 'common/directives/currencyValueDirective',
        directiveUtilService: 'common/services/directiveUtilService',
        httpService: 'common/services/httpService',
        commonService: 'common/services/commonService',
        confirmDialogCtrl: 'common/controllers/confirmDialogCtrl',
        tabViewCtrl: 'common/controllers/tabViewCtrl'
    },
    shim: {
        jquery: { exports: 'jquery' },
        spin: { deps: ['jquery'] },
        bootstrap: { deps: ['jquery'] },
        angular: {
            deps: ['jquery'],
            exports: 'angular'
        },
        uiRoute: { deps: ['angular'] },
        ngAnimate: { deps: ['angular'] },
        ngUiBootstrap: { deps: ['angular'] },
        ngDialog: { deps: ['angular'] },
        ngSelect: { deps: ['angular'] },
        ngDate: {
            deps: [
                'angular',
                'jquery-ui/datepicker/zh-CN'
            ]
        },
        ngNumberic: { deps: ['angular'] },
        'ui-bootstrap-tpls': { deps: ['angular'] },
        customSelect0Directive: { deps: ['StringUtils'] },
        app: {
            deps: ['angular'],
            exports: 'app'
        },
        commonService: { deps: ['app'] }
    },
    priority: ['angular']
});
require([
    'angular',
    'require',
    'metro',
    'echarts',
    'spin',
    'ngDate',
    'ui-bootstrap-tpls',
    'DateUtils',
    'app',
    'percentFilter',
    'currencyUnitFilter',
    'customSelect0Directive',
    'datePickerDirective',
    'percentValueDirective',
    'currencyValueDirective',
    'commonService',
    'httpService',
    'confirmDialogCtrl',
    'tabViewCtrl'
], function (angular, require) {
    'use strict';
    var dataDefine = {
        mainModule: { name: 'tfcalculator' },
        subModule: [
            {
                name: 'tfcalculator.basis_pndl_analysis',
                path: 'basis_pndl_analysis/main'
            },
            {
                name: 'tfcalculator.tc',
                path: 'tf_calculator/main'
            }
        ],
        routeConst: {
            basis_pndl_analysis: 'tab_view.basis_pndl_analysis',
            tf_calculator: 'tab_view.tf_calculator'
        }
    };
    var mainModule = angular.module(dataDefine.mainModule.name);
    mainModule.constant('routeConst', dataDefine.routeConst);
    mainModule.config([
        '$httpProvider',
        function ($httpProvider) {
            $httpProvider.defaults.useXDomain = true;
            delete $httpProvider.defaults.headers.common['X-Requested-With'];
        }
    ]).config([
        '$stateProvider',
        '$urlRouterProvider',
        'routeConst',
        function ($stateProvider, $urlRouterProvider, routeConst) {
            $stateProvider.state('tab_view', {
                url: '/',
                templateUrl: 'common/views/tabView.html'
            }).state(routeConst.basis_pndl_analysis, {
                url: 'basis_pndl_analysis/:tfId',
                templateUrl: 'basis_pndl_analysis/main.html'
            }).state(routeConst.tf_calculator, {
                url: 'tf_calculator/:tfId',
                templateUrl: 'tf_calculator/main.html'
            });
            $urlRouterProvider.otherwise('/basis_pndl_analysis/');
        }
    ]).config(function (uiSelectConfig) {
        uiSelectConfig.theme = 'select2';
        uiSelectConfig.resetSearchInput = false;
        uiSelectConfig.appendToBody = true;
    });
    mainModule.run([
        '$rootScope',
        '$urlRouter',
        function ($rootScope, $urlRouter) {
            $rootScope.$on('$locationChangeSuccess', function (event, next, current) {
            });
            $rootScope.$on('$routeChangeSuccess', function () {
            });
        }
    ]);
    var modulesLoaded = false;
    var domLoaded = false;
    require(dataDefine.subModule.map(function (x) {
        return x.path;
    }), function (mainModule) {
        modulesLoaded = true;
        if (domLoaded) {
            angular.bootstrap(document, dataDefine.subModule.map(function (x) {
                return x.name;
            }).concat([dataDefine.mainModule.name]));
        }
    });
    angular.element(document.getElementsByTagName('html')[0]).ready(function () {
        domLoaded = true;
        if (modulesLoaded) {
            angular.bootstrap(document, dataDefine.subModule.map(function (x) {
                return x.name;
            }).concat([dataDefine.mainModule.name]));
        }
    });
});
define('config', [
    'angular',
    'require',
    'metro',
    'echarts',
    'spin',
    'ngDate',
    'ui-bootstrap-tpls',
    'DateUtils',
    'app',
    'percentFilter',
    'currencyUnitFilter',
    'customSelect0Directive',
    'datePickerDirective',
    'percentValueDirective',
    'currencyValueDirective',
    'commonService',
    'httpService',
    'confirmDialogCtrl',
    'tabViewCtrl'
], function () {
    return;
});